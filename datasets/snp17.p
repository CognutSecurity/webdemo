{"labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], "data": ["     import java.security.SecureRandom;\n     import javax.crypto.Cipher;\n     import javax.crypto.KeyGenerator;\n     import javax.crypto.SecretKey;\n     import javax.crypto.spec.SecretKeySpec;\n\n     public class SimpleCrypto {\n\npublic  String encrypt(String seed, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result);\n}\n\npublic  String decrypt(String seed, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n}\n\n//done\nprivate  byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\n\nprivate  byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n}\n\nprivate  byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n}\n\npublic  String toHex(String txt) {\n        return toHex(txt.getBytes());\n}\npublic  String fromHex(String hex) {\n        return new String(toByte(hex));\n}\n\npublic  byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i &lt; len; i++)\n                result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n}\n\npublic  String toHex(byte[] buf) {\n        if (buf == null)\n                return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i &lt; buf.length; i++) {\n                appendHex(result, buf[i]);\n        }\n        return result.toString();\n}\nprivate final static String HEX = \"0123456789ABCDEF\";\nprivate  void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));\n}\n\n  }\n", "public static SecretKey generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {\n// Number of PBKDF2 hardening rounds to use. Larger values increase\n// computation time. You should select a value that causes computation\n// to take &gt;100ms.\nfinal int iterations = 8000; \n\n// Generate a 160-bit key\nfinal int outputKeyLength = 160;\n\nSecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nKeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);\nSecretKey secretKey = secretKeyFactory.generateSecret(keySpec);\nreturn secretKey;\n", "CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\nInputStream instream = context.getResources().openRawResource(R.raw.gtux_cert);\nCertificate ca;\ntry {\n    ca = cf.generateCertificate(instream);\n} finally {\n    caInput.close();\n}\n\nKeyStore kStore = KeyStore.getInstance(KeyStore.getDefaultType());\nkStore.load(null, null);\nkStore.setCertificateEntry(\"ca\", ca);\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm(););\ntmf.init(kStore);\n\nSSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, tmf.getTrustManagers(), null);\n\nokHttpClient.setSslSocketFactory(context.getSocketFactory());\n", "public static void showHashKey(Context context) {\n            try {\n                PackageInfo info = context.getPackageManager().getPackageInfo(\n                        \"com.example.tryitonjewelry\", PackageManager.GET_SIGNATURES); //Your            package name here\n                for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    Log.i(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                    }\n            } catch (NameNotFoundException e) {\n            } catch (NoSuchAlgorithmException e) {\n            }\n        }\n", "PackageInfo pi = packageManager.getPackageInfo(getPackageName());\nbyte[] certificate = pi.signatures[0].toByteArray();\nMessageDigest md = MessageDigest.getInstance(\"MD5\");\nbyte[] fingerprint = md.digest(certificate);\nString hexFingerprint = toHexString(fingerprint);\n", "import java.security.SecureRandom;\nclass secure{\n    public static void main(String[] args) throws Exception{\n        SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n        System.out.println(random.nextInt(100));\n    }\n}\n", "    MessageDigest digest;\n    try {\n        digest = MessageDigest.getInstance(\"MD5\");\n        byte utf8_bytes[] = tag_xml.getBytes();\n        digest.update(utf8_bytes,0,utf8_bytes.length);\n        hash = new BigInteger(1, digest.digest()).toString(16);\n    } \n    catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n", "  public static byte[] decryptAES(byte[] key, byte[] text) throws Exception {   \n\n          SecretKeySpec skeySpec = new SecretKeySpec(GetKey(key), \"AES\");\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\",\"BC\");  \n\n            byte [] iv = new byte[cipher.getBlockSize()];\n            for(int i=0;i&lt;iv.length;i++)iv[i] = 0;\n            IvParameterSpec ivSpec = new IvParameterSpec(iv);\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec);\n\n            byte[] decrypted = cipher.doFinal(text);   \n            return decrypted;   \n        }\n", "TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {\n    public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] certs, String authType) {\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] certs, String authType) {\n    }\n}};\n\n// Install the all-trusting trust manager\nSSLContext sc = SSLContext.getInstance(\"SSL\");\nsc.init(null, trustAllCerts, new java.security.SecureRandom());\n\nSSLSocketFactory sslsocketfactory = sc.getSocketFactory();\nSSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(\"google.com\", 443);\n...\n", "try{\n   SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n   sslContext.init(null, new TrustManager[] { new X509TrustManager() {\n      @Override\n      public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType)\n         throws java.security.cert.CertificateException {;}\n      @Override\n      public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType)\n         throws java.security.cert.CertificateException {;}\n\n      public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n         return new java.security.cert.X509Certificate[] {};  }\n   }}, null);\n   HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n}catch (Exception e) {;}\n", "byte[] iv = new byte[] { 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF }; \nIvParameterSpec ivSpec = new IvParameterSpec(iv);\n\nSecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CFB/NoPadding\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);\n", "// data[] is pre-filled with modulus and publicExponent\nString ENCRYPTION_ALGORITHM = \"RSA\";\n\nBigInteger modulus = (BigInteger) data[0];\nBigInteger publicExponent = (BigInteger) data[1];\n\nPublicKey publicKey = getKeyFactory().generatePublic(new RSAPublicKeySpec(modulus, publicExponent));\nreturn publicKey;\n\nprivate static KeyFactory getKeyFactory() {\n    if (keyFactory == null) {\n        try {\n            keyFactory = KeyFactory.getInstance(ENCRYPTION_ALGORITHM);\n        } catch (NoSuchAlgorithmException e) {\n            // Algorithm is part of every Android installation. Since we do not get here under realistic\n            // circumstances it is OK to crash here.\n            throw new HellFrozeOverException();\n        }\n    }\n    return keyFactory;\n}\n", "public class CSRHttpClient {\n\n    public static HttpClient getNewHttpClient()\n    {\n        try\n        {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            trustStore.load(null, null);\n\n            SSLSocketFactory sf = new CSRSSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n            HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sf, 443));\n\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception ex)\n        {\n            return new DefaultHttpClient();\n        }\n\n    }\n\n\n}\n", "private TrustManager[] trustAllCerts = new TrustManager[] {\n    new X509TrustManager() {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n        public void checkClientTrusted(\n            java.security.cert.X509Certificate[] certs, String authType) {\n        }\n        public void checkServerTrusted(\n            java.security.cert.X509Certificate[] certs, String authType) {\n        }\n    }\n};\n", "public ServiceConnectionSE(String url) throws IOException {\n    try {\n        SSLContext sc = SSLContext.getInstance(\"TLS\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n    } catch (Exception e) {\n        e.getMessage();\n    }\n    connection = (HttpsURLConnection) new URL(url).openConnection();\n    ((HttpsURLConnection) connection).setHostnameVerifier(new AllowAllHostnameVerifier());\n}    \n", "public ServiceConnectionSE(Proxy proxy, String url) throws IOException {\n    try {\n        SSLContext sc = SSLContext.getInstance(\"TLS\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n     } catch (Exception e) {\n        e.getMessage();\n     }\n     connection = (HttpsURLConnection) new URL(url).openConnection();\n    ((HttpsURLConnection) connection).setHostnameVerifier(new AllowAllHostnameVerifier());\n\n    connection.setUseCaches(false);\n    connection.setDoOutput(true);\n    connection.setDoInput(true);\n}\n", "public static void showHashKey(Context context) {\n\n// Set Your Package Name                                                                                                                 \nString m_PackageName = \"com.example\";\n\n    try {\n        PackageInfo info = context.getPackageManager().getPackageInfo(m_PackageName, PackageManager.GET_SIGNATURES); \n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"HashKey\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n        Log.d(\"HashKey\", e.getMessage());\n\n    } catch (NoSuchAlgorithmException e) {\n        Log.d(\"HashKey\", e.getMessage());\n\n    }\n}\n", "Provider[] providers = Security.getProviders();\nfor (Provider provider : providers) {\n    for (Object entry : provider.keySet()) {\n        String name = String.valueOf(entry);\n        if (name.startsWith(\"Cipher\")) {\n            Log.d(\"Cipher\", \"Supports: \" + name.substring(7));\n        }\n    }\n}\n", "try\n{\n    PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) \n    {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        Log.e(\"MY KEY HASH:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} \ncatch (NameNotFoundException e)\n{\n\n} \ncatch (NoSuchAlgorithmException e) \n{\n\n}\n", "private static final class TrustAllSSLSocketFactory implements\n    LayeredSocketFactory {\n\n    private static final TrustAllSSLSocketFactory DEFAULT_FACTORY = new TrustAllSSLSocketFactory();\n\n    public static TrustAllSSLSocketFactory getSocketFactory() {\n        return DEFAULT_FACTORY;\n    }\n\n    private SSLContext sslcontext;\n    private javax.net.ssl.SSLSocketFactory socketfactory;\n\n    private TrustAllSSLSocketFactory() {\n        super();\n        TrustManager[] tm = new TrustManager[] { new X509TrustManager() {\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException {\n                // do nothing\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException {\n                // do nothing\n            }\n\n            @Override\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[0];\n            }\n\n        } };\n        try {\n            this.sslcontext = SSLContext.getInstance(SSLSocketFactory.TLS);\n            this.sslcontext.init(null, tm, new SecureRandom());\n            this.socketfactory = this.sslcontext.getSocketFactory();\n        } catch ( NoSuchAlgorithmException e ) {\n            Log.e(LOG_TAG,\n                \"Failed to instantiate TrustAllSSLSocketFactory!\", e);\n        } catch ( KeyManagementException e ) {\n            Log.e(LOG_TAG,\n                \"Failed to instantiate TrustAllSSLSocketFactory!\", e);\n        }\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port,\n        boolean autoClose) throws IOException, UnknownHostException {\n        SSLSocket sslSocket = (SSLSocket) this.socketfactory.createSocket(\n            socket, host, port, autoClose);\n        return sslSocket;\n    }\n\n    @Override\n    public Socket connectSocket(Socket sock, String host, int port,\n        InetAddress localAddress, int localPort, HttpParams params)\n        throws IOException, UnknownHostException, ConnectTimeoutException {\n        if ( host == null ) {\n            throw new IllegalArgumentException(\n                \"Target host may not be null.\");\n        }\n        if ( params == null ) {\n            throw new IllegalArgumentException(\n                \"Parameters may not be null.\");\n        }\n\n        SSLSocket sslsock = (SSLSocket) ( ( sock != null ) ? sock\n            : createSocket() );\n\n        if ( ( localAddress != null ) || ( localPort &gt; 0 ) ) {\n\n            // we need to bind explicitly\n            if ( localPort &lt; 0 ) {\n                localPort = 0; // indicates \"any\"\n            }\n\n            InetSocketAddress isa = new InetSocketAddress(localAddress,\n                localPort);\n            sslsock.bind(isa);\n        }\n\n        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n        int soTimeout = HttpConnectionParams.getSoTimeout(params);\n\n        InetSocketAddress remoteAddress;\n        remoteAddress = new InetSocketAddress(host, port);\n\n        sslsock.connect(remoteAddress, connTimeout);\n\n        sslsock.setSoTimeout(soTimeout);\n\n        return sslsock;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        // the cast makes sure that the factory is working as expected\n        return (SSLSocket) this.socketfactory.createSocket();\n    }\n\n    @Override\n    public boolean isSecure(Socket sock) throws IllegalArgumentException {\n        return true;\n    }\n\n}\n", "           ClientHttpRequestFactory HttpComponentsClientHttpRequestFactory = new   \n\n      org.springframework.http.client.HttpComponentsClientHttpRequestFactory(getNewHttpC\n  lient()) ;\n       restTemplate.setRequestFactory(HttpComponentsClientHttpRequestFactory);\n\n\npublic HttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        MySSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", " import org.apache.http.conn.ssl.SSLSocketFactory;\npublic class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n }\n", "public class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory \n{  \n    private SSLContext sslcontext = null;  \n\n    private static SSLContext createEasySSLContext() throws IOException \n    {  \n        try\n        {  \n            SSLContext context = SSLContext.getInstance(\"TLS\");  \n            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);  \n            return context;  \n        }\n        catch (Exception e) \n        {  \n            throw new IOException(e.getMessage());  \n        }  \n    }  \n\n    private SSLContext getSSLContext() throws IOException \n    {  \n        if (this.sslcontext == null) \n        {  \n            this.sslcontext = createEasySSLContext();  \n        }  \n        return this.sslcontext;  \n    }  \n\n    /** \n     * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int, \n     *      java.net.InetAddress, int, org.apache.http.params.HttpParams) \n     */  \n    public Socket connectSocket(Socket sock,\n            String host,\n            int port, \n            InetAddress localAddress,\n            int localPort,\n            HttpParams params) \n\n                    throws IOException, UnknownHostException, ConnectTimeoutException \n                    {  \n        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);  \n        int soTimeout = HttpConnectionParams.getSoTimeout(params);  \n        InetSocketAddress remoteAddress = new InetSocketAddress(host, port);  \n        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());  \n\n        if ((localAddress != null) || (localPort &gt; 0)) \n        {  \n            // we need to bind explicitly  \n            if (localPort &lt; 0) \n            {  \n                localPort = 0; // indicates \"any\"  \n            }  \n            InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);  \n            sslsock.bind(isa);  \n        }  \n\n        sslsock.connect(remoteAddress, connTimeout);  \n        sslsock.setSoTimeout(soTimeout);  \n        return sslsock;    \n                    }  \n\n    /** \n     * @see org.apache.http.conn.scheme.SocketFactory#createSocket() \n     */  \n    public Socket createSocket() throws IOException {  \n        return getSSLContext().getSocketFactory().createSocket();  \n    }  \n\n    /** \n     * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket) \n     */  \n    public boolean isSecure(Socket socket) throws IllegalArgumentException {  \n        return true;  \n    }  \n\n    /** \n     * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int, \n     *      boolean) \n     */  \n    public Socket createSocket(Socket socket,\n            String host, \n            int port,\n            boolean autoClose) throws IOException,  \n            UnknownHostException \n            {  \n        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);  \n            }  \n\n    // -------------------------------------------------------------------  \n    // javadoc in org.apache.http.conn.scheme.SocketFactory says :  \n    // Both Object.equals() and Object.hashCode() must be overridden  \n    // for the correct operation of some connection managers  \n    // -------------------------------------------------------------------  \n\n    public boolean equals(Object obj) {  \n        return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));  \n    }  \n\n    public int hashCode() {  \n        return EasySSLSocketFactory.class.hashCode();  \n    }  \n}\n", "public class EasyX509TrustManager implements X509TrustManager \n{  \n    private X509TrustManager standardTrustManager = null;  \n\n    /** \n     * Constructor for EasyX509TrustManager. \n     */  \n    public EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException \n    {  \n        super();  \n        TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());  \n        factory.init(keystore);  \n        TrustManager[] trustmanagers = factory.getTrustManagers();  \n        if (trustmanagers.length == 0) \n        {  \n            throw new NoSuchAlgorithmException(\"no trust manager found\");  \n        }  \n        this.standardTrustManager = (X509TrustManager) trustmanagers[0];  \n    }  \n\n    /** \n     * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType) \n     */  \n    public void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException \n    {\n        standardTrustManager.checkClientTrusted(certificates, authType);  \n    }  \n\n    /** \n     * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType) \n     */  \n    public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException \n    {  \n        X509Certificate c = certificates[0];\n        String name = c.getIssuerDN().getName();\n        if(!\"bla bla\".equals(name))\n            throw new CertificateException(\"OMG! it is not bla bla!\");\n        standardTrustManager.checkServerTrusted(certificates, authType);    \n    }  \n\n    /** \n     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers() \n     */  \n    public X509Certificate[] getAcceptedIssuers() \n    {  \n        return this.standardTrustManager.getAcceptedIssuers();  \n    }    \n}  \n", "  try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"your.package\",\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"YOURHASH KEY:\",\n                    Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "String Decrypt(String text) throws Exception {\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n    // here\n    byte[] results = cipher.doFinal(Base64.decode(text));\n\n    int results1 = cipher.doFinal(Base64.decode(text), 0, Base64.decode(text).length, results, 0);\n    System.out.println(\"String resultssssssssssssss \" + results1);\n    return new String(results, \"UTF-8\");\n}\n\nString Encrypt(String text)\n    throws Exception {\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    System.out.println(\"String input : \" + text);\n\n    cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n    // and here\n    byte[] results = cipher.doFinal(text.getBytes());\n\n    int results1 = cipher.doFinal(text.getBytes(), 0, text.getBytes().length, results, 0);\n    return Base64.encode(results);\n}\n", "KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n\n// get user password and file input stream\nchar[] password = \"password of the keystore in the file system\";\n\njava.io.FileInputStream fis = null;\ntry {\n    fis = new java.io.FileInputStream(\"keyStoreName\");\n    ks.load(fis, password);\n} finally {\n    if (fis != null) {\n        fis.close();\n    }\n}\n", "        String STORAGE_SCOPE = \"https://www.googleapis.com/auth/devstorage.read_write\";\n        JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n\n        Log.d(\"testing\", \"checking if I can create a credential\");\n        httpTransport = AndroidHttp.newCompatibleTransport();\n        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\n        keystore.load(resources_.openRawResource(R.raw.gcs_privatekey),\n                \"password\".toCharArray());\n\n        PrivateKey key = (PrivateKey) keystore.getKey(\"privatekey\", \"password\".toCharArray());\n\n        GoogleCredential credential = new GoogleCredential.Builder()\n                .setTransport(httpTransport)\n                .setJsonFactory(JSON_FACTORY)\n                .setServiceAccountPrivateKey(key)\n                .setServiceAccountId(SERVICE_ACCOUNT_EMAIL)\n                .setServiceAccountScopes(Collections.singleton(STORAGE_SCOPE))\n                // .setServiceAccountUser(SERVICE_ACCOUNT_EMAIL)\n                // .setClientSecrets(CLIENT_ID, CLIENT_SECRET)\n                .build();\n        credential.refreshToken();\n\n        String URI = \"https://storage.googleapis.com/\" + BUCKET_NAME;\n        HttpRequestFactory requestFactory = httpTransport.createRequestFactory(credential);\n        GenericUrl url = new GenericUrl(URI);\n        HttpRequest request = requestFactory.buildGetRequest(url);\n        HttpResponse response = request.execute();\n        String content = response.parseAsString();\n        Log.d(\"testing\", \"response content is: \" + content);\n        new Storage.Builder(httpTransport, JSON_FACTORY, credential)\n                .setApplicationName(\"appname\").build();\n", "private TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {\n        final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];\n        return new TrustManager[]{\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return originalTrustManager.getAcceptedIssuers();\n                    }\n\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                        try {\n                            originalTrustManager.checkClientTrusted(certs, authType);\n                        } catch (CertificateException e) {\n                            e.printStackTrace();\n                        }\n                    }\n\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                        try {\n                            originalTrustManager.checkServerTrusted(certs, authType);\n                        } catch (CertificateException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n        };\n    }\n\nprivate SSLSocketFactory getSSLSocketFactory_Certificate(String keyStoreType, int keystoreResId)\n        throws CertificateException, KeyStoreException, IOException, NoSuchAlgorithmException, KeyManagementException {\n\n    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n    InputStream caInput = getResources().openRawResource(keystoreResId);\n\n    Certificate ca = cf.generateCertificate(caInput);\n    caInput.close();\n\n    if (keyStoreType == null || keyStoreType.length() == 0) {\n        keyStoreType = KeyStore.getDefaultType();\n    }\n    KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n    keyStore.load(null, null);\n    keyStore.setCertificateEntry(\"ca\", ca);\n\n    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n    tmf.init(keyStore);\n\n    TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());\n\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, wrappedTrustManagers, null);\n\n    return sslContext.getSocketFactory();\n}\n\nprivate SSLSocketFactory getSSLSocketFactory_KeyStore(String keyStoreType, int keystoreResId, String keyPassword)\n            throws CertificateException, KeyStoreException, IOException, NoSuchAlgorithmException, KeyManagementException {\n\n        InputStream caInput = getResources().openRawResource(keystoreResId);\n\n        // creating a KeyStore containing trusted CAs\n\n        if (keyStoreType == null || keyStoreType.length() == 0) {\n            keyStoreType = KeyStore.getDefaultType();\n        }\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n\n        keyStore.load(caInput, keyPassword.toCharArray());\n\n        // creating a TrustManager that trusts the CAs in the KeyStore\n\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n\n        TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, wrappedTrustManagers, null);\n\n        return sslContext.getSocketFactory();\n    }\n", "private static final String CA_FILE = \"ca.pem\";\nprivate static final String INTERMEDIATE_FILE = \"intermediate.pem\";\nprivate static final String CERTIFICATE_FILE = \"app_01.pfx\";\nprivate static final char[] CERTIFICATE_KEY = \"password\".toCharArray();\n\n[...]\n\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\nString algorithm = TrustManagerFactory.getDefaultAlgorithm();\n\n/* trust setup */\nInputStream ca = this.context.getAssets().open(CA_FILE);\nInputStream intermediate = this.context.getAssets().open(INTERMEDIATE_FILE);\nKeyStore trustStore = KeyStore.getInstance(\"PKCS12\");\ntrustStore.load(null);\nCertificate caCert = cf.generateCertificate(ca);\nCertificate intermediateCert = cf.generateCertificate(intermediate);\ntrustStore.setCertificateEntry(\"CA Name\", caCert);\ntrustStore.setCertificateEntry(\"Intermediate Name\", intermediateCert);\nCustomTrustManager tm = new CustomTrustManager(trustStore);\nca.close();\nintermediate.close();\n\n/* client certificate setup */\nInputStream clientCert = this.context.getAssets().open(CERTIFICATE_FILE);\nKeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\nkeyStore.load(clientCert, CERTIFICATE_KEY);\nKeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);\nkmf.init(keyStore, CERTIFICATE_KEY);\nclientCert.close();\n\n/* SSLContext setup */\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(kmf.getKeyManagers(), new TrustManager[]{tm}, null);\n\n[...]\n\n((HttpsURLConnection) con).setSSLSocketFactory(sslContext.getSocketFactory());\n", "    public class ActivateHttpClient extends DefaultHttpClient { \n    final Context context;\n\n\n    /**\n     * Public constructor taking two arguments for ActivateHttpClient.\n     * @param context - Context referencing the calling Activity, for creation of\n     * the socket factory.\n     * @param params - HttpParams passed to this, specifically to set timeouts on the\n     * connection.\n     */\n    public ActivateHttpClient(Context context, HttpParams params) {\n        this.setParams(params);\n    }\n\n\n    /* (non-Javadoc)\n     * @see org.apache.http.impl.client.DefaultHttpClient#createClientConnectionManager()\n     * Create references for both http and https schemes, allowing us to attach our custom\n     * SSLSocketFactory to either\n     */\n    @Override\n    protected ClientConnectionManager createClientConnectionManager() {\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory\n                .getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n        return new SingleClientConnManager(getParams(), registry);\n    }\n\n    /**\n     * Creation of new SSLSocketFactory, which imports a certificate from\n     * a server which self-signs its own certificate.\n     * @return\n     */\n    protected SSLSocketFactory newSslSocketFactory() {\n        try {\n\n            //Keystore must be in BKS (Bouncy Castle Keystore)\n            KeyStore trusted = KeyStore.getInstance(\"BKS\");\n\n            //Reference to the Keystore\n            InputStream in = context.getResources().openRawResource(\n                    R.raw.cert);\n\n            //Password to the keystore\n            try {\n                trusted.load(in, PASSWORD_HERE.toCharArray());\n            } finally {\n                in.close();\n            }\n\n            // Pass the keystore to the SSLSocketFactory. The factory is\n            // responsible\n            // for the verification of the server certificate.\n            SSLSocketFactory sf = new SSLSocketFactory(trusted);\n\n            // Hostname verification from certificate\n            // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506\n            sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n            return sf;\n\n            // return new SSLSocketFactory(trusted);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new AssertionError(e);\n        }\n    }\n\n}\n", "private final void processChallenge(XmlPullParser parser, Writer writer,\n        String sessionKey, String sessionSecret) throws IOException,\n        NoSuchAlgorithmException, XmlPullParserException {\n\n    parser.require(XmlPullParser.START_TAG, null, \"challenge\");\n    String challenge = new String(Base64.decode(parser.nextText(),\n            Base64.DEFAULT));\n\n    String params[] = challenge.split(\"&amp;\");\n    HashMap&lt;String, String&gt; paramMap = new HashMap&lt;String, String&gt;();\n    for (int i = 0; i &lt; params.length; ++i) {\n        String p[] = params[i].split(\"=\");\n        p[0] = URLDecoder.decode(p[0]);\n        p[1] = URLDecoder.decode(p[1]);\n        paramMap.put(p[0], p[1]);\n    }\n\n    String api_key = \"YOUR_API_KEY\";\n    String call_id = \"\" + System.currentTimeMillis();\n    String method = paramMap.get(\"method\");\n    String nonce = paramMap.get(\"nonce\");\n    String v = \"1.0\";\n\n    StringBuffer sigBuffer = new StringBuffer();\n    sigBuffer.append(\"api_key=\" + api_key);\n    sigBuffer.append(\"call_id=\" + call_id);\n    sigBuffer.append(\"method=\" + method);\n    sigBuffer.append(\"nonce=\" + nonce);\n    sigBuffer.append(\"session_key=\" + sessionKey);\n    sigBuffer.append(\"v=\" + v);\n    sigBuffer.append(sessionSecret);\n\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(sigBuffer.toString().getBytes());\n    byte[] digest = md.digest();\n\n    StringBuffer sig = new StringBuffer();\n    for (int i = 0; i &lt; digest.length; ++i) {\n        sig.append(Integer.toHexString(0xFF &amp; digest[i]));\n    }\n\n    StringBuffer response = new StringBuffer();\n    response.append(\"api_key=\" + URLEncoder.encode(api_key));\n    response.append(\"&amp;call_id=\" + URLEncoder.encode(call_id));\n    response.append(\"&amp;method=\" + URLEncoder.encode(method));\n    response.append(\"&amp;nonce=\" + URLEncoder.encode(nonce));\n    response.append(\"&amp;session_key=\" + URLEncoder.encode(sessionKey));\n    response.append(\"&amp;v=\" + URLEncoder.encode(v));\n    response.append(\"&amp;sig=\" + URLEncoder.encode(sig.toString()));\n\n    StringBuilder out = new StringBuilder();\n    out.append(\"&lt;response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;\");\n    out.append(Base64.encodeToString(response.toString().getBytes(),\n            Base64.NO_WRAP));\n    out.append(\"&lt;/response&gt;\");\n\n    writer.write(out.toString());\n    writer.flush();\n}\n", "import java.security.MessageDigest;\nimport java.security.cert.Certificate;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\n\nimport sun.misc.BASE64Encoder;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        for (String jarFilename : args)\n            extractHash(jarFilename);\n    }\n\n    private static void extractHash(String jarFilename) throws Exception {\n        BASE64Encoder base64 = new BASE64Encoder();\n        MessageDigest sha1 = MessageDigest.getInstance(\"SHA\");\n        Set&lt;Certificate&gt; certificates = new HashSet&lt;Certificate&gt;();\n        JarFile jarFile = new JarFile(jarFilename);\n        for (JarEntry jarEntry : Collections.list(jarFile.entries())) {\n            jarFile.getInputStream(jarEntry).skip(Long.MAX_VALUE);\n            Certificate[] certs = jarEntry.getCertificates();\n            if (certs == null)\n                continue;\n            certificates.addAll(Arrays.asList(certs));\n        }\n        System.out.printf(\"%s:\", jarFilename);\n        for (Certificate cert : certificates) {\n            byte[] digest = sha1.digest(cert.getEncoded());\n            System.out.printf(\" %s\", base64.encode(digest));\n        }\n        if (certificates.isEmpty())\n            System.out.printf(\" NOT SIGNED!\");\n        System.out.println();\n        jarFile.close();\n    }\n}\n", "@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.facebook.samples.hellofacebook\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "public class MyHttpClient extends DefaultHttpClient {\nfinal Context context;\nTrustManager easyTrustManager = new X509TrustManager() {\n    @Override\n    public void checkClientTrusted(\n            X509Certificate[] chain,\n            String authType) throws CertificateException {\n    }\n\n    @Override\n    public void checkServerTrusted(\n            X509Certificate[] chain,\n            String authType) throws CertificateException {\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }    \n};\n  public MyHttpClient(Context context) {\n    this.context = context;\n  }\n\n  @Override protected ClientConnectionManager createClientConnectionManager() {\n    SchemeRegistry registry = new SchemeRegistry();\n    registry.register(\n        new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n    registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n    return new SingleClientConnManager(getParams(), registry);\n  }\n\n\n  private MySSLSocketFactory newSslSocketFactory() {\n    try {\n      KeyStore trusted = KeyStore.getInstance(\"BKS\");      \n      try {\n         trusted.load(null, null);\n\n      } finally {\n      }\n\n      MySSLSocketFactory sslfactory =  new MySSLSocketFactory(trusted);\n        sslfactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        return sslfactory;\n    } catch (Exception e) {\n      throw new AssertionError(e);\n    }\n\n  }\n  public class MySSLSocketFactory extends SSLSocketFactory {\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n        public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n            super(truststore);\n\n            TrustManager tm = new X509TrustManager() {\n                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                public X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n            };\n\n            sslContext.init(null, new TrustManager[] { tm }, null);\n        }\n\n        @Override\n        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n        }\n\n        @Override\n        public Socket createSocket() throws IOException {\n            return sslContext.getSocketFactory().createSocket();\n        }\n    }\n   }\n", "HttpClient httpClient = null;\ntry {\n    HttpParams httpParameters = new BasicHttpParams();\n    KeyStore rootca = KeyStore.getInstance(\"BKS\");\n    rootca.load(getResources().openRawResource(R.raw.rootcacert),\"bkskeystorepass\".toCharArray());\n    KeyStore mycert = KeyStore.getInstance(\"pkcs12\");\n    mycert.load(getResources().openRawResource(R.raw.clientcertandkey),\"pkcs12storepass\".toCharArray());\n    SSLSocketFactory sockfact = new SSLSocketFactory(mycert,null,rootca);\n    SchemeRegistry registry = new SchemeRegistry();\n    registry.register(new Scheme(\"https\",sockfact , 443));\n    httpClient = new DefaultHttpClient(new ThreadSafeClientConnManager(httpParameters, registry), httpParameters);\n} catch (Exception e) {\n    e.printStackTrace();\n}\n", "public class MyHttpClient extends DefaultHttpClient {\n\n  final Context context;\n\n  public MyHttpClient(Context context) {\n      this.context = context;\n  }\n\n  @Override\n  protected ClientConnectionManager createClientConnectionManager() {\n      SchemeRegistry registry = new SchemeRegistry();\n      registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n      // Register for port 443 our SSLSocketFactory with our keystore\n      // to the ConnectionManager\n      registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n      return new SingleClientConnManager(getParams(), registry);\n  }\n\n  private SSLSocketFactory newSslSocketFactory() {\n      try {\n          // Get an instance of the Bouncy Castle KeyStore format\n          KeyStore trusted = KeyStore.getInstance(\"BKS\");\n          // Get the raw resource, which contains the keystore with\n          // your trusted certificates (root and any intermediate certs)\n          InputStream in = context.getResources().openRawResource(R.raw.mykeystore);\n          try {\n              // Initialize the keystore with the provided trusted certificates\n              // Also provide the password of the keystore\n              trusted.load(in, \"mysecret\".toCharArray());\n          } finally {\n              in.close();\n          }\n          // Pass the keystore to the SSLSocketFactory. The factory is responsible\n          // for the verification of the server certificate.\n          SSLSocketFactory sf = new SSLSocketFactory(trusted);\n          // Hostname verification from certificate\n          // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506\n          sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n          return sf;\n      } catch (Exception e) {\n          throw new AssertionError(e);\n      }\n  }\n}\n", "private String executeRequest(String urlAddress)\n{\n    String responce = null;\n    String msg = null;\n    int error = 0;\n    try {\n        URL url = new URL(urlAddress);\n        HttpsURLConnection  connection = (HttpsURLConnection)url.openConnection();\n        SSLSocketFactory factory =  SecureSocketFactory.getSSLSocketFactory();\n        connection.setSSLSocketFactory(factory);\n\n        connection.setHostnameVerifier(new Verifier());\n\n        if (method == RequestMethod.POST)\n        {\n            connection.setDoOutput(true);\n            connection.setRequestMethod(\"POST\");\n        }\n        else\n        {\n            connection.setDoInput(true);\n            connection.setRequestMethod(\"GET\");\n        }\n        msg = connection.getResponseMessage();\n        error = connection.getResponseCode();\n        if (\"OK\".equals(msg))\n        {\n            InputStream content = (InputStream) connection.getContent();\n            responce = convertStreamToString(content);\n        }\n        else\n        {\n            responce = \"Error \" + error;\n        }\n        connection.disconnect();\n\n    } catch (Exception e) {\n        responce = e.toString();\n    }\n\n    return responce;\n}\n", "package com.example.android.secure;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class EncryptionManager {\n\n // we should get a password from the user\n String password = \"...\";\n String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n // Important not to rely on default here !!!! use CBC instead of ECB\n String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n int NUM_OF_ITERATIONS = 1000;\n int KEY_SIZE = 256;\n // generated on first run\n byte[] salt = \"abababababababababa bab\".getBytes();\n byte[] iv = \"1234567890abcdef\".getBytes();\n // This is the value to be encrypted.\n String clearText = \"...\";\n byte[] encryptedText;\n byte[] decryptedText;\n\n public void exampleCodeNoRealMethod() {\n    try {\n       PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, NUM_OF_ITERATIONS, KEY_SIZE);\n       SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n       SecretKey tempKey = keyFactory.generateSecret(pbeKeySpec);\n       SecretKey secretKey = new SecretKeySpec(tempKey.getEncoded(), \"AES\");\n       IvParameterSpec ivSpec = new IvParameterSpec(iv);\n       Cipher encCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n       encCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n       Cipher decCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n       decCipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);\n       encryptedText = encCipher.doFinal(clearText.getBytes());\n       decryptedText = decCipher.doFinal(encryptedText);\n       String sameAsClearText = new String(decryptedText);\n    } catch (Exception e) { \n       // TODO handle this exception\n    }\n }\n\n}\n", "public static SecretKey generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {\n    // Number of PBKDF2 hardening rounds to use. Larger values increase\n    // computation time. You should select a value that causes computation\n    // to take &gt;100ms.\n    final int iterations = 1000; \n\n    // Generate a 256-bit key\n    final int outputKeyLength = 256;\n\n    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);\n    SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);\n    return secretKey;\n}\n", "KeyFactory rsaKeyFac = KeyFactory.getInstance(\"RSA\");\nX509EncodedKeySpec keySpec = new X509EncodedKeySpec(key);  \nRSAPublicKey rsaPubKey = (RSAPublicKey)rsaKeyFac.generatePublic(keySpec);\nreturn new PublicKeyImpl(rsaPubKey);    \n", "HostnameVerifier hostnameVerifier = new HostnameVerifier() {\n    @Override\n    public boolean verify(String hostname, SSLSession session) {\n        HostnameVerifier hv =\n            HttpsURLConnection.getDefaultHostnameVerifier();\n        return hv.verify(\"localhost\", session);\n    }\n};\n", "public void getHashKeyForFacebook(Activity activity, String packageName){\n    try{\n        PackageInfo info = activity.getPackageManager().getPackageInfo(packageName,  PackageManager.GET_SIGNATURES);\n\n        for (Signature signature : info.signatures){\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (Exception ex){\n\n    }\n}\n", "private void getHashKey() {\n\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"your_package_name\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\"); \n            md.update(signature.toByteArray());\n            Log.e(\"YOURHASH KEY:\",\n                    Base64.encodeToString(md.digest(),Base64.DEFAULT));\n            String WEATHER_HASH = Base64.encodeToString(md.digest(),\n                    Base64.DEFAULT);\n\n            return;\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n    return;\n\n}\n", "SecureRandom r = new SecureRandom(); // should be the best PRNG\nbyte[] iv = new byte[16];\nr.nextBytes(iv);\n\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));\n", "private static SoapObject getBody(final SoapSerializationEnvelope soapEnvelope) throws Exception {\n        if (soapEnvelope.bodyIn == null) {\n            throw new Exception(\"soapEnvelope.bodyIn=null\");\n        }\n        else if (soapEnvelope.bodyIn.getClass() == SoapFault.class) {\n            throw new ExceptionLogic((SoapFault) soapEnvelope.bodyIn));\n        }\n        else {\n            return (SoapObject) soapEnvelope.bodyIn;\n        }\n\n    }\n\nprivate static SoapSerializationEnvelope sendRequete(final SoapObject soapReq, final String classMappingName,\n            final Class&lt;?&gt; classMapping, final int timeOutSpecial) {\n\n\n\n        final SoapSerializationEnvelope soapEnvelope = new SoapSerializationEnvelope(SoapEnvelope.VER11);\n        soapEnvelope.implicitTypes = true;\n        soapEnvelope.dotNet = true;\n\n        if (classMappingName != null) {\n            soapEnvelope.addMapping(NAMESPACE, classMappingName, classMapping);\n        }\n\n        soapEnvelope.setOutputSoapObject(soapReq);\n\n        try {\n\n            final HttpTransportSE httpTransport = new HttpTransportSE(Constante.urlWebService, timeOutSpecial);\n            httpTransport.debug = BuildConfig.DEBUG;\n\n            // Prod\n            if (Constante.urlWebService.startsWith(\"https://\")) {\n                final List&lt;HeaderProperty&gt; headerList = new ArrayList&lt;HeaderProperty&gt;();\n                headerList.add(new HeaderProperty(\"Authorization\", \"Basic \"\n                        + org.kobjects.base64.Base64.encode((Constante.CERTIFICAT_LOGIN + \":\" + Constante.CERTIFICAT_MDP).getBytes())));\n\n                FakeX509TrustManager.allowAllSSL();\n                httpTransport.call(NAMESPACE + \"/\" + soapReq.getName(), soapEnvelope, headerList);\n            }\n            // Test\n            else {\n                httpTransport.call(NAMESPACE + \"/\" + soapReq.getName(), soapEnvelope);\n            }\n\n            return soapEnvelope;\n        }\n        catch (final Exception e) {\n            throw new Exception(\"Erreur : \" + e.getMessage(), e);\n        }\n\n    }\n\n\n\n    private static class FakeX509TrustManager implements X509TrustManager {\n        private static TrustManager[] trustManagers;\n        private final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return _AcceptedIssuers;\n        }\n\n        public static void allowAllSSL() {\n            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n\n                @Override\n                public boolean verify(final String hostname, final SSLSession session) {\n                    return true;\n                }\n            });\n            SSLContext context = null;\n            if (trustManagers == null) {\n                trustManagers = new TrustManager[] { new FakeX509TrustManager() };\n            }\n            try {\n                context = SSLContext.getInstance(\"TLS\");\n                context.init(null, trustManagers, new SecureRandom());\n            }\n            catch (final NoSuchAlgorithmException e) {\n                e.printStackTrace();\n            }\n            catch (final KeyManagementException e) {\n                e.printStackTrace();\n            }\n            HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n        }\n\n        @Override\n        public void checkClientTrusted(final X509Certificate[] arg0, final String arg1) throws CertificateException {\n\n        }\n\n        @Override\n        public void checkServerTrusted(final X509Certificate[] chain, final String authType) throws CertificateException {\n\n        }\n    }\n", "class User {\n    @DatabaseField(canBeNull = false)\n    private String passwordHash;\n\n    public void setPassword(String password) {\n        this.passwordHash = hashPassword(password);\n    }\n\n    public boolean isPasswordCorrect(String givenPassword) {\n        return TextUtils.equals(hasPassword(givenPassword), passwordHash);\n    }\n\n    private String hashPassword(String password) {\n        return AeSimpleSHA1.SHA1(password);\n    }\n}\n\npublic class AeSimpleSHA1 { \n\n    private static String convertToHex(byte[] data) { \n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i &lt; data.length; i++) { \n            int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;\n            int two_halfs = 0;\n            do { \n                if ((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9)) \n                    buf.append((char) ('0' + halfbyte));\n                else \n                    buf.append((char) ('a' + (halfbyte - 10)));\n                halfbyte = data[i] &amp; 0x0F;\n            } while(two_halfs++ &lt; 1);\n        } \n        return buf.toString();\n    } \n\n    public static String SHA1(String text) \n    throws NoSuchAlgorithmException, UnsupportedEncodingException  { \n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    } \n} \n", "public void ListSupportedAlgorithms() {\nString result = \"\";\n\n// get all the providers\nProvider[] providers = Security.getProviders();\n\nfor (int p = 0; p &lt; providers.length; p++) {\n    // get all service types for a specific provider\n    Set&lt;Object&gt; ks = providers[p].keySet();\n    Set&lt;String&gt; servicetypes = new TreeSet&lt;String&gt;();\n    for (Iterator&lt;Object&gt; it = ks.iterator(); it.hasNext();) {\n        String k = it.next().toString();\n        k = k.split(\" \")[0];\n        if (k.startsWith(\"Alg.Alias.\"))\n            k = k.substring(10);\n\n        servicetypes.add(k.substring(0, k.indexOf('.')));\n    }\n\n    // get all algorithms for a specific service type\n    int s = 1;\n    for (Iterator&lt;String&gt; its = servicetypes.iterator(); its.hasNext();) {\n        String stype = its.next();\n        Set&lt;String&gt; algorithms = new TreeSet&lt;String&gt;();\n        for (Iterator&lt;Object&gt; it = ks.iterator(); it.hasNext();) {\n        String k = it.next().toString();\n        k = k.split(\" \")[0];\n        if (k.startsWith(stype + \".\"))\n            algorithms.add(k.substring(stype.length() + 1));\n        else if (k.startsWith(\"Alg.Alias.\" + stype +\".\"))\n            algorithms.add(k.substring(stype.length() + 11));\n    }\n\n    int a = 1;\n    for (Iterator&lt;String&gt; ita = algorithms.iterator(); ita.hasNext();) {\n        result += (\"[P#\" + (p + 1) + \":\" + providers[p].getName() + \"]\" +\n                   \"[S#\" + s + \":\" + stype + \"]\" +\n                   \"[A#\" + a + \":\" + ita.next() + \"]\\n\");\n        a++;\n    }\n\n    s++;\n}\n}\n", "public class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n\n\npublic static HttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n\n}\n", "public class MailSender {\nprivate String mailhost = \"smtp.gmail.com\";\nprivate String user;\nprivate String password;\nprivate Session session;\nprivate Multipart _multipart;\npublic BodyPart messageBodyPart;\nDataSource source;\nstatic {\n    Security.addProvider(new com.PackageName.JSSEProvider());\n}\n\npublic MailSender(String user, String password) {\n    this.user = user;\n    this.password = password;\n\n    Properties props = new Properties();\n    props.setProperty(\"mail.transport.protocol\", \"smtp\");\n    props.setProperty(\"mail.smtp.host\", mailhost);\n    props.put(\"mail.smtp.auth\", \"true\");\n    props.put(\"mail.smtp.port\", \"465\");\n    props.put(\"mail.smtp.socketFactory.port\", \"465\");\n    props.put(\"mail.smtp.socketFactory.class\",\n            \"javax.net.ssl.SSLSocketFactory\");\n    props.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n    props.setProperty(\"mail.smtp.quitwait\", \"false\");\n    _multipart = new MimeMultipart();\n    session = Session.getInstance(props, new MailAuthenticator(user,\n            password));\n\n}\n\npublic synchronized void sendMail(final String subject, final String uuid,\n        final String address, final double latitude,\n        final double longitude, final String recipients,\n        final String filepath, final Context context, final int i, final int j)\n        throws Exception {\n\n    Thread thread = new Thread() {\n        public void run() {\n            Looper.prepare();\n            try {\n                System.out.println(\"SENDING       MAIL\");\n                Message message = new MimeMessage(session);\n                messageBodyPart = new MimeBodyPart();\n                DatabaseAdapter db = new DatabaseAdapter(context);\n                String eId = db.getYourId();\n                message.setFrom(new InternetAddress(eId));\n                message.setSubject(subject);\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n                String currentDate = sdf.format(new Date());\n                SimpleDateFormat sTf = new SimpleDateFormat(\"hh:mm:ss\");\n                String currentTime = sTf.format(new Date());\n                System.out.println(i);\n                messageBodyPart\n                        .setText(\"Someone tried to unlock your device(ID : \"+uuid+\" ) at: \"\n                                + currentTime + \" on \" + currentDate + \"\\n\"\n                                + \"Device Location : \" + address + \"\\n\"\n                                + \"Map: \" + \"http://maps.google.com/?q=\"\n                                + latitude + \",\" + longitude);\n                if (recipients.indexOf(',') &gt; 0)\n                    message.setRecipients(Message.RecipientType.TO,\n                            InternetAddress.parse(recipients));\n                else\n                    message.setRecipient(Message.RecipientType.TO,\n                            new InternetAddress(recipients));\n\n                Transport transport = session.getTransport(\"smtp\");\n                System.out.println(\"CONECTING.....\");\n                transport.connect(mailhost, user, password);\n                message.saveChanges();\n                message.setContent(_multipart);\n                _multipart.addBodyPart(messageBodyPart);\n                message.setContent(_multipart);\n                if (source != null) {\n\n                    message.setFileName(\"image\");\n                }\n                Transport.send(message);\n                System.out.println(\"Mail  sent ...\");\n\n                }\n\n                transport.close();\n\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n        }\n    };\n    thread.start();\n\n}\n\npublic void addAttachment(String filename) throws Exception {\n    if (!filename.equals(\"\")) {\n        System.out.println(\"Ataching     file        :)\");\n        messageBodyPart = new MimeBodyPart();\n        source = new FileDataSource(filename);\n        messageBodyPart.setDataHandler(new DataHandler(source));\n        messageBodyPart.setFileName(filename);\n        _multipart.addBodyPart(messageBodyPart);\n        System.out.println(\"FILE    ATTACHED        :)\");\n    }\n}\n\n\nclass MailAuthenticator extends Authenticator {\n    String us;\n    String pw;\n\n    public MailAuthenticator(String username, String password) {\n        super();\n        this.us = username;\n        this.pw = password;\n    }\n\n    public PasswordAuthentication getPasswordAuthentication() {\n        return new PasswordAuthentication(us, pw);\n    }\n}\n", "SSLContext sslcontext = SSLContext.getInstance(\"TLSv1\");\nsslcontext.init(null, null, null);\n//  NoSSLv3SocketFactory is @bhavit-s-sengar's http://stackoverflow.com/a/29946540/8524\nSSLSocketFactory noSSLv3Factory = new NoSSLv3SocketFactory(sslcontext.getSocketFactory());\n\nNetHttpTransport.Builder netTransportBuilder = new NetHttpTransport.Builder();\nnetTransportBuilder.setSslSocketFactory(noSSLv3Factory);\nHTTP_TRANSPORT = netTransportBuilder.build();\n", "private static final String CLASS_NAME = \"SendQueryTask\";\n//...\nimport java.io.StringWriter;\n\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n//...\nprivate String transformXmlToString(Node node)\n{\n    Transformer transformer = null;\n    try\n    {\n        transformer = TransformerFactory.newInstance().newTransformer();\n    }\n    catch (TransformerConfigurationException e)\n    {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    catch (TransformerFactoryConfigurationError e)\n    {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    if ( transformer != null )\n    {\n        transformer.setOutputProperty( OutputKeys.INDENT, \"yes\" );\n\n        // initialize StreamResult with File object to save to file\n        StreamResult result = new StreamResult( new StringWriter() );\n        DOMSource source = new DOMSource( node );\n\n        try\n        {\n            transformer.transform( source, result );\n        }\n        catch (TransformerException e)\n        {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        String xmlString = result.getWriter().toString();\n        Log.i( CLASS_NAME, \"flattened=\" + (xmlString) );\n\n        return xmlString;\n    }       \n    return null;\n}\n", "public class SSLCertificateHandler {\n\n    protected static final String TAG = \"NukeSSLCerts\";\n\n    /**\n     * Enables https connections\n     */\n    public static void nuke() {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() {\n                    X509Certificate[] myTrustedAnchors = new X509Certificate[0];\n                    return myTrustedAnchors;\n                }\n\n                @Override\n                public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                }\n\n                @Override\n                public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                }\n            } };\n\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, trustAllCerts, new SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n                @Override\n                public boolean verify(String arg0, SSLSession arg1) {\n                    return true;\n                }\n            });\n        } catch (Exception e) {\n        }\n    }\n\n}\n", "public void startTLS() {\n\n    try {\n        sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustCerts, null);\n    } catch(NoSuchAlgorithmException nsa) {\n        System.out.println(\"Exception : No Such Algorithm\");\n    } catch(KeyManagementException kme) {\n        System.out.println(\"Exception : KeyManagementException:\");\n    }//try-catch\n\n\n    IoFilterChain chain = session.getFilterChain();\n    SslFilter sslFilter = (SslFilter) chain.get(\"sslFilter\");\n\n    if (sslFilter == null) {\n        sslFilter = new SslFilter(sslContext);\n        sslFilter.setUseClientMode(true);\n        if ((cipherSuites != null) &amp;&amp; !cipherSuites.isEmpty()) {\n            sslFilter.setEnabledCipherSuites(cipherSuites.toArray( new String[cipherSuites.size()] )); \n        } \n\n        chain.addFirst(\"sslFilter\", sslFilter);\n\n    }else {\n        try {\n            sslFilter.startSsl(this.session);\n        } catch(SSLException se) {\n            System.out.println(\"SslException:\"+se);\n        }\n    }//if-else\n\n}//startTLS\n", "package com.facebook.android;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.harmony.javax.security.auth.callback.CallbackHandler;\nimport org.apache.harmony.javax.security.sasl.Sasl;\nimport org.jivesoftware.smack.SASLAuthentication;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.sasl.SASLMechanism;\nimport org.jivesoftware.smack.util.Base64;\n\nimport android.util.Log;\n\n\npublic class SASLXFacebookPlatformMechanism extends SASLMechanism {\n\n    private static final String NAME              = \"X-FACEBOOK-PLATFORM\";\n\n    private String              apiKey            = \"\";\n    private String              accessToken        = \"\";\n\n    /**\n     * Constructor.\n     */\n    public SASLXFacebookPlatformMechanism(SASLAuthentication saslAuthentication) {\n        super(saslAuthentication);\n    }\n\n    @Override\n    protected void authenticate() throws IOException, XMPPException {\n        getSASLAuthentication().send(new AuthMechanism(NAME, \"\"));\n    }\n\n    @Override\n    public void authenticate(String apiKey, String host, String accessToken) throws IOException, XMPPException {\n        if (apiKey == null || accessToken == null) {\n            throw new IllegalArgumentException(\"Invalid parameters\");\n        }\n\n        this.apiKey = apiKey;\n        this.accessToken = accessToken;\n        this.hostname = host;\n\n        String[] mechanisms = { \"DIGEST-MD5\" };\n        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n        this.sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props, this);\n        authenticate();\n    }\n\n    @Override\n    public void authenticate(String username, String host, CallbackHandler cbh) throws IOException, XMPPException {\n        String[] mechanisms = { \"DIGEST-MD5\" };\n        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n        this.sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props, cbh);\n        authenticate();\n    }\n\n    @Override\n    protected String getName() {\n        return NAME;\n    }\n\n    @Override\n    public void challengeReceived(String challenge) throws IOException {\n        byte[] response = null;\n\n        if (challenge != null) {\n            String decodedChallenge = new String(Base64.decode(challenge));\n            Map&lt;String, String&gt; parameters = getQueryMap(decodedChallenge);\n\n            String version = \"1.0\";\n            String nonce = parameters.get(\"nonce\");\n            String method = parameters.get(\"method\");\n\n            String composedResponse =\n                \"method=\" + URLEncoder.encode(method, \"utf-8\") +\n                        \"&amp;nonce=\" + URLEncoder.encode(nonce, \"utf-8\") +\n                        \"&amp;access_token=\" + URLEncoder.encode(accessToken, \"utf-8\") +\n                        \"&amp;api_key=\" + URLEncoder.encode(apiKey, \"utf-8\") +\n                        \"&amp;call_id=0\" +\n                        \"&amp;v=\" + URLEncoder.encode(version, \"utf-8\");\n            response = composedResponse.getBytes();\n        }\n\n        String authenticationText = \"\";\n\n        if (response != null) {\n            authenticationText = Base64.encodeBytes(response);\n        }\n\n        // Send the authentication to the server\n        getSASLAuthentication().send(new Response(authenticationText));\n    }\n\n    private Map&lt;String, String&gt; getQueryMap(String query) {\n        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\n        String[] params = query.split(\"\\\\&amp;\");\n\n        for (String param : params) {\n            String[] fields = param.split(\"=\", 2);\n            map.put(fields[0], (fields.length &gt; 1 ? fields[1] : null));\n        }\n\n        return map;\n    }\n}\n", " try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    \"your package name\",\n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n", "    protected HttpsURLConnection createConnection(String url, Object extra) throws IOException {\n    String encodedUrl = Uri.encode(url, ALLOWED_URI_CHARS);\n\n    // Load CAs from an InputStream\n    // (could be from a resource or ByteArrayInputStream or ...)\n    CertificateFactory cf = null;\n    try {\n        cf = CertificateFactory.getInstance(\"X.509\");\n    } catch (CertificateException e1) {\n\n        // TODO Auto-generated catch block\n        e1.printStackTrace();\n\n    }\n    // From https://www.washington.edu/itconnect/security/ca/load-der.crt\n    InputStream caInput = new BufferedInputStream(new FileInputStream(Environment.getExternalStorageDirectory()\n            + \"/cub.crt\"));\n    Certificate ca = null;\n    try {\n        try {\n            ca = cf.generateCertificate(caInput);\n            System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n        } catch (CertificateException e) {\n\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n\n        }\n    } finally {\n        caInput.close();\n    }\n\n    // Create a KeyStore containing our trusted CAs\n    String keyStoreType = KeyStore.getDefaultType();\n    KeyStore keyStore = null;\n    try {\n        keyStore = KeyStore.getInstance(keyStoreType);\n        try {\n            keyStore.load(null, null);\n            keyStore.setCertificateEntry(\"ca\", ca);\n        } catch (NoSuchAlgorithmException e1) {\n\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n\n        } catch (CertificateException e1) {\n\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n\n        }\n\n        // Create a TrustManager that trusts the CAs in our KeyStore\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = null;\n        try {\n            tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n            tmf.init(keyStore);\n        } catch (NoSuchAlgorithmException e1) {\n\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n\n        }\n\n        // Create an SSLContext that uses our TrustManager\n        SSLContext context = null;\n        try {\n            context = SSLContext.getInstance(\"TLS\");\n        } catch (NoSuchAlgorithmException e) {\n\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n\n        }\n        try {\n            context.init(null, tmf.getTrustManagers(), null);\n        } catch (KeyManagementException e) {\n\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n\n        }\n        HttpsURLConnection conn = (HttpsURLConnection) new URL(encodedUrl).openConnection();\n        conn.setConnectTimeout(connectTimeout);\n        conn.setSSLSocketFactory(context.getSocketFactory());\n        conn.setReadTimeout(readTimeout);\n        return conn;\n    } catch (KeyStoreException e) {\n\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n\n    }\n    return null;\n\n}\n", "public BoolString tryEncrypt(String inString, String password) {\n    try {\n        String value= encrypt(inString, password);\n        return new BoolString(true,\"\",value);\n    }\n    catch (GeneralSecurityException e){\n        return new BoolString(false,e.getMessage(),\"\");\n    }\n}\n\n    protected void onPostExecute(BoolString result){          \n        progress.dismiss();\n        if (result.success){\n                result.value;\n        }\n        else {\n              result.err;\n        }\n    }\n", "HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n            DefaultHttpClient client = new DefaultHttpClient();\n            SchemeRegistry registry = new SchemeRegistry();\n            SSLSocketFactory socketFactory = SSLSocketFactory\n                    .getSocketFactory();\n            socketFactory\n                    .setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\n            registry.register(new Scheme(\"https\", socketFactory, 443));\n            SingleClientConnManager mgr = new SingleClientConnManager(\n                    client.getParams(), registry);\n            // defaultHttpClient\n            DefaultHttpClient httpClient = new DefaultHttpClient(mgr,\n                    client.getParams());\n            HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n", "String filename = hash(Uri.parse(downloadLink).getLastPathSegment());\n\npublic String hash(String victim) throws NoSuchAlgorithmException\n{\n    MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n    md.reset();\n    byte[] buffer = victim.getBytes();\n    md.update(buffer);\n    byte[] digest = md.digest();\n\n    StringBuilder hexStr = new StringBuilder();\n    for (int i = 0; i &lt; digest.length; i++) {\n        hexStr.append(Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 ));\n    }\n    return hexStr.toString();\n}\n", "// get the key\nfinal KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\ngenerator.init(128);\nfinal SecretKey secretKey = generator.generateKey();\n\n// perform encryption\nfinal Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);\nFileInputStream fis = new FileInputStream(System.getProperty(\"user.home\") + java.io.File.separatorChar + \"plain.pdf\");\nFileOutputStream fos = new FileOutputStream(System.getProperty(\"user.home\") + java.io.File.separatorChar + \"test.enc\");\nfinal CipherOutputStream output = new CipherOutputStream(fos, cipher);\n\nint bytesRead = 0;\nfinal byte[] plainText = new byte[4096];\nwhile ((bytesRead = fis.read(plainText)) &gt;= 0) {\n    output.write(plainText, 0, bytesRead);\n}\noutput.flush();\noutput.close();\nfos.close();\nfis.close();\nfinal byte[] iv = cipher.getIV();\n\n// decrypt the file\ncipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));\nfis = new FileInputStream(System.getProperty(\"user.home\") + java.io.File.separatorChar + \"test.enc\");\nfos = new FileOutputStream(System.getProperty(\"user.home\") + java.io.File.separatorChar + \"test.pdf\");\nfinal CipherInputStream input = new CipherInputStream(fis, cipher);\n\nfinal byte[] decryptedData = new byte[4096];\nint decryptedRead;\nwhile ((decryptedRead = input.read(decryptedData)) &gt;= 0) {\n    fos.write(decryptedData, 0, decryptedRead);\n}\nfos.flush();\nfos.close();\ninput.close();\nfis.close();\n", "KeyStore ts = KeyStore.getInstance(\"BKS\");\nInputStream in = getResources().openRawResource(R.raw.mytruststore);\nts.load(in, TRUSTSTORE_PASSWORD.toCharArray());\n\nSchemeRegistry schemeRegistry = new SchemeRegistry();\nschemeRegistry.register(new Scheme(\"http\", PlainSocketFactory\n                .getSocketFactory(), 80));\nSSLSocketFactory sslSocketFactory = new SSLSocketFactory(ts);\nschemeRegistry.register(new Scheme(\"https\", sslSocketFactory, 443));\nHttpParams params = new BasicHttpParams();\nClientConnectionManager cm = \n    new ThreadSafeClientConnManager(params, schemeRegistry);\n\nHttpClient client = new DefaultHttpClient(cm, params);\n", "public void generateHashkey(){\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                PACKAGE,\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n\n            Log.e(\"Hash key\", \"\"+Base64.encodeToString(md.digest(),Base64.NO_WRAP));\n        }\n    } catch (PackageManager.NameNotFoundException e) {\n        Log.d(TAG, e.getMessage(), e);\n    } catch (NoSuchAlgorithmException e) {\n        Log.d(TAG, e.getMessage(), e);\n    }\n}\n", "private void printKeyHash() {\n    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"YOUR PACKAGE NAME\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n        Log.e(\"KeyHash:\", e.toString());\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(\"KeyHash:\", e.toString());\n    }\n}\n", "private InputStream getDecodedInputStream (InputStream eis) {\n   Cipher cipher = Cipher.getInstance(\"your cipher definition\");\n   cipher.init(Cipher.DECRYPT_MODE, \"your keySpec\", new IvParameterSpec(\"your IV parameter spec\"));\n   InputStream decryptedInputStream = new CipherInputStream(is, cipher);\n   return decryptedInputStream;\n}\n", "public final class PubKeyManager implements X509TrustManager\n{\n  private static String PUB_KEY = \"30820122300d06092a864886f70d0101...\";\n\n  public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException\n  {\n    if (chain == null) {\n      throw new IllegalArgumentException(\"checkServerTrusted: X509Certificate array is null\");\n    }\n\n    if (!(chain.length &gt; 0)) {\n      throw new IllegalArgumentException(\"checkServerTrusted: X509Certificate is empty\");\n    }\n\n    if (!(null != authType &amp;&amp; authType.equalsIgnoreCase(\"RSA\"))) {\n      throw new CertificateException(\"checkServerTrusted: AuthType is not RSA\");\n    }\n\n    // Perform customary SSL/TLS checks\n    try {\n      TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");\n      tmf.init((KeyStore) null);\n\n      for (TrustManager trustManager : tmf.getTrustManagers()) {\n        ((X509TrustManager) trustManager).checkServerTrusted(chain, authType);\n      }\n    } catch (Exception e) {\n      throw new CertificateException(e);\n    }\n\n    // Hack ahead: BigInteger and toString(). We know a DER encoded Public Key begins\n    // with 0x30 (ASN.1 SEQUENCE and CONSTRUCTED), so there is no leading 0x00 to drop.\n    RSAPublicKey pubkey = (RSAPublicKey) chain[0].getPublicKey();\n    String encoded = new BigInteger(1 /* positive */, pubkey.getEncoded()).toString(16);\n\n    // Pin it!\n    final boolean expected = PUB_KEY.equalsIgnoreCase(encoded);\n    if (!expected) {\n      throw new CertificateException(\"checkServerTrusted: Expected public key: \"\n                + PUB_KEY + \", got public key:\" + encoded);\n      }\n    }\n  }\n}\n", "SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\nLog.i(TAG, \"rand.getProvider(): \" + rand.getProvider().getName());\n", "SecretKey key = SecretKeyFactory.getInstance(\n              \"PBEWithMD5AndDES\").generateSecret(keySpec);\n", "SecretKey key = SecretKeyFactory.getInstance(\n              \"PBEWithMD5AndDES\",\"BC\").generateSecret(keySpec);\n", "try {\n   PackageInfo info = getPackageManager().getPackageInfo(\"[your package name, e.g. com.yourcompany.yourapp]\", PackageManager.GET_SIGNATURES);\n   for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"Hash Key:\", Base64.encode(md.digest()));\n   }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "String password = \"_sOme*ShaREd*SecreT\";\nbyte[] salta = new byte[]{-84, -119, 25, 56, -100, 100, -120, -45, 84, 67, 96, 10, 24, 111, 112, -119, 3};\nSecretKeyFactory factory = null;\ntry {\n    factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n} catch (NoSuchAlgorithmException e2) {\n    e2.printStackTrace();\n}\nKeySpec spec = new PBEKeySpec(password.toCharArray(), salta, 1024, 128);\nSecretKey tmp = null;\ntry {\n    tmp = factory.generateSecret(spec);\n} catch (InvalidKeySpecException e2) {\n    e2.printStackTrace();\n}\nSecretKeySpec secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\nLog.i(\"The secret Key: \" , Base64.encodeToString(secret.getEncoded(), 0 ));\n", "    /* User types in their password: */\n    String password = \"password\";\n\n    /* Store these things on disk used to derive key later: */\n    int iterationCount = 1000;\n    int saltLength = 32; // bytes; should be the same size as the output (256 / 8 = 32)\n    int keyLength = 256; // 256-bits for AES-256, 128-bits for AES-128, etc\n    byte[] salt; // Should be of saltLength\n\n    /* When first creating the key, obtain a salt with this: */\n    SecureRandom random = new SecureRandom();\n    byte[] salt = new byte[saltLength];\n    randomb.nextBytes(salt);\n\n    /* Use this to derive the key from the password: */\n    KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,\n                iterationCount, keyLength);\n    SecretKeyFactory keyFactory = SecretKeyFactory\n                .getInstance(\"PBKDF2WithHmacSHA1\");\n    byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\n    SecretKey key = new SecretKeySpec(keyBytes, \"AES\");\n", "try {\n\n        File file = new File(keystore location);\n        is = new FileInputStream(file);\n        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        String password = \"password\";\n        keystore.load(is, password.toCharArray());\n\n\n        Enumeration enumeration = keystore.aliases();\n        while(enumeration.hasMoreElements()) {\n            String alias = (String)enumeration.nextElement();\n            System.out.println(\"alias name: \" + alias);\n            Certificate certificate = keystore.getCertificate(alias);\n            System.out.println(certificate.toString());\n\n        }\n\n    } catch (java.security.cert.CertificateException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (KeyStoreException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }finally {\n        if(null != is)\n            try {\n                is.close();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n    }\n", "Key key = keyStore.getKey(alias, password.toCharArray());\nString encodedKey = new Base64Encoder().encode(key.getEncoded());\nSystem.out.println(\"key ? \" + encodedKey);\n", "public static byte[] encrypt2(byte[] value) throws GeneralSecurityException, IOException\n{\n    SecretKeySpec key1 = getSecretKeySpec(true);\n    System.err.println(\"encrypt():\\t\" + key1.toString());\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key1, cipher.getParameters());\n    byte[] encrypted = cipher.doFinal(value);\n\n    SecretKeySpec key2 = getSecretKeySpec(false);\n    System.err.println(\"encrypt():\\t\" + key2.toString());\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, key2, new IvParameterSpec(getIV()));\n    byte[] encrypted2 = cipher.doFinal(encrypted);\n\n    return encrypted2;//Base64Coder.encode(encrypted2);\n}\n\npublic static byte[] decrypt2(byte[] message, boolean A) throws GeneralSecurityException, IOException\n{\n    SecretKeySpec key1 = getSecretKeySpec(false);\n    System.err.println(\"decrypt():\\t\" + key1.toString());\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, key1, new IvParameterSpec(getIV()));\n    byte[] decrypted = cipher.doFinal(message);\n\n    SecretKeySpec key2 = getSecretKeySpec(true);\n    System.err.println(\"decrypt():\\t\" + key2.toString());\n    cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key2);\n    byte[] decrypted2 = cipher.doFinal(decrypted);\n\n    return decrypted2;\n}\n", " // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"yourpackagename\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "private void getSHAFingerPrint(){\n      PackageInfo info;\n      try {\n\n          info = getPackageManager().getPackageInfo(\n                  \"your.package\", PackageManager.GET_SIGNATURES);\n\n          for (Signature signature : info.signatures) {\n              MessageDigest md;\n              md = MessageDigest.getInstance(\"SHA\");\n              md.update(signature.toByteArray());\n              String something = new String(Base64.encode(md.digest(), 0));\n              Log.e(\"Hash key\", something);\n              System.out.println(\"Hash key\" + something);\n          }\n\n      } catch (NameNotFoundException e1) {\n          Log.e(\"name not found\", e1.toString());\n      } catch (NoSuchAlgorithmException e) {\n          Log.e(\"no such an algorithm\", e.toString());\n      } catch (Exception e) {\n          Log.e(\"exception\", e.toString());\n      }\n  }\n", "    public class Sample {\n\n    static {\n        Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);\n    }\n\n    public void printProviders() {\n        for (Provider provider : Security.getProviders()) {\n            System.out.println(\"Provider: \" + provider.getName());\n            for (Provider.Service service : provider.getServices()) {\n                System.out.println(\"  Algorithm: \" + service.getAlgorithm());\n            }\n        }\n    }\n}\n", "TrustManagerFactory tmf;\n    try {\n        tmf = TrustManagerFactory.getInstance(TrustManagerFactory\n                .getDefaultAlgorithm());\n\n        tmf.init((KeyStore) null);\n\n        X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];\n        for (X509Certificate cert : xtm.getAcceptedIssuers()) {\n            String certStr = \"S:\" + cert.getSubjectDN().getName() + \"\\nI:\"\n                    + cert.getIssuerDN().getName();\n            Log.d(LOG_TAG, certStr);\n        }\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (KeyStoreException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n", "try \n    {\n        KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\n        if (ks != null) \n        {\n            ks.load(null, null);\n            Enumeration aliases = ks.aliases();\n            while (aliases.hasMoreElements()) \n            {\n                String alias = (String) aliases.nextElement();\n                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);\n\n                Log.d(LOG_TAG, cert.getIssuerDN().getName());\n            }\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (KeyStoreException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (java.security.cert.CertificateException e) {\n        e.printStackTrace();\n    }\n", "FileInputStream fis = new FileInputStream(new File(\"D:/Shashank/Test123.txt\"));\n        File outfile = new File(\"D:/Shashank/encTest1234.txt\");\n        int read;\n        if(!outfile.exists())\n            outfile.createNewFile();\n        File decfile = new File(\"D:/Shashank/dec123.txt\");\n        if(!decfile.exists())\n            decfile.createNewFile();\n        FileOutputStream fos = new FileOutputStream(outfile);\n        FileInputStream encfis = new FileInputStream(outfile);\n        FileOutputStream decfos = new FileOutputStream(decfile);\n        Cipher encipher = Cipher.getInstance(\"AES\");\n        Cipher decipher = Cipher.getInstance(\"AES\");\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecretKey skey = kgen.generateKey();\n        encipher.init(Cipher.ENCRYPT_MODE, skey);\n        CipherInputStream cis = new CipherInputStream(fis, encipher);\n        decipher.init(Cipher.DECRYPT_MODE, skey);\n        CipherOutputStream cos = new CipherOutputStream(decfos,decipher);\n        while((read = cis.read())!=-1)\n                {\n                    fos.write((char)read);\n                    fos.flush();\n                }   \n        fos.close();\n        while((read=encfis.read())!=-1)\n        {\n            cos.write(read);\n            cos.flush();\n        }\n    cos.close();\n", "    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n            \"your package name, e.g. com.yourcompany.yourapp]\", \n            PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "private enum BuildSigner {\n    unknown,\n    Joe,\n    Carl,\n    Linda\n}\n\nprivate BuildSigner whoBuiltThis() {\n    try {\n        PackageManager packageManager = getPackageManager();\n        PackageInfo info = packageManager.getPackageInfo(getPackageName(),\n                PackageManager.GET_SIGNATURES);\n        Signature[] signs = info.signatures;\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        X509Certificate cert = (X509Certificate)cf.generateCertificate(\n                new ByteArrayInputStream(signs[0].toByteArray()));\n        PublicKey key = cert.getPublicKey();\n        int modulusHash = ((RSAPublicKey)key).getModulus().hashCode();\n        switch (modulusHash) {\n            case 123456789:\n                return BuildSigner.Joe;\n            case 424242424:\n                return BuildSigner.Carl;\n            case -975318462:\n                return BuildSigner.Linda;\n        }\n    } catch (Exception e) {\n    }\n\n    return BuildSigner.unknown;\n}\n", "@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.main);\n    int hash = 0;\n    try{\n        PackageManager packageManager = getPackageManager();\n        PackageInfo info = packageManager.getPackageInfo(\n                \"com.stackexchange.marvin\", PackageManager.GET_SIGNATURES);\n        Signature[] signs = info.signatures;\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        X509Certificate cert = (X509Certificate) cf.generateCertificate(\n                new ByteArrayInputStream(signs[0].toByteArray()));\n        PublicKey key = cert.getPublicKey();\n        hash = ((RSAPublicKey) key).getModulus().hashCode();\n    }catch(Exception e){}\n\n    TextView tv = ((TextView)findViewById(R.id.tv));\n    tv.setText(\"The Stack Exchange app's signature hash is \" + hash + \".\");\n    tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 24);\n}\n", "import org.apache.http.conn.ssl.SSLSocketFactory;\n\npublic class MyHttpClient extends DefaultHttpClient {\n  final Context context;\n\n  public MyHttpClient(Context context) {\n    this.context = context;\n  }\n\n  @Override \n  protected ClientConnectionManager createClientConnectionManager() {\n    SchemeRegistry registry = new SchemeRegistry();\n    registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n    registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n    return new SingleClientConnManager(getParams(), registry);\n  }\n\n  private SSLSocketFactory newSslSocketFactory() {\n    try {\n      TrustManager tm = new MyCustomTrustManager();\n      SSLContext ctx = SSLContext.getInstance(\"TLS\");\n      ctx.init(null, new TrustManager[] {tm}, null);\n      SSLSocketFactory sf = new SSLSocketFactory(ctx);\n      return new SSLSocketFactory(ctx);\n    } catch (Exception e) {\n      throw new Error(e);\n    }\n  }\n}\n", "    import java.io.ByteArrayInputStream;\n    import java.io.ByteArrayOutputStream;\n    import java.io.File;\n    import java.io.FileInputStream;\n    import java.io.IOException;\n    import java.nio.ByteBuffer;\n    import java.nio.ByteOrder;\n    import java.nio.charset.Charset;\n    import java.nio.file.Files;\n    import java.nio.file.Path;\n    import java.nio.file.Paths;\n    import javax.crypto.Cipher;\n    import javax.crypto.spec.IvParameterSpec;\n    import javax.crypto.spec.SecretKeySpec;\n\n    public class HelloWorld {\n\n        public static void main(String[] args) throws Exception {\n            // TODO Auto-generated method stub\n            Path p = Paths\n                    .get(\"C:\\\\Users\\\\casilva\\\\workspace\\\\StackOverflow\\\\src\\\\tst.enc\");\n\n            byte[] a = Files.readAllBytes(p);\n            byte[] result = decodeFile(\"myKey123\", a);\n            System.out.println(\"Result=\" + new String(result, \"UTF-8\"));\n        }\n\n\n        public static byte[] decodeFile(String key, byte[] fileData)\n                throws Exception {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            byte[] bKey = key.getBytes(\"UTF-16LE\");\n\n            SecretKeySpec keySpec = new SecretKeySpec(bKey, \"AES\");\n\n            IvParameterSpec ivSpec = new IvParameterSpec(bKey);\n\n            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\n            byte[] decrypted = cipher.doFinal(fileData);\n\n            return decrypted;\n        }\n\n    }\n", "try{                \n      String keyStoreType = KeyStore.getDefaultType();\n      KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n      keyStore.load(Dummy.class.getResourceAsStream(\"IPMessengerServerKeystore\"), \"dhar9654\".toCharArray());                \n\n      String keyalg=KeyManagerFactory.getDefaultAlgorithm();\n      KeyManagerFactory kmf=KeyManagerFactory.getInstance(keyalg);\n      kmf.init(keyStore, \"dhar9654\".toCharArray());\n\n      SSLContext context = SSLContext.getInstance(\"TLS\");\n      context.init(MainActivity.kmf.getKeyManagers(), null, null);          \n      SSLServerSocket ss=(SSLServerSocket)context.getServerSocketFactory().createServerSocket(Constants.CHAT_SERVER_PORT);\n\n  }catch(Exception e){\n     e.printStackTrace();\n   }     \n", " private HttpClient getNewHttpClient() {\n\n                try {               \n                        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                        trustStore.load(null, null);\n\n                        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n                        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n                        HttpParams params = new BasicHttpParams();\n                        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n                        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n                        SchemeRegistry registry = new SchemeRegistry();\n                        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n                        registry.register(new Scheme(\"https\", sf, 443));\n\n                        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n                        return new DefaultHttpClient(ccm, params);\n                    } catch (Exception e) {\n                        return new DefaultHttpClient();\n                    }\n                }\n", " public class MySSLSocketFactory extends SSLSocketFactory {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n            public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n                super(truststore);\n\n                TrustManager tm = new X509TrustManager() {\n                    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                    }\n\n                    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                    }\n\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                    }\n                };\n\n                sslContext.init(null, new TrustManager[] { tm }, null);\n            }\n\n            @Override\n            public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n                return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n            }\n\n            @Override\n            public Socket createSocket() throws IOException {\n                return sslContext.getSocketFactory().createSocket();\n            }\n        }\n", " private void getShaKey() {\n\n try {\n PackageInfo info = getPackageManager().getPackageInfo(\"YOUR_PACKAGE_NAME\",\n PackageManager.GET_SIGNATURES);\n for (Signature signature : info.signatures) {\n MessageDigest md = MessageDigest.getInstance(\"SHA\");\n md.update(signature.toByteArray());\n Log.v(TAG, \"KeyHash:\" + Base64.encodeToString(md.digest(),\n Base64.DEFAULT));\n }\n } catch (NameNotFoundException e) {\n e.printStackTrace();\n } catch (NoSuchAlgorithmException e) {\n e.printStackTrace();\n }\n\n }\n", "HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n\nDefaultHttpClient client = new DefaultHttpClient();\n\nSchemeRegistry registry = new SchemeRegistry();\nSSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();\nsocketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\nregistry.register(new Scheme(\"https\", socketFactory, 8443));\nSingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);\nDefaultHttpClient httpClient = new DefaultHttpClient(mgr, client.getParams());\n\n// Set verifier      \nHttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n\n// Example send http request\nfinal String url = \"https://ts.xoomworks.com:8443/XoomworksTimesheets/ping/\";\nHttpPost httpPost = new HttpPost(url);\nHttpResponse response = httpClient.execute(httpPost);\n\nresponse.getStatusLine().getStatusCode();\n\nin = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\nStringBuffer sb = new StringBuffer(\"\");\nString l = \"\";\nString nl = System.getProperty(\"line.separator\");\nwhile ((l = in.readLine()) !=null){\n    sb.append(l + nl);\n}\nin.close();\ndata = sb.toString();\nreturn data;\n", "    import java.security.SecureRandom;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.KeyGenerator;\n    import javax.crypto.SecretKey;\n    import javax.crypto.spec.SecretKeySpec;\n\n    import android.util.Base64;\n\n    public class StringCryptor \n    {\n        private static final String CIPHER_ALGORITHM = \"AES\";\n        private static final String RANDOM_GENERATOR_ALGORITHM = \"SHA1PRNG\";\n        private static final int RANDOM_KEY_SIZE = 128;\n\n        // Encrypts string and encode in Base64\n        public static String encrypt( String password, String data ) throws Exception \n        {\n            byte[] secretKey = generateKey( password.getBytes() );\n            byte[] clear = data.getBytes();\n\n            SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );\n            Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );\n            cipher.init( Cipher.ENCRYPT_MODE, secretKeySpec );\n\n            byte[] encrypted = cipher.doFinal( clear );\n            String encryptedString = Base64.encodeToString( encrypted, Base64.DEFAULT );\n\n            return encryptedString;\n        }\n\n        // Decrypts string encoded in Base64\n        public static String decrypt( String password, String encryptedData ) throws Exception \n        {\n            byte[] secretKey = generateKey( password.getBytes() );\n\n            SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );\n            Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );\n            cipher.init( Cipher.DECRYPT_MODE, secretKeySpec );\n\n            byte[] encrypted = Base64.decode( encryptedData, Base64.DEFAULT );\n            byte[] decrypted = cipher.doFinal( encrypted );\n\n            return new String( decrypted );\n        }\n\n        public static byte[] generateKey( byte[] seed ) throws Exception\n        {\n            KeyGenerator keyGenerator = KeyGenerator.getInstance( CIPHER_ALGORITHM );\n            SecureRandom secureRandom = SecureRandom.getInstance( RANDOM_GENERATOR_ALGORITHM );\n            secureRandom.setSeed( seed );\n            keyGenerator.init( RANDOM_KEY_SIZE, secureRandom );\n            SecretKey secretKey = keyGenerator.generateKey();\n            return secretKey.getEncoded();\n        }\n    }\n", "FileInputStream fis = new FileInputStream(new File(\"D:/Shashank/inputVideo.avi\"));\n        File outfile = new File(\"D:/Shashank/encVideo.avi\");\n        int read;\n        if(!outfile.exists())\n            outfile.createNewFile();\n        File decfile = new File(\"D:/Shashank/decVideo.avi\");\n        if(!decfile.exists())\n            decfile.createNewFile();\n        FileOutputStream fos = new FileOutputStream(outfile);\n        FileInputStream encfis = new FileInputStream(outfile);\n        FileOutputStream decfos = new FileOutputStream(decfile);\n        Cipher encipher = Cipher.getInstance(\"AES\");\n        Cipher decipher = Cipher.getInstance(\"AES\");\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        //byte key[] = {0x00,0x32,0x22,0x11,0x00,0x00,0x00,0x00,0x00,0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x00};\n        SecretKey skey = kgen.generateKey();\n        //Lgo\n        encipher.init(Cipher.ENCRYPT_MODE, skey);\n        CipherInputStream cis = new CipherInputStream(fis, encipher);\n        decipher.init(Cipher.DECRYPT_MODE, skey);\n        CipherOutputStream cos = new CipherOutputStream(decfos,decipher);\n        while((read = cis.read())!=-1)\n                {\n                    fos.write((char)read);\n                    fos.flush();\n                }   \n        fos.close();\n        while((read=encfis.read())!=-1)\n        {\n            cos.write(read);\n            cos.flush();\n        }\n    cos.close(); \n", "try{\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.example.creeper\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\",Base64.encodeToString(md.digest(), Base64.DEFAULT));       \n\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n}\n", "String algorithm = key.getAlgorithm();\nCipher cipher = Cipher.getInstance(algorithm);\n", "try {\nPackageInfo info = getPackageManager().getPackageInfo(\"com.eatapp\", PackageManager.GET_SIGNATURES);\nfor (Signature signature : info.signatures) {\n    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n    md.update(signature.toByteArray());\n    Log.e(\"MY KEY HASH:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n}\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "import java.io.UnsupportedEncodingException;\nimport java.security.Security;\nimport java.security.spec.KeySpec;\nimport java.util.Random;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class SSL {\n\n    private final static String HEX = \"0123456789ABCDEF\";\n    private final static String ENC = \"US-ASCII\";\n    private final static int ITERATION = 1337;\n\n    private static final String RANDOM_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n    private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n    private static final String SECRET_KEY_ALGORITHM = \"AES\";\n\n    private static IvParameterSpec ips;\n\n    public static void init(byte[] iv) {\n        if(iv == null) {\n            iv = new byte[16];\n\n            Random random = new Random();\n            random.nextBytes(iv);\n        }\n\n        ips = new IvParameterSpec(iv);\n\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    public static byte[] getCertificate() {\n        return ips.getIV();\n    }\n\n    public static String encrypt(Session current, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(current.getCurrentSession().toCharArray());\n        byte[] result = encrypt(rawKey, cleartext.getBytes(ENC));\n        return toHex(result);\n    }\n\n    public static String decrypt(Session current, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(current.getCurrentSession().toCharArray());\n        byte[] enc = toByte(encrypted);     \n        byte[] result = decrypt(rawKey, enc);\n        return new String(result, ENC);\n    }\n\n    private static byte[] getRawKey(char[] seed) throws Exception {\n        KeySpec keySpec = new PBEKeySpec(seed, ips.getIV(), ITERATION);\n\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(RANDOM_ALGORITHM);\n        byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\n        SecretKey secretKey = new SecretKeySpec(keyBytes, \"AES\");\n\n        return secretKey.getEncoded();\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, SECRET_KEY_ALGORITHM);\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ips);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, SECRET_KEY_ALGORITHM);\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, ips);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) throws UnsupportedEncodingException {\n        return toHex(txt.getBytes(ENC));\n    }\n    public static String fromHex(String hex) throws UnsupportedEncodingException {\n        return new String(toByte(hex), ENC);\n    }\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i &lt; len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i &lt; buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));\n    }\n}\n", "         // Add code to print out the key hash\ntry {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.facebook.samples.hellofacebook\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "public URLConnection getTolerantClient(URL url) throws IOException {\n    URLConnection conn = url.openConnection();\n    if (!(conn instanceof HttpsURLConnection)) {\n        /* not an https:// URL, nothing to do */\n        return conn;\n    }\n    HttpsURLConnection httpsconn = (HttpsURLConnection)conn;\n    final HostnameVerifier delegate = httpsconn.getHostnameVerifier();\n    if(!(delegate instanceof MyVerifier)) {\n        httpsconn.setHostnameVerifier(new MyVerifier(delegate));\n    }\n    return conn;\n}\n", "public class AES {\n\n    public static SecretKey generateAESKey(int bits) throws NoSuchAlgorithmException{\n        //This method is provided as to securely generate a AES key of the given length.\n\n        //In practice you can specify your own SecureRandom instance.\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        kgen.init(bits);\n        return kgen.generateKey();\n    }\n\n    public static byte[] encrypt(SecretKey key, byte[] plaintext) throws Exception{\n        //In practice you should specify your SecureRandom implementation.\n        SecureRandom rnd = new SecureRandom();\n\n        //Generate random IV of 128-bit (AES block size)\n        byte[] IV = new byte[128 / 8]; \n        rnd.nextBytes(IV);\n        IvParameterSpec IVSpec = new IvParameterSpec(IV);\n\n        //Create the cipher object to perform AES operations.\n        //Specify Advanced Encryption Standard - Cipher Feedback Mode - No Padding\n        Cipher AESCipher = Cipher.getInstance(\"AES/CFB/NoPadding\");\n\n        //Initialize the Cipher with the key and initialization vector.\n        AESCipher.init(Cipher.ENCRYPT_MODE, key, IVSpec);\n\n        //Encrypts the plaintext data\n        byte[] ciphertext = AESCipher.doFinal(plaintext);\n\n       /*\n        * The IV must now be transferred with the ciphertext somehow. The easiest \n        * way to accomplish this would be to prepend the IV to the ciphertext \n        * message.\n        */\n\n        //Allocate new array to hold ciphertext + IV\n        byte[] output = new byte[ciphertext.length + (128 / 8)];\n\n        //Copy the respective parts into the array.\n        System.arraycopy(IV, 0, output, 0, IV.length);\n        System.arraycopy(ciphertext, 0, output, IV.length, ciphertext.length);\n\n        return output;\n    }\n\n    public static byte[] decrypt(SecretKey key, byte[] IV, byte[] ciphertext) throws Exception{\n        //Create the cipher object to perform AES operations.\n        //Specify Advanced Encryption Standard - Cipher Feedback Mode - No Padding\n        Cipher AESCipher = Cipher.getInstance(\"AES/CFB/NoPadding\");\n\n        //Create the IvParameterSpec object from the raw IV\n        IvParameterSpec IVSpec = new IvParameterSpec(IV);\n\n        //Initialize the Cipher with the key and initialization vector.\n        AESCipher.init(Cipher.DECRYPT_MODE, key, IVSpec);\n\n        //Decrypts the ciphertext data\n        byte[] plaintext = AESCipher.doFinal(ciphertext);\n\n        return plaintext;\n    }\n\n    public static void main(String[] args) throws Exception{\n        //Demo the program\n\n        String sPlaintext = \"rainbows\"; //String plaintext\n        byte[] rPlaintext = sPlaintext.getBytes(Charset.forName(\"UTF-8\")); //Raw byte array plaintext\n\n        //We first need to generate a key of 128-bit\n        SecretKey key = generateAESKey(128);\n\n        //Encrypt the plaintext\n        byte[] output = encrypt(key, rPlaintext);\n\n        // ----------------- //\n\n        //Extract the IV from the encryption output\n        byte[] IV = new byte[128 / 8];\n        byte[] ciphertext = new byte[output.length - (128 / 8)];\n\n        System.arraycopy(output, 0, IV, 0, IV.length);\n        System.arraycopy(output, IV.length, ciphertext, 0, ciphertext.length);\n\n        //Decrypt the ciphertext\n        byte[] dPlaintext = decrypt(key, IV, ciphertext);\n\n        String decryptedMessage = new String(dPlaintext, Charset.forName(\"UTF-8\"));\n\n        //Print stuff out\n        System.out.println(\"Original message: \" + sPlaintext);\n        System.out.println(\"Original message bytes: \" + Arrays.toString(rPlaintext));\n        System.out.println(\"Encryption Output bytes: \" + Arrays.toString(output));\n        System.out.println(\"Decrypted message bytes: \" + Arrays.toString(dPlaintext));\n        System.out.println(\"Decrypted message: \" + decryptedMessage);\n    }\n}\n", "/*\n * Return the string from a authenticated SSL secured webserver call\n * */\npublic String sendHTTPSPostMessage(String userName, String userPass, String url, String[] postVars) throws NoSuchAlgorithmException, KeyManagementException, MalformedURLException, IOException {\n    StringBuffer sb = new StringBuffer();\n\n    final String serverAuth = userName + \":\" + userPass;\n    final String serverAuthBase64 = MyBase64.encode(serverAuth.getBytes());\n\n    SSLContext sc = SSLContext.getInstance(\"TLS\");\n    sc.init(null, new TrustManager[] { new MyTrustManager() }, new SecureRandom());\n    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n    HttpsURLConnection.setDefaultHostnameVerifier(new MyHostnameVerifier());\n    HttpsURLConnection con = (HttpsURLConnection) new URL(url).openConnection();\n\n    try {\n        StringBuffer urlParameters = new StringBuffer();\n        String[] tmpPair = null;\n\n        for (int i = 0; i &lt; postVars.length; i++) {\n            tmpPair = postVars[i].toString().split(\"=\");\n\n            if (i &gt; 0)\n                urlParameters.append(\"&amp;\" + tmpPair[0] + \"=\" + URLEncoder.encode(tmpPair[1], \"UTF-8\"));\n            else\n                urlParameters.append(tmpPair[0] + \"=\" + URLEncoder.encode(tmpPair[1], \"UTF-8\"));\n        }\n\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Authorization\", \"Basic \" + serverAuthBase64);\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.toString().getBytes().length));\n        con.setUseCaches(false);\n        con.setDoOutput(true);\n        con.setDoInput(true);\n\n        DataOutputStream wr = new DataOutputStream (con.getOutputStream());\n        wr.writeBytes (urlParameters.toString());\n        wr.flush();\n        wr.close();\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()), 8192 );\n        String line;\n        while ( ( line = br.readLine() ) != null ) {\n                sb.append(line);\n        }\n    }\n    catch(Exception e) {\n        Log.e(\"sendHTTPSPostMessage\", e.getLocalizedMessage());\n    }\n    finally {\n        if(con != null) {\n            con.disconnect(); \n        }\n    }\n    return sb.toString();\n}\n", "public class ClientSSLSocketFactory extends SSLCertificateSocketFactory {\n    private SSLContext sslContext;\n\n    public static SSLSocketFactory getSocketFactory(){\n        try\n        {\n            X509TrustManager tm = new X509TrustManager() {\n                public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {}\n\n                public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {}\n\n                public X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n            };\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, new TrustManager[] { tm }, null);\n\n            SSLSocketFactory ssf = ClientSSLSocketFactory.getDefault(10000, new SSLSessionCache(Application.getInstance()));\n\n            return ssf;\n        } catch (Exception ex) {\n            return null;\n        }\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n}\n", "public void trustSelfSignedSSL() {\n        try {\n            SSLContext ctx = SSLContext.getInstance(\"TLS\");\n            X509TrustManager tm = new X509TrustManager() {\n\n                public void checkClientTrusted(X509Certificate[] xcs,\n                        String string) throws CertificateException {\n                }\n\n                public void checkServerTrusted(X509Certificate[] xcs,\n                        String string) throws CertificateException {\n                }\n\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n\n                @Override\n                public void checkClientTrusted(\n                        java.security.cert.X509Certificate[] arg0, String arg1)\n                        throws java.security.cert.CertificateException {\n                }\n\n                @Override\n                public void checkServerTrusted(\n                        java.security.cert.X509Certificate[] arg0, String arg1)\n                        throws java.security.cert.CertificateException {\n\n                }\n            };\n            ctx.init(null, new TrustManager[] { tm }, null);\n            SSLContext.setDefault(ctx);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Exception occurred \",ex)\n        }\n    }\n", "String keyStoreType = KeyStore.getDefaultType();\nKeyStore keyStore = KeyStore.getInstance(keyStoreType);\n", " static final String ENABLED_CIPHERS[] = {\n    \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\",\n    \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\",\n    \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\",\n    \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\",\n    \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\",\n    \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\",\n    \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\",\n    \"TLS_ECDHE_RSA_WITH_RC4_128_SHA\",\n    \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\",\n    \"TLS_RSA_WITH_AES_256_CBC_SHA\",\n    \"TLS_RSA_WITH_AES_128_CBC_SHA\",\n    \"SSL_RSA_WITH_3DES_EDE_CBC_SHA\",\n    \"SSL_RSA_WITH_RC4_128_SHA\",\n    \"SSL_RSA_WITH_RC4_128_MD5\",\n};\n// put this in a place where it can be reused\nstatic final String ENABLED_PROTOCOLS[] = {\n        \"TLSv1.2\", \"TLSv1.1\", \"TLSv1\"\n    };\n\n   private void sslCon()\n    {\n        try {\n                             // setup truststore to provide trust for the server certificate\n              // load truststore certificate\n            InputStream trustStoresIs = getResources().openRawResource(R.raw.client_ca);\n            String trustStoreType = KeyStore.getDefaultType();\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            trustStore.load(trustStoresIs, \"spsoft_123\".toCharArray());\n            //keyStore.setCertificateEntry(\"ca\", ca);\n\n            // initialize trust manager factory with the read truststore\n            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n            tmf.init(trustStore);\n\n            // setup client certificate\n            // load client certificate\n            InputStream keyStoreStream = getResources().openRawResource(R.raw.client_cert_key);\n            KeyStore keyStore = null;\n            keyStore = KeyStore.getInstance(\"BKS\");\n            keyStore.load(keyStoreStream, \"your password\".toCharArray());\n\n            KeyManagerFactory keyManagerFactory = null;\n            keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, \"your password\".toCharArray());\n\n            // Create an SSLContext that uses our TrustManager\n            SSLContext context = SSLContext.getInstance(\"SSL\");\n            context.init(keyManagerFactory.getKeyManagers(), tmf.getTrustManagers(), null);\n\n            SSLSocketFactory sslsocketfactory = (SSLSocketFactory)context.getSocketFactory();\n            InetAddress serverAddr = InetAddress.getByName(\"192.168.11.104\");\n            sslSocket = (SSLSocket) sslsocketfactory.createSocket(serverAddr, 5212);\n            //String[] ciphers = sslSocket.getEnabledCipherSuites();\n            sslSocket.setEnabledCipherSuites(ENABLED_CIPHERS);\n            // put this right before setEnabledCipherSuites()!\n            //sslSocket.setEnabledProtocols(ENABLED_PROTOCOLS);\n            //InputStream inputStream =  sslSocket.getInputStream();\n            OutputStream out = sslSocket.getOutputStream();\n\n            Toast.makeText(getApplicationContext(), \"Connected\", Toast.LENGTH_SHORT).show();\n            sslSocket.close();\n\n\n        } catch (KeyManagementException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (KeyStoreException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n}\n", "MessageDigest md = MessageDigest.getInstance(\"MD5\");\ntry (InputStream is = Files.newInputStream(Paths.get(\"file.txt\"))) {\n  DigestInputStream dis = new DigestInputStream(is, md);\n  /* Read stream to EOF as normal... */\n}\nbyte[] digest = md.digest();\n", "   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n          super.onCreate(savedInstanceState);\n          setContentView(R.layout.activity_main);\n\n          Button encryptButton = (Button) findViewById(R.id.button1);\n          Button DecryptButton = (Button) findViewById(R.id.button2);\n          encryptButton.setOnClickListener(new OnClickListener() {\n\n                 @Override\n                 public void onClick(View v) {\n                       // TODO Auto-generated method stub\n                       try {\n                              encrypt();\n                       } catch (InvalidKeyException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (NoSuchAlgorithmException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (NoSuchPaddingException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (IOException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       }\n                 }\n          });\n\n          DecryptButton.setOnClickListener(new OnClickListener() {\n\n                 @Override\n                 public void onClick(View v) {\n                       // TODO Auto-generated method stub\n                       try {\n                              decrypt();\n                       } catch (InvalidKeyException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (NoSuchAlgorithmException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (NoSuchPaddingException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (IOException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       }\n                 }\n          });\n\n   }\n\n   /**\n    * Here is Both function for encrypt and decrypt file in Sdcard folder. we\n    * can not lock folder but we can encrypt file using AES in Android, it may\n    * help you.\n    *\n    * @throws IOException\n    * @throws NoSuchAlgorithmException\n    * @throws NoSuchPaddingException\n    * @throws InvalidKeyException\n    */\n\n   static void encrypt() throws IOException, NoSuchAlgorithmException,\n                 NoSuchPaddingException, InvalidKeyException {\n          // Here you read the cleartext.\n          File extStore = Environment.getExternalStorageDirectory();\n          FileInputStream fis = new FileInputStream(extStore + \"/sampleFile\");\n          // This stream write the encrypted text. This stream will be wrapped by\n          // another stream.\n          FileOutputStream fos = new FileOutputStream(extStore + \"/encrypted\");\n\n          // Length is 16 byte\n          SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(),\n                       \"AES\");\n          // Create cipher\n          Cipher cipher = Cipher.getInstance(\"AES\");\n          cipher.init(Cipher.ENCRYPT_MODE, sks);\n          // Wrap the output stream\n          CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n          // Write bytes\n          int b;\n          byte[] d = new byte[8];\n          while ((b = fis.read(d)) != -1) {\n                 cos.write(d, 0, b);\n          }\n          // Flush and close streams.\n          cos.flush();\n          cos.close();\n          fis.close();\n   }\n\n   static void decrypt() throws IOException, NoSuchAlgorithmException,\n                 NoSuchPaddingException, InvalidKeyException {\n\n          File extStore = Environment.getExternalStorageDirectory();\n          FileInputStream fis = new FileInputStream(extStore + \"/encrypted\");\n\n          FileOutputStream fos = new FileOutputStream(extStore + \"/decrypted\");\n          SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(),\n                       \"AES\");\n          Cipher cipher = Cipher.getInstance(\"AES\");\n          cipher.init(Cipher.DECRYPT_MODE, sks);\n          CipherInputStream cis = new CipherInputStream(fis, cipher);\n          int b;\n          byte[] d = new byte[8];\n          while ((b = cis.read(d)) != -1) {\n                 fos.write(d, 0, b);\n          }\n          fos.flush();\n          fos.close();\n          cis.close();\n   }\n", "import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.security.KeyFactory;\nimport java.security.Signature;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport org.spongycastle.util.io.pem.PemObject;\nimport org.spongycastle.util.io.pem.PemReader;\n\npublic class VerifySignature {\n    public static void main(final String[] args) throws Exception {\n        try (PemReader reader = publicKeyReader(); InputStream data = data(); InputStream signatureData = signature()) {\n            final PemObject publicKeyPem = reader.readPemObject();\n            final byte[] publicKeyBytes = publicKeyPem.getContent();\n            final KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            final X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);\n            final RSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(publicKeySpec);\n\n            final Signature signature = Signature.getInstance(\"SHA1withRSA\");\n            signature.initVerify(publicKey);\n\n            final byte[] buffy = new byte[16 * 1024];\n            int read = -1;\n            while ((read = data.read(buffy)) != -1) {\n                signature.update(buffy, 0, read);\n            }\n\n            final byte[] signatureBytes = new byte[publicKey.getModulus().bitLength() / 8];\n            signatureData.read(signatureBytes);\n\n            System.out.println(signature.verify(signatureBytes));\n        }\n    }\n\n    private static InputStream data() throws FileNotFoundException {\n        return new FileInputStream(\"someHTMLDoc.html\");\n    }\n\n    private static PemReader publicKeyReader() throws FileNotFoundException {\n        return new PemReader(new InputStreamReader(new FileInputStream(\"publicKey.pem\")));\n    }\n\n    private static InputStream signature() throws FileNotFoundException {\n        return new FileInputStream(\"signature.bin\");\n    }\n}\n", "private void getAppKeyHash() {\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md;\n\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String something = new String(Base64.encode(md.digest(), 0));\n            Log.d(\"Hash key\", something);\n        } \n    }\n    catch (NameNotFoundException e1) {\n        // TODO Auto-generated catch block\n        Log.e(\"name not found\", e1.toString());\n    }\n\n    catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        Log.e(\"no such an algorithm\", e.toString());\n    }\n    catch (Exception e){\n        Log.e(\"exception\", e.toString());\n    }\n\n}\n", "try {\n\n   PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\n\n   for (Signature signature : info.signatures) \n   {\n    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n    md.update(signature.toByteArray());\n    Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n   }\n\n  } catch (NameNotFoundException e) {\n   Log.e(\"name not found\", e.toString());\n  } catch (NoSuchAlgorithmException e) {\n   Log.e(\"no such an algorithm\", e.toString());\n  }\n", "public final class NetworkUtils {\npublic static final byte CONNECTION_OFFLINE = 1;\npublic static final byte CONNECTION_WIFI = 2;\npublic static final byte CONNECTION_ROAMING = 3;\npublic static final byte CONNECTION_SLOW = 4;\npublic static final byte CONNECTION_FAST = 5;\n\nprivate static String sUserId;\n\nprivate NetworkUtils() {}\n\n\n/**\n * Check if the device is connected to the internet (mobile network or\n * WIFI).\n */\npublic static boolean isOnline(Context _context) {\n    boolean online = false;\n\n    TelephonyManager tmanager = (TelephonyManager) _context.getSystemService(Context.TELEPHONY_SERVICE);\n    if (tmanager != null) {\n        if (tmanager.getDataState() == TelephonyManager.DATA_CONNECTED) {\n            // Mobile network\n            online = true;\n        } else {\n            // WIFI\n            ConnectivityManager cmanager = (ConnectivityManager) _context\n                    .getSystemService(Context.CONNECTIVITY_SERVICE);\n            if (cmanager != null) {\n                NetworkInfo info = cmanager.getActiveNetworkInfo();\n                if (info != null)\n                    online = info.isConnected();\n            }\n        }\n    }\n\n    return online;\n}\n\n/**\n * Get the User Agent String in the format\n * AppName + AppVersion + Model + ReleaseVersion + Locale\n */\npublic static String getUserAgentString(Context _c, String _appName) {\n    if(_appName == null)\n        _appName = \"\";\n\n    String agent = _appName + \" \" + BackendUtil.getAppVersionString(_c) + \" (\" + Build.MODEL + \"; Android \"\n            + Build.VERSION.RELEASE + \"; \" + Locale.getDefault() + \")\";\n\n    if(agent.startsWith(\" \"))\n        agent = agent.substring(1);\n\n    return agent;\n}\n\n/**\n * Evaluate the current network connection and return the\n * corresponding type, e.g. CONNECTION_WIFI.\n */\npublic static byte getCurrentNetworkType(Context _context){\n    NetworkInfo netInfo = ((ConnectivityManager) _context.getSystemService(Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo();\n\n    if(netInfo == null)\n        return CONNECTION_OFFLINE;\n\n    if(netInfo.getType() == ConnectivityManager.TYPE_WIFI)\n        return CONNECTION_WIFI;\n\n    if(netInfo.isRoaming())\n        return CONNECTION_ROAMING;\n\n    if(!(netInfo.getType() == ConnectivityManager.TYPE_MOBILE \n            &amp;&amp;  (netInfo.getSubtype() == TelephonyManager.NETWORK_TYPE_UMTS \n              || netInfo.getSubtype() == TelephonyManager.NETWORK_TYPE_HSDPA\n              || netInfo.getSubtype() == TelephonyManager.NETWORK_TYPE_HSUPA\n              || netInfo.getSubtype() == TelephonyManager.NETWORK_TYPE_HSPA \n              || netInfo.getSubtype() == 13 // NETWORK_TYPE_LTE\n              || netInfo.getSubtype() == 15))) // NETWORK_TYPE_HSPAP  \n         {\n\n        return CONNECTION_SLOW;\n    }\n\n    return CONNECTION_FAST;\n}\n\n\n/**\n * Return the current IP adresse of the device or null if it could not be\n * found.\n */\npublic static String getIpAdress() {\n    String result = null;\n    try {\n        for (Enumeration&lt;NetworkInterface&gt; interfaces = NetworkInterface.getNetworkInterfaces(); interfaces.hasMoreElements();) {\n            NetworkInterface iface = interfaces.nextElement();\n            for (Enumeration&lt;InetAddress&gt; adresses = iface.getInetAddresses(); adresses.hasMoreElements();) {\n                InetAddress ip = adresses.nextElement();\n                if (!ip.isLoopbackAddress())\n                    result = ip.getHostAddress();\n            }\n        }\n    } catch (SocketException _e) {\n        LL.error(\"Could not find device's ip adress\");\n    }\n    return result;\n}\n\n\n/**\n * Return a MD5 hash of the device id.\n */\npublic static synchronized String getUserId(Context _context) {\n    if (sUserId == null) {\n        TelephonyManager tm = (TelephonyManager) _context.getSystemService(Context.TELEPHONY_SERVICE);\n        String id = tm.getDeviceId();\n        try {\n            MessageDigest digester = MessageDigest.getInstance(\"MD5\");\n            digester.update(id.getBytes());\n            byte[] digest = digester.digest();\n\n            // Convert to hex string\n            BigInteger converter = new BigInteger(1, digest);\n            String md5 = converter.toString(16);\n            while (md5.length() &lt; 32)\n                md5 = \"0\" + md5;\n            sUserId = md5;\n        } catch (NoSuchAlgorithmException _e) {\n            LL.error(\"Could not find MD5\");\n        }\n    }\n    return sUserId;\n}\n", "private static void xmlParser() {\n    try {\n        String filepath = \"yourfile.xml\";\n        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();\n        Document doc = docBuilder.parse(filepath);\n        // Get the root element\n        Node min = doc.getElementsByTagName(\"poem\").item(0);\n        NamedNodeMap attr = min.getAttributes();\n                    // get the value of the name=\n        Node nodeAttr = attr.getNamedItem(\"name\");\n                    //if you want to change the value of the name use \n                    nodeAttr.setTextContent(\"new name value\");\n                    //if you want to get the value between &gt;value&lt; use \n                    nodeAttr.getTextContent()\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = transformerFactory.newTransformer();\n        DOMSource source = new DOMSource(doc);\n        StreamResult result = new StreamResult(new File(filepath));\n        transformer.transform(source, result);\n    } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n    }\n     catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (SAXException sae) {\n            sae.printStackTrace();\n        } catch (TransformerConfigurationException e) {\n\n            e.printStackTrace();\n        } catch (TransformerException e) {\n\n            e.printStackTrace();\n        }\n}\n", "package com.arisglobal.aglite.network;\n\nimport java.io.InputStream;\nimport java.security.KeyStore;\n\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.SingleClientConnManager;\n\nimport com.arisglobal.aglite.activity.R;\n\nimport android.content.Context;\n\npublic class MyHttpClient extends DefaultHttpClient {\n\n    final Context context;\n\n    public MyHttpClient(Context context) {\n        this.context = context;\n    }\n\n    @Override\n    protected ClientConnectionManager createClientConnectionManager() {\n        SchemeRegistry registry = new SchemeRegistry();\n\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n\n        // Register for port 443 our SSLSocketFactory with our keystore to the ConnectionManager\n        registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n        return new SingleClientConnManager(getParams(), registry);\n    }\n\n    private SSLSocketFactory newSslSocketFactory() {\n        try {\n            // Get an instance of the Bouncy Castle KeyStore format\n            KeyStore trusted = KeyStore.getInstance(\"BKS\");\n\n            // Get the raw resource, which contains the keystore with your trusted certificates (root and any intermediate certs)\n            InputStream in = context.getResources().openRawResource(R.raw.aglite);\n            try {\n                // Initialize the keystore with the provided trusted certificates.\n                // Also provide the password of the keystore\n                trusted.load(in, \"aglite\".toCharArray());\n            } finally {\n                in.close();\n            }\n\n            // Pass the keystore to the SSLSocketFactory. The factory is responsible for the verification of the server certificate.\n            SSLSocketFactory sf = new SSLSocketFactory(trusted);\n\n            // Hostname verification from certificate\n            // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n            return sf;\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n    }\n}\n", "/**\n * Disables the SSL certificate checking for new instances of {@link HttpsURLConnection} This has been created to\n * aid testing on a local box, not for use on production.\n */\nprivate static void disableSSLCertificateChecking() {\n    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        @Override\n        public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {\n            // Not implemented\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {\n            // Not implemented\n        }\n    } };\n\n    try {\n        SSLContext sc = SSLContext.getInstance(\"TLS\");\n\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n    } catch (KeyManagementException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n}\n", " /**\n   * Generates SHA-1 digest of the provided data.\n   * \n   * @param data the data to digest\n   * @return SHA-1 digest of the provided data.\n   */\n  public static byte[] sha1Digest(byte[] data) {\n    MessageDigest mdSha1 = null;\n    try {\n      mdSha1 = MessageDigest.getInstance(\"SHA-1\");\n    } catch (NoSuchAlgorithmException e1) {\n      Log.e(LOG_TAG, \"Error initializing SHA1 message digest\");\n    }\n    mdSha1.update(data);\n    byte[] sha1hash = mdSha1.digest();\n    return sha1hash;\n  }\n", "try\n    {\n        PackageInfo info = getPackageManager().getPackageInfo(getApplication().getPackageName(), PackageManager.GET_SIGNATURES);\n        for(Signature signature : info.signatures)\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String myHashCode = Base64.encodeBytes(md.digest());\n            Log.e(\"-------------FACEBOOK HASH KEY-----------\", myHashCode);\n        }\n    }\n    catch(NameNotFoundException e)\n    {\n        e.printStackTrace();\n    }\n    catch(NoSuchAlgorithmException e)\n    {\n        e.printStackTrace();\n    }\n    catch(Exception e)\n    {\n        e.printStackTrace();\n    }\n    catch(Error e)\n    {\n        e.printStackTrace();\n    }\n", "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class Sha1Hex {\n\n    public String makeSHA1Hash(String input)\n            throws NoSuchAlgorithmException, UnsupportedEncodingException\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.reset();\n            byte[] buffer = input.getBytes(\"UTF-8\");\n            md.update(buffer);\n            byte[] digest = md.digest();\n\n            String hexStr = \"\";\n            for (int i = 0; i &lt; digest.length; i++) {\n                hexStr +=  Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 );\n            }\n            return hexStr;\n        }\n}\n", "    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"my.package.name\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String something = new String(Base64.encode(md.digest(), 0));\n            //String something = new String(Base64.encodeBytes(md.digest()));\n            Log.e(\"hash key\", something);\n        }\n    } catch (NameNotFoundException e1) {\n        Log.e(\"name not found\", e1.toString());\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(\"no such an algorithm\", e.toString());\n    } catch (Exception e) {\n        Log.e(\"exception\", e.toString());\n    }\n", "  public class SimpleSSLSocketFactory extends org.apache.http.conn.ssl.SSLSocketFactory {\n    private SSLSocketFactory sslFactory = HttpsURLConnection.getDefaultSSLSocketFactory();\n\n    public SimpleSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException,\n            UnrecoverableKeyException {\n        super(null);\n\n        try {\n            SSLContext context = SSLContext.getInstance(\"TLS\");\n\n            // Create a trust manager that does not validate certificate chains and simply\n            // accept all type of certificates\n            TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return new java.security.cert.X509Certificate[] {};\n                }\n\n                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n            } };\n\n            // Initialize the socket factory\n            context.init(null, trustAllCerts, new SecureRandom());\n            sslFactory = context.getSocketFactory();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslFactory.createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslFactory.createSocket();\n    }\n}\n", " private HttpClient sslClient(HttpClient client) {\n    try {\n        X509TrustManager tm = new X509TrustManager() { \n            public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n        ctx.init(null, new TrustManager[]{tm}, null);\n        SSLSocketFactory ssf = new MySSLSocketFactory(ctx);\n        ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        ClientConnectionManager ccm = client.getConnectionManager();\n        SchemeRegistry sr = ccm.getSchemeRegistry();\n        sr.register(new Scheme(\"https\", ssf, 443));\n        return new DefaultHttpClient(ccm, client.getParams());\n    } catch (Exception ex) {\n        return null;\n    }\n}\n", " public class MySSLSocketFactory extends SSLSocketFactory {\n     SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n     public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n         super(truststore);\n\n         TrustManager tm = new X509TrustManager() {\n             public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n             }\n\n             public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n             }\n\n             public X509Certificate[] getAcceptedIssuers() {\n                 return null;\n             }\n         };\n\n         sslContext.init(null, new TrustManager[] { tm }, null);\n     }\n\n     public MySSLSocketFactory(SSLContext context) throws KeyManagementException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {\n        super(null);\n        sslContext = context;\n     }\n\n     @Override\n     public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n         return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n     }\n\n     @Override\n     public Socket createSocket() throws IOException {\n         return sslContext.getSocketFactory().createSocket();\n     }\n}\n", "// Load CAs from an InputStream\n// (could be from a resource or ByteArrayInputStream or ...)\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n// From https://www.washington.edu/itconnect/security/ca/load-der.crt\nInputStream caInput = new BufferedInputStream(new FileInputStream(\"load-der.crt\"));\nCertificate ca;\ntry {\n    ca = cf.generateCertificate(caInput);\n    System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n} finally {\n    caInput.close();\n}\n\n// Create a KeyStore containing our trusted CAs\nString keyStoreType = KeyStore.getDefaultType();\nKeyStore keyStore = KeyStore.getInstance(keyStoreType);\nkeyStore.load(null, null);\nkeyStore.setCertificateEntry(\"ca\", ca);\n\n// Create a TrustManager that trusts the CAs in our KeyStore\nString tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\ntmf.init(keyStore);\n\n// Create an SSLContext that uses our TrustManager\nSSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, tmf.getTrustManagers(), null);\n\n// Tell the URLConnection to use a SocketFactory from our SSLContext\nURL url = new URL(\"https://certs.cac.washington.edu/CAtest/\");\nHttpsURLConnection urlConnection =\n    (HttpsURLConnection)url.openConnection();\nurlConnection.setSSLSocketFactory(context.getSocketFactory());\nInputStream in = urlConnection.getInputStream();\ncopyInputStreamToOutputStream(in, System.out);\n", "public class AESCryptt {\n    private static final String TAG = \"AESCrypt\";\n    private static final String AES_MODE = \"AES/ECB/ZeroBytePadding\";\n    private static final String CHARSET = \"UTF-8\";//\n    public static boolean DEBUG_LOG_ENABLED = false;\n\n\n    private static SecretKeySpec generateKey(final String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        byte[] key = new byte[]{your key in byte here (byte) a, (byte) f , ..... };\n        SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n        return secretKeySpec;\n    }\n\n\n    /**\n     * Encrypt and encode message using 256-bit AES with key generated from password.\n     *\n     *\n     * @param password used to generated key\n     * @param message the thing you want to encrypt assumed String UTF-8\n     * @return Base64 encoded CipherText\n     * @throws GeneralSecurityException if problems occur during encryption\n     */\n    public static String encrypt(final String password, String message)\n            throws GeneralSecurityException {\n        try {\n            final SecretKeySpec key = generateKey(password);\n            log(\"message\", message);\n            byte[] cipherText = encrypt(key, ivBytes, message.getBytes(CHARSET));\n            //NO_WRAP is important as was getting \\n at the end\n            String encoded = String.valueOf(Base64.encodeToString(cipherText, Base64.NO_PADDING ));\n            log(\"Base64.NO_WRAP\", encoded);\n            return encoded;\n        } catch (UnsupportedEncodingException e) {\n            if (DEBUG_LOG_ENABLED)\n                Log.e(TAG, \"UnsupportedEncodingException \", e);\n            throw new GeneralSecurityException(e);\n        }\n    }\n\n\n    /**\n     * More flexible AES encrypt that doesn't encode\n     * @param key AES key typically 128, 192 or 256 bit\n     * @param iv Initiation Vector\n     * @param message in bytes (assumed it's already been decoded)\n     * @return Encrypted cipher text (not encoded)\n     * @throws GeneralSecurityException if something goes wrong during encryption\n     */\n    public static byte[] encrypt(final SecretKeySpec key, final byte[] iv, final byte[] message)\n            throws GeneralSecurityException {\n        final Cipher cipher = Cipher.getInstance(AES_MODE);\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        cipher.init(Cipher.ENCRYPT_MODE, key);//, ivSpec\n        byte[] cipherText = cipher.doFinal(message);\n        log(\"cipherText\", cipherText);\n        return cipherText;\n    }\n\n\n    /**\n     * Decrypt and decode ciphertext using 256-bit AES with key generated from password\n     *\n     * @param password used to generated key\n     * @param base64EncodedCipherText the encrpyted message encoded with base64\n     * @return message in Plain text (String UTF-8)\n     * @throws GeneralSecurityException if there's an issue decrypting\n     */\n    public static String decrypt(final String password, String base64EncodedCipherText)\n            throws GeneralSecurityException {\n\n        try {\n            final SecretKeySpec key = generateKey(password);\n            log(\"base64EncodedCipherText\", base64EncodedCipherText);\n            byte[] decodedCipherText = Base64.decode(base64EncodedCipherText, Base64.DEFAULT);\n            log(\"decodedCipherText\", decodedCipherText);\n            byte[] decryptedBytes = decrypt(key, ivBytes, decodedCipherText);\n            log(\"decryptedBytes\", decryptedBytes);\n            String message = new String(decryptedBytes, CHARSET);\n            log(\"message\", message);\n            return message;\n        } catch (UnsupportedEncodingException e) {\n            if (DEBUG_LOG_ENABLED)\n                Log.e(TAG, \"UnsupportedEncodingException \", e);\n            throw new GeneralSecurityException(e);\n        }\n    }\n\n\n    /**\n     * More flexible AES decrypt that doesn't encode\n     *\n     * @param key AES key typically 128, 192 or 256 bit\n     * @param iv Initiation Vector\n     * @param decodedCipherText in bytes (assumed it's already been decoded)\n     * @return Decrypted message cipher text (not encoded)\n     * @throws GeneralSecurityException if something goes wrong during encryption\n     */\n    public static byte[] decrypt(final SecretKeySpec key, final byte[] iv, final byte[] decodedCipherText)\n            throws GeneralSecurityException {\n        final Cipher cipher = Cipher.getInstance(AES_MODE );\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        cipher.init(Cipher.DECRYPT_MODE, key);//, ivSpec\n        byte[] decryptedBytes = cipher.doFinal(decodedCipherText);\n        log(\"decryptedBytes\", decryptedBytes);\n        return decryptedBytes;\n    }\n\n\n\n\n    private static void log(String what, byte[] bytes) {\n        if (DEBUG_LOG_ENABLED)\n            Log.d(TAG, what + \"[\" + bytes.length + \"] [\" + bytesToHex(bytes) + \"]\");\n    }\n\n    private static void log(String what, String value) {\n        if (DEBUG_LOG_ENABLED)\n            Log.d(TAG, what + \"[\" + value.length() + \"] [\" + value + \"]\");\n    }\n\n\n    /**\n     * Converts byte array to hexidecimal useful for logging and fault finding\n     * @param bytes\n     * @return\n     */\n    private static String bytesToHex(byte[] bytes) {\n        final char[] hexArray = {'0', '1', '2', '3', '4', '5', '6', '7', '8',\n                '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n        char[] hexChars = new char[bytes.length * 2];\n        int v;\n        for (int j = 0; j &lt; bytes.length; j++) {\n            v = bytes[j] &amp; 0xFF;\n            hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];\n            hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];\n        }\n        return new String(hexChars);\n    }\n\n    private AESCryptt() {\n    }\n}\n", "public void onLocationChanged(Location location) {\n  Timestamp time = new Timestamp(location.getTime());\n\n  textTime.setText(time.toString());\n}\n", "public static void encryptAndClose(FileInputStream fis, FileOutputStream fos) \n        throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n    // Length is 16 byte\n    SecretKeySpec sks = new SecretKeySpec(\"1234567890123456\".getBytes(), \"AES\");\n    // Create cipher\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);      \n\n    // Wrap the output stream for encoding\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);       \n\n    //wrap output with buffer stream\n    BufferedOutputStream bos = new BufferedOutputStream(cos);     \n\n    //wrap input with buffer stream\n    BufferedInputStream bis = new BufferedInputStream(fis); \n\n    // Write bytes\n    int b;\n    byte[] d = new byte[8];\n    while((b = bis.read(d)) != -1) {\n        bos.write(d, 0, b);\n    }\n    // Flush and close streams.\n    bos.flush();\n    bos.close();\n    bis.close();\n}\n\n\npublic static void decryptAndClose(FileInputStream fis, FileOutputStream fos) \n        throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n    SecretKeySpec sks = new SecretKeySpec(\"1234567890123456\".getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n\n    //wrap input with buffer stream\n    BufferedInputStream bis = new BufferedInputStream(cis); \n\n    //wrap output with buffer stream\n    BufferedOutputStream bos = new BufferedOutputStream(fos);       \n\n    int b;\n    byte[] d = new byte[8];\n    while((b = bis.read(d)) != -1) {\n        bos.write(d, 0, b);\n    }\n    bos.flush();\n    bos.close();\n    bis.close();\n}\n", "public class SampleEncryptor extends SecretKeyWrapper{\nprivate static final SecureRandom RANDOM = new SecureRandom();\n\nprivate SharedPreferences pref;\nprivate SecretKey secretKey;\nprivate byte[] encryptedKey;\n\npublic SampleEncryptor(Context context)\n        throws GeneralSecurityException, IOException {\n    super(context, \"myalias\");\n    this.pref = context.getSharedPreferences(\"mySecretKeyStore\", Context.MODE_PRIVATE);\n    String base64key = pref.getString(\"key\", null);\n    if(base64key==null){\n        this.secretKey = KeyGenerator.getInstance(\"AES\").generateKey();\n        this.encryptedKey = this.wrap(this.secretKey);\n        pref.edit().putString(\"key\", Base64.encodeToString(encryptedKey, Base64.DEFAULT)).commit();\n    }else{\n        this.encryptedKey = Base64.decode(base64key, Base64.DEFAULT);\n        this.secretKey = this.unwrap(this.encryptedKey);\n    }\n}\n\npublic byte[] encrypt(byte[] data) throws GeneralSecurityException{     \n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    return  cipher.doFinal(data);\n}\n\npublic byte[] decrypt(byte[] data) throws GeneralSecurityException{\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n    return  cipher.doFinal(data);\n}\n\npublic String encryptBoolean(boolean value) throws GeneralSecurityException{\n    BigInteger i = new BigInteger(128, RANDOM);\n    if(value){\n        i = i.setBit(0);\n    }else{\n        i = i.clearBit(0);\n    }\n    byte[] encrypted =  encrypt(i.toByteArray());\n\n    return Base64.encodeToString(encrypted, Base64.DEFAULT);\n}\n\npublic Boolean decryptBoolean(String encrypted) throws GeneralSecurityException{\n    byte[] data = Base64.decode(encrypted, Base64.DEFAULT);     \n    BigInteger i = new BigInteger(decrypt(data));\n    return i.testBit(0);\n}\n", " private void getShaKey() {\n\n try {\n PackageInfo info = getPackageManager().getPackageInfo(\"your_package_name\",\n PackageManager.GET_SIGNATURES);\n for (Signature signature : info.signatures) {\n MessageDigest md = MessageDigest.getInstance(\"SHA\");\n md.update(signature.toByteArray());\n Log.v(TAG, \"KeyHash:\" + Base64.encodeToString(md.digest(),\n Base64.DEFAULT));\n }\n } catch (NameNotFoundException e) {\n e.printStackTrace();\n } catch (NoSuchAlgorithmException e) {\n e.printStackTrace();\n }\n\n }\n", "import javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport java.math.*;\n\npublic class Encryptor3 {\n\n  public static byte[] hexStringToByteArray(String hexInputString){\n    byte[] bts = new byte[hexInputString.length() / 2];\n\n    for (int i = 0; i &lt; bts.length; i++) {\n      bts[i] = (byte) Integer.parseInt(hexInputString.substring(2*i, 2*i+2), 16);\n    }\n\n    return bts;\n  }\n\n  public static String byteArrayToString(byte[] byteArray) {\n    StringBuilder str = new StringBuilder();\n\n    for (int i = 0; i &lt; byteArray.length; i++) {\n      str.append((char) byteArray[i]);\n    }\n\n    return str.toString();\n  }\n\n  public static String byteArrayToHexString(byte[] arg) {\n    int l = arg.length * 2;\n    return String.format(\"%0\"+l+\"x\", new BigInteger(1, arg));\n  }\n\n  public static byte[] encrypt(byte[] key1, byte[] key2, byte[] value) {\n    try {\n      IvParameterSpec iv = new IvParameterSpec(key2);\n      SecretKeySpec skeySpec = new SecretKeySpec(key1, \"AES\");\n\n      Cipher cipher = Cipher.getInstance(\"AES/CBC/NOPADDING\");\n      cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n\n      byte[] encrypted = cipher.doFinal(value);\n\n      return encrypted;\n\n    } catch (Exception ex) {\n      ex.printStackTrace();\n    }\n\n    return null;\n  }\n\n  public static byte[] decrypt(byte[] key1, byte[] key2, byte[] encrypted) {\n    try {\n      IvParameterSpec iv = new IvParameterSpec(key2);\n      SecretKeySpec skeySpec = new SecretKeySpec(key1, \"AES\");\n\n      Cipher cipher = Cipher.getInstance(\"AES/CBC/NOPADDING\");\n      cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n\n      byte[] original = cipher.doFinal(encrypted);\n\n      return original;\n\n    } catch (Exception ex) {\n      ex.printStackTrace();\n    }\n\n    return null;\n  }\n\n  public static String toHex(String arg) {\n    int l = arg.length() * 2;\n\n    return String.format(\"%0\"+l+\"x\", new BigInteger(1, arg.getBytes()));\n  }\n\n  public static String HexStringToString (String arg) {\n    StringBuilder output = new StringBuilder();\n    for (int i = 0; i &lt; arg.length(); i+=2) {\n      String str = arg.substring(i, i+2);\n      output.append((char)Integer.parseInt(str, 16));\n    }\n\n    return output.toString();\n  }\n\n\n  public static void main(String[] args) {\n    // source: http://www.inconteam.com/software-development/41-encryption/55-aes-test-vectors#aes-cbc-128\n    String message = \"6bc1bee22e409f96e93d7e117393172a\"; // 16 byte = 128 bit key\n    //String message = toHex(\"Hello00000000000\");\n    String key1 =    \"2b7e151628aed2a6abf7158809cf4f3c\";\n    String iv =      \"000102030405060708090A0B0C0D0E0F\";\n    String match =   \"7649abac8119b246cee98e9b12e9197d\";\n\n    System.out.print(\"message (hex):         \"); System.out.println(message);\n    System.out.print(\"key (hex):             \"); System.out.println(key1);\n    System.out.print(\"iv (hex):              \"); System.out.println(iv);\n    System.out.print(\"match (hex):           \"); System.out.println(match);\n    System.out.println();\n\n    byte[] enc_message_ba = encrypt(hexStringToByteArray(key1), hexStringToByteArray(iv), hexStringToByteArray(message));\n    System.out.print(\"Encrypted (hex):       \"); System.out.println(byteArrayToHexString(enc_message_ba));\n    System.out.println();\n\n    byte[] dec_message_ba = decrypt(hexStringToByteArray(key1), hexStringToByteArray(iv), enc_message_ba);\n    System.out.print(\"Decrypted (hex):       \"); System.out.println(byteArrayToHexString(dec_message_ba));\n  }\n}\n", "public class CustomSSLSocketFactory extends SSLSocketFactory {\n\n    private SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public CustomSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws certificateException {\n        }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n        };\n\n        sslContext.init(null, new TrustManager[] {tm}, null);\n\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n\n}\n", "public HttpClient getHttpClient() {\n\n    DefaultHttpClient client = null;\n\n    try {\n\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new CustomSSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        // Setting up parameters\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, \"utf-8\");\n        params.setBooleanParameter(\"http.protocol.expect-continue\", false);\n\n        // Setting timeout\n        HttpConnectionParams.setConnectionTimeout(params, TIMEOUT);\n        HttpConnectionParams.setSoTimeout(params, TIMEOUT);\n\n        // Registering schemes for both HTTP and HTTPS\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        // Creating thread safe client connection manager\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        // Creating HTTP client\n        client = new DefaultHttpClient(ccm, params);\n\n        // Registering user name and password for authentication\n        client.getCredentialsProvider().setCredentials(\n                new AuthScope(null, -1),\n                new UsernamePasswordCredentials(mUsername, mPassword));\n\n    } catch (Exception e) {\n        client = new DefaultHttpClient();\n    }\n\n    return client;\n\n}\n", "KeyStore trustStore  = KeyStore.getInstance( \"BKS\" /*KeyStore.getDefaultType()*/ );\nFileInputStream instream = new FileInputStream(new File(\"/mnt/sdcard/keystore.bks\"));\ntry {\n    trustStore.load(instream, \"222222\".toCharArray());\n} catch (NoSuchAlgorithmException e) {\n    e.printStackTrace();\n} catch (CertificateException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    try { instream.close(); } catch (Exception ignore) {}\n}\n\n// Create socket factory with given keystore.\nSSLSocketFactory socketFactory = new SSLSocketFactory(trustStore);\n\nSSLSocketFactory socketFactory = new SSLSocketFactory(trustStore);\nScheme sch = new Scheme(\"https\", socketFactory, 443);\nhttpclient.getConnectionManager().getSchemeRegistry().register(sch);\n\nHttpGet httpget = new HttpGet(\"https://10.2.20.20/fido/EzPay/login.php\");\n\nSystem.out.println(\"executing request \" + httpget.getRequestLine());\n\nHttpResponse response = httpclient.execute(httpget);\nHttpEntity entity = response.getEntity();\n\nSystem.out.println(\"----------------------------------------\");\nSystem.out.println(response.getStatusLine());\nif (entity != null) {\n    System.out.println(\"Response content length:  \" + entity.getContentLength());\n}\n\n// Print html.\nBufferedReader in = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\nString line = \"\";\nwhile ((line = in.readLine()) != null) {\n     System.out.println(line);\n}\nin.close();\n", "String alias = \"test\";\nKeyStore memoryKeyStore = KeyStore.getInstance(\"BKS\");\nmemoryKeyStore.load(null);\nX509Certificate[] chain = KeyChain.getCertificateChain(getApplicationContext(),alias);\nPrivateKey key = KeyChain.getPrivateKey(getApplicationContext(),alias);\nmemoryKeyStore.setKeyEntry(alias, key.getEncoded(), chain);\n", "import java.util.List;\nimport java.util.Arrays;\nimport java.util.ArrayList;\n\nimport java.io.IOException;\n\nimport java.security.KeyStore;\nimport java.security.SecureRandom;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\n\nimport java.net.Socket;\nimport java.net.InetAddress;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.KeyManager;\nimport javax.net.ssl.TrustManager;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\n\nclass SSLSocketFactoryEx extends SSLSocketFactory\n{\n    public SSLSocketFactoryEx() throws NoSuchAlgorithmException, KeyManagementException\n    {\n        initSSLSocketFactoryEx(null,null,null);\n    }\n\n    public SSLSocketFactoryEx(KeyManager[] km, TrustManager[] tm, SecureRandom random) throws NoSuchAlgorithmException, KeyManagementException\n    {\n        initSSLSocketFactoryEx(km, tm, random);\n    }\n\n    public SSLSocketFactoryEx(SSLContext ctx) throws NoSuchAlgorithmException, KeyManagementException\n    {\n        initSSLSocketFactoryEx(ctx);\n    }\n\n    public String[] getDefaultCipherSuites()\n    {\n        return m_ciphers;\n    }\n\n    public String[] getSupportedCipherSuites()\n    {\n        return m_ciphers;\n    }\n\n    public String[] getDefaultProtocols()\n    {\n        return m_protocols;\n    }\n\n    public String[] getSupportedProtocols()\n    {\n        return m_protocols;\n    }\n\n    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException\n    {\n        SSLSocketFactory factory = m_ctx.getSocketFactory();\n        SSLSocket ss = (SSLSocket)factory.createSocket(s, host, port, autoClose);\n\n        ss.setEnabledProtocols(m_protocols);\n        ss.setEnabledCipherSuites(m_ciphers);\n\n        return ss;\n    }\n\n    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException\n    {\n        SSLSocketFactory factory = m_ctx.getSocketFactory();\n        SSLSocket ss = (SSLSocket)factory.createSocket(address, port, localAddress, localPort);\n\n        ss.setEnabledProtocols(m_protocols);\n        ss.setEnabledCipherSuites(m_ciphers);\n\n        return ss;\n    }\n\n    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException\n    {\n        SSLSocketFactory factory = m_ctx.getSocketFactory();\n        SSLSocket ss = (SSLSocket)factory.createSocket(host, port, localHost, localPort);\n\n        ss.setEnabledProtocols(m_protocols);\n        ss.setEnabledCipherSuites(m_ciphers);\n\n        return ss;\n    }\n\n    public Socket createSocket(InetAddress host, int port) throws IOException\n    {\n        SSLSocketFactory factory = m_ctx.getSocketFactory();\n        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);\n\n        ss.setEnabledProtocols(m_protocols);\n        ss.setEnabledCipherSuites(m_ciphers);\n\n        return ss;\n    }\n\n    public Socket createSocket(String host, int port) throws IOException\n    {\n        SSLSocketFactory factory = m_ctx.getSocketFactory();\n        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);\n\n        ss.setEnabledProtocols(m_protocols);\n        ss.setEnabledCipherSuites(m_ciphers);\n\n        return ss;\n    }\n\n    private void initSSLSocketFactoryEx(KeyManager[] km, TrustManager[] tm, SecureRandom random)\n    throws NoSuchAlgorithmException, KeyManagementException\n    {\n        m_ctx = SSLContext.getInstance(\"TLS\");\n        m_ctx.init(km, tm, random);\n\n        m_protocols = GetProtocolList();\n        m_ciphers = GetCipherList();\n    }\n\n    private void initSSLSocketFactoryEx(SSLContext ctx)\n    throws NoSuchAlgorithmException, KeyManagementException\n    {\n        m_ctx = ctx;\n\n        m_protocols = GetProtocolList();\n        m_ciphers = GetCipherList();\n    }\n\n    protected String[] GetProtocolList()\n    {\n        String[] preferredProtocols = { \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\", \"TLSv1.3\" };\n        String[] availableProtocols = null;\n\n        SSLSocket socket = null;\n\n        try\n        {\n            SSLSocketFactory factory = m_ctx.getSocketFactory();\n            socket = (SSLSocket)factory.createSocket();\n\n            availableProtocols = socket.getSupportedProtocols();\n            Arrays.sort(availableProtocols);\n        }\n        catch(Exception e)\n        {\n            return new String[]{ \"TLSv1\" };\n        }\n        finally\n        {\n            if(socket != null)\n                socket.close();\n        }\n\n        List&lt;String&gt; aa = new ArrayList&lt;String&gt;();\n        for(int i = 0; i &lt; preferredProtocols.length; i++)\n        {\n            int idx = Arrays.binarySearch(availableProtocols, preferredProtocols[i]);\n            if(idx &gt;= 0)\n                aa.add(preferredProtocols[i]);\n        }\n\n        return aa.toArray(new String[0]);\n    }\n\n    protected String[] GetCipherList()\n    {\n        String[] preferredCiphers = {\n\n            // *_CHACHA20_POLY1305 are 3x to 4x faster than existing cipher suites.\n            //   http://googleonlinesecurity.blogspot.com/2014/04/speeding-up-and-strengthening-https.html\n            // Use them if available. Normative names can be found at (TLS spec depends on IPSec spec):\n            //   http://tools.ietf.org/html/draft-nir-ipsecme-chacha20-poly1305-01\n            //   http://tools.ietf.org/html/draft-mavrogiannopoulos-chacha-tls-02\n            \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\",\n            \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\",\n            \"TLS_ECDHE_ECDSA_WITH_CHACHA20_SHA\",\n            \"TLS_ECDHE_RSA_WITH_CHACHA20_SHA\",\n\n            \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305\",\n            \"TLS_RSA_WITH_CHACHA20_POLY1305\",\n            \"TLS_DHE_RSA_WITH_CHACHA20_SHA\",\n            \"TLS_RSA_WITH_CHACHA20_SHA\",\n\n            // Done with bleeding edge, back to TLS v1.2 and below\n            \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\",\n            \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\",\n            \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\",\n            \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\",\n\n            \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\n            \"TLS_DHE_DSS_WITH_AES_256_GCM_SHA384\",\n            \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n            \"TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\",\n\n            // TLS v1.0 (with some SSLv3 interop)\n            \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA384\",\n            \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\",\n            \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\",\n            \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\",\n\n            \"TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\",\n            \"TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\",\n            \"SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA\",\n            \"SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA\",\n\n            // RSA key transport sucks, but they are needed as a fallback.\n            // For example, microsoft.com fails under all versions of TLS\n            // if they are not included. If only TLS 1.0 is available at\n            // the client, then google.com will fail too. TLS v1.3 is\n            // trying to deprecate them, so it will be interesteng to see\n            // what happens.\n            \"TLS_RSA_WITH_AES_256_CBC_SHA256\",\n            \"TLS_RSA_WITH_AES_256_CBC_SHA\",\n            \"TLS_RSA_WITH_AES_128_CBC_SHA256\",\n            \"TLS_RSA_WITH_AES_128_CBC_SHA\"\n        };\n\n        String[] availableCiphers = null;\n\n        try\n        {\n            SSLSocketFactory factory = m_ctx.getSocketFactory();\n            availableCiphers = factory.getSupportedCipherSuites();\n            Arrays.sort(availableCiphers);\n        }\n        catch(Exception e)\n        {\n            return new String[] {\n                \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\",\n                \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA\",\n                \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\",\n                \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\",\n                \"TLS_RSA_WITH_AES_256_CBC_SHA256\",\n                \"TLS_RSA_WITH_AES_256_CBC_SHA\",\n                \"TLS_RSA_WITH_AES_128_CBC_SHA256\",\n                \"TLS_RSA_WITH_AES_128_CBC_SHA\",\n                \"TLS_EMPTY_RENEGOTIATION_INFO_SCSV\"\n            };\n        }\n\n        List&lt;String&gt; aa = new ArrayList&lt;String&gt;();\n        for(int i = 0; i &lt; preferredCiphers.length; i++)\n        {\n            int idx = Arrays.binarySearch(availableCiphers, preferredCiphers[i]);\n            if(idx &gt;= 0)\n                aa.add(preferredCiphers[i]);\n        }\n\n        aa.add(\"TLS_EMPTY_RENEGOTIATION_INFO_SCSV\");\n\n        return aa.toArray(new String[0]);\n    }\n\n    private SSLContext m_ctx;\n\n    private String[] m_ciphers;\n    private String[] m_protocols;\n}\n", "public class MainActivity extends AppCompatActivity {\n\n    private Context mContext = this;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            // cert file stored in \\app\\src\\main\\res\\raw\n            InputStream caInput = getResources().openRawResource(R.raw.your_cert);\n\n            Certificate ca = cf.generateCertificate(caInput);\n            caInput.close();\n\n            KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n            keyStore.load(null, null);\n            keyStore.setCertificateEntry(\"ca\", ca);\n\n            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n            tmf.init(keyStore);\n\n            TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, wrappedTrustManagers, null);\n\n            AsyncSSLSocketMiddleware sslMiddleWare = Ion.getDefault(mContext).getHttpClient().getSSLSocketMiddleware();\n            sslMiddleWare.setTrustManagers(wrappedTrustManagers);\n            sslMiddleWare.setHostnameVerifier(getHostnameVerifier());\n            sslMiddleWare.setSSLContext(sslContext);\n\n            // Post application/x-www-form-urlencoded and read a String\n            Ion.with(mContext)\n                    .load(\"https://yourserver/token\")\n                    .setBodyParameter(\"grant_type\", \"password\")\n                    .setBodyParameter(\"username\", \"bnk\")\n                    .setBodyParameter(\"password\", \"bnk123456789\")\n                    .asString()\n                    .setCallback(new FutureCallback&lt;String&gt;() {\n                        @Override\n                        public void onCompleted(Exception e, String result) {\n                            if (result != null) {\n                                Log.i(\"ionSample\", result);\n                            } else if (e != null) {\n                                e.printStackTrace();\n                            }\n                        }\n                    });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private HostnameVerifier getHostnameVerifier() {\n        return new HostnameVerifier() {\n            @Override\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n                // or the following:\n                // HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();\n                // return hv.verify(\"www.yourserver.com\", session);\n            }\n        };\n    }\n\n    private TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {\n        final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];\n        return new TrustManager[]{\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return originalTrustManager.getAcceptedIssuers();\n                    }\n\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                        try {\n                            originalTrustManager.checkClientTrusted(certs, authType);\n                        } catch (CertificateException ignored) {\n                        }\n                    }\n\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                        try {\n                            originalTrustManager.checkServerTrusted(certs, authType);\n                        } catch (CertificateException ignored) {\n                        }\n                    }\n                }\n        };\n    }\n", "public void saveToFile(String fileName, BigInteger mod, BigInteger exp)\n        throws IOException {\n    ObjectOutputStream oout = new ObjectOutputStream(\n            new BufferedOutputStream(new FileOutputStream(fileName)));\n    try {\n        oout.writeObject(mod);\n        oout.writeObject(exp);\n    } catch (Exception e) {\n        throw new IOException(\"Unexpected error\", e);\n    } finally {\n        oout.close();\n    }\n}\n\nPublicKey ReadPublicKeyFromFile(String keyFileName) throws IOException {\n    InputStream in = RSACrypt.class.getClassLoader().getResourceAsStream(keyFileName);\n    ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(\n            in));\n    try {\n        BigInteger m = (BigInteger) oin.readObject();\n        BigInteger e = (BigInteger) oin.readObject();\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PublicKey pubKey = fact.generatePublic(keySpec);\n        return pubKey;\n    } catch (Exception e) {\n        throw new RuntimeException(\"Spurious serialisation error\", e);\n    } finally {\n        oin.close();\n    }\n}\n", "private HttpClient getHttpClient()\n{\n    HttpParams params = new BasicHttpParams();\n\n    //Set main protocol parameters\n    HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n    HttpProtocolParams.setContentCharset(params, HTTP.DEFAULT_CONTENT_CHARSET);\n    HttpProtocolParams.setUseExpectContinue(params, true);\n\n    // Turn off stale checking.  Our connections break all the time anyway, and it's not worth it to pay the penalty of checking every time.\n    HttpConnectionParams.setStaleCheckingEnabled(params, false);\n    // FIX v2.2.1+ - Set timeout to 30 seconds, seems like 5 seconds was not enough for good communication\n    HttpConnectionParams.setConnectionTimeout(params, 30 * 1000);\n    HttpConnectionParams.setSoTimeout(params, 30 * 1000);\n    HttpConnectionParams.setSocketBufferSize(params, 8192);\n\n    // Don't handle redirects -- return them to the caller.  Our code often wants to re-POST after a redirect, which we must do ourselves.\n    HttpClientParams.setRedirecting(params, false);\n\n    // Register our own \"trust-all\" SSL scheme\n    SchemeRegistry schReg = new SchemeRegistry();\n    try\n    {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        TrustAllSSLSocketFactory sslSocketFactory = new TrustAllSSLSocketFactory(trustStore);\n        sslSocketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        Scheme sslTrustAllScheme = new Scheme(\"https\", sslSocketFactory, 443);\n        schReg.register(sslTrustAllScheme);\n    }\n    catch (Exception ex)\n    {\n        LogData.e(LOG_TAG, ex, LogData.Priority.None);\n    }\n\n    ClientConnectionManager conMgr = new ThreadSafeClientConnManager(params,schReg);\n    return new DefaultHttpClient(conMgr, params);\n}\n", "    public void checkServerTrusted(X509Certificate[] certificates,String authType) throws CertificateException {\n    if ((certificates != null) &amp;&amp; LOG.isDebugEnabled()) {\n        LOG.debug(\"Server certificate chain:\");\n        for (int i = 0; i &lt; certificates.length; i++) {\n            LOG.debug(\"X509Certificate[\" + i + \"]=\" + certificates[i]);\n        }\n    }\n    if ((certificates != null) &amp;&amp; (certificates.length == 1)) {\n        certificates[0].checkValidity();\n    } else {\n        List&lt;X509Certificate&gt; certs = new ArrayList&lt;X509Certificate&gt;();\n        certs.addAll(Arrays.asList(certificates));\n        X509Certificate certChain = certs.get(0);\n        certs.remove(certChain);\n        LinkedList&lt;X509Certificate&gt; chainList= new LinkedList&lt;X509Certificate&gt;();\n        chainList.add(certChain);\n        Principal certIssuer = certChain.getIssuerDN();\n        Principal certSubject = certChain.getSubjectDN();\n        while(!certs.isEmpty()){\n            List&lt;X509Certificate&gt; tempcerts = new ArrayList&lt;X509Certificate&gt;();\n            tempcerts.addAll(certs);\n            for (X509Certificate cert : tempcerts){\n                if(cert.getIssuerDN().equals(certSubject)){\n                    chainList.addFirst(cert);\n                    certSubject = cert.getSubjectDN();\n                    certs.remove(cert);\n                    continue;\n                }\n\n                if(cert.getSubjectDN().equals(certIssuer)){\n                    chainList.addLast(cert);\n                    certIssuer = cert.getIssuerDN();\n                    certs.remove(cert);\n                    continue;\n                }\n            }\n        }\n    standardTrustManager.checkServerTrusted(chainList.toArray(new X509Certificate[]{}),authType);\n\n    }\n}\n", "byte[] key = \"MARTIN_123456789\".getBytes(\"UTF-8\");\nbyte[] iv = \"1234567890123456\".getBytes(\"UTF-8\");\nbyte[] decryptedData = decrypt(key, iv, b);\n\nprivate byte[] decrypt(byte[] raw, byte[] iv, byte[] encrypted) throws Exception {\n  SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n  Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n  IvParameterSpec ivspec = new IvParameterSpec(iv);         \n  cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivspec);\n  byte[] decrypted = cipher.doFinal(encrypted);\n\n  return decrypted;\n}\n", "OkHttpClient client = new OkHttpClient();\nclient.setHostnameVerifier(new HostnameVerifier() {\n            @Override\n            public boolean verify(String hostname, SSLSession session) {\n                if (!urlHostName.equalsIgnoreCase(session.getPeerHost())) {\n                    System.out.println(\"Warning: URL host '\" + urlHostName\n                            + \"' is different to SSLSession host '\"\n                            + session.getPeerHost() + \"'.\");\n                }\n                return true;\n            }\n        });\n", "MessageDigest md = MessageDigest.getInstance(\"MD5\");\nInputStream is = new FileInputStream(\"file.txt\");\ntry {\n    is = new DigestInputStream(is, md);\n    // read stream to EOF as normal...\n}\nfinally {\n  is.close();\n}\nbyte[] digest = md.digest();\n", "@Override\nprotected Void doInBackground(Void... params){\n    // Create a trust manager that does not validate certificate chains\n    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n        }\n\n        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n        }\n    } };\n\n    // Install the all-trusting trust manager\n    try {\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n\n    // Your code ...\n    URL url = null;\n    HttpsURLConnection conn = null;\n    try {\n      url = new URL(\"https://example.com\");\n    } catch (MalformedURLException e) {\n      e.printStackTrace();\n    }\n\n    // ...\n}\n", "public static String hashKeyForDisk(String key) {\n    String cacheKey;\n    try {\n        final MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        if (key == null) {\n            Log.e(\"TEST\",\"key = null\");\n            throw new IllegalArgumentException(\" key == null\");\n        }\n\n        if (mDigest == null) {\n            Log.e(\"TEST\",\"mDigest = null\");\n\n            return String.valueOf(key.hashCode());\n        }\n        byte[] bytes = key.getBytes();\n        mDigest.update(bytes);\n        cacheKey = bytesToHexString(mDigest.digest());\n    } catch (NoSuchAlgorithmException e) {\n        cacheKey = String.valueOf(key.hashCode());\n    }\n    return cacheKey;\n}\n", "public static final byte[] md5(String s) { \n    try { \n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(s.getBytes(\"UTF-8\"));\n\n        String md5 = EncodingUtils.getString(messageDigest, \"UTF-8\");\n\n        Log.i(\"Function MD5\", md5);\n        Log.i(\"Function MD5 Length\",\"Length: \"+ md5.length());\n\n        return messageDigest;\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } \n    return null;\n}   \n", "try {\n        Cipher cipher = Cipher.getInstance(\"DESEDE/ECB/PKCS5Padding\");\n        SecretKeySpec myKey = new SecretKeySpec(hash,\"DESede\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, myKey);\n\n        try {\n            byte[] encryptedPlainText = cipher.doFinal(plaintextByte);\n\n            encrypted = Base64.encodeToString(encryptedPlainText, 0); \n            Log.i(\"ENCRYPT\", \"Pwd encrypted: \"+encrypted);\n            return encrypted;\n\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }       \n", "/**\n     * Get the InputStream contents for a specific URL request, with parameters.\n     * Uses POST. PLEASE NOTE: You should NOT use this method in the main\n     * thread.\n     * \n     * @param url\n     *            is the URL to query\n     * @param parameters\n     *            is a Vector with instances of String containing the parameters\n     */\n    public static InputStream readHTTPContents(String url, String requestMethod, byte[] bodyData, String bodyEncoding, Map&lt;String, String&gt; parameters)\n            throws AppException {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        try {\n            URL urlObj = new URL(url);\n            if (urlObj.getProtocol().toLowerCase().equals(\"https\")) {\n                trustAllHosts();\n                HttpsURLConnection https = (HttpsURLConnection) urlObj\n                        .openConnection();\n                https.setHostnameVerifier(new HostnameVerifier() {\n                    public boolean verify(String hostname, SSLSession session) {\n                        return true;\n                    }\n                });\n                connection = https;\n            } else {\n                connection = (HttpURLConnection) urlObj.openConnection();\n            }\n            // Allow input\n            connection.setDoInput(true);\n            // If there's data, prepare to send.\n            if (bodyData != null) {\n                connection.setDoOutput(true);\n            }\n            // Write additional parameters if any\n            if (parameters != null) {\n                Iterator&lt;String&gt; i = parameters.keySet().iterator();\n                while (i.hasNext()) {\n                    String key = i.next();\n                    connection.addRequestProperty(key, parameters.get(key));\n                }\n            }\n            // Sets request method\n            connection.setRequestMethod(requestMethod);\n            // Establish connection\n            connection.connect();\n            // Send data if any\n\n            if (bodyData != null) {\n                OutputStream os = connection.getOutputStream();\n                os.write(bodyData);\n            }\n            if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                throw new AppException(\"Error HTTP code \" + connection.getResponseCode());\n            }\n            is = connection.getInputStream();\n            int numBytes = is.available();\n            if (numBytes &lt;= 0) {\n                closeInputStream(is);\n                connection.disconnect();\n                throw new AppException(MessageConstants.MSG_ERROR_CONNECTION_UNKNOWN);\n            }\n\n            ByteArrayOutputStream content = new ByteArrayOutputStream();\n\n            // Read response into a buffered stream\n            int readBytes = 0;\n            while ((readBytes = is.read(sBuffer)) != -1) {\n                content.write(sBuffer, 0, readBytes);\n            }\n            ByteArrayInputStream byteStream = new ByteArrayInputStream(content.toByteArray());\n            content.flush();\n            return byteStream;\n        } catch (Exception e) {\n//          Logger.logDebug(e.getMessage());\n            throw new AppException(e.getMessage());\n        } finally {\n            closeInputStream(is);\n            closeHttpConnection(connection);\n        }\n    }\n", "Signature Signer = Signature.getInstance(\"SHA1withRSA\");\nSigner.initSign(MyKey, new SecureRandom()); //Where do you get the key?\nbyte []Message = MyMessage(); //Initialize somehow\nSigner.update(Message, 0, Message.length);\nbyte [] Signature = Sign.sign();\n", "public HttpClient getNewHttpClient() {\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore\n                    .getDefaultType());\n            trustStore.load(null, null);\n\n            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n            HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory\n                    .getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sf, 443));\n\n\n\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(\n                    params, registry);\n\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception e) {\n            return new DefaultHttpClient();\n        }\n    }\n", "try {\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n", "KeyStore ks;\ntry {\n     ks = KeyStore.getInstance(\"JKS\");\n", "/***\n  Copyright (c) 2014 CommonsWare, LLC\n\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n  not use this file except in compliance with the License. You may obtain\n  a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage com.commonsware.cwac.security;\n\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.Signature;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class SignatureUtils {\n  public static String getOwnSignatureHash(Context ctxt)\n                                                        throws NameNotFoundException,\n                                                        NoSuchAlgorithmException {\n    return(getSignatureHash(ctxt, ctxt.getPackageName()));\n  }\n\n  public static String getSignatureHash(Context ctxt, String packageName)\n                                                                         throws NameNotFoundException,\n                                                                         NoSuchAlgorithmException {\n    MessageDigest md=MessageDigest.getInstance(\"SHA-256\");\n    Signature sig=\n        ctxt.getPackageManager()\n            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];\n\n    return(toHexStringWithColons(md.digest(sig.toByteArray())));\n  }\n\n  // based on https://stackoverflow.com/a/2197650/115145\n\n  public static String toHexStringWithColons(byte[] bytes) {\n    char[] hexArray=\n        { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B',\n            'C', 'D', 'E', 'F' };\n    char[] hexChars=new char[(bytes.length * 3) - 1];\n    int v;\n\n    for (int j=0; j &lt; bytes.length; j++) {\n      v=bytes[j] &amp; 0xFF;\n      hexChars[j * 3]=hexArray[v / 16];\n      hexChars[j * 3 + 1]=hexArray[v % 16];\n\n      if (j &lt; bytes.length - 1) {\n        hexChars[j * 3 + 2]=':';\n      }\n    }\n\n    return new String(hexChars);\n  }\n}\n", "KeyStore trustStore = KeyStore.getInstance(\"BKS\");\nKeyStore certStore = KeyStore.getInstance(\"BKS\");\nInputStream in = context.getResources().openRawResource(R.raw.signature_certstore);\ntry {\n    certStore.load(in, \"some_password\".toCharArray());\n} finally {\n    in.close();\n}\n\nin = context.getResources().openRawResource(R.raw.signature_truststore);\ntry {\n    trustStore.load(in, \"some_password\".toCharArray());\n} finally {\n    in.close();\n}\n", "private static char[] hextable = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n\npublic static String byteArrayToHex(byte[] array) {\n    String s = \"\";\n    for (int i = 0; i &lt; array.length; ++i) {\n        int di = (array[i] + 256) &amp; 0xFF; // Make it unsigned\n        s = s + hextable[(di &gt;&gt; 4) &amp; 0xF] + hextable[di &amp; 0xF];\n    }\n    return s;\n}\n\npublic static String digest(String s, String algorithm) {\n    MessageDigest m = null;\n    try {\n        m = MessageDigest.getInstance(algorithm);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n        return s;\n    }\n\n    try {\n        m.update(s.getBytes(\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n        m.update(s.getBytes());\n    }\n    return byteArrayToHex(m.digest());\n}\n\npublic static String md5(String s) {\n    return digest(s, \"MD5\");\n}\n", "        CipherParameters p = new KeyParameter(key.getBytes(\"UTF-8\"));\n\n        WhirlpoolDigest w = new WhirlpoolDigest();\n        HMac hm = new HMac(w);\n        hm.init(p);\n        hm.update(inbytes, 0, inbytes.length);\n        byte[] result = new byte[hm.getMacSize()];\n        hm.doFinal(result, 0);\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.example.packagename\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "public static SecretKey generateKey() throws NoSuchAlgorithmException, InvalidKeySpecException {\n    return secret = new SecretKeySpec(password.getBytes(), \"AES\");\n}\n\npublic static byte[] encryptMsg(String message, SecretKey secret) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException {\n/* Encrypt the message. */\n    Cipher cipher = null;\n    cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    byte[] cipherText = cipher.doFinal(message.getBytes(\"UTF-8\"));\n    return cipherText;\n}\n\npublic static String decryptMsg(byte[] cipherText, SecretKey secret) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidParameterSpecException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException {\n\n    /* Decrypt the message, given derived encContentValues and initialization vector. */\n    Cipher cipher = null;\n    cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n   cipher.init(Cipher.DECRYPT_MODE, secret);\n    String decryptString = new String(cipher.doFinal(cipherText), \"UTF-8\");\n    return decryptString;\n}\n", "KeyStore keyStore = KeyStore.getInstance( \"PKCS12\" );\nString pkcs12 = UserSession.getCertificate( context );\nInputStream sslInputStream = new ByteArrayInputStream( MyBase64Decoder.decode( pkcs12.getBytes() ) );\nkeyStore.load( sslInputStream, \"password\".toCharArray() );\n", "/**\n     * Generates the hash key used for Facebook console to register app. It can also be used for other sdks) Method copied from: https://developers.facebook.com/docs/android/getting-started/\n     */\n    public static String printHashKey(Context ctx) {\n        // Add code to print out the key hash\n        try {\n            PackageInfo info = ctx.getPackageManager().getPackageInfo(ctx.getPackageName(), PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                return Base64.encodeToString(md.digest(), Base64.DEFAULT);\n            }\n        } catch (NameNotFoundException e) {\n            return \"SHA-1 generation: the key count not be generated: NameNotFoundException thrown\";\n        } catch (NoSuchAlgorithmException e) {\n            return \"SHA-1 generation: the key count not be generated: NoSuchAlgorithmException thrown\";\n        }\n\n        return \"SHA-1 generation: epic failed\";\n    }\n", "/**\n * Android Central Keystore repo usually located on /data/misc/keychain \n * including the system trusted anchors located on /system/etc/security\n */\nKeyStore keyStore = KetStore.getInstance(\"AndroidCAStore\");\nkeyStore.load(null, null); //Load default system keystore\nEnumeration&lt;String&gt; keyAliases = keyStore.aliases();\n\nwhile(keyAliases.hasMoreElements()){\n    String alias = aliases.nextElement();\n    X509Certificate cert = (X509Certificate) keyStore.getCertificate(alias);\n\n    //&lt;User cert in whatever way you want&gt;\n}\n", " public class ChooseTeamActivity extends ListActivity {\n\n    private static final String apiKey = \"4545ggg454hfnf7557kfdkgg454\"; \n    private static final String apiUser = \"AndroidUser\"; \n\n    long unixTimeStamp = System.currentTimeMillis() / 1000L;\n\n    String newFeedRequest = \"1.0/evoStructure?timestamp=\" + unixTimeStamp;\n    String fixturesFeedURL = \"https://secure.TestSite.com/_services/api/\" + newFeedRequest;\n    String strHash = null;\n    public void hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{\n\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(fixturesFeedURL.getBytes(\"UTF-8\"));\n        byte[] digest = md.digest();\n        strHash = new String(digest);\n\n    }   \n\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n\n    setContentView(R.layout.chooseact);\n\n     hash();\n     Log.v(\"myApp\", fixturesFeedURL);\n     Log.v(\"myApp\", strhash);\n\n\n\n    }\n\n}\n", "public class ChooseTeamActivity extends ListActivity {\n\n    private static final String apiKey = \"4545ggg454hfnf7557kfdkgg454\"; \n    private static final String apiUser = \"AndroidUser\"; \n\n    long unixTimeStamp = System.currentTimeMillis() / 1000L;\n\n    String newFeedRequest = \"1.0/evoStructure?timestamp=\" + unixTimeStamp;\n    String fixturesFeedURL = \"https://secure.TestSite.com/_services/api/\" + newFeedRequest;\n\n    public String hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{\n\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(fixturesFeedURL.getBytes(\"UTF-8\"));\n        byte[] digest = md.digest();\n        return new String(digest);\n\n    }   \n\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n\n    setContentView(R.layout.chooseact);\n\n     String strhash = hash();\n     Log.v(\"myApp\", fixturesFeedURL);\n     Log.v(\"myApp\", strhash);\n\n\n\n    }\n\n}\n", "static String decrypt(String strInput) throws IOException,\n    NoSuchAlgorithmException, NoSuchPaddingException,\n    InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n    FileInputStream fis = new FileInputStream(strInput);\n\n    int endFile = strInput.length() - 4;\n    String strOut = strInput.substring(0, endFile) + \"xx.txt\"; \n\n    FileOutputStream fos = new FileOutputStream(strOut);\n\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n\n    int b;\n    byte[] d = new byte[8];\n    while ((b = fis.read(d)) != -1) {\n        fos.write(cipher.update(d));\n    }\n    fos.write(cipher.doFinal());\n\n    fos.flush();\n    fos.close();\n    fis.close();\n    return strOut;\n}\n", "OkHttpClient okHttpClient = new OkHttpClient();\ntry {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, null, null);\n    okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());\n} catch (GeneralSecurityException ignored) {\n}\n\n// open a URL connection to the Servlet\nfileInputStream = mImagePath.getContentStream();\nURL url = new URL(Api.url(Api.Methods.UPLOAD_IMAGE));\n\nconn = okHttpClient.open(url); // FIX!!!\nconn.setDoInput(true);\nconn.setDoOutput(true);\nconn.setUseCaches(false);\nconn.setRequestMethod(\"POST\");\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.yours.package\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "PackageInfo info;\ntry {\n    info = getPackageManager().getPackageInfo(\"YOUR_APP_PACKAGE\", PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String keyhash = new String(Base64.encode(md.digest(), 0));\n        //string something is what you should paste as key hash\n        Log.e(\"hash key\", keyhash);\n    }\n} catch (NameNotFoundException e1) {\n    Log.e(\"name not found\", e1.toString());\n} catch (NoSuchAlgorithmException e) {\n    Log.e(\"no such an algorithm\", e.toString());\n} catch (Exception e) {\n    Log.e(\"exception\", e.toString());\n} \n", "HttpClient httpClient = MainActivity.createHttpClient();\n\n\npublic static HttpClient createHttpClient(){\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, 15000);\n        HttpConnectionParams.setSoTimeout(params, 5000);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", "public class TwitterUpdater {\n     Context context;\n     public TwitterUpdate(Context ctx){\n        context = ctx;\n        Timer timer = new Timer;\n        timer.scheduleAtFixedRate(new TwitterTask(), 0, 300000);\n     }\n\n}\n\npublic class TwitterTask extends TimerTask{\n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n        this.loadMessages();\n    }\n\n}\npublic void loadMessages(){\n        StringBuilder builder = new StringBuilder();\n        HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n\n           DefaultHttpClient client = new DefaultHttpClient();\n\n           SchemeRegistry registry = new SchemeRegistry();\n           SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();\n           socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\n           registry.register(new Scheme(\"https\", socketFactory, 443));\n           SingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);\n           DefaultHttpClient httpClient = new DefaultHttpClient(mgr, client.getParams());\n\n           // Set verifier      \n           HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n\n\n        HttpGet httpGet = new HttpGet(\"https://api.twitter.com/1/statuses/user_timeline.json?include_entities=true&amp;include_rts=true&amp;screen_name=&lt;Your twitter account name&gt;\");\n        try {\n          HttpResponse response = httpClient.execute(httpGet);\n          StatusLine statusLine = response.getStatusLine();\n          int statusCode = statusLine.getStatusCode();\n          if (statusCode == 200) {\n\n            HttpEntity entity = response.getEntity();\n            InputStream content = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n            String line;\n            while ((line = reader.readLine()) != null) {\n              builder.append(line);\n            }\n            JSONArray obj = new JSONArray(builder.toString());\n            if (obj.getClass() == JSONArray.class){\n                JSONArray  results = obj;\n                for(int i = 0; i &lt; results.length(); i++){\n                    JSONObject result = results.getJSONObject(i);\n\n                    JSONObject user = result.getJSONObject(\"user\");\n                    if(((String) user.get(\"screen_name\")).compareToIgnoreCase(\"TNCVB\")== 0){\n                        String name = user.getString(\"screen_name\");\n                        String text =result.getString(\"text\");\n                        String timestamp = result.getString(\"created_at\");\n                        //Put them in an object and add to array or something\n                    }\n                }\n            }\n\n                Intent nintent = new Intent(context, MyActivity.class);\n                PendingIntent pintent = PendingIntent.getActivity(context, 0, nintent, 0);\n\n                NotificationCompat.Builder mBuilder =\n                        new NotificationCompat.Builder(context)\n                        .setSmallIcon(R.drawable.ic_launcher)\n                        .setContentTitle(\"Update\")\n                        .setContentIntent(pintent)\n                        .setContentText(\"New messages are available.\");\n                NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n                notificationManager.notify(007, mBuilder.build());\n          } else {\n            Log.e(\"JSON Error:\", \"Failed to download file\");\n          }\n        } catch (ClientProtocolException e) {\n          e.printStackTrace();\n        } catch (IOException e) {\n          e.printStackTrace();\n        }catch(Exception e){\n\n        }\n\n    }\n}\n", "// use local trust store (CA)\nTrustManagerFactory tmf;\nKeyStore trustedStore = null;\nInputStream in = context.getResources().openRawResource(R.raw.mycatruststore); // BKS in res/raw\ntrustedStore = KeyStore.getInstance(\"BKS\");\ntrustedStore.load(in, \"insertBksPasswordHere\".toCharArray());\ntmf = TrustManagerFactory.getInstance(\"X509\");\ntmf.init(trustedStore);\n\n// load client certificate\nKeyStore clientKeyStore = loadClientKeyStore(getApplicationContext());\nKeyManagerFactory kmf = KeyManagerFactory.getInstance(\"X509\");\nkmf.init(clientKeyStore, \"insertPasswordHere\".toCharArray());\n\nSSLContext context = SSLContext.getInstance(\"TLS\");\n\n// provide client cert - if server requires client cert this will pass\ncontext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\nHostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.STRICT_HOSTNAME_VERIFIER;\n\n// connect to url\nURL u = new URL(\"https://10.0.2.2:8888/\");\nHttpsURLConnection urlConnection = (HttpsURLConnection) u.openConnection();\nurlConnection.setSSLSocketFactory(context.getSocketFactory());\nurlConnection.setHostnameVerifier(hostnameVerifier);\nurlConnection.connect();\nSystem.out.println(\"Response Code: \" + urlConnection.getResponseCode());\n", "private KeyStore loadClientKeyStore(Context context) {\n    InputStream in = context.getResources().openRawResource(R.yourKeyStoreFile);\n    KeyStore trusted = null;\n    trusted = KeyStore.getInstance(\"BKS\");\n    trusted.load(in, \"yourClientPassword\".toCharArray());\n    in.close();\n    return trusted;\n}\n", "import java.util.Properties;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.w3c.dom.Document;\n\n\npublic class XMLhelper\n{\n    private static String serializeDocument(Document doc)\n    {\n        String xml = null;\n        try\n        {\n            TransformerFactory factory = TransformerFactory.newInstance();\n            Transformer transformer = factory.newTransformer();\n            Properties outFormat = new Properties();\n            outFormat.setProperty( OutputKeys.INDENT, \"yes\" );\n            outFormat.setProperty( OutputKeys.METHOD, \"xml\" );\n            outFormat.setProperty( OutputKeys.OMIT_XML_DECLARATION, \"no\" );\n            outFormat.setProperty( OutputKeys.VERSION, \"1.0\" );\n            outFormat.setProperty( OutputKeys.ENCODING, \"UTF-8\" );\n            transformer.setOutputProperties( outFormat );\n\n            DOMSource domSource = new DOMSource( doc.getDocumentElement() );\n            OutputStream output = new StringOutputStream();\n            StreamResult result = new StreamResult( output );\n            transformer.transform( domSource, result );\n\n            xml = output.toString();\n            android.util.Log.i( \"XMLHELPER\", xml );\n        }\n        catch (TransformerConfigurationException e)\n        {\n            android.util.Log.d( \"XMLHELPER\", \"Exception: \" + e );\n            e.printStackTrace();\n        }\n        catch (TransformerException e)\n        {\n            android.util.Log.d( \"XMLHELPER\", \"Exception: \" + e );\n            e.printStackTrace();\n        }\n\n        return xml;\n    }\n}\n", "try {\nPackageInfo info = getPackageManager().getPackageInfo(\n      \"com.facebook.samples.loginhowto\", PackageManager.GET_SIGNATURES);\nfor (Signature signature : info.signatures){\n       MessageDigest md = MessageDigest.getInstance(\"SHA\");\n       md.update(signature.toByteArray());\n       Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n}\n} catch (NameNotFoundException e) {\n} catch (NoSuchAlgorithmException e) {\n}\n", "public class PreferredCipherSuiteSSLSocketFactory extends SSLSocketFactory {\n\n\nprivate static final String PREFERRED_CIPHER_SUITE = \"TLS_RSA_WITH_AES_128_CBC_SHA\";\n\nprivate final SSLSocketFactory delegate;\n\npublic PreferredCipherSuiteSSLSocketFactory(SSLSocketFactory delegate) {\n\n    this.delegate = delegate;\n}\n\n@Override\npublic String[] getDefaultCipherSuites() {\n\n    return setupPreferredDefaultCipherSuites(this.delegate);\n}\n\n@Override\npublic String[] getSupportedCipherSuites() {\n\n    return setupPreferredSupportedCipherSuites(this.delegate);\n}\n\n@Override\npublic Socket createSocket(String arg0, int arg1) throws IOException,\n        UnknownHostException {\n\n    Socket socket = this.delegate.createSocket(arg0, arg1);\n    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);\n    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);\n\n    return socket;\n}\n\n@Override\npublic Socket createSocket(InetAddress arg0, int arg1) throws IOException {\n\n    Socket socket = this.delegate.createSocket(arg0, arg1);\n    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);\n    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);\n\n    return socket;\n}\n\n@Override\npublic Socket createSocket(Socket arg0, String arg1, int arg2, boolean arg3)\n        throws IOException {\n\n    Socket socket = this.delegate.createSocket(arg0, arg1, arg2, arg3);\n    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);\n    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);\n\n    return socket;\n}\n\n@Override\npublic Socket createSocket(String arg0, int arg1, InetAddress arg2, int arg3)\n        throws IOException, UnknownHostException {\n\n    Socket socket = this.delegate.createSocket(arg0, arg1, arg2, arg3);\n    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);\n    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);\n\n    return socket;\n}\n\n@Override\npublic Socket createSocket(InetAddress arg0, int arg1, InetAddress arg2,\n        int arg3) throws IOException {\n\n    Socket socket = this.delegate.createSocket(arg0, arg1, arg2, arg3);\n    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);\n    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);\n\n    return socket;\n}\n\nprivate static String[] setupPreferredDefaultCipherSuites(SSLSocketFactory sslSocketFactory) {\n\n    String[] defaultCipherSuites = sslSocketFactory.getDefaultCipherSuites();\n\n    ArrayList&lt;String&gt; suitesList = new ArrayList&lt;String&gt;(Arrays.asList(defaultCipherSuites));\n    suitesList.remove(PREFERRED_CIPHER_SUITE);\n    suitesList.add(0, PREFERRED_CIPHER_SUITE);\n\n    return suitesList.toArray(new String[suitesList.size()]);\n}\n\nprivate static String[] setupPreferredSupportedCipherSuites(SSLSocketFactory sslSocketFactory) {\n\n    String[] supportedCipherSuites = sslSocketFactory.getSupportedCipherSuites();\n\n    ArrayList&lt;String&gt; suitesList = new ArrayList&lt;String&gt;(Arrays.asList(supportedCipherSuites));\n    suitesList.remove(PREFERRED_CIPHER_SUITE);\n    suitesList.add(0, PREFERRED_CIPHER_SUITE);\n\n    return suitesList.toArray(new String[suitesList.size()]);\n}\n}\n", "            HttpsURLConnection connection = (HttpsURLConnection) (new URL(url))\n                .openConnection();\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        TrustManager tm[] = {new SSLPinningTrustManager()};\n        context.init(null, tm, null);\n        SSLSocketFactory preferredCipherSuiteSSLSocketFactory = new PreferredCipherSuiteSSLSocketFactory(context.getSocketFactory());\n        connection.setSSLSocketFactory(preferredCipherSuiteSSLSocketFactory);\n                    connection.connect();\n", "// open the certificate\nkeyStore = KeyStore.getInstance(\"PKCS12\");\nfis = new FileInputStream(certificateFile);\nkeyStore.load(fis, clientCertPassword.toCharArray());\n\n\n// create the SSL context\nKeyManagerFactory kmf = KeyManagerFactory.getInstance(\"X509\");\nkmf.init(keyStore, clientCertPassword.toCharArray());\nKeyManager[] keyManagers = kmf.getKeyManagers();\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");\ntmf.init(trustStore);\nTrustManager[] trustManagers = tmf.getTrustManagers();\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(keyManagers, trustManagers, null);\n\n\n// perform the HTTP request\nString result = null;\nHttpURLConnection urlConnection = null;\n\ntry {\n    URL requestedUrl = new URL(url);\n    urlConnection = (HttpURLConnection) requestedUrl.openConnection();\n    if(urlConnection instanceof HttpsURLConnection) {\n        ((HttpsURLConnection)urlConnection)\n             .setSSLSocketFactory(sslContext.getSocketFactory());\n    }\n    urlConnection.setRequestMethod(\"GET\");\n    urlConnection.setConnectTimeout(1500);\n    urlConnection.setReadTimeout(1500);\n    lastResponseCode = urlConnection.getResponseCode();\n    result = IOUtil.readFully(urlConnection.getInputStream());\n    lastContentType = urlConnection.getContentType();\n} catch(Exception ex) {\n    result = ex.toString();\n} finally {\n    if(urlConnection != null) {\n        urlConnection.disconnect();\n    }\n}\n", "byte[] keyBytes = Base64.decode(publicK.getBytes(\"utf-8\"));\nX509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nPublicKey key = keyFactory.generatePublic(spec);\n", "byte[] keyBytes = Base64.decode(privateK.getBytes(\"utf-8\"));\nPKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(clear);\nKeyFactory fact = KeyFactory.getInstance(\"RSA\");\nPrivateKey priv = fact.generatePrivate(keySpec);\n", "try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.facebook.samples.hellofacebook\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "    public static SignedRequestResponse parse_signed_request(String input, String secret, int max_age) {\n        String[] split = input.split(\"[.]\", 2);\n        SignedRequestResponse response = new SignedRequestResponse();\n        response.setStatus(Status.Failure);\n\n        String encoded_sig = split[0];\n        String encoded_envelope = split[1];\n        JSONParser parser = new JSONParser();\n        Map envelope;\n        try {\n            envelope = (Map) parser.parse(new String(base64_url_decode(encoded_envelope)));\n        } catch (Exception ex) {\n            response.addError(\"ParsingError\");\n            return response;\n        }\n\n        response.setEnvelope(envelope);\n\n        String algorithm = (String) envelope.get(\"algorithm\");\n\n        if (!algorithm.equals(\"HMAC-SHA256\")) {\n            response.addError(\"UnsupportedAlgorithm\");\n            return response;    // instant fail\n        }\n\n        byte[] key = secret.getBytes();\n        SecretKey hmacKey = new SecretKeySpec(key, \"HMACSHA256\");\n        Mac mac = null;\n        try {\n            mac = Mac.getInstance(\"HMACSHA256\");\n            mac.init(hmacKey);\n        } catch (Exception e) {\n            response.addError(\"DecryptionError\");\n            return response; // instant fail\n        }\n\n        byte[] digest = mac.doFinal(encoded_envelope.getBytes());\n        try {\n\n            if (!Arrays.equals(base64_url_decode(encoded_sig), digest)) {\n                response.addError(\"InvalidSignature\");\n                return response; // instant fail\n            }\n        } catch (Exception ex) {\n            response.addError(\"InvalidSignature\");\n            return response; // instant fail\n        }\n\n        if (((Long) envelope.get(\"issued_at\")) &lt; System.currentTimeMillis() / 1000 - max_age) {\n            response.addError(\"Expired\");\n            response.setStatus(Status.PartialSuccess);\n            return response;    // partial fail\n        }\n\n        response.setStatus(Status.Success);\n        return response;\n    }\n}\n", "private static String convertToHex(byte[] data) {\n    StringBuilder buf = new StringBuilder();\n    for (byte b : data) {\n        int halfbyte = (b &gt;&gt;&gt; 4) &amp; 0x0F;\n        int two_halfs = 0;\n        do {\n            buf.append((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));\n            halfbyte = b &amp; 0x0F;\n        } while (two_halfs++ &lt; 1);\n    }\n    return buf.toString();\n}\n\npublic static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n    md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n    byte[] sha1hash = md.digest();\n    return convertToHex(sha1hash);\n}\n", "public static String encrypt(String inputString, byte[] keyBytes) {\n        Calendar cal = Calendar.getInstance();\n        int mDay = cal.get(Calendar.DAY_OF_MONTH);\n        // System.out.println(\"Day of month :::\" + mDay);\n        String encryptedString = \"\";\n        Key publicKey = null;\n        try {\n            Random generator = new Random(mDay);\n            int num = (generator.nextInt()) % 100;\n            String salt = \"MNSadm563784\" + num;\n            //inputString += salt;\n            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyBytes);\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            publicKey = keyFactory.generatePublic(publicKeySpec);\n        } catch (Exception e) {\n            System.out.println(\"Exception rsaEncrypt:::::::::::::::::  \"\n                    + e.getMessage());\n            e.printStackTrace();\n        }\n        // Encode the original data with RSA public key\n        byte[] encodedBytes = null;\n        try {\n            Cipher c = Cipher.getInstance(\"RSA\");\n            c.init(Cipher.ENCRYPT_MODE, publicKey);\n            encodedBytes = c.doFinal(inputString.getBytes());\n            encryptedString = Base64.encodeToString(encodedBytes,\n                    Base64.NO_CLOSE);\n            System.out.print(\"-----??\"+encryptedString+\"??-------\");\n        } catch (Exception e) {\n            System.out.println(\"Exception rsaEncrypt:::::::::::::::::  \"\n                    + e.getMessage());\n            e.printStackTrace();\n        }\n\n        return encryptedString;\n    }\n", "public static String decrypt(String inputString, byte[] keyBytes) {\n        String resultStr = null;\n//      Calendar cal = Calendar.getInstance();\n//      int mDay = cal.get(Calendar.DAY_OF_MONTH);\n//      Random generator = new Random(mDay);\n//      int num = (generator.nextInt()) % 100;\n//      String salt = \"MNSadm563784\" + num;\n        PrivateKey privateKey = null;\n        try {\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(\n                    keyBytes);\n            privateKey = keyFactory.generatePrivate(privateKeySpec);\n        } catch (Exception e) {\n            System.out.println(\"Exception privateKey:::::::::::::::::  \"\n                    + e.getMessage());\n            e.printStackTrace();\n        }\n        byte[] decodedBytes = null;\n        try {\n            Cipher c = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n            // Cipher c = Cipher.getInstance(\"RSA\");\n            c.init(Cipher.DECRYPT_MODE, privateKey);\n            decodedBytes = c.doFinal(Base64.decodeBase64(inputString));\n            // decodedBytes = c.doFinal(Base64InputStream());\n\n        } catch (Exception e) {\n            System.out.println(\"Exception privateKey1:::::::::::::::::  \"\n                    + e.getMessage());\n            e.printStackTrace();\n        }\n        if (decodedBytes != null) {\n            resultStr = new String(decodedBytes);\n            System.out.println(\"resultStr:::\" + resultStr + \":::::\");\n//          resultStr = resultStr.replace(salt, \"\");\n        }\n        return resultStr;\n\n    }\n", "    PEMWriter writer = new PEMWriter(new FileWriter(\"test.pem\"));\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(3072);\n    KeyPair keyPair = kpg.generateKeyPair();\n    writer.writeObject(keyPair.getPublic());\n    writer.close();\n", "</p>\n\n<pre><code>/**\n * &lt;p&gt;Title: RSA Security&lt;/p&gt;\n * Description: This class generates a RSA private and public key, reinstantiates\n * the keys from the corresponding key files.It also generates compatible .Net Public Key,\n * which we will read later in C# program using .Net Securtiy Framework\n * The reinstantiated keys are used to sign and verify the given data.&lt;/p&gt;\n *\n * @author Shaheryar\n * @version 1.0\n */\n\nimport java.security.*;\nimport java.security.spec.*;\nimport java.io.*;\nimport java.security.interfaces.*;\nimport java.security.cert.*;\nimport javax.xml.transform.stream.*;\nimport javax.xml.transform.dom.*;\nimport javax.xml.transform.*;\nimport org.w3c.dom.*;\nimport javax.xml.parsers.*;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class SecurityManager {\n\n  private KeyPairGenerator keyGen; //Key pair generator for RSA\n  private PrivateKey privateKey; // Private Key Class\n  private PublicKey publicKey; // Public Key Class\n  private KeyPair keypair; // KeyPair Class\n  private Signature sign; // Signature, used to sign the data\n  private String PRIVATE_KEY_FILE; // Private key file.\n  private String PUBLIC_KEY_FILE; // Public key file.\n  private String DOT_NET_PUBLIC_KEY_FILE; // File to store .Net Compatible Key Data\n\n  /**\n   * Default Constructor. Instantiates the key paths and signature algorithm.\n * @throws IOException \n * @throws InvalidKeySpecException \n * @throws NoSuchAlgorithmException \n   */\n  public SecurityManager() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {\n\n  }\n\n\n  public static void main(String args[]) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException{\n      GenerateDotNetKey(\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp6340BNzismmb/n98sTcYfNEmmzNGumdWnK1e7NNWntM6mjZMnQaVZ9HiJKmMgtn69dAU4gaMVUWACDsuup1GBxN8dLgDbtR26M0u1jf1G8AQehcKfqxqSYzxKquXXotffdYsJPpjseZbi96Y7j47kz9CjNP3y1BzjJNTWQUx9fc9e2Bpsi0GtqJ8porPBuIGTjcCnlKM14tIv6YlHtECW1L1wcOBkoj/5liI1nhlYDth/DNXg1OY11JqIIP1fO2vQPtKEpdtcTBTjmB9M45O1N8K/shTcMntFjwVTpL0hRd+eaN1bUjpMvrhFik0VcF/ZNN6Hn0Coqe+ey18dLosQIDAQAB\");\n  }\n  public static void GenerateDotNetKey(String base64PubKey)\n          throws IOException, NoSuchAlgorithmException,\n          InvalidKeySpecException {\n      /*\n       * String base64PubKey - \n       * Is a Key retrieved from Google Checkout Merchant Account\n       */\n      BASE64Decoder decoder = new BASE64Decoder();\n\n      byte[] publicKeyBytes = decoder.decodeBuffer(base64PubKey);\n\n      EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);\n      RSAPublicKey publicKey = (RSAPublicKey) KeyFactory.getInstance(\"RSA\").generatePublic(publicKeySpec);\n\n      byte[] modulusBytes = publicKey.getModulus().toByteArray();\n      byte[] exponentBytes = publicKey.getPublicExponent().toByteArray();\n\n      modulusBytes = stripLeadingZeros1(modulusBytes);\n\n      BASE64Encoder encoder = new BASE64Encoder();\n      String modulusB64 = encoder.encode(modulusBytes);\n      String exponentB64 = encoder.encode(exponentBytes);\nint i=0;\n     // return new DotNetRSA(modulusB64, exponentB64);\n  }\n\n    private static byte[] stripLeadingZeros1(byte[] a) {\n      int lastZero = -1;\n      for (int i = 0; i &lt; a.length; i++) {\n        if (a[i] == 0) {\n          lastZero = i;\n        }\n        else {\n          break;\n        }\n      }\n      lastZero++;\n      byte[] result = new byte[a.length - lastZero];\n      System.arraycopy(a, lastZero, result, 0, result.length);\n      return result;\n    }\n\n\n  }\n", "public String calcHmac(String src) throws Exception {\n\n    String key = \"d6fc3a4a06ed55d24fecde188aaa9161\";\n    Mac mac = Mac.getInstance(\"HmacSHA1\");\n    SecretKeySpec sk = new SecretKeySpec(key.getBytes(),mac.getAlgorithm());  \n    mac.init(sk);\n    byte[] result = mac.doFinal(src.getBytes());\n\n\n    return Base64.encodeToString(result ,Base64.URL_SAFE);\n}\n", "     try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"your.application.package.name\",\n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (PackageManager.NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n }\n", "static void encrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    // Here you read the cleartext.\n    FileInputStream fis = new FileInputStream(\"data/cleartext\");\n    // This stream write the encrypted text. This stream will be wrapped by another stream.\n    FileOutputStream fos = new FileOutputStream(\"data/encrypted\");\n\n    // Length is 16 byte\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n    // Create cipher\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);\n    // Wrap the output stream\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n    // Write bytes\n    int b;\n    byte[] d = new byte[8];\n    while((b = fis.read(d)) != -1) {\n        cos.write(d, 0, b);\n    }\n    // Flush and close streams.\n    cos.flush();\n    cos.close();\n    fis.close();\n}\n", "static void decrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    FileInputStream fis = new FileInputStream(\"data/encrypted\");\n\n    FileOutputStream fos = new FileOutputStream(\"data/decrypted\");\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    int b;\n    byte[] d = new byte[8];\n    while((b = cis.read(d)) != -1) {\n        fos.write(d, 0, b);\n    }\n    fos.flush();\n    fos.close();\n    cis.close();\n}\n", "FileInputStream fis;\nFileOutputStream fos;\nCipherOutputStream cos;\n// File you are reading from\nfis = new FileInputStream(\"/tmp/a.txt\");\n// File output\nfos = new FileOutputStream(\"/tmp/b.txt\");\n\n// Here the file is encrypted. The cipher1 has to be created.\n// Key Length should be 128, 192 or 256 bit =&gt; i.e. 16 byte\nSecretKeySpec skeySpec = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\"); \nCipher cipher1 = Cipher.getInstance(\"AES\");  \ncipher1.init(Cipher.ENCRYPT_MODE, skeySpec);\ncos = new CipherOutputStream(fos, cipher1);\n// Here you read from the file in fis and write to cos.\nbyte[] b = new byte[8];\nint i = fis.read(b);\nwhile (i != -1) {\n    cos.write(b, 0, i);\n    i = fis.read(b);\n}\ncos.flush();\n", "final PackageManager packageManager = context.getPackageManager();\nfinal List&lt;PackageInfo&gt; packageList = packageManager.getInstalledPackages(PackageManager.GET_SIGNATURES);\nCertificateFactory certFactory = null;\ntry {\n    certFactory = CertificateFactory.getInstance(\"X509\");\n}\ncatch (CertificateException e) {\n    // e.printStackTrace();\n}\n\nfor (PackageInfo p : packageList) {\n    String strName = p.applicationInfo.loadLabel(packageManager).toString();\n    String strVendor = p.packageName;\n\n    sb.append(\"&lt;br&gt;\" + strName + \" / \" + strVendor + \"&lt;br&gt;\");\n\n    Signature[] arrSignatures = p.signatures;\n    for (Signature sig : arrSignatures) {\n        /*\n        * Get the X.509 certificate.\n        */\n        byte[] rawCert = sig.toByteArray();\n        InputStream certStream = new ByteArrayInputStream(rawCert);\n\n        X509Certificate x509Cert = null;\n        try {\n            x509Cert = (X509Certificate) certFactory.generateCertificate(certStream);\n        }\n        catch (CertificateException e) {\n            // e.printStackTrace();\n        }\n\n        sb.append(\"Certificate subject: \" + x509Cert.getSubjectDN() + \"&lt;br&gt;\");\n        sb.append(\"Certificate issuer: \" + x509Cert.getIssuerDN() + \"&lt;br&gt;\");\n        sb.append(\"Certificate serial number: \" + x509Cert.getSerialNumber() + \"&lt;br&gt;\");\n        sb.append(\"&lt;br&gt;\");\n    }\n}\n", "public String WriteSignature(String packageName)\n{     \n   PackageManager pm = this.getPackageManager();\n   String sig = \"\"; \n   PackageInfo pi = null;\n   try {\n       pi = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);\n   } catch (NameNotFoundException e1) {\n       e1.printStackTrace();\n   }\n\n   try {\n       for (Signature signature : pi.signatures) {\n           MessageDigest md = MessageDigest.getInstance(\"SHA\");\n           md.update(signature.toByteArray());\n           sig = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n           Log.d(ACTIVITY_TAG, sig);\n       }\n   } catch (NoSuchAlgorithmException e) {\n       e.printStackTrace();\n   }\n\n   return sig;\n}\n", "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\nimport android.util.Base64;\n\npublic class SimpleCrypto {\n\n    private String charsetName = \"UTF8\";\n    private String algorithm = \"DES\";\n    private int base64Mode = Base64.DEFAULT;\n\n    public String getCharsetName() {\n        return charsetName;\n    }\n\n    public void setCharsetName(String charsetName) {\n        this.charsetName = charsetName;\n    }\n\n    public String getAlgorithm() {\n        return algorithm;\n    }\n\n    public void setAlgorithm(String algorithm) {\n        this.algorithm = algorithm;\n    }\n\n    public int getBase64Mode() {\n        return base64Mode;\n    }\n\n    public void setBase64Mode(int base64Mode) {\n        this.base64Mode = base64Mode;\n    }\n\n    public String encrypt(String key, String data) {\n        if (key == null || data == null)\n            return null;\n        try {\n            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));\n            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);\n            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n            byte[] dataBytes = data.getBytes(charsetName);\n            Cipher cipher = Cipher.getInstance(algorithm);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            return Base64.encodeToString(cipher.doFinal(dataBytes), base64Mode);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String decrypt(String key, String data) {\n        if (key == null || data == null)\n            return null;\n        try {\n            byte[] dataBytes = Base64.decode(data, base64Mode);\n            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));\n            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);\n            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n            Cipher cipher = Cipher.getInstance(algorithm);\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));\n            return new String(dataBytesDecrypted);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}\n", " // encryption\n              DESKeySpec keySpec = new DESKeySpec(\n                      \"123456789123456789\".getBytes(\"UTF8\"));\n              SecretKeyFactory keyFactory = SecretKeyFactory\n                      .getInstance(\"DES\");\n              SecretKey key = keyFactory.generateSecret(keySpec);\n\n          // BASE64Decoder base64decoder = new BASE64Decoder();\n          // Base64.\n\n          // ENCODE plainTextPassword String\n          byte[] cleartext = pass.getBytes(\"UTF8\");\n\n          Cipher cipher = Cipher.getInstance(\"DES\"); // cipher is not\n                                                      // thread safe\n          cipher.init(Cipher.ENCRYPT_MODE, key);\n\n          cleartext = Base64.encode(cipher.doFinal(cleartext), 0);\n          String enstr = new String(cleartext);\n          Log.e(\"Encrypted password\", enstr);\n", "public class MessageUtil {\n      private final static String AUTH = \"authentication\";\n\n      private static final String UPDATE_CLIENT_AUTH = \"Update-Client-Auth\";\n\n      public static final String PARAM_REGISTRATION_ID = \"registration_id\";\n\n      public static final String PARAM_DELAY_WHILE_IDLE = \"delay_while_idle\";\n\n      public static final String PARAM_COLLAPSE_KEY = \"collapse_key\";\n\n      private static final String UTF8 = \"UTF-8\";\n\n      public static int sendMessage(String auth_token, String registrationId,\n          String message) throws IOException {\n\n        StringBuilder postDataBuilder = new StringBuilder();\n        postDataBuilder.append(PARAM_REGISTRATION_ID).append(\"=\")\n            .append(registrationId);\n        postDataBuilder.append(\"&amp;\").append(PARAM_COLLAPSE_KEY).append(\"=\")\n            .append(\"0\");\n        postDataBuilder.append(\"&amp;\").append(\"data.payload\").append(\"=\")\n            .append(URLEncoder.encode(message, UTF8));\n\n        byte[] postData = postDataBuilder.toString().getBytes(UTF8);\n\n        // Hit the dm URL.\n\n        URL url = new URL(\"https://android.clients.google.com/c2dm/send\");\n        HttpsURLConnection\n            .setDefaultHostnameVerifier(new CustomizedHostnameVerifier());\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.setUseCaches(false);\n        conn.setRequestMethod(\"POST\");\n        conn.setRequestProperty(\"Content-Type\",\n            \"application/x-www-form-urlencoded;charset=UTF-8\");\n        conn.setRequestProperty(\"Content-Length\",\n            Integer.toString(postData.length));\n        conn.setRequestProperty(\"Authorization\", \"GoogleLogin auth=\"\n            + auth_token);\n\n        OutputStream out = conn.getOutputStream();\n        out.write(postData);\n        out.close();\n\n        int responseCode = conn.getResponseCode();\n        return responseCode;\n      }\n\n      private static class CustomizedHostnameVerifier implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n          return true;\n        }\n      }\n } \n", "    private void generateHashKey() {\n    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"your.package.name\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            System.out.println(\"KeyHash:\" + Base64.encodeToString(md.digest(),Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n}\n", "import javax.crypto.spec.IvParameterSpec\nimport javax.crypto.spec.SecretKeySpec\nimport javax.crypto.Cipher\n\next {\n    KEY = \"mysecretkey\".padRight(16).getBytes(\"UTF-8\")\n    SERVERKEY = \"serverkey\"\n    IV = \"1234\".padRight(16).getBytes(\"UTF-8\")\n    PROVIDER = \"SunJCE\"\n}\n\ntask encIt &lt;&lt; {\n    SecretKeySpec key = new SecretKeySpec(KEY, \"AES\")\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", PROVIDER)\n    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(IV))\n    def encBytes = cipher.doFinal(SERVERKEY.bytes)\n    def out = file('obf.enc')\n    out.delete()\n    out &lt;&lt; encBytes\n}\n\ntask decIt &lt;&lt; {\n    def cipherText = file('obf.enc').bytes\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", PROVIDER)\n    SecretKeySpec key = new SecretKeySpec(KEY, \"AES\")\n    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(IV))\n    println new String(cipher.doFinal(cipherText), \"UTF-8\")\n}\n", "public static String hashKeyForDisk(String key) {\n    String cacheKey;\n    try {\n        final MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        mDigest.update(key.getBytes());\n        cacheKey = bytesToHexString(mDigest.digest());\n    } catch (NoSuchAlgorithmException e) {\n        cacheKey = String.valueOf(key.hashCode());\n    }\n    return cacheKey;\n}\n\nprivate static String bytesToHexString(byte[] bytes) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i &lt; bytes.length; i++) {\n        String hex = Integer.toHexString(0xFF &amp; bytes[i]);\n        if (hex.length() == 1) {\n            sb.append('0');\n        }\n        sb.append(hex);\n    }\n    return sb.toString();\n}\n", "private void genKey() {\n        // TODO Auto-generated method stub\n        Context context = this;\n        final Dialog myDialog = new Dialog(context);\n\n        myDialog.setContentView(R.layout.dialog);\n\n        myDialog.setTitle(\"enter key\");\n\n        key_edt = (EditText) myDialog.findViewById(R.id.dg_key_tv);\n        Button ok_btn = (Button) myDialog.findViewById(R.id.dg_ok_btn);\n        Button cancel_btn = (Button) myDialog.findViewById(R.id.dg_cancel_btn);\n\n        Log.d(TAG1, key_str);\n\n        ok_btn.setOnClickListener(new OnClickListener() {\n\n            @Override\n            public void onClick(View v) {\n                // TODO Auto-generated method stub\n\n                key_str = key_edt.getText().toString();\n\n                // only try to create the Key Spec now we have our key string\n                // first check to make sure it's not blank\n                if(key_str != null &amp;&amp; !key_str.isEmpty()){\n                    try {\n                        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n                        sr.setSeed(key_str.getBytes());\n\n                        KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n                        kg.init(128, sr);\n                        this.sks = new SecretKeySpec((kg.generateKey()).getEncoded(), \"AES\");\n                        Log.i(\"encrypt\", sks.toString());\n\n                    } catch (Exception e) {\n                        Log.e(TAG, \"AES secret key spec error\");\n                    }\n                }\n                else{   // string is empty\n                    // make some toast to alert user\n                }\n            }\n        });\n\n        cancel_btn.setOnClickListener(new OnClickListener() {\n\n            @Override\n            public void onClick(View v) {\n                // TODO Auto-generated method stub\n                myDialog.dismiss();\n            }\n        });\n        myDialog.show();\n\n    }\n", "private void encrypt() {\n    if (this.sks == null){\n        // make toast and tell user to generate the key\n    } else {\n        try {\n            Cipher c = Cipher.getInstance(\"AES\");\n            // use the class key spec to encrypt\n            c.init(Cipher.ENCRYPT_MODE, this.sks);\n            encodedBytes = c.doFinal(getData_str.getBytes());\n            String encoded = Base64\n                    .encodeToString(encodedBytes, Base64.DEFAULT);\n            System.out.println(\" \" + encoded);\n        } catch (Exception e) {\n            Log.e(TAG, \"AES encryption error\");\n        }\n    }\n}\n", "try {\n   PackageInfo info = getPackageManager().getPackageInfo(\"**YOURPACKAGENAME**\", PackageManager.GET_SIGNATURES);\n   for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.i(\"PXR\", Base64.encodeBytes(md.digest()));\n   }\n}\ncatch (NameNotFoundException e) {}\ncatch (NoSuchAlgorithmException e) {}\n", "public void PrintInstalledCertificates( ){\n\n    try \n    {\n        KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\n        if (ks != null) \n        {\n            ks.load(null, null);\n            Enumeration&lt;String&gt; aliases = ks.aliases();\n            while (aliases.hasMoreElements()) \n            {\n                String alias = (String) aliases.nextElement();\n                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);\n\n                //To print System Certs only\n                if(cert.getIssuerDN().getName().contains(\u00e2\u0080\u009csystem\u00e2\u0080\u009d))\n                {\n                    System.out.println(cert.getIssuerDN().getName());\n                }\n\n                //To print User Certs only \n                if(cert.getIssuerDN().getName().contains(\u00e2\u0080\u009cuser\u00e2\u0080\u009d))\n                {\n                    System.out.println(cert.getIssuerDN().getName());\n                }\n\n                //To print all certs\n                System.out.println(cert.getIssuerDN().getName());                           \n            }\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (KeyStoreException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (java.security.cert.CertificateException e) {\n        e.printStackTrace();\n    }               \n}\n", "public boolean checkCACertificateInstalled(javax.security.cert.X509Certificate x509){\n\n    boolean isCACertificateInstalled = false;\n\n    try \n    {\n        String name = x509.getIssuerDN().getName(); \n        KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\n        if (ks != null) \n        {\n            ks.load(null, null);\n            Enumeration&lt;String&gt; aliases = ks.aliases();\n            while (aliases.hasMoreElements()) \n            {\n                String alias = (String) aliases.nextElement();\n                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);\n\n                if (cert.getIssuerDN().getName().contains(name)) \n                {\n                    isCACertificateInstalled = true;\n                    break;\n                }\n            }\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (KeyStoreException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (java.security.cert.CertificateException e) {\n        e.printStackTrace();\n    }\n\n    return isCACertificateInstalled;\n}\n", "import java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.HttpVersion;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpParams;\nimport org.apache.http.params.HttpProtocolParams;\nimport org.apache.http.protocol.HTTP;\n\npublic class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n\n\npublic static DefaultHttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n}\n", "    try {\n\n           PackageInfo info = getPackageManager().getPackageInfo(\"Your.packet.name\",PackageManager.GET_SIGNATURES);\n\n           for (Signature signature : info.signatures) {\n              MessageDigest md = MessageDigest.getInstance(\"SHA\");\n              md.update(signature.toByteArray());\n              Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n           }\n\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "public class ChooseTeamActivity extends ListActivity {\n\n    private static final String apiKey = \"4545ggg454hfnf7557kfdkgg454\"; \n    private static final String apiUser = \"AndroidUser\"; \n\n    long unixTimeStamp = System.currentTimeMillis() / 1000L;\n\n    String newFeedRequest = \"1.0/evoStructure?timestamp=\" + unixTimeStamp;\n    String fixturesFeedURL = \"https://secure.TestSite.com/_services/api/\" + newFeedRequest;\n\n    public void hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{\n\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(fixturesFeedURL.getBytes(\"UTF-8\"));\n        byte[] digest = md.digest();\n        String strhash = new String(digest);\n\n     Log.v(\"myApp\", fixturesFeedURL);\n     Log.v(\"myApp\", strhash);\n    }   \n\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n\n    setContentView(R.layout.chooseact);\n    try{ \n     hash();\n      }catch(Exception e){\n       }\n\n    }\n\n}\n", "public class SomeApp extends Application {\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see android.app.Application#onCreate()\n     */\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        // initImageLoader(getApplicationContext());\n\n        PreferenceHelper.getPrefernceHelperInstace().init(\n                getApplicationContext());\n\n        // The following line triggers the initialization of ACRA\n        if (PreferenceHelper.getPrefernceHelperInstace().getBoolean(\n                PreferenceHelper.SUBMIT_LOGS, true)) {\n            ACRA.init(this);\n        }\n\n\n            //----------It is your Key Hash-----------\n        Toast.makeText(getApplicationContext(),\n                \"keyHash\" + printKeyHash(getApplicationContext()), 1000).show();\n\n    }\n\n    public static String printKeyHash(Context context) {\n        PackageInfo packageInfo;\n        String key = null;\n        try {\n            // getting application package name, as defined in manifest\n            String packageName = context.getApplicationContext()\n                    .getPackageName();\n\n            // Retriving package info\n            packageInfo = context.getPackageManager().getPackageInfo(\n                    packageName, PackageManager.GET_SIGNATURES);\n\n            Log.e(\"Package Name=\", context.getApplicationContext()\n                    .getPackageName());\n\n            for (Signature signature : packageInfo.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                key = new String(Base64.encode(md.digest(), 0));\n\n                // String key = new String(Base64.encodeBytes(md.digest()));\n                Log.e(\"Key Hash=\", key);\n            }\n        } catch (NameNotFoundException e1) {\n            Log.e(\"Name not found\", e1.toString());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(\"No such an algorithm\", e.toString());\n        } catch (Exception e) {\n            Log.e(\"Exception\", e.toString());\n        }\n\n        return key;\n    }\n\n}\n", "    public static Bitmap getBitmapFromURL(String src) {\n        Bitmap myBitmap = null;\n            try {\n\n                URL url = new URL(src);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setDoInput(true);\n                connection.connect();\n\n                //Decryption\n                try {\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                SecretKeySpec keySpec = new SecretKeySpec(\"01234567890abcde\".getBytes(), \"AES\");\n                IvParameterSpec ivSpec = new IvParameterSpec(\"fedcba9876543210\".getBytes());\n                cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\n                InputStream input = connection.getInputStream();\n                CipherInputStream cis = new CipherInputStream(input, cipher);\n\n\n                myBitmap = BitmapFactory.decodeStream(cis);\n\n                }\n                catch(Exception e){\n                    e.fillInStackTrace();\n                    Log.v(\"ERROR\",\"Errorchence : \"+e);\n                }\n\n                return myBitmap;\n\n\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n}\n", "@Test\npublic void testKeyConversion() throws GeneralSecurityException {\n\n    /* Generate random key pair */\n    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n    AlgorithmParameterSpec spec = new RSAKeyGenParameterSpec(1024, RSAKeyGenParameterSpec.F4);\n    keyPairGenerator.initialize(spec, new SecureRandom());\n    KeyPair keyPair = keyPairGenerator.generateKeyPair();\n\n    /* Encode private key as PKCS#8 base64 string */\n    byte[] privKeyBytes = keyPair.getPrivate().getEncoded();\n    String privKeyStr = DatatypeConverter.printBase64Binary(privKeyBytes);\n\n    /* Decode private key as PKCS#8 base64 string */\n    byte[] privKeyBytes2 = DatatypeConverter.parseBase64Binary(privKeyStr);\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n    PKCS8EncodedKeySpec privSpec = new PKCS8EncodedKeySpec(privKeyBytes2);\n    PrivateKey privateKey = keyFactory.generatePrivate(privSpec);\n\n    /* Ensure key is the same */\n    byte[] privKeyBytes3 = privateKey.getEncoded();\n    assertEquals(\n            DatatypeConverter.printHexBinary(privKeyBytes),\n            DatatypeConverter.printHexBinary(privKeyBytes3));\n}\n", "    public String getDeviceID() {\n\n/*String Return_DeviceID = USERNAME_and_PASSWORD.getString(DeviceID_key,\"Guest\");\nreturn Return_DeviceID;*/\n\nTelephonyManager TelephonyMgr = (TelephonyManager) getApplicationContext().getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE);\nString m_szImei = TelephonyMgr.getDeviceId(); // Requires\n// READ_PHONE_STATE\n\n// 2 compute DEVICE ID\nString m_szDevIDShort = \"35\"\n+ // we make this look like a valid IMEI\nBuild.BOARD.length() % 10 + Build.BRAND.length() % 10\n+ Build.CPU_ABI.length() % 10 + Build.DEVICE.length() % 10\n+ Build.DISPLAY.length() % 10 + Build.HOST.length() % 10\n+ Build.ID.length() % 10 + Build.MANUFACTURER.length() % 10\n+ Build.MODEL.length() % 10 + Build.PRODUCT.length() % 10\n+ Build.TAGS.length() % 10 + Build.TYPE.length() % 10\n+ Build.USER.length() % 10; // 13 digits\n// 3 android ID - unreliable\nString m_szAndroidID = Secure.getString(getContentResolver(),Secure.ANDROID_ID);\n// 4 wifi manager, read MAC address - requires\n// android.permission.ACCESS_WIFI_STATE or comes as null\nWifiManager wm = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE);\nString m_szWLANMAC = wm.getConnectionInfo().getMacAddress();\n// 5 Bluetooth MAC address android.permission.BLUETOOTH required\nBluetoothAdapter m_BluetoothAdapter = null; // Local Bluetooth adapter\nm_BluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\nString m_szBTMAC = m_BluetoothAdapter.getAddress();\nSystem.out.println(\"m_szBTMAC \"+m_szBTMAC);\n\n// 6 SUM THE IDs\nString m_szLongID = m_szImei + m_szDevIDShort + m_szAndroidID+ m_szWLANMAC + m_szBTMAC;\nSystem.out.println(\"m_szLongID \"+m_szLongID);\nMessageDigest m = null;\ntry {\nm = MessageDigest.getInstance(\"MD5\");\n} catch (NoSuchAlgorithmException e) {\ne.printStackTrace();\n                }\nm.update(m_szLongID.getBytes(), 0, m_szLongID.length());\nbyte p_md5Data[] = m.digest();\n\nString m_szUniqueID = new String();\nfor (int i = 0; i &lt; p_md5Data.length; i++) {\nint b = (0xFF &amp; p_md5Data[i]);\n// if it is a single digit, make sure it have 0 in front (proper\n// padding)\nif (b &lt;= 0xF)\nm_szUniqueID += \"0\";\n// add number to string\nm_szUniqueID += Integer.toHexString(b);\n}\nm_szUniqueID = m_szUniqueID.toUpperCase();\n\nLog.i(\"-------------DeviceID------------\", m_szUniqueID);\nLog.d(\"DeviceIdCheck\", \"DeviceId that generated MPreferenceActivity:\"+m_szUniqueID);\n\nreturn m_szUniqueID;\n\n}\n", "public void generateFacebookHashKey()\n    {\n\n        try\n        {\n            PackageInfo info = getPackageManager().getPackageInfo(\"Your package name\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures)\n            {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"TEMPTAGHASH KEY:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        }\n        catch (NameNotFoundException e)\n        {\n\n        }\n        catch (NoSuchAlgorithmException e)\n        {\n\n        }\n\n    }\n", "Cipher c1 = Cipher.getInstance(\"DES/ECB/PKCS5Padding\"); and\nCipher c1 = Cipher.getInstance(\"DES\"); are equivalent statements.\n", "SSLContext ctx = SSLContext.getInstance(\"TLS\");\nctx.init(null, new TrustManager[] {\n  new X509TrustManager() {\n    public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n    public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n    public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; }\n  }\n}, null);\nHttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());\n", "/**\n * Adapter for bouncy castle crypto implementation (decryption).\n *\n * @author olaf@merkert.de\n * @author owlstead\n */\npublic class AESDecrypterOwlstead extends AESCryptoBase implements AESDecrypter {\n\n\n    private final boolean verify;\n\n    public AESDecrypterOwlstead(boolean verify) {\n        this.verify = verify;\n    }\n\n    // TODO consider keySize (but: we probably need to adapt the key size for the zip file as well)\n    public void init( String pwStr, int keySize, byte[] salt, byte[] pwVerification ) throws ZipException {\n        byte[] pwBytes = pwStr.getBytes();\n\n        super.saltBytes = salt;\n\n        PBEParametersGenerator generator = new PKCS5S2ParametersGenerator();\n        generator.init( pwBytes, salt, ITERATION_COUNT );\n\n        cipherParameters = generator.generateDerivedParameters(KEY_SIZE_BIT*2 + 16);\n        byte[] keyBytes = ((KeyParameter)cipherParameters).getKey();\n\n        this.cryptoKeyBytes = new byte[ KEY_SIZE_BYTE ];\n        System.arraycopy( keyBytes, 0, cryptoKeyBytes, 0, KEY_SIZE_BYTE );\n\n        this.authenticationCodeBytes = new byte[ KEY_SIZE_BYTE ];\n        System.arraycopy( keyBytes, KEY_SIZE_BYTE, authenticationCodeBytes, 0, KEY_SIZE_BYTE );\n\n        // based on SALT + PASSWORD (password is probably correct)\n        this.pwVerificationBytes = new byte[ 2 ];\n        System.arraycopy( keyBytes, KEY_SIZE_BYTE*2, this.pwVerificationBytes, 0, 2 );\n\n        if( !ByteArrayHelper.isEqual( this.pwVerificationBytes, pwVerification ) ) {\n            throw new ZipException(\"wrong password - \" + ByteArrayHelper.toString(this.pwVerificationBytes) + \"/ \" + ByteArrayHelper.toString(pwVerification));\n        }\n\n        cipherParameters = new KeyParameter(cryptoKeyBytes);\n\n        // checksum added to the end of the encrypted data, update on each encryption call\n\n        if (this.verify) {\n            this.mac = new HMac( new SHA1Digest() );\n            this.mac.init( new KeyParameter(authenticationCodeBytes) );\n        }\n\n        this.aesCipher = new SICZIPBlockCipher(new AESFastEngine());\n        this.blockSize = aesCipher.getBlockSize();\n\n        // incremented on each 16 byte block and used as encryption NONCE (ivBytes)\n\n        // warning: non-CTR; little endian IV and starting with 1 instead of 0\n\n        nonce = 1;\n\n        byte[] ivBytes = ByteArrayHelper.toByteArray( nonce, 16 );\n\n        ParametersWithIV ivParams = new ParametersWithIV(cipherParameters, ivBytes);\n        aesCipher.init( false, ivParams );\n    }\n\n    // --------------------------------------------------------------------------\n\n    protected CipherParameters cipherParameters;\n\n    protected SICZIPBlockCipher aesCipher;\n\n    protected HMac mac;\n\n\n    @Override\n    public void decrypt(byte[] in, int length) {\n        if (verify) {\n            mac.update(in, 0, length);\n        }\n        aesCipher.processBytes(in, 0, length, in, 0);\n    }\n\n    public byte[] getFinalAuthentication() {\n        if (!verify) {\n            return null;\n        }\n        byte[] macBytes = new byte[ mac.getMacSize() ];\n        mac.doFinal( macBytes, 0 );\n        byte[] macBytes10 = new byte[10];\n        System.arraycopy( macBytes, 0, macBytes10, 0, 10 );\n        return macBytes10;\n    }\n}\n", "/**\n * Implements the Segmented Integer Counter (SIC) mode on top of a simple\n * block cipher. This mode is also known as CTR mode. This CTR mode\n * was altered to comply with the ZIP little endian counter and\n * different starting point.\n */\npublic class SICZIPBlockCipher\n    extends StreamBlockCipher\n    implements SkippingStreamCipher\n{\n    private final BlockCipher     cipher;\n    private final int             blockSize;\n\n    private byte[]          IV;\n    private byte[]          counter;\n    private byte[]          counterOut;\n    private int             byteCount;\n\n    /**\n     * Basic constructor.\n     *\n     * @param c the block cipher to be used.\n     */\n    public SICZIPBlockCipher(BlockCipher c)\n    {\n        super(c);\n\n        this.cipher = c;\n        this.blockSize = cipher.getBlockSize();\n        this.IV = new byte[blockSize];\n        this.counter = new byte[blockSize];\n        this.counterOut = new byte[blockSize];\n        this.byteCount = 0;\n    }\n\n    public void init(\n        boolean             forEncryption, //ignored by this CTR mode\n        CipherParameters    params)\n        throws IllegalArgumentException\n    {\n        if (params instanceof ParametersWithIV)\n        {\n            ParametersWithIV ivParam = (ParametersWithIV)params;\n            byte[] iv = ivParam.getIV();\n            System.arraycopy(iv, 0, IV, 0, IV.length);\n\n            // if null it's an IV changed only.\n            if (ivParam.getParameters() != null)\n            {\n                cipher.init(true, ivParam.getParameters());\n            }\n\n            reset();\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"SICZIP mode requires ParametersWithIV\");\n        }\n    }\n\n    public String getAlgorithmName()\n    {\n        return cipher.getAlgorithmName() + \"/SICZIP\";\n    }\n\n    public int getBlockSize()\n    {\n        return cipher.getBlockSize();\n    }\n\n    public int processBlock(byte[] in, int inOff, byte[] out, int outOff)\n          throws DataLengthException, IllegalStateException\n    {\n        processBytes(in, inOff, blockSize, out, outOff);\n\n        return blockSize;\n    }\n\n    protected byte calculateByte(byte in)\n          throws DataLengthException, IllegalStateException\n    {\n        if (byteCount == 0)\n        {\n            cipher.processBlock(counter, 0, counterOut, 0);\n\n            return (byte)(counterOut[byteCount++] ^ in);\n        }\n\n        byte rv = (byte)(counterOut[byteCount++] ^ in);\n\n        if (byteCount == counter.length)\n        {\n            byteCount = 0;\n\n            incrementCounter();\n        }\n\n        return rv;\n    }\n\n    private void incrementCounter()\n    {\n        // increment counter by 1.\n        for (int i = 0; i &lt; counter.length &amp;&amp; ++counter[i] == 0; i++)\n        {\n            ; // do nothing - pre-increment and test for 0 in counter does the job.\n        }\n    }\n\n    private void decrementCounter()\n    {\n        // TODO test - owlstead too lazy to test\n\n        if (counter[counter.length - 1] == 0)\n        {\n            boolean nonZero = false;\n\n            for (int i = 0; i &lt; counter.length; i++)\n            {\n                if (counter[i] != 0)\n                {\n                    nonZero = true;\n                }\n            }\n\n            if (!nonZero)\n            {\n                throw new IllegalStateException(\"attempt to reduce counter past zero.\");\n            }\n        }\n\n        // decrement counter by 1.\n        for (int i = 0; i &lt; counter.length &amp;&amp; --counter[i] == -1; i++)\n        {\n            ;\n        }\n    }\n\n    private void adjustCounter(long n)\n    {\n        if (n &gt;= 0)\n        {\n            long numBlocks = (n + byteCount) / blockSize;\n\n            for (long i = 0; i != numBlocks; i++)\n            {\n                incrementCounter();\n            }\n\n            byteCount = (int)((n + byteCount) - (blockSize * numBlocks));\n        }\n        else\n        {\n            long numBlocks = (-n - byteCount) / blockSize;\n\n            for (long i = 0; i != numBlocks; i++)\n            {\n                decrementCounter();\n            }\n\n            int gap = (int)(byteCount + n + (blockSize * numBlocks));\n\n            if (gap &gt;= 0)\n            {\n                byteCount = 0;\n            }\n            else\n            {\n                decrementCounter();\n                byteCount =  blockSize + gap;\n            }\n        }\n    }\n\n    public void reset()\n    {\n        System.arraycopy(IV, 0, counter, 0, counter.length);\n        cipher.reset();\n        this.byteCount = 0;\n    }\n\n    public long skip(long numberOfBytes)\n    {\n        adjustCounter(numberOfBytes);\n\n        cipher.processBlock(counter, 0, counterOut, 0);\n\n        return numberOfBytes;\n    }\n\n    public long seekTo(long position)\n    {\n        reset();\n\n        return skip(position);\n    }\n\n    public long getPosition()\n    {\n        byte[] res = new byte[IV.length];\n\n        System.arraycopy(counter, 0, res, 0, res.length);\n\n        for (int i = 0; i &lt; res.length; i++)\n        {\n            int v = (res[i] - IV[i]);\n\n            if (v &lt; 0)\n            {\n               res[i + 1]--;\n               v += 256;\n            }\n\n            res[i] = (byte)v;\n        }\n\n        // TODO still broken - owlstead too lazy to fix for zip\n        return Pack.bigEndianToLong(res, res.length - 8) * blockSize + byteCount;\n    }\n}\n", "X509TrustManager manager = null;\nFileInputStream fs = null;\n\nTrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\nKeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n\ntry\n{\n    fs = new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")); \n    keyStore.load(fs, null);\n}\nfinally\n{\n    if (fs != null) { fs.close(); }\n}\n\ntrustManagerFactory.init(keyStore);\nTrustManager[] managers = trustManagerFactory.getTrustManagers();\n\nfor (TrustManager tm : managers)\n{\n    if (tm instanceof X509TrustManager) \n    {\n        manager = (X509TrustManager) tm;\n        break;\n    }\n}\n", "private static final String apiKey = \"4545ggg454hfnf7557kfdkgg454\"; \nprivate static final String apiUser = \"AndroidUser\"; \nString strhash=\"\";\nlong unixTimeStamp = System.currentTimeMillis() / 1000L;\n\nString newFeedRequest = \"1.0/evoStructure?timestamp=\" + unixTimeStamp;\nString fixturesFeedURL = \"https://secure.TestSite.com/_services/api/\" + newFeedRequest;\n\npublic void hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{\n\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(fixturesFeedURL.getBytes(\"UTF-8\"));\n    byte[] digest = md.digest();\n    strhash = new String(digest);\n\n}   \n\n\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    // TODO Auto-generated method stub\n    super.onCreate(savedInstanceState);\n\nsetContentView(R.layout.chooseact);\n\n\n Log.v(\"myApp\", fixturesFeedURL);\n Log.v(\"myApp\", strhash);\n\n}}\n", "MessageDigest md = MessageDigest.getInstance(\"MD5\");\nbyte[] b = md.digest(input.getBytes());\nStringBuffer output = new StringBuffer();\nfor (int i = 0; i &lt; b.length; i++) {\n  String tmpStr = \"0\" + Integer.toHexString((0xff &amp; b[i]));\n  output.append(tmpStr.substring(tmpStr.length() - 2));\n}\nreturn output.toString();\n", "public static String Encrypt(String text, String key)\n    {\n        String Encoded = \"\";\n        try {\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            byte[] keyBytes = new byte[16];\n            byte[] b = key.getBytes(\"UTF-8\");\n            int len = b.length;\n            if (len &gt; keyBytes.length)\n            {\n                len = keyBytes.length;\n            }\n            System.arraycopy(b, 0, keyBytes, 0, len);\n            SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n            //IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n            final byte[] iv = new byte[16];\n            Arrays.fill(iv, (byte) 0x00);\n            IvParameterSpec ivSpec = new IvParameterSpec(iv);\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec,ivSpec);\n            byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));\n            Encoded = Base64.encodeToString(results,Base64.URL_SAFE);\n\n        } catch (NoSuchAlgorithmException e) {\n            Log.v(TAG, e.getMessage());\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            Log.v(TAG, e.getMessage());\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            Log.v(TAG, e.getMessage());\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            Log.v(TAG, e.getMessage());\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            Log.v(TAG, e.getMessage());\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            Log.v(TAG, e.getMessage());\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            Log.v(TAG, e.getMessage());\n            e.printStackTrace();\n        }\n        return Encoded;\n    }\n", "private void keyHashGenerate() {\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                getPackageName(), PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            UsefullData.Log(\"KeyHash: \"\n                    + Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n}\n", "  import java.io.BufferedReader;\n import java.io.File;\n     import java.io.FileInputStream;\n     import java.io.FileOutputStream;\n     import java.io.FilterWriter;\n     import java.io.InputStream;\n     import java.io.InputStreamReader;\n\n     import javax.crypto.Cipher;\n     import javax.crypto.CipherInputStream;\n     import javax.crypto.KeyGenerator;\n     import javax.crypto.SecretKey;\n\n import android.os.Bundle;\n import android.app.Activity;\n import android.view.Menu;\n import android.view.View;\n import android.view.View.OnClickListener;\n import android.widget.Button;\n import android.widget.EditText;\n import org.apache.commons.codec.binary.Base64;\n\n  public class EncryptionTest1 extends Activity {\nEditText output, outputDecrypt;\nEditText input;\nString plainData = \"\";\nString cipherText, decryptedText;\nKeyGenerator keyGen;\nSecretKey secretKey;\n\nCipher aesCipher;\nFileOutputStream fos;\n\nbyte[] byteDataToEncrypt, byteCipherText, byteDecryptedText;\nbyte[] xmlStream;\n\n@Override\n   protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_encryption_test1);\n    input = (EditText) findViewById(R.id.text_inputText1);\n    output = (EditText) findViewById(R.id.text_Result1);\n    outputDecrypt = (EditText) findViewById(R.id.text_decrypt_Result1);\n\n    Button btn_encrypt = (Button) findViewById(R.id.btn_encrpyt1);\n\n    btn_encrypt.setOnClickListener(new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n\n            try {\n                plainData = input.getText().toString();\n                System.out.println(\"input==&gt;&gt;\" + plainData);\n                byte[] fileStreams = fileOpening(\"SaleReport.xml\");\n                byte[] DataEncrypt = encrypt(fileStreams);\n                String DataDecrypt = decrypt(DataEncrypt);\n\n            System.out.println(\"Decrypted Text:===&gt;&gt;\" + DataDecrypt);\n                outputDecrypt.setText(DataDecrypt);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n    });\n  }\n\nprivate byte[] fileOpening(String fileName) throws Exception {\n    InputStream is = getAssets().open(fileName);\n    int size = is.available();\n    xmlStream = new byte[size];\n    is.read(xmlStream);\n    System.out.println(\"xmlstream length==&gt;&gt;\" + xmlStream.length);\n    return xmlStream;\n}\n\nprivate byte[] encrypt(byte[] xmlStream) throws Exception {\n\n    keyGen = KeyGenerator.getInstance(\"AES\");\n    keyGen.init(128);\n    secretKey = keyGen.generateKey();\n    aesCipher = Cipher.getInstance(\"AES\");\n    aesCipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    // byteDataToEncrypt = plainData.getBytes();\n\n    byteCipherText = aesCipher.doFinal(xmlStream);\n    cipherText = new String(new Base64().encodeBase64(byteCipherText));\n    output.setText(cipherText);\n    System.out.println(cipherText);\n\n    return byteCipherText;\n\n}\n\npublic String decrypt(byte[] DataEncrypt) throws Exception {\n    aesCipher.init(Cipher.DECRYPT_MODE, secretKey,\n    aesCipher.getParameters());\n    byteDecryptedText = aesCipher.doFinal(DataEncrypt);\n    decryptedText = new String(byteDecryptedText);\n    return decryptedText;\n  }\n\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n    // Inflate the menu; this adds items to the action bar if it is present.\n    getMenuInflater().inflate(R.menu.encryption_test1, menu);\n    return true;\n}\n\n   }\n", "try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"Your Package Name\",\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.i(\"KeyHash:\",\n                    \"KeyHash: \"\n                            + Base64.encodeToString(md.digest(),\n                                    Base64.DEFAULT));\n\n        }\n    } catch (NameNotFoundException e) {\n        Log.i(\"KeyHash !!!!!!!:\", e.getMessage());\n\n    } catch (NoSuchAlgorithmException e) {\n        Log.i(\"KeyHash $$$$$$$:\", e.getMessage());\n    }\n", "public static String getKeyHash(Context context, String packageName) {\ntry {\n    PackageInfo info = context.getPackageManager().getPackageInfo(\n            packageName,\n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String keyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n        return keyHash;\n    }\n} catch (PackageManager.NameNotFoundException e) {\n    return null;\n} catch (NoSuchAlgorithmException e) {\n    return null;\n}\nreturn null;\n", "import java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport android.app.Activity;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.Signature;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class MainActivity extends Activity {\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n\n            PackageManager pm = this.getPackageManager();\n            String packageName = this.getPackageName();\n            int flags = PackageManager.GET_SIGNATURES;\n\n            PackageInfo packageInfo = null;\n\n            try {\n                    packageInfo = pm.getPackageInfo(packageName, flags);\n            } catch (NameNotFoundException e) {\n                    e.printStackTrace();\n            }\n            Signature[] signatures = packageInfo.signatures;\n\n            byte[] cert = signatures[0].toByteArray();\n\n            InputStream input = new ByteArrayInputStream(cert);\n\n            CertificateFactory cf = null;\n            try {\n                    cf = CertificateFactory.getInstance(\"X509\");\n\n\n            } catch (CertificateException e) {\n                    e.printStackTrace();\n            }\n            X509Certificate c = null;\n            try {\n                    c = (X509Certificate) cf.generateCertificate(input);\n            } catch (CertificateException e) {\n                    e.printStackTrace();\n            }\n\n\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n                byte[] publicKey = md.digest(c.getPublicKey().getEncoded());\n\n\n                StringBuffer hexString = new StringBuffer();\n                for (int i=0;i&lt;publicKey.length;i++) {\n                    String appendString = Integer.toHexString(0xFF &amp; publicKey[i]);\n                    if(appendString.length()==1)hexString.append(\"0\");\n                    hexString.append(appendString);\n                    }\n\n\n                Log.d(\"Example\", \"Cer: \"+ hexString.toString());\n\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n            } \n\n    }\n}\n", "KeyFactory fact1 = KeyFactory.getInstance(\"RSA\",\"SC\");\nPublicKey pubKey = fact1.generatePublic(keySpec);\nPrivateKey privateKey = fact1.generatePrivate(new RSAPrivateKeySpec(priv\n    .getModulus(), priv.getPrivateExponent()));\n", "public static String printKeyHash(Activity context) {\n        PackageInfo packageInfo;\n        String key = null;\n        try {\n            //getting application package name, as defined in manifest\n            String packageName = context.getApplicationContext().getPackageName();\n\n            //Retriving package info\n            packageInfo = context.getPackageManager().getPackageInfo(packageName,\n                    PackageManager.GET_SIGNATURES);\n\n            Log.e(\"Package Name=\", context.getApplicationContext().getPackageName());\n\n            for (Signature signature : packageInfo.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                key = new String(Base64.encode(md.digest(), 0));\n\n                // String key = new String(Base64.encodeBytes(md.digest()));\n                Log.e(\"Key Hash=\", key);\n            }\n        } catch (PackageManager.NameNotFoundException e1) {\n            Log.e(\"Name not found\", e1.toString());\n        }\n        catch (NoSuchAlgorithmException e) {\n            Log.e(\"No such an algorithm\", e.toString());\n        } catch (Exception e) {\n            Log.e(\"Exception\", e.toString());\n        }\n\n        return key;\n    }\n", "private void addNewObject(String fiQty, String fiUnWeight, String fiTotWeight, String lotBin) {\n\n    try {\n        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();\n\n        // root elements\n        Document doc = docBuilder.newDocument();\n        Element rootElement = doc.createElement(\"root\");\n        doc.appendChild(rootElement);\n\n        // elements\n        Element obj = doc.createElement(\"object\");\n        rootElement.appendChild(obj);\n\n        Element fiQtyE = doc.createElement(\"fiQty\");\n        fiQtyE.appendChild(doc.createTextNode(fiQty));\n        obj.appendChild(fiQtyE);\n        //  elements\n        Element fiUnWeightE = doc.createElement(\"fiUnWeight\");\n        fiUnWeightE.appendChild(doc.createTextNode(fiUnWeight));\n        obj.appendChild(fiUnWeightE);\n\n        Element fiTotWeightE = doc.createElement(\"fiTotWeight\");\n        fiTotWeightE.appendChild(doc.createTextNode(fiTotWeight));\n        obj.appendChild(fiTotWeightE);\n\n        //  elements\n        Element lotBinE = doc.createElement(\"lotBin\");\n        lotBinE.appendChild(doc.createTextNode(lotBin));\n        obj.appendChild(lotBinE);\n\n        // write the content into xml file\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = transformerFactory.newTransformer();\n        DOMSource source = new DOMSource(doc);\n\n        StreamResult result = new StreamResult(new File(Config.FILE_NAME));//your dir file\n\n        // Output to console for testing\n        // StreamResult result = new StreamResult(System.out);\n        transformer.transform(source, result);\n\n        System.out.println(\"File saved!\");\n\n    } catch (ParserConfigurationException pce) {\n        pce.printStackTrace();\n    } catch (TransformerException tfe) {\n        tfe.printStackTrace();\n    }\n\n}\n", " public void generateHashkey() {\n        try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    \"com.integration\",\n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n\n                Log.i(\"Info\", info.packageName + \"\\n\" + Base64.encodeToString(md.digest(),\n                        Base64.NO_WRAP));\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            Log.d(TAG, e.getMessage(), e);\n        } catch (NoSuchAlgorithmException e) {\n            Log.d(TAG, e.getMessage(), e);\n        }\n    }\n", "try {\n    Cipher en = Cipher.getInstance(\"AES/ECB/NOPADDING\");\n    //use the cipher\n    //...\n} catch (NoSuchAlgorithmException e) {\n    //handle exception\n    // ex: e.printStackTrace(); System.exit(1);\n} catch (NoSuchPaddingException e) {\n    //handle exception\n} finally {\n    //optional, use this block if necessary\n}\n", "            boolean validated = false;\n            byte[] Resp = AndAppStorePurchaseChecking(\"test@andappstore.com\",\"98765\", \"543788\");\n            if(isValidPurchase(Resp))\n                validated = true;\n\n\n       private byte[] AndAppStorePurchaseChecking(String u, String d, String a) {\n\n            final HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, \"UTF-8\");\n            final SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\",PlainSocketFactory.getSocketFactory(), 80));\n            final ThreadSafeClientConnManager manager = new ThreadSafeClientConnManager(params, registry);\n            HttpClient httpClient = new DefaultHttpClient(manager, params);\n\n           byte[] buffer = null; \n           final Uri.Builder uri = new Uri.Builder();\n            uri.path(\"/AndroidApplications/purchaseCheck\");\n\n            uri.appendQueryParameter(\"u\", u);\n            uri.appendQueryParameter(\"d\", d);\n            uri.appendQueryParameter(\"a\", a);                               \n\n            HttpEntity entity = null;\n            HttpHost host = new HttpHost(\"andappstore.com\", 80, \"http\");\n            try {\n                final HttpResponse response = httpClient.execute(host, new HttpPost(uri.build().toString()));\n                if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    entity = response.getEntity();\n                    final InputStream in = entity.getContent();\n                    //FileOutputStream fos = openFileOutput(\"AndLicense.001\", MODE_PRIVATE);\n                    try {\n                        buffer = new byte[20];\n                        in.read(buffer);\n//                      int len;\n//                      while((len = in.read(buffer)) &gt; 0 ) {\n//                          fos.write(buffer, 0, len);\n//                      }\n                    } finally {\n                        //fos.close();\n                    }\n                }               \n            } catch (Exception ex) {\n                new AlertDialog.Builder(this)\n                    .setIcon(android.R.drawable.ic_dialog_alert)\n                    .setTitle(\"Error validating installation\")\n                    .setMessage(ex.getMessage())\n                    .setPositiveButton(\"OK\", null)\n                    .show(); \n            } finally {\n                if (entity != null) {\n                    try {\n                        entity.consumeContent(); \n                    } catch(IOException ioe) {\n                        // Ignore errors during consumption, there is \n                        // no possible corrective action.\n                    }\n                }\n            }  \n            return buffer;\n        }   \n\n\n    public boolean isValidPurchase(final byte[] fromServer) {           \n          if( fromServer == null || fromServer.length == 0 ) \n            return false;\n\n          try{\n              MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n              byte[] digest = md.digest(\"98765PURCHASING-API-KEY\".getBytes(\"UTF-8\"));\n              return Arrays.equals(fromServer, digest);\n          } catch(Exception ex) {\n              return false;\n          }\n        }   \n", "    private SSLSocketFactory getSSLSocketFactory_KeyStore(String keyStoreType, int keystoreResId, String keyPassword)\n            throws CertificateException, KeyStoreException, IOException, NoSuchAlgorithmException, KeyManagementException {\n\n        InputStream caInput = getResources().openRawResource(keystoreResId);\n\n        // creating a KeyStore containing trusted CAs\n\n        if (keyStoreType == null || keyStoreType.length() == 0) {\n            keyStoreType = KeyStore.getDefaultType();\n        }\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n\n        keyStore.load(caInput, keyPassword.toCharArray());\n\n        // creating a TrustManager that trusts the CAs in the KeyStore\n\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n\n        TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, wrappedTrustManagers, null);\n\n        return sslContext.getSocketFactory();\n    }\n", "protected String encrypt( String value ) {\n\n    try {\n        final byte[] bytes = value!=null ? value.getBytes(UTF8) : new byte[0];\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));\n        return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP),UTF8);\n\n    } catch( Exception e ) {\n        throw new RuntimeException(e);\n    }\n\n}\n\nprotected String decrypt(String value){\n    try {\n        final byte[] bytes = value!=null ? Base64.decode(value,Base64.DEFAULT) : new byte[0];\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));\n        return new String(pbeCipher.doFinal(bytes),UTF8);\n\n    } catch( Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "private static byte[] decryptPBKDF2WithBC(char[] password, byte[] data, byte[] salt, byte[] iv)\n  throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException,\n  InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n\n   PBEParametersGenerator generator = new PKCS5S2ParametersGenerator();\n   generator.init(PBEParametersGenerator.PKCS5PasswordToUTF8Bytes(password), salt,CryptographicToolBox.CRYPTO_ITERATIONS);\n   KeyParameter params = (KeyParameter)generator.generateDerivedParameters(CryptographicToolBox.KEY_SIZE);\n\n   byte[] endcoded = params.getKey();\n   SecretKey key = new SecretKeySpec(endcoded, \"AES\");\n\n   Cipher ciph = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n   ciph.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv);\n   return ciph.doFinal(data);\n}\n", "public static String printKeyHash(Activity context) {\n    PackageInfo packageInfo;\n    String key = null;\n    try {\n        //getting application package name, as defined in manifest\n        String packageName = context.getApplicationContext().getPackageName();\n\n        //Retriving package info\n        packageInfo = context.getPackageManager().getPackageInfo(packageName,\n                PackageManager.GET_SIGNATURES);\n\n        Log.e(\"Package Name=\", context.getApplicationContext().getPackageName());\n\n        for (Signature signature : packageInfo.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            key = new String(Base64.encode(md.digest(), 0));\n\n            // String key = new String(Base64.encodeBytes(md.digest()));\n            Log.e(\"Key Hash=\", key);\n        }\n    } catch (NameNotFoundException e1) {\n        Log.e(\"Name not found\", e1.toString());\n    }\n    catch (NoSuchAlgorithmException e) {\n        Log.e(\"No such an algorithm\", e.toString());\n    } catch (Exception e) {\n        Log.e(\"Exception\", e.toString());\n    }\n\n    return key;\n}\n", "public class StringCryptor \n{\n    private static final String CIPHER_ALGORITHM = \"AES\";\n    private static final String RANDOM_GENERATOR_ALGORITHM = \"SHA1PRNG\";\n    private static final int RANDOM_KEY_SIZE = 128;\n\n    // Encrypts string and encode in Base64\n    public static String encrypt( String password, String data ) throws Exception \n    {\n        byte[] secretKey = generateKey( password.getBytes() );\n        byte[] clear = data.getBytes();\n\n        SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );\n        Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );\n        cipher.init( Cipher.ENCRYPT_MODE, secretKeySpec );\n\n        byte[] encrypted = cipher.doFinal( clear );\n        String encryptedString = Base64.encodeToString( encrypted, Base64.DEFAULT );\n\n        return encryptedString;\n    }\n\n    // Decrypts string encoded in Base64\n    public static String decrypt( String password, String encryptedData ) throws Exception \n    {\n        byte[] secretKey = generateKey( password.getBytes() );\n\n        SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );\n        Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );\n        cipher.init( Cipher.DECRYPT_MODE, secretKeySpec );\n\n        byte[] encrypted = Base64.decode( encryptedData, Base64.DEFAULT );\n        byte[] decrypted = cipher.doFinal( encrypted );\n\n        return new String( decrypted );\n    }\n\n    public static byte[] generateKey( byte[] seed ) throws Exception\n    {\n        KeyGenerator keyGenerator = KeyGenerator.getInstance( CIPHER_ALGORITHM );\n        SecureRandom secureRandom = SecureRandom.getInstance( RANDOM_GENERATOR_ALGORITHM );\n        secureRandom.setSeed( seed );\n        keyGenerator.init( RANDOM_KEY_SIZE, secureRandom );\n        SecretKey secretKey = keyGenerator.generateKey();\n        return secretKey.getEncoded();\n    }\n}\n", "public class CipherUtils {\n    public static byte[] getKey(String password, byte[] salt) {\n        try {\n            byte[] passwordSalt = EncodingUtils.getAsciiBytes(password);\n            passwordSalt = concatenateByteArrays(passwordSalt, salt);\n\n            byte[] hash1 = getHashForHash(null, passwordSalt);\n            byte[] hash2 = getHashForHash(hash1, passwordSalt);\n            byte[] key = concatenateByteArrays(hash1, hash2);\n\n            return key;\n        } catch (Exception e) {\n            return null;\n        }\n\n    }\n\n    public static byte[] getIV(String password, byte[] salt) {\n        try {\n            byte[] passwordSalt = EncodingUtils.getAsciiBytes(password);\n            passwordSalt = concatenateByteArrays(passwordSalt, salt);\n            byte[] hash1 = getHashForHash(null, passwordSalt);\n            byte[] hash2 = getHashForHash(hash1, passwordSalt);\n            byte[] hash3 = getHashForHash(hash2, passwordSalt);\n            return hash3;\n        } catch (Exception e) {\n            return null;\n        }\n\n    }\n\n    private static byte[] getHashForHash(byte[] hash, byte[] passwordSalt) {\n        try {\n            byte[] hashMaterial = concatenateByteArrays(hash, passwordSalt);\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            return md.digest(hashMaterial);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private static byte[] concatenateByteArrays(byte[] a, byte[] b) {\n        if (a == null)\n            return b;\n        if (b == null)\n            return a;\n        byte[] result = new byte[a.length + b.length];\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n    }\n}\n", "byte[] key = CipherUtils.getKey(password, null);\nbyte[] IV = CipherUtils.getIV(password, null);\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"),\n        new IvParameterSpec(IV));\ncis = new CipherInputStream(is, cipher);\n", "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MainClass {\n  public static void main(String[] args) throws Exception {\n    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());    \n    byte[] input = \"www.java2s.com\".getBytes();\n    byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, \n                 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, \n                 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, \n                 0x15, 0x16, 0x17 };\n\n    SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n\n    System.out.println(new String(input));\n\n    // encryption pass\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n\n    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];\n    int ctLength = cipher.update(input, 0, input.length, cipherText, 0);\n    ctLength += cipher.doFinal(cipherText, ctLength);\n    System.out.println(new String(cipherText));\n    System.out.println(ctLength);\n\n    // decryption pass\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    byte[] plainText = new byte[cipher.getOutputSize(ctLength)];\n    int ptLength = cipher.update(cipherText, 0, ctLength, plainText, 0);\n    ptLength += cipher.doFinal(plainText, ptLength);\n    System.out.println(new String(plainText));\n    System.out.println(ptLength);\n  }\n}\n", "private byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n    int offset = 0;\n    byte[] encrypted;\n\n    while(offset &lt; clear.length()) {\n        final byte[] answer = cipher.update(clear, offset, 1024);\n        encrypted = Arrays.copyOf( encrypted, encrypted.length + 1024);\n        System.arrayCopy(answer, 0, encrypted, offset, 1024);\n        offset += 1024;\n    }\n    encrypted += cipher.doFinal(clear, offset, clear.length() - offset);\n    return encrypted;\n}\n", "   public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException\n{\n    Cipher cipher = Cipher.getInstance(cipherTransformation);\n    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n    cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);\n    cipherText = cipher.doFinal(cipherText);\n    return cipherText;\n}\n\npublic byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException\n{\n    Cipher cipher = Cipher.getInstance(cipherTransformation);\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n    plainText = cipher.doFinal(plainText);\n    return plainText;\n}\n", "    try\n    {\n        MessageDigest digester = MessageDigest.getInstance(\"MD5\");\n        digester.update(\"test\".getBytes(\"UTF-8\"));\n        byte[] digest = digester.digest();\n    }\n    catch (Throwable e1)\n    {\n        e1.printStackTrace();\n        // Class available but not functional\n    }\n", "String aid = Settings.Secure.getString(getContext().getContentResolver(), \"android_id\");\n\nObject obj = null;\ntry {\n    ((MessageDigest) (obj = MessageDigest.getInstance(\"MD5\"))).update(\n                                   aid.getBytes(), 0, aid.length());\n\n    obj = String.format(\"%032X\", new Object[] { new BigInteger(1,\n                                   ((MessageDigest) obj).digest()) });\n} catch (NoSuchAlgorithmException localNoSuchAlgorithmException) {\n    obj = aid.substring(0, 32);\n}\nadRequest.addTestDevice(obj.toString());\n", "    PackageInfo packageInfo = null;\n    try {\n        packageInfo = getContext().getPackageManager().getPackageInfo(getContext().getPackageName(), PackageManager.GET_SIGNATURES);\n    } catch (PackageManager.NameNotFoundException e) {\n        e.printStackTrace();\n    }\n    Signature[] signatures = packageInfo.signatures;\n    byte[] cert = signatures[0].toByteArray();\n    InputStream input = new ByteArrayInputStream(cert);\n\n    CertificateFactory cf = null;\n    try {\n        cf = CertificateFactory.getInstance(\"X509\");\n    } catch (CertificateException e) {\n        e.printStackTrace();\n    }\n    X509Certificate c = null;\n    try {\n        c = (X509Certificate) cf.generateCertificate(input);\n    } catch (CertificateException e) {\n        e.printStackTrace();\n    }\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n        byte[] publicKey = md.digest(c.getPublicKey().getEncoded());\n\n        StringBuffer hexString = new StringBuffer();\n        for (int i=0;i&lt;publicKey.length;i++) {\n            String appendString = Integer.toHexString(0xFF &amp; publicKey[i]);\n            if(appendString.length()==1)hexString.append(\"0\");\n            hexString.append(appendString);\n        }\n        Log.d(\"SHA1\", \"Cer: \" + hexString.toString());\n\n    } catch (NoSuchAlgorithmException e1) {\n        e1.printStackTrace();\n    }\n", "public class WriteXMLFile {\n\n    public static void main(String argv[]) {\n\n      try {\n\n        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();\n\n        // root elements\n        Document doc = docBuilder.newDocument();\n        Element rootElement = doc.createElement(\"company\");\n        doc.appendChild(rootElement);\n\n        // staff elements\n        Element staff = doc.createElement(\"Staff\");\n        rootElement.appendChild(staff);\n\n        // set attribute to staff element\n        Attr attr = doc.createAttribute(\"id\");\n        attr.setValue(\"1\");\n        staff.setAttributeNode(attr);\n\n        // shorten way\n        // staff.setAttribute(\"id\", \"1\");\n\n        // firstname elements\n        Element firstname = doc.createElement(\"firstname\");\n        firstname.appendChild(doc.createTextNode(\"yong\"));\n        staff.appendChild(firstname);\n\n        // lastname elements\n        Element lastname = doc.createElement(\"lastname\");\n        lastname.appendChild(doc.createTextNode(\"mook kim\"));\n        staff.appendChild(lastname);\n\n        // nickname elements\n        Element nickname = doc.createElement(\"nickname\");\n        nickname.appendChild(doc.createTextNode(\"mkyong\"));\n        staff.appendChild(nickname);\n\n        // salary elements\n        Element salary = doc.createElement(\"salary\");\n        salary.appendChild(doc.createTextNode(\"100000\"));\n        staff.appendChild(salary);\n\n        // write the content into xml file\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = transformerFactory.newTransformer();\n        DOMSource source = new DOMSource(doc);\n        StreamResult result = new StreamResult(new File(\"C:\\\\file.xml\"));\n\n        // Output to console for testing\n        // StreamResult result = new StreamResult(System.out);\n\n        transformer.transform(source, result);\n\n        System.out.println(\"File saved!\");\n\n      } catch (ParserConfigurationException pce) {\n        pce.printStackTrace();\n      } catch (TransformerException tfe) {\n        tfe.printStackTrace();\n      }\n    }\n}\n", "private static void trustAllHosts()\n{\n    // Create a trust manager that does not validate certificate chains\n    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager()\n    {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers()\n        {\n            return new java.security.cert.X509Certificate[] {};\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException\n        {}\n\n        public void checkServerTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException\n        {}\n    }\n\n    // Install the all-trusting trust manager\n    try\n    {\n        SSLContext sc = SSLContext.getInstance(\"TLS\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection\n        .setDefaultSSLSocketFactory(sc.getSocketFactory());\n    }\n    catch (Exception e)\n    {\n        e.printStackTrace();\n    }\n}\n", "private static class MyTrustManager implements X509TrustManager\n{\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n         throws CertificateException\n    {\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n        throws CertificateException\n    {\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers()\n    {\n        return null;\n    }\n\n}\n\n...\n\nHttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\ntry\n{\n    // Create an SSLContext that uses our TrustManager\n    SSLContext context = SSLContext.getInstance(\"TLS\");\n    TrustManager[] tmlist = {new MyTrustManager()};\n    context.init(null, tmlist, null);\n    conn.setSSLSocketFactory(context.getSocketFactory());\n}\ncatch (NoSuchAlgorithmException e)\n{\n    throw new IOException(e);\n} catch (KeyManagementException e)\n{\n    throw new IOException(e);\n}\nconn.setRequestMethod(\"GET\");\nint rcode = conn.getResponseCode();\n", "public static String encriptSHA1(String password){\n        String hash = \"\";\n\n        try {\n            MessageDigest md;\n            byte[] buffer, digest;\n\n            buffer = password.getBytes();\n            md = MessageDigest.getInstance(\"SHA1\");\n\n            md.update(buffer);\n            digest = md.digest();\n\n            for(byte aux : digest) {\n                int b = aux &amp; 0xff;\n                if (Integer.toHexString(b).length() == 1) hash += \"0\";\n                hash += Integer.toHexString(b);\n            }\n        } catch (NoSuchAlgorithmException e) {\n        }\n\n        return hash;\n    }\n", "\npublic class GMailSender extends javax.mail.Authenticator {\n private String mailhost = \"smtp.gmail.com\";\n private String user;\n private String password;\n private Session session;\n\n static {\n  Security.addProvider(new JSSEProvider());\n }\n\n public GMailSender(String user, String password) {\n  this.user = user;\n  this.password = password;\n\n  Properties props = new Properties();\n  props.setProperty(\"mail.transport.protocol\", \"smtp\");\n  props.setProperty(\"mail.host\", mailhost);\n  props.put(\"mail.smtp.auth\", \"true\");\n  props.put(\"mail.smtp.port\", \"465\");\n  props.put(\"mail.smtp.socketFactory.port\", \"465\");\n  props.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n  props.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n  props.setProperty(\"mail.smtp.quitwait\", \"false\");\n\n  session = Session.getDefaultInstance(props, this);\n }\n\n protected PasswordAuthentication getPasswordAuthentication() {\n  return new PasswordAuthentication(user, password);\n }\n\n public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {\n  MimeMessage message = new MimeMessage(session);\n  DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));\n  message.setSender(new InternetAddress(sender));\n  message.setSubject(subject);\n  message.setDataHandler(handler);\n  if (recipients.indexOf(',') > 0)\n   message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));\n  else\n   message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));\n  Transport.send(message);\n }\n\n public class ByteArrayDataSource implements DataSource {\n  private byte[] data;\n  private String type;\n\n  public ByteArrayDataSource(byte[] data, String type) {\n   super();\n   this.data = data;\n   this.type = type;\n  }\n\n  public ByteArrayDataSource(byte[] data) {\n   super();\n   this.data = data;\n  }\n\n  public void setType(String type) {\n   this.type = type;\n  }\n\n  public String getContentType() {\n   if (type == null)\n    return \"application/octet-stream\";\n   else\n    return type;\n  }\n\n  public InputStream getInputStream() throws IOException {\n   return new ByteArrayInputStream(data);\n  }\n\n  public String getName() {\n   return \"ByteArrayDataSource\";\n  }\n\n  public OutputStream getOutputStream() throws IOException {\n   throw new IOException(\"Not Supported\");\n  }\n }\n}\n", "\n@SuppressWarnings(\"serial\")\npublic final class JSSEProvider extends Provider {\n public JSSEProvider() {\n  super(\"HarmonyJSSE\", 1.0, \"Harmony JSSE Provider\");\n  AccessController.doPrivileged(new java.security.PrivilegedAction() {\n   public Void run() {\n    put(\"SSLContext.TLS\", \"org.apache.harmony.xnet.provider.jsse.SSLContextImpl\");\n    put(\"Alg.Alias.SSLContext.TLSv1\", \"TLS\");\n    put(\"KeyManagerFactory.X509\", \"org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl\");\n    put(\"TrustManagerFactory.X509\", \"org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl\");\n    return null;\n   }\n  });\n }\n}\n</pre>", "KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\nkeyStore.load(getAssets().open(\"test.keystore\"), \"ssltest\".toCharArray());\n\nServerSocketFactory socketFactory = SSLServerSocketFactory.getDefault();\nmServerSocket = (SSLServerSocket) socketFactory.createServerSocket(8080);\n", "final String appPackage = \"com.example\"  // TODO: Add here the package name!!\n\ntry {\n    final PackageManager pm = getPackageManager();\n    final ApplicationInfo ai = pm.getApplicationInfo(appPackage, PackageManager.GET_META_DATA);\n\n    if ( ai != null ) {\n        final PackageInfo pi = pm.getPackageInfo(this.packageName, PackageManager.GET_PERMISSIONS);\n\n        if ( pi != null ) {\n            final Signature[] signatures = pi.signatures;\n\n            if ( (pi.signatures != null) &amp;&amp; (pi.signatures.length &gt; 0) ) {\n                for ( final Signature signature : signatures ) {\n                    if ( signature != null ) {\n                        final InputStream certInputStream = new ByteArrayInputStream(signature.toByteArray());\n                        final CertificateFactory certFactory;\n                        final X509Certificate x509Cert;\n\n                        try {\n                            certFactory = CertificateFactory.getInstance(\"X509\");\n\n                            if ( certFactory != null ) {\n                                x509Cert = (X509Certificate) certFactory.generateCertificate(certInputStream);\n\n                                if ( x509Cert != null ) {\n                                    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n                                    Log.d(TAG, \"Certificate Owner: \" + x509Cert.getSubjectDN().toString());\n                                    Log.d(TAG, \"Certificate Issuer: \" + x509Cert.getIssuerDN().toString());\n                                    Log.d(TAG, \"Certificate Serial Number: \" + x509Cert.getSerialNumber().toString());\n                                    Log.d(TAG, \"Certificate Algorithm: \" + x509Cert.getSigAlgName());\n                                    Log.d(TAG, \"Certificate Version: \" + x509Cert.getVersion());\n                                    Log.d(TAG, \"Certificate OID: \" + x509Cert.getSigAlgOID());\n                                    Log.d(TAG, \"Certificate Valid From: \" + dateFormat.format( x509Cert.getNotBefore() ));\n                                    Log.d(TAG, \"Certificate Valid To: \" + dateFormat.format( x509Cert.getNotAfter() ));\n\n                                    try {\n                                        final MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n                                        md.update( x509Cert.getEncoded() );\n\n                                        Log.d(TAG, \"Certificate SHA-256: \" + getHex(md.digest()));\n                                    }\n                                    catch ( NoSuchAlgorithmException e ) {\n                                        //Debug:\n                                        Log.e(TAG, \"MessageDigest ERROR: \" + e.getMessage() + \"\\n\");\n                                        //e.printStackTrace();\n                                    }\n                                }\n                            }\n                        }\n                        catch ( final CertificateException e ) {\n                            //Debug:\n                            Log.e(TAG, \"CertificateFactory ERROR: \" + e.getMessage() + \"\\n\");\n                            //e.printStackTrace();\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\ncatch ( final PackageManager.NameNotFoundException e ) {\n    //Debug:\n    Log.e(TAG, \"ApplicationInfo ERROR: \" + e.getMessage() + \"\\n\");\n    //e.printStackTrace();\n}\n", "private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\nSecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec);\nbyte[] encrypted = cipher.doFinal(clear);\nreturn encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws   \n Exception   {\nSecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.DECRYPT_MODE, skeySpec);\nbyte[] decrypted = cipher.doFinal(encrypted);\nreturn decrypted;\n}\n", "    Provider[] providers = Security.getProviders();\n    for (Provider p : providers) {\n        Log.d(TAG, \"provider: \" + p.getName());\n        Set&lt;Provider.Service&gt; services = p.getServices();\n        for (Provider.Service s : services) {\n            Log.d(TAG, \"--&gt; algorithm: \" + s.getAlgorithm());\n        }\n    }\n", "//Generate a key\nKeyGenerator KeyGen = KeyGenerator.getInstance(\"AES\");\nKeyGen.init(128);\nSecretKey Key = KeyGen.generateKey();\n\n//Generate init vector\nSecureRandom rng = SecureRandom.getInstance(\"SHA1PRNG\");\nbyte [] IV = new byte[16];\nrng.nextBytes(IV);\n\n//Initialize the encryptor\nCipher ci = Cipher.getInstance(\"AES/CBC/NoPadding\"); //The spec might be different!\nci.init(Cipher.ENCRYPT_MODE, Key, new IvParameterSpec(IV));\n", "/*\nCopyright (C) 2012 Sveinung Kval Bakken, sveinung.bakken@gmail.com\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n */\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.util.Base64;\n\n\npublic class SecurePreferences {\n\n    public static class SecurePreferencesException extends RuntimeException {\n\n        public SecurePreferencesException(Throwable e) {\n            super(e);\n        }\n\n    }\n\n    private static final String TRANSFORMATION = \"AES/CBC/PKCS5Padding\";\n    private static final String KEY_TRANSFORMATION = \"AES/ECB/PKCS5Padding\";\n    private static final String SECRET_KEY_HASH_TRANSFORMATION = \"SHA-256\";\n    private static final String CHARSET = \"UTF-8\";\n\n    private final boolean encryptKeys;\n    private final Cipher writer;\n    private final Cipher reader;\n    private final Cipher keyWriter;\n    private final SharedPreferences preferences;\n\n    /**\n     * This will initialize an instance of the SecurePreferences class\n     * @param context your current context.\n     * @param preferenceName name of preferences file (preferenceName.xml)\n     * @param secureKey the key used for encryption, finding a good key scheme is hard. \n     * Hardcoding your key in the application is bad, but better than plaintext preferences. Having the user enter the key upon application launch is a safe(r) alternative, but annoying to the user.\n     * @param encryptKeys settings this to false will only encrypt the values, \n     * true will encrypt both values and keys. Keys can contain a lot of information about \n     * the plaintext value of the value which can be used to decipher the value.\n     * @throws SecurePreferencesException\n     */\n    public SecurePreferences(Context context, String preferenceName, String secureKey, boolean encryptKeys) throws SecurePreferencesException {\n        try {\n            this.writer = Cipher.getInstance(TRANSFORMATION);\n            this.reader = Cipher.getInstance(TRANSFORMATION);\n            this.keyWriter = Cipher.getInstance(KEY_TRANSFORMATION);\n\n            initCiphers(secureKey);\n\n            this.preferences = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);\n\n            this.encryptKeys = encryptKeys;\n        }\n        catch (GeneralSecurityException e) {\n            throw new SecurePreferencesException(e);\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new SecurePreferencesException(e);\n        }\n    }\n\n    protected void initCiphers(String secureKey) throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException,\n            InvalidAlgorithmParameterException {\n        IvParameterSpec ivSpec = getIv();\n        SecretKeySpec secretKey = getSecretKey(secureKey);\n\n        writer.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n        reader.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);\n        keyWriter.init(Cipher.ENCRYPT_MODE, secretKey);\n    }\n\n    protected IvParameterSpec getIv() {\n        byte[] iv = new byte[writer.getBlockSize()];\n        System.arraycopy(\"fldsjfodasjifudslfjdsaofshaufihadsf\".getBytes(), 0, iv, 0, writer.getBlockSize());\n        return new IvParameterSpec(iv);\n    }\n\n    protected SecretKeySpec getSecretKey(String key) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        byte[] keyBytes = createKeyBytes(key);\n        return new SecretKeySpec(keyBytes, TRANSFORMATION);\n    }\n\n    protected byte[] createKeyBytes(String key) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(SECRET_KEY_HASH_TRANSFORMATION);\n        md.reset();\n        byte[] keyBytes = md.digest(key.getBytes(CHARSET));\n        return keyBytes;\n    }\n\n    public void put(String key, String value) {\n        if (value == null) {\n            preferences.edit().remove(toKey(key)).commit();\n        }\n        else {\n            putValue(toKey(key), value);\n        }\n    }\n\n    public boolean containsKey(String key) {\n        return preferences.contains(toKey(key));\n    }\n\n    public void removeValue(String key) {\n        preferences.edit().remove(toKey(key)).commit();\n    }\n\n    public String getString(String key) throws SecurePreferencesException {\n        if (preferences.contains(toKey(key))) {\n            String securedEncodedValue = preferences.getString(toKey(key), \"\");\n            return decrypt(securedEncodedValue);\n        }\n        return null;\n    }\n\n    public void clear() {\n        preferences.edit().clear().commit();\n    }\n\n    private String toKey(String key) {\n        if (encryptKeys)\n            return encrypt(key, keyWriter);\n        else return key;\n    }\n\n    private void putValue(String key, String value) throws SecurePreferencesException {\n        String secureValueEncoded = encrypt(value, writer);\n\n        preferences.edit().putString(key, secureValueEncoded).commit();\n    }\n\n    protected String encrypt(String value, Cipher writer) throws SecurePreferencesException {\n        byte[] secureValue;\n        try {\n            secureValue = convert(writer, value.getBytes(CHARSET));\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new SecurePreferencesException(e);\n        }\n        String secureValueEncoded = Base64.encodeToString(secureValue, Base64.NO_WRAP);\n        return secureValueEncoded;\n    }\n\n    protected String decrypt(String securedEncodedValue) {\n        byte[] securedValue = Base64.decode(securedEncodedValue, Base64.NO_WRAP);\n        byte[] value = convert(reader, securedValue);\n        try {\n            return new String(value, CHARSET);\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new SecurePreferencesException(e);\n        }\n    }\n\n    private static byte[] convert(Cipher cipher, byte[] bs) throws SecurePreferencesException {\n        try {\n            return cipher.doFinal(bs);\n        }\n        catch (Exception e) {\n            throw new SecurePreferencesException(e);\n        }\n    }\n}\n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(\"YOUR_PACKAGE_NAME\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                }\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n", "enter code here\npublic static void GenerateKeyPair()\n{       \n    try{\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(2048);\n        KeyPair kp = kpg.genKeyPair();\n\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        RSAPublicKeySpec pub = fact.getKeySpec(kp.getPublic(),\n          RSAPublicKeySpec.class);\n        RSAPrivateKeySpec priv = fact.getKeySpec(kp.getPrivate(),\n          RSAPrivateKeySpec.class);\n\n        saveToFile(\"public.key\", pub.getModulus(),\n                  pub.getPublicExponent());\n        saveToFile(\"private.key\", priv.getModulus(),\n                  priv.getPrivateExponent());\n    }catch(Exception e){\n        System.out.println(e.getMessage());\n    }\n}\n\npublic static void saveToFile(String fileName,\n  BigInteger mod, BigInteger exp) throws Exception {\n  ObjectOutputStream oout = new ObjectOutputStream(\n    new BufferedOutputStream(new FileOutputStream(fileName)));\n  try {\n    oout.writeObject(mod);\n    oout.writeObject(exp);\n  } catch (Exception e) {\n    throw new Exception(\"error\", e);\n  } finally {\n    oout.close();\n  }\n}\n", "private void showHashKey()\n{\n    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.kisan.kisan\",\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (PackageManager.NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n\n}\n", "//get keystore \n//jks for type \"JKS\",\n//.p12 or .pfx for type \"PKCS12\"\n//specification name is PKCS#12, but the # is not used in the Java keystore type name\nKeyStore keystore = KeyStore.getInstance(\"pkcs12\");\n//load keystore - is FileImputStream to location of your pfx/jks file          \nkeystore.load(is, password);\n//get private key           \nPrivateKey privateKey = (PrivateKey)keystore.getKey(alias, password);\n", "    InputStream is = new FileInputStream(...); //Input stream\n\n    SecretKeySpec skey = new SecretKeySpec(Hex.decodeHex(key.toCharArray()), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, skey); \n    FileOutputStream fileOuputStream = new FileOutputStream(SD_CARD_PATH+ \"/\" + \"abcd.db\"); \n    CipherOutputStream cos = new CipherOutputStream(fileOuputStream, cipher);\n\n    //Now read from input and write to output using your favorite utilities library\n    //Guava and Apache Commons IO are good examples.\n    FooUtils.copy(is, cos);\n    //Remember to close streams if the previous call didn't (preferably in a finally block)\n", "SSLContext ctx;\n        try {\n            ctx = SSLContext.getInstance(\"TLS\");\n            ctx.init(null, new TrustManager[] {\n                      new X509TrustManager() {\n                        public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n                        public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n                        public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; }\n                      }\n                    }, null);\n            HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (KeyManagementException e) {\n            e.printStackTrace();\n        }\n", "HttpParams params = new BasicHttpParams();\nHttpConnectionParams.setConnectionTimeout(params, 5000);\nHttpConnectionParams.setSoTimeout(params, 30000);\nHostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n\nDefaultHttpClient httpClient = new DefaultHttpClient();\n\nSchemeRegistry registry = new SchemeRegistry();\nSSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();\nsocketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\nregistry.register(new Scheme(\"https\", socketFactory, 443));\nSingleClientConnManager mgr = new SingleClientConnManager(httpClient.getParams(), registry);\nDefaultHttpClient client = new DefaultHttpClient(mgr, httpClient.getParams());\n\n// Set verifier      \nHttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n", "public void setPassCode(String   value) throws Exception { \n\n    try {\n\n        SecretKeySpec sks = null; \n        sks = getEncryptKey();\n\n        byte[] userLatENC=null;\n\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.ENCRYPT_MODE,sks ); \n        userLatENC = c.doFinal(value.getBytes());\n\n        passCode = Base64.encodeToString(userLatENC, Base64.DEFAULT);\n\n    } catch (Exception e) {\n        throw e;\n    }\n}\n", "    try {\n\n        String encVal = \"pass_code\";\n\n        if (encVal.isEmpty()) {\n            return encVal;\n        }\n\n\n        sks = getDecryptKey();\n\n        byte[] latDEC=null;\n\n\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.DECRYPT_MODE, sks);\n\n        latDEC = c.doFinal(Base64.decode(encVal, Base64.DEFAULT));\n\n\n\n\n        return new String(latDEC);\n\n    } catch (Exception e) {\n        throw e;\n    }\n}\n", "    SecretKeySpec sks = null; \n    SecretKey key =null;\n    byte[]  keyToSave;\n\n\n    try {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n\n\n\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(\"any data used as random seed\".getBytes());\n        KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n\n\n        kg.init(128, sr);\n        key= kg.generateKey();\n        keyToSave =key.getEncoded();\n        sks = new SecretKeySpec(keyToSave, \"AES\");\n\n        ks.load(null,null);\n        ks.setKeyEntry(\"aliasKey\",key,null, null);\n\n\n        FileOutputStream ksout = context.openFileOutput(\"keystore_android\", Context.MODE_PRIVATE);\n        ks.store(ksout, null);\n        ksout.close();\n\n        return sks;\n\n    } catch (Exception e) {\n        throw e;\n    }\n}\n", "    SecretKeySpec sks = null;\n\n    try {\n\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        FileInputStream fis = null;\n\n        fis = context.openFileInput(\"keystore_android\");\n\n\n\n        keyStore.load(fis,null);\n        sks=new SecretKeySpec((keyStore.getKey(\"aliasKey\", null)).getEncoded(), \"AES\");\n\n        return sks;\n    } catch (Exception e) {\n        throw e;\n    } \n}\n", "public class ServerThread extends Thread\n{\n    //is the thread running\n    private boolean running = true;\n\n    //ports for the server sockets\n    private final int dataPort;\n    private final int filePort;\n\n    private final String certificateDir;\n    private final char[] password;\n\n    private Vector&lt;ClientHandlerThread&gt; connectedClients = new Vector&lt;ClientHandlerThread&gt;(20, 5);\n    private Properties userProperties = new Properties();\n\n    public ServerThread(int dataPort,\n                        int filePort,\n                        String certificateDir,\n                        char[] password,\n                        Properties userProperties)\n    {\n        this.dataPort = dataPort;\n        this.filePort = filePort;\n        this.certificateDir = certificateDir;\n        this.password = password;\n        this.userProperties = userProperties;\n    }\n\n    public void run()\n    {\n        /*\n         * We need a server socket that can accept traffic. I use one for file traffic and one\n         * for data traffic although one socket could be used.\n         */\n        SSLServerSocket sslDataTraffic = null;\n        SSLServerSocket sslFileTraffic = null;\n        SSLServerSocketFactory sslFac = null;\n\n        /*\n         * Everything in the following block is related to creating a SSL security manager. \n         * If you don't need validated communications you don't have to use SSL. Just normal\n         * sockets.\n         */\n        try\n        {\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(new FileInputStream(certificateDir), password);\n\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            tmf.init(keyStore);\n\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance((KeyManagerFactory.getDefaultAlgorithm()));\n            kmf.init(keyStore, password);\n\n            System.setProperty(\"https.protocols\", \"SSL\");\n            SSLContext ctx = SSLContext.getInstance(\"SSL\");\n            ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n            sslFac = ctx.getServerSocketFactory();\n        }\n        catch(Exception e)\n        {\n            System.out.println(\"FAILED.\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        try\n        {\n            //create data server socket \n            System.out.print(\"Creating data socket......... \");\n            sslDataTraffic = (SSLServerSocket) sslFac.createServerSocket(dataPort);\n            System.out.println(\"DONE. Est. on:\" + dataPort);\n\n            //create file server socket\n            System.out.print(\"Creating file socket......... \");\n            sslFileTraffic = (SSLServerSocket) sslFac.createServerSocket(filePort);\n            System.out.println(\"DONE. Est. on:\" + filePort);\n        }\n        catch (IOException e)\n        {\n            System.out.println(\"FAILED.\");\n            System.out.println(e.toString() + \" ::: \" + e.getCause());\n            System.exit(-1);\n        }\n\n        /*\n         * This block is used to print the ip the server is running on. Easy to incorporate this here\n         * so the information doesn't have to be gathered form another source.\n         */\n        try\n        {\n            System.out.print(\"Finishing.................... \");\n            Socket s = new Socket(\"google.com\", 80);\n            System.out.println(\"DONE.\");\n            System.out.println(\"Server online at: \" + s.getLocalAddress().getHostAddress());\n            System.out.println(\"====================*====================\");\n            s.close();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n\n        /*\n         * This is the block that accepts connections from clients.\n         */\n        try\n        {\n            while (running)\n            {\n                //wait here until a connection is bound to new sockets through the server sockets\n                SSLSocket sslDataTrafficSocketInstance = (SSLSocket) sslDataTraffic.accept();\n                SSLSocket sslFileTrafficSocketInstance = (SSLSocket) sslFileTraffic.accept();\n                //sockets to communicate with the client are created. Lets put them in a thread so \n                //we can continue to accept new clients while we work with the newly and previously\n                //connected clients\n\n                //create a new thread\n                ClientHandlerThread c = new ClientHandlerThread(\n                        sslDataTrafficSocketInstance, \n                        sslFileTrafficSocketInstance, \n                        userProperties);\n                //start thread\n                c.start();\n                //add newly connected client to the list of connected clients\n                connectedClients.add(c);\n            }\n        }\n        catch (IOException e)\n        {\n            System.out.println(\"Fatal server error, terminating server and client handler threads\");\n\n            stopServer();\n        }\n    }\n}\n", "    private void connect()\n    {\n        try\n        {\n            SSLSocketFactory sslFac;\n            SSLSocket dataSocket = null;\n            SSLSocket fileSocket = null;\n\n            /*\n             * This block is nearly identical to the security block for the server side.  \n             */\n            try\n            {\n                KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                keyStore.load(new FileInputStream(certificateDir), password.toCharArray());\n\n                TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                tmf.init(keyStore);\n\n                KeyManagerFactory kmf = KeyManagerFactory.getInstance((KeyManagerFactory.getDefaultAlgorithm()));\n                kmf.init(keyStore, password.toCharArray());\n\n                System.setProperty(\"https.protocols\", \"SSL\");\n                SSLContext ctx = SSLContext.getInstance(\"SSL\");\n                ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n                sslFac = ctx.getSocketFactory();\n\n                String ip = \"&lt;THE SERVER'S IP ADDRESS&gt;\";\n                dataSocket = (SSLSocket) sslFac.createSocket(ip, dataPort);\n                fileSocket = (SSLSocket) sslFac.createSocket(ip, filePort);\n            }\n            catch(Exception e)\n            {\n                System.out.println(\"FAILED.\");\n                e.printStackTrace();\n                System.exit(-1);\n            }\n\n            reader = new BufferedReader(new InputStreamReader(dataSocket.getInputStream()));\n            writer = new PrintWriter(dataSocket.getOutputStream());\n            OutputStream fileOut = fileSocket.getOutputStream();\n\n            writer.println(\"CLIENT_HANDSHAKE_INIT\");\n            writer.flush();\n            }\n     }\n", "public boolean deleteFile(File target)\n{\n    if (System.getSecurityManager() != null)\n    {\n        try\n        {\n            Actions actions = (Actions) m_actions.get();\n            actions.set(Actions.DELETE_FILE_ACTION, target);\n            return ((Boolean) AccessController.doPrivileged(actions, m_acc))\n                .booleanValue();\n        }\n        catch (PrivilegedActionException ex)\n        {\n            throw (RuntimeException) ex.getException();\n        }\n    }\n    else\n    {\n        // Solution: Rename before deleting\n        // http://stackoverflow.com/questions/11539657/open-failed-ebusy-device-or-resource-busy\n\n        File to = new File(target.getAbsolutePath() + System.currentTimeMillis());\n        boolean renameStatus = target.renameTo(to);\n        boolean deleteStatus = to.delete();\n        boolean returnStatus = ( renameStatus &amp;&amp; deleteStatus );\n\n        // Debug SecureAction\n        //boolean returnStatus = target.delete();\n        Log.e ( \"SecureAction\" , \"Deleting \" + target + \" delete(): \" + returnStatus );\n        return returnStatus;\n    }\n}\n", "    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"my.package.name\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(signature.toByteArray());\n            Log.e(\"hash key\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e1) {\n        Log.e(\"name not found\", e1.toString());\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(\"no such an algorithm\", e.toString());\n    } catch (Exception e) {\n        Log.e(\"exception\", e.toString());\n    }\n", "public static String decrypt(byte[] keyValue, String ivValue, String encryptedData) throws Exception {\n    Key key = new SecretKeySpec(keyValue, \"AES\");\n    byte[] iv = Base64.decode(ivValue.getBytes(\"UTF-8\"), Base64.DEFAULT);\n    byte[] decodedValue = Base64.decode(encryptedData.getBytes(\"UTF-8\"), Base64.DEFAULT);\n\n    Cipher c = Cipher.getInstance(\"AES/CBC/PKCS7Padding\"); // or PKCS5Padding\n    c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n    byte[] decValue = c.doFinal(decodedValue);\n\n    int firstQuoteIndex = 0;\n    while(decValue[firstQuoteIndex] != (byte)'\"') firstQuoteIndex++;\n    return new String(Arrays.copyOfRange(decValue, firstQuoteIndex + 1, decValue.length-2));\n}\n", "public static String decrypt(byte[] keyValue, String ivValue, String encryptedData, String macValue) throws Exception {\n    Key key = new SecretKeySpec(keyValue, \"AES\");\n    byte[] iv = Base64.decode(ivValue.getBytes(\"UTF-8\"), Base64.DEFAULT);\n    byte[] decodedValue = Base64.decode(encryptedData.getBytes(\"UTF-8\"), Base64.DEFAULT);\n\n    SecretKeySpec macKey = new SecretKeySpec(keyValue, \"HmacSHA256\");\n    Mac hmacSha256 = Mac.getInstance(\"HmacSHA256\");\n    hmacSha256.init(macKey);\n    hmacSha256.update(ivValue.getBytes(\"UTF-8\"));\n    byte[] calcMac = hmacSha256.doFinal(encryptedData.getBytes(\"UTF-8\"));\n    byte[] mac = Hex.decodeHex(macValue.toCharArray());\n    if (!Arrays.equals(calcMac, mac)) // TODO: use time-constant compare\n        return null; // or throw exception\n\n    Cipher c = Cipher.getInstance(\"AES/CBC/PKCS7Padding\"); // or PKCS5Padding\n    c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n    byte[] decValue = c.doFinal(decodedValue);\n\n    int firstQuoteIndex = 0;\n    while(decValue[firstQuoteIndex] != (byte)'\"') firstQuoteIndex++;\n    return new String(Arrays.copyOfRange(decValue, firstQuoteIndex + 1, decValue.length-2));\n}\n", "private static class CookiePersistingClient extends ApacheClient {\n\n    private static final int HTTPS_PORT = 443;\n    private static final int SOCKET_TIMEOUT = 300000;\n    private static final int CONNECTION_TIMEOUT = 300000;\n\n    public CookiePersistingClient() {\n        super(createDefaultClient());\n    }\n\n    private static HttpClient createDefaultClient() {\n        // Registering https clients.\n        SSLSocketFactory sf = null;\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore\n                    .getDefaultType());\n            trustStore.load(null, null);\n\n            sf = new MySSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        } catch (KeyManagementException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params,\n                CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(params, SOCKET_TIMEOUT);\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"https\", sf, HTTPS_PORT));\n        // More customization (https / timeouts etc) can go here...\n\n        ClientConnectionManager cm = new ThreadSafeClientConnManager(\n                params, registry);\n        DefaultHttpClient client = new DefaultHttpClient(cm, params);\n\n        // Set the default cookie store\n        client.setCookieStore(COOKIE_STORE);\n\n        return client;\n    }\n\n    @Override\n    protected HttpResponse execute(final HttpClient client,\n            final HttpUriRequest request) throws IOException {\n        // Set the http context's cookie storage\n        BasicHttpContext mHttpContext = new BasicHttpContext();\n        mHttpContext.setAttribute(ClientContext.COOKIE_STORE, COOKIE_STORE);\n        return client.execute(request, mHttpContext);\n    }\n\n    @Override\n    public Response execute(final Request request) throws IOException {\n        Response response = super.execute(request);\n        if (response.getStatus() == 401) {\n\n            // Retrofit Callback to handle AccessToken\n            Callback&lt;AccessTockenResponse&gt; accessTokenCallback = new Callback&lt;AccessTockenResponse&gt;() {\n\n                @SuppressWarnings(\"deprecation\")\n                @Override\n                public void success(\n                        AccessTockenResponse loginEntityResponse,\n                        Response response) {\n                    try {\n                        String accessToken =  loginEntityResponse\n                                .getAccessToken();\n                        TypedOutput body = request.getBody();\n                        ByteArrayOutputStream byte1 = new ByteArrayOutputStream();\n                        body.writeTo(byte1);\n                        String s = byte1.toString();\n                        FormUrlEncodedTypedOutput output = new FormUrlEncodedTypedOutput();\n                        String[] pairs = s.split(\"&amp;\");\n                        for (String pair : pairs) {\n                            int idx = pair.indexOf(\"=\");\n                            if (URLDecoder.decode(pair.substring(0, idx))\n                                    .equals(\"access_token\")) {\n                                output.addField(\"access_token\",\n                                        accessToken);\n                            } else {\n                                output.addField(URLDecoder.decode(\n                                        pair.substring(0, idx), \"UTF-8\"),\n                                        URLDecoder.decode(\n                                                pair.substring(idx + 1),\n                                                \"UTF-8\"));\n                            }\n                        }\n                        execute(new Request(request.getMethod(),\n                                request.getUrl(), request.getHeaders(),\n                                output));\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n\n                }\n\n                @Override\n                public void failure(RetrofitError error) {\n                    // Handle Error while refreshing access_token\n                }\n            };\n            // Call Your retrofit method to refresh ACCESS_TOKEN\n            refreshAccessToken(GRANT_REFRESH,CLIENT_ID, CLIENT_SECRET_KEY,accessToken, accessTokenCallback);\n        }\n\n        return response;\n    }\n}\n", "public void setHttpsClient(String password) {\n\n        try {\n            KeyStore mycert = KeyStore.getInstance(\"pkcs12\");\n\n            byte[] pkcs12;\n\n            //Load the PKCS file from database or file.\n            pkcs12 = DataManager.getAuthP12Data();\n            ByteArrayInputStream pkcs12BAIS = new ByteArrayInputStream(pkcs12);\n            mycert.load(pkcs12BAIS, password.toCharArray());\n\n            SSLSocketFactory sockfact = new SSLSocketFactory(mycert, null, null);\n\n             sockfact.setHostnameVerifier(new StrictHostnameVerifier());\n\n            // Done temporarily to accept all hosts\n            //sockfact.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"https\", sockfact, 443));\n\n            BasicHttpParams httpParameters = new BasicHttpParams();\n            HttpProtocolParams.setUseExpectContinue(httpParameters, false);\n            HttpProtocolParams.setVersion(httpParameters, HttpVersion.HTTP_1_1);\n\n            HttpConnectionParams.setConnectionTimeout(httpParameters, _TIMEOUT);\n            HttpConnectionParams.setSoTimeout(httpParameters, _TIMEOUT);\n\n            ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(\n                    httpParameters, registry);\n            cm.closeExpiredConnections();\n            cm.closeIdleConnections(3000, TimeUnit.MILLISECONDS);\n\n            _httpClient = new MyHttpClient(cm, httpParameters);\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n", "private static SecretKey key = generateAESkey();\nprivate static String cipherString = \"AES/CBC/PKCS5Padding\";\n\npublic static void main(String[] args) throws Exception {\n    ByteArrayOutputStream log = new ByteArrayOutputStream();\n    appendToLog(\"Test1\", log);\n    appendToLog(\"Test2 is longer\", log);\n    appendToLog(\"Test3 is multiple of block size!\", log);\n    appendToLog(\"Test4 is shorter.\", log);\n\n    byte[] encLog = log.toByteArray();\n\n    List&lt;String&gt; logs = decryptLog(new ByteArrayInputStream(encLog));\n\n    for(String logLine : logs) {\n        System.out.println(logLine);\n    }\n}\n\nprivate static SecretKey generateAESkey() {\n    try {\n        return KeyGenerator.getInstance(\"AES\").generateKey();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\nprivate static byte[] generateIV() {\n    SecureRandom random = new SecureRandom();\n    byte[] iv = new byte[16];\n    random.nextBytes(iv);\n    return iv;\n}\n\npublic static void appendToLog(String s, OutputStream os) throws Exception {\n    Cipher cipher = Cipher.getInstance(cipherString);\n    byte[] iv = generateIV();\n    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));\n    byte[] data = cipher.doFinal(s.getBytes(\"UTF-8\"));\n    os.write(data.length);\n    os.write(iv);\n    os.write(data);\n}\n\npublic static List&lt;String&gt; decryptLog(InputStream is) throws Exception{\n    ArrayList&lt;String&gt; logs = new ArrayList&lt;String&gt;();\n    while(is.available() &gt; 0) {\n        int len = is.read();\n        byte[] encLogLine = new byte[len];\n        byte[] iv = new byte[16];\n        is.read(iv);\n        is.read(encLogLine);\n\n        Cipher cipher = Cipher.getInstance(cipherString);\n        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n        byte[] data = cipher.doFinal(encLogLine);\n        logs.add(new String(data, \"UTF-8\"));\n    }\n    return logs;\n}\n", "  public static byte[] encrypt(String plainText, String encryptionKey) throws Exception   \n  {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\", \"SunJCE\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(new byte[cipher.getBlockSize()]));\n    return cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n  }\n\n  public static String decrypt(byte[] cipherText, String encryptionKey) throws Exception\n  {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\", \"SunJCE\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(new byte[cipher.getBlockSize()]));\n    return new String(cipher.doFinal(cipherText),\"UTF-8\");\n  }\n", "Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\ncipher.init(Cipher.DECRYPT_MODE, key);\ncipher.update(cipherBytes);\n\n// byte[] plaintext = cipher.doFinal(cipherBytes);\n//                                   ^-- You shouldn't pass cipherBytes twice.\n//                                   v-- instead use the parameter-less method:\nbyte[] plaintext    = cipher.doFinal();\n", " * This method returns the appropriate HttpClient.\n * @param isTLS Whether Transport Layer Security is required.\n * @param trustStoreInputStream The InputStream generated from the BKS keystore.\n * @param trustStorePsw The password related to the keystore.\n * @return The DefaultHttpClient object used to invoke execute(request) method.\nprivate DefaultHttpClient getHttpClient(boolean isTLS, InputStream trustStoreInputStream, String trustStorePsw) \n    throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, KeyManagementException, UnrecoverableKeyException {\n    DefaultHttpClient client = null;        \n    SchemeRegistry schemeRegistry = new SchemeRegistry();\n    Scheme http = new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 8080);\n    schemeRegistry.register(http);\n    if(isTLS) {\n        KeyStore trustKeyStore = null;\n        char[] trustStorePswCharArray = null;\n        if(trustStorePsw!=null) {\n            trustStorePswCharArray = trustStorePsw.toCharArray();\n        } \n        trustKeyStore = KeyStore.getInstance(\"BKS\");\n        trustKeyStore.load(trustStoreInputStream, trustStorePswCharArray);\n        SSLSocketFactory sslSocketFactory = null;\n        sslSocketFactory = new SSLSocketFactory(trustKeyStore);\n        Scheme https = new Scheme(\"https\", sslSocketFactory, 8443);\n        schemeRegistry.register(https);\n    }                \n    HttpParams httpParams = new BasicHttpParams();\n    HttpConnectionParams.setConnectionTimeout(httpParams, CONNECTION_TIMEOUT);\n    HttpConnectionParams.setSoTimeout(httpParams, SOCKET_TIMEOUT);        \n    ClientConnectionManager clientConnectionManager = new ThreadSafeClientConnManager(httpParams, schemeRegistry);        \n    client = new DefaultHttpClient(clientConnectionManager, httpParams);        \n    return client;\n}\n", " * This method set the certificate for the HttpsURLConnection\n * @param url The url to contact.\n * @param certificateInputStream The InputStream generated from the .crt certificate.\n * @param certAlias The alias for the certificate. \n * @return The returned HttpsURLConnection\nprivate HttpsURLConnection getHttpsURLConnection(URL url, InputStream certificateInputStream, String certAlias) \n    throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException, KeyManagementException {\n    HttpsURLConnection connection = null;\n    CertificateFactory certFactory = null;\n    Certificate cert = null;\n    KeyStore keyStore = null;\n    TrustManagerFactory tmFactory = null;\n    SSLContext sslContext = null;\n    // Load certificates from an InputStream\n    certFactory = CertificateFactory.getInstance(\"X.509\");\n    cert = certFactory.generateCertificate(certificateInputStream);\n    certificateInputStream.close();\n    // Create a KeyStore containing the trusted certificates\n    keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n    keyStore.load(null, null);\n    keyStore.setCertificateEntry(certAlias, cert);\n    // Create a TrustManager that trusts the certificates in our KeyStore\n    tmFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    tmFactory.init(keyStore);\n    // Create an SSLContext that uses our TrustManager\n    sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, tmFactory.getTrustManagers(), null);\n    connection = (HttpsURLConnection)url.openConnection();\n    connection.setSSLSocketFactory(sslContext.getSocketFactory());\n    return connection;\n}\n", " @Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main2);\n    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n    setSupportActionBar(toolbar);\n\n\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.example.chirag.maptesting\",\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            Toast.makeText(Main2Activity.this, \"Hash Key :\"+Base64.encodeToString(md.digest(), Base64.DEFAULT), Toast.LENGTH_SHORT).show();\n        }\n    } catch (PackageManager.NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n}\n", "String keyStorePath = \"absolute path to your JKS keystore file\";\nString keyStorePass = \"keystore password\";\n\nSystem.setProperty(\"javax.net.ssl.keyStore\", keyStorePath);\nSystem.setProperty(\"javax.net.ssl.keyStorePassword\", keyStorePass);\n\nSSLServerSocketFactory sslserversocketfactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\nSSLServerSocket serverSocket = (SSLServerSocket) sslserversocketfactory.createServerSocket(port_number);\n\nwhile (true) {\n    new ClientThread((SSLSocket) serverSocket.accept()).start();\n}\n", "private String doFetch(URL url, String postdata, String sk, String token) throws Exception {\n        HttpURLConnection conn = null;\n\n        Proxy proxy = null;\n        String host = null;\n        int port = -1;\n\n        if(Build.VERSION.SDK_INT &lt;11) {\n            Context ctx = IRCCloudApplication.getInstance().getApplicationContext();\n            if(ctx != null) {\n                host = android.net.Proxy.getHost(ctx);\n                port = android.net.Proxy.getPort(ctx);\n            }\n        } else {\n            host = System.getProperty(\"http.proxyHost\", null);\n            try {\n                port = Integer.parseInt(System.getProperty(\"http.proxyPort\", \"8080\"));\n            } catch (NumberFormatException e) {\n                port = -1;\n            }\n        }\n\n        if(host != null &amp;&amp; host.length() &gt; 0 &amp;&amp; !host.equalsIgnoreCase(\"localhost\") &amp;&amp; !host.equalsIgnoreCase(\"127.0.0.1\") &amp;&amp; port &gt; 0) {\n            InetSocketAddress proxyAddr = new InetSocketAddress(host, port);\n            proxy = new Proxy(Proxy.Type.HTTP, proxyAddr);\n        }\n\n        if(host != null &amp;&amp; host.length() &gt; 0 &amp;&amp; !host.equalsIgnoreCase(\"localhost\") &amp;&amp; !host.equalsIgnoreCase(\"127.0.0.1\") &amp;&amp; port &gt; 0) {\n            Crashlytics.log(Log.DEBUG, TAG, \"Requesting: \" + url + \" via proxy: \" + host);\n        } else {\n            Crashlytics.log(Log.DEBUG, TAG, \"Requesting: \" + url);\n        }\n\n        if (url.getProtocol().toLowerCase().equals(\"https\")) {\n            HttpsURLConnection https = (HttpsURLConnection)((proxy != null)?url.openConnection(proxy):url.openConnection(Proxy.NO_PROXY));\n            if(url.getHost().equals(IRCCLOUD_HOST))\n                https.setSSLSocketFactory(IRCCloudSocketFactory);\n            conn = https;\n        } else {\n            conn = (HttpURLConnection)((proxy != null)?url.openConnection(proxy):url.openConnection(Proxy.NO_PROXY));\n        }\n\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.setUseCaches(false);\n        conn.setRequestProperty(\"User-Agent\", useragent);\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        if(sk != null)\n            conn.setRequestProperty(\"Cookie\", \"session=\"+sk);\n        if(token != null)\n            conn.setRequestProperty(\"x-auth-formtoken\", token);\n        if(postdata != null) {\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n            OutputStream ostr = null;\n            try {\n                ostr = conn.getOutputStream();\n                ostr.write(postdata.getBytes());\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (ostr != null)\n                    ostr.close();\n            }\n        }\n        BufferedReader reader = null;\n        String response = \"\";\n\n        try {\n            ConnectivityManager cm = (ConnectivityManager)IRCCloudApplication.getInstance().getSystemService(Context.CONNECTIVITY_SERVICE);\n            NetworkInfo ni = cm.getActiveNetworkInfo();\n            if(ni != null &amp;&amp; ni.getType() == ConnectivityManager.TYPE_WIFI) {\n                Crashlytics.log(Log.DEBUG, TAG, \"Loading via WiFi\");\n            } else {\n                Crashlytics.log(Log.DEBUG, TAG, \"Loading via mobile\");\n            }\n        } catch (Exception e) {\n        }\n\n        try {\n            if(conn.getInputStream() != null) {\n                reader = new BufferedReader(new InputStreamReader(conn.getInputStream()), 512);\n            }\n        } catch (IOException e) {\n            if(conn.getErrorStream() != null) {\n                reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()), 512);\n            }\n        }\n\n        if(reader != null) {\n            response = toString(reader);\n            reader.close();\n        }\n        conn.disconnect();\n        return response;\n    }\n", "CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n    // From https://www.washington.edu/itconnect/security/ca/load-der.crt\n    InputStream is = context.getResources().getAssets().openAsset(\"somefolder/somecertificate.crt\"); // path should be your files path\n    InputStream caInput = new BufferedInputStream(is);\n    Certificate ca;\n    try {\n        ca = cf.generateCertificate(caInput);\n        // System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n    } finally {\n        caInput.close();\n    }\n", "private void AdjustSocket(Socket socket)\n{\n    String[] protocols = ((SSLSocket) socket).getSSLParameters().getProtocols();\n    ArrayList&lt;String&gt; protocolList = new ArrayList&lt;String&gt;(Arrays.asList(protocols));\n\n    for (int ii = protocolList.size() - 1; ii &gt;= 0; --ii )\n        {\n        if ((protocolList.get(ii).contains(\"TLSv1.1\")) || (protocolList.get(ii).contains(\"TLSv1.2\")))\n            protocolList.remove(ii);\n        }\n\n    protocols = protocolList.toArray(new String[protocolList.size()]);\n    ((SSLSocket)socket).setEnabledProtocols(protocols);\n}\n", "public static String dirMD5(String dir)\n{\n    String md5    = \"\";\n    File   folder = new File(dir);\n    File[] files  = folder.listFiles();\n\n    for (int i=0; i&lt;files.length; i++)\n    {\n        md5 = md5 + getMd5OfFile(files[i].toString());\n    }\n    md5 = GetMD5HashOfString(md5);\n    return md5;\n}\n\n\npublic static String getMd5OfFile(String filePath)\n{\n    String returnVal = \"\";\n    try \n    {\n        InputStream   input   = new FileInputStream(filePath); \n        byte[]        buffer  = new byte[1024];\n        MessageDigest md5Hash = MessageDigest.getInstance(\"MD5\");\n        int           numRead = 0;\n        while (numRead != -1)\n        {\n            numRead = input.read(buffer);\n            if (numRead &gt; 0)\n            {\n                md5Hash.update(buffer, 0, numRead);\n            }\n        }\n        input.close();\n\n        byte [] md5Bytes = md5Hash.digest();\n        for (int i=0; i &lt; md5Bytes.length; i++)\n        {\n            returnVal += Integer.toString( ( md5Bytes[i] &amp; 0xff ) + 0x100, 16).substring( 1 );\n        }\n    } \n    catch(Throwable t) {t.printStackTrace();}\n    return returnVal.toUpperCase();\n}\n\npublic static String    GetMD5HashOfString  (String str)\n    {\n        MessageDigest md5 ;        \n        StringBuffer  hexString = new StringBuffer();\n        try\n        {                            \n            md5 = MessageDigest.getInstance(\"md5\");         \n            md5.reset();\n            md5.update(str.getBytes());                       \n            byte messageDigest[] = md5.digest();\n            for (int i = 0; i &lt; messageDigest.length; i++)\n            {\n                hexString.append(Integer.toHexString((0xF0 &amp; messageDigest[i])&gt;&gt;4));\n                hexString.append(Integer.toHexString (0x0F &amp; messageDigest[i]));\n            }\n        } \n        catch (Throwable t) {History.Error(t);}      \n        return hexString.toString();\n    }\n", "public void PrintInstalledCertificates( ){\n\n               try \n                {\n                    KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\n                    if (ks != null) \n                    {\n                        ks.load(null, null);\n                        Enumeration&lt;String&gt; aliases = ks.aliases();\n                        while (aliases.hasMoreElements()) \n                        {\n                            String alias = (String) aliases.nextElement();\n                            java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);\n                                        //To print System Certs only\n                                        if(cert.getIssuerDN().getName().contains(\u00e2\u0080\u009csystem\u00e2\u0080\u009d)){\n                                         System.out.println(cert.getIssuerDN().getName());\n                                        }\n\n                                        //To print User Certs only \n                                        if(cert.getIssuerDN().getName().contains(\u00e2\u0080\u009cuser\u00e2\u0080\u009d)){\n                                         System.out.println(cert.getIssuerDN().getName());\n                                        }\n\n                                        //To print all certs\n                            System.out.println(cert.getIssuerDN().getName());                           \n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchAlgorithmException e) {\n                    e.printStackTrace();\n                } catch (java.security.cert.CertificateException e) {\n                    e.printStackTrace();\n                }               \n\n     }\n", "public class RestModule {\n     private RestAdapter mRestAdapter;\n     private RaasService mRaasService;\n     private String mAccessToken;\n\n     public RestModule(final Context context, final String endPoint)\n     {\n          init(context, endPoint);\n     }\n     public RestModule(final Context context, final String endPoint, final String accessToken) {\n          mAccessToken = accessToken;\n          init(context, endPoint);\n     }\n     public void init(final Context context, final String endPoint) {\n          final MyPreferences preference = MyPreferences.getInstance();\n          final RestAdapter.Builder builder = new RestAdapter.Builder().setLogLevel(RestAdapter.LogLevel.FULL)\n                  .setRequestInterceptor(new RequestInterceptor() {\n                      @Override\n                      public void intercept(RequestFacade requestFacade) {\n                          if (mAccessToken == null) {\n                              mAccessToken = preference.getCurrentAccountAccessToken();\n                          }\n                          requestFacade.addHeader(\"secretToken\", mAccessToken);\n                          requestFacade.addHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n                      }\n                  })\n                  .setEndpoint(endPoint);\n          builder.setClient(new OkClient(getPinnedOkHttpClient(context)));\n          mRestAdapter = builder.build();\n\n     }\n\n     private static OkHttpClient getPinnedOkHttpClient(Context context) {\n          try {\n              final SSLContext sslContext = getSslContext(context);\n              sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n              // Create an ssl socket factory with our all-trusting manager\n              final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n              OkHttpClient okHttpClient = new OkHttpClient();\n              okHttpClient.setSslSocketFactory(sslSocketFactory);\n              okHttpClient.setHostnameVerifier(new HostnameVerifier() {\n                  @Override\n                  public boolean verify(String hostname, SSLSession session) {\n                      return true;\n                  }\n              });\n              okHttpClient.setConnectTimeout(30, TimeUnit.SECONDS);\n              okHttpClient.setReadTimeout(30, TimeUnit.SECONDS);\n              return okHttpClient;\n          } catch (Exception e) {\n              throw new RuntimeException(e);\n          }\n     }\n\n     private SSLContext getSslContext(Context context) throws Exception {\n         KeyStore trustStore = loadTrustStore(context);\n         String algotithmName = TrustManagerFactory.getDefaultAlgorithm();\n         TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(algotithmName);\n         trustManagerFactory.init(trustStore);\n         SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n         sslContext.init(null, trustManagerFactory.getTrustManagers(), null);\n         return sslContext;\n     }\n\n     private KeyStore loadTrustStore(Context context) throws Exception {\n         KeyStore trustStore = KeyStore.getInstance(\"BKS\");\n         InputStream trustStoreStream = context.getResources().getAssets().open(\"trust.bks\");\n         trustStore.load(trustStoreStream, \"password\".toCharArray());\n         return trustStore;\n     }\n\n     public RaasService getService() {\n          if (mRaasService == null) {\n              mRaasService = mRestAdapter.create(RaasService.class);\n          }\n          return mRaasService;\n     }\n}\n", "public class HttpsTrustManager implements X509TrustManager {\n    private static TrustManager[] trustManagers;\n    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};\n\n@Override\npublic void checkClientTrusted(\n        X509Certificate[] x509Certificates, String s)\n        throws java.security.cert.CertificateException {\n}\n\n@Override\npublic void checkServerTrusted(\n        X509Certificate[] x509Certificates, String s)\n        throws java.security.cert.CertificateException {\n}\n\npublic boolean isClientTrusted(X509Certificate[] chain) {\n    return true;\n}\n\npublic boolean isServerTrusted(X509Certificate[] chain) {\n    return true;\n}\n\n@Override\npublic X509Certificate[] getAcceptedIssuers() {\n    return _AcceptedIssuers;\n}\n\npublic static void allowAllSSL() {\n    HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n\n        @Override\n        public boolean verify(String arg0, SSLSession arg1) {\n            return true;\n        }\n\n    });\n\n    SSLContext context = null;\n    if (trustManagers == null) {\n        trustManagers = new TrustManager[]{new HttpsTrustManager()};\n    }\n\n    try {\n        context = SSLContext.getInstance(\"TLS\");\n        context.init(null, trustManagers, new SecureRandom());\n    } catch (NoSuchAlgorithmException | KeyManagementException e) {\n        e.printStackTrace();\n    }\n\n    HttpsURLConnection.setDefaultSSLSocketFactory(context != null ? context.getSocketFactory() : null);\n}\n", "public class TokenEncryptor {\n\n    private final static String TOKEN_KEY = \"fqJfdzGDvfwbedsKSUGty3VZ9taXxMVw\";\n\n    public static String encrypt(String plain) {\n        try {\n            byte[] iv = new byte[16];\n            new SecureRandom().nextBytes(iv);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(TOKEN_KEY.getBytes(\"utf-8\"), \"AES\"), new IvParameterSpec(iv));\n            byte[] cipherText = cipher.doFinal(plain.getBytes(\"utf-8\"));\n            byte[] ivAndCipherText = getCombinedArray(iv, cipherText);\n            return Base64.encodeToString(ivAndCipherText, Base64.NO_WRAP);\n        } catch (Exception e) {\n            Ln.e(e);\n            return null;\n        }\n    }\n\n    public static String decrypt(String encoded) {\n        try {\n            byte[] ivAndCipherText = Base64.decode(encoded, Base64.NO_WRAP);\n            byte[] iv = Arrays.copyOfRange(ivAndCipherText, 0, 16);\n            byte[] cipherText = Arrays.copyOfRange(ivAndCipherText, 16, ivAndCipherText.length);\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(TOKEN_KEY.getBytes(\"utf-8\"), \"AES\"), new IvParameterSpec(iv));\n            return new String(cipher.doFinal(cipherText), \"utf-8\");\n        } catch (Exception e) {\n            Ln.e(e);\n            return null;\n        }\n    }\n\n    private static byte[] getCombinedArray(byte[] one, byte[] two) {\n        byte[] combined = new byte[one.length + two.length];\n        for (int i = 0; i &lt; combined.length; ++i) {\n            combined[i] = i &lt; one.length ? one[i] : two[i - one.length];\n        }\n        return combined;\n    }\n\n}\n", "/**\n * An {@link javax.net.ssl.SSLSocket} that doesn't allow {@code SSLv3} only connections\n * &lt;p&gt;fixes https://github.com/koush/ion/issues/386&lt;/p&gt;\n */\nprivate static class NoSSLv3SSLSocket extends DelegateSSLSocket {\n\nprivate NoSSLv3SSLSocket(SSLSocket delegate) {\n    super(delegate);\n\n    String canonicalName = delegate.getClass().getCanonicalName();\n    if (!canonicalName.equals(\"org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl\")){\n        // try replicate the code from HttpConnection.setupSecureSocket()\n        try {\n            Method msetUseSessionTickets = delegate.getClass().getMethod(\"setUseSessionTickets\", boolean.class);\n            if (null != msetUseSessionTickets) {\n                msetUseSessionTickets.invoke(delegate, true);\n            }\n        } catch (NoSuchMethodException ignored) {\n        } catch (InvocationTargetException ignored) {\n        } catch (IllegalAccessException ignored) {\n        }\n    }\n}\n\n@Override\npublic void setEnabledProtocols(String[] protocols) {\n    if (protocols != null &amp;&amp; protocols.length == 1 &amp;&amp; \"SSLv3\".equals(protocols[0])) {\n        // no way jose\n        // see issue https://code.google.com/p/android/issues/detail?id=78187\n        List&lt;String&gt; enabledProtocols = new ArrayList&lt;String&gt;(Arrays.asList(delegate.getEnabledProtocols()));\n        if (enabledProtocols.size() &gt; 1) {\n            enabledProtocols.remove(\"SSLv3\");\n        } else {\n            LogManager.getLogger().w(\"SSL stuck with protocol available for \" + String.valueOf(enabledProtocols));\n        }\n        protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);\n    }\n    super.setEnabledProtocols(protocols);\n}\n}\n\n\n/**\n * {@link javax.net.ssl.SSLSocketFactory} that doesn't allow {@code SSLv3} only connections\n */\nprivate static class NoSSLv3Factory extends SSLSocketFactory {\nprivate final SSLSocketFactory delegate;\n\nprivate NoSSLv3Factory() {\n    this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();\n}\n\n@Override\npublic String[] getDefaultCipherSuites() {\n    return delegate.getDefaultCipherSuites();\n}\n\n@Override\npublic String[] getSupportedCipherSuites() {\n    return delegate.getSupportedCipherSuites();\n}\n\nprivate static Socket makeSocketSafe(Socket socket) {\n    if (socket instanceof SSLSocket) {\n        socket = new NoSSLv3SSLSocket((SSLSocket) socket);\n    }\n    return socket;\n}\n\n@Override\npublic Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));\n}\n\n@Override\npublic Socket createSocket(String host, int port) throws IOException {\n    return makeSocketSafe(delegate.createSocket(host, port));\n}\n\n@Override\npublic Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));\n}\n\n@Override\npublic Socket createSocket(InetAddress host, int port) throws IOException {\n    return makeSocketSafe(delegate.createSocket(host, port));\n}\n\n@Override\npublic Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));\n}\n}\n\nstatic {\nHttpsURLConnection.setDefaultSSLSocketFactory(new NoSSLv3Factory());\n}\n", "fileinputstrm=new FileInputStream(path);\nBufferedInputStream input=new BufferedInputStream(fileinputstrm);\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nSecretKeyFactory keyFac = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\nPBEKeySpec pbeKeySpec = new PBEKeySpec(\"pass\".toCharArray());          \n\nPBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, 20);\nSecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\nCipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\npbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n\nFileOutputStream output = new FileOutputStream(path + \".icrpt\");\nCipherOutputStream cos = new CipherOutputStream(output, pbeCipher);\n\nByteArrayOutputStream bytes = new ByteArrayOutputStream();\noutput.write(bytes.toByteArray());\ncos.close();\n", "byte[] salt = { (byte) 0xc7, (byte) 0x73, (byte) 0x21, (byte) 0x8c,\n        (byte) 0x7e, (byte) 0xc8, (byte) 0xee, (byte) 0x99 };\nfileinputstrm = new FileInputStream(path);\n\nPBEKeySpec pbeKeySpec = new PBEKeySpec(\"pass\".toCharArray());\n\nPBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, 20);\nSecretKeyFactory keyFac = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\nSecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n\nCipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\npbeCipher.init(Cipher.DECRYPT_MODE, pbeKey, pbeParamSpec);\n\nFileInputStream fis=new FileInputStream(path);\nCipherInputStream cis=new CipherInputStream(fis, pbeCipher);\nBufferedInputStream bfi=new BufferedInputStream(cis);\nbfi.read();\ncis.close();\nFileOutputStream output1 = new FileOutputStream(path+\".jpeg\");\nByteArrayOutputStream baos=new ByteArrayOutputStream();\nBufferedOutputStream bfo=new BufferedOutputStream(output1);\noutput1.write(baos.toByteArray());\n", "/*\n * Copyright 2006 Sun Microsystems, Inc.  All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   - Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *   - Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *\n *   - Neither the name of Sun Microsystems nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n * http://blogs.sun.com/andreas/resource/InstallCert.java\n * Use:\n * java InstallCert hostname\n * Example:\n *% java InstallCert ecc.fedora.redhat.com\n */\n\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.security.KeyStore;\nimport java.security.MessageDigest;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\n/**\n * Class used to add the server's certificate to the KeyStore\n * with your trusted certificates.\n */\npublic class InstallCert {\n\n    public static void main(String[] args) throws Exception {\n    String host;\n    int port;\n    char[] passphrase;\n    if ((args.length == 1) || (args.length == 2)) {\n        String[] c = args[0].split(\":\");\n        host = c[0];\n        port = (c.length == 1) ? 443 : Integer.parseInt(c[1]);\n        String p = (args.length == 1) ? \"changeit\" : args[1];\n        passphrase = p.toCharArray();\n    } else {\n        System.out.println(\"Usage: java InstallCert &lt;host&gt;[:port] [passphrase]\");\n        return;\n    }\n\n    File file = new File(\"jssecacerts\");\n    if (file.isFile() == false) {\n        char SEP = File.separatorChar;\n        File dir = new File(System.getProperty(\"java.home\") + SEP\n                + \"lib\" + SEP + \"security\");\n        file = new File(dir, \"jssecacerts\");\n        if (file.isFile() == false) {\n            file = new File(dir, \"cacerts\");\n        }\n    }\n    System.out.println(\"Loading KeyStore \" + file + \"...\");\n    InputStream in = new FileInputStream(file);\n    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n    ks.load(in, passphrase);\n    in.close();\n\n    SSLContext context = SSLContext.getInstance(\"TLS\");\n    TrustManagerFactory tmf =\n            TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    tmf.init(ks);\n    X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0];\n    SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);\n    context.init(null, new TrustManager[]{tm}, null);\n    SSLSocketFactory factory = context.getSocketFactory();\n\n    System.out.println(\"Opening connection to \" + host + \":\" + port + \"...\");\n    SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n    socket.setSoTimeout(10000);\n    try {\n        System.out.println(\"Starting SSL handshake...\");\n        socket.startHandshake();\n        socket.close();\n        System.out.println();\n        System.out.println(\"No errors, certificate is already trusted\");\n    } catch (SSLException e) {\n        System.out.println();\n        e.printStackTrace(System.out);\n    }\n\n    X509Certificate[] chain = tm.chain;\n    if (chain == null) {\n        System.out.println(\"Could not obtain server certificate chain\");\n        return;\n    }\n\n    BufferedReader reader =\n            new BufferedReader(new InputStreamReader(System.in));\n\n    System.out.println();\n    System.out.println(\"Server sent \" + chain.length + \" certificate(s):\");\n    System.out.println();\n    MessageDigest sha1 = MessageDigest.getInstance(\"SHA1\");\n    MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n    for (int i = 0; i &lt; chain.length; i++) {\n        X509Certificate cert = chain[i];\n        System.out.println\n                (\" \" + (i + 1) + \" Subject \" + cert.getSubjectDN());\n        System.out.println(\"   Issuer  \" + cert.getIssuerDN());\n        sha1.update(cert.getEncoded());\n        System.out.println(\"   sha1    \" + toHexString(sha1.digest()));\n        md5.update(cert.getEncoded());\n        System.out.println(\"   md5     \" + toHexString(md5.digest()));\n        System.out.println();\n    }\n\n    System.out.println(\"Enter certificate to add to trusted keystore or 'q' to quit: [1]\");\n    String line = reader.readLine().trim();\n    int k;\n    try {\n        k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;\n    } catch (NumberFormatException e) {\n        System.out.println(\"KeyStore not changed\");\n        return;\n    }\n\n    X509Certificate cert = chain[k];\n    String alias = host + \"-\" + (k + 1);\n    ks.setCertificateEntry(alias, cert);\n\n    OutputStream out = new FileOutputStream(\"jssecacerts\");\n    ks.store(out, passphrase);\n    out.close();\n\n    System.out.println();\n    System.out.println(cert);\n    System.out.println();\n        System.out.println\n                (\"Added certificate to keystore 'jssecacerts' using alias '\"\n                        + alias + \"'\");\n    }\n\n    private static final char[] HEXDIGITS = \"0123456789abcdef\".toCharArray();\n\n    private static String toHexString(byte[] bytes) {\n        StringBuilder sb = new StringBuilder(bytes.length * 3);\n        for (int b : bytes) {\n            b &amp;= 0xff;\n            sb.append(HEXDIGITS[b &gt;&gt; 4]);\n            sb.append(HEXDIGITS[b &amp; 15]);\n            sb.append(' ');\n        }\n        return sb.toString();\n    }\n\nprivate static class SavingTrustManager implements X509TrustManager {\n\n        private final X509TrustManager tm;\n        private X509Certificate[] chain;\n\n        SavingTrustManager(X509TrustManager tm) {\n            this.tm = tm;\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            throw new UnsupportedOperationException();\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType)\n                throws CertificateException {\n            throw new UnsupportedOperationException();\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType)\n                throws CertificateException {\n            this.chain = chain;\n            tm.checkServerTrusted(chain, authType);\n        }\n    }\n}\n", "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.security.KeyStore;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\n\npublic class CertManager {\n\nprivate static final char[] passphrase = \"changeit\".toCharArray();\nprivate String rootPath;\nprivate SSLSocketFactory factory;\nprivate SavingTrustManager trustManager;\nprivate KeyStore keyStore;\n\n\n/**\n * Creates a CertManager.\n * @param rootPath Path to directory where the file 'jssecacerts' is located.\n */\npublic CertManager(String rootPath){\n    this.rootPath = rootPath;       \n}\n\n/**\n * Gets a SSLSocketFactory with the trusted certs.\n * @return\n * @throws Exception\n */\npublic SSLSocketFactory getSSLSocketFactory() throws Exception {\n    //Load trusted certs\n    File file = new File(rootPath+\"jssecacerts\");\n\n    System.out.println(\"Loading KeyStore \" + file + \"...\");\n    InputStream in = new FileInputStream(file);\n    keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n    keyStore.load(in, passphrase);\n    in.close();\n\n    //Use these certs \n    SSLContext context = SSLContext.getInstance(\"TLS\");\n    TrustManagerFactory tmf =\n        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    tmf.init(keyStore);\n    X509TrustManager defaultTrustManager = (X509TrustManager)tmf.getTrustManagers()[0];\n    trustManager = new SavingTrustManager(defaultTrustManager);\n    context.init(null, new TrustManager[] {trustManager}, null);\n    factory = context.getSocketFactory();\n    return factory;\n}\n\nprivate static class SavingTrustManager implements X509TrustManager {\n\n    private final X509TrustManager tm;\n    private X509Certificate[] chain;\n\n    SavingTrustManager(X509TrustManager tm) {\n        this.tm = tm;\n    }\n\n    public X509Certificate[] getAcceptedIssuers() {         \n        return tm.getAcceptedIssuers();\n    }\n\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n    throws CertificateException {\n        this.chain = chain;\n        tm.checkClientTrusted(chain, authType);\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n    throws CertificateException {\n        this.chain = chain;\n        tm.checkServerTrusted(chain, authType);\n    }\n}\n}\n", "public static byte[] encrypt(String passphrase, byte[] data) throws Exception {\n\n    // Hash the ASCII-encoded passphrase with md5\n\n    byte[] keyData = passphrase.getBytes(Charset.forName(\"US-ASCII\"));\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte [] md5HashOfKey = md.digest(keyData);\n\n    // Need to use bouncycastle (spongycastle on Android) to get RC2\n\n    Security.addProvider(new BouncyCastleProvider());\n\n    Cipher rc2 = Cipher.getInstance(\"RC2/CBC/PKCS5PADDING\");\n\n    // Create an RC2 40-bit key from the 1st 5 bytes of the hash.\n\n    SecretKeySpec rc2KeySpec = new SecretKeySpec(md5HashOfKey, 0, 5, \"RC2\");\n    rc2.init(Cipher.ENCRYPT_MODE, rc2KeySpec);\n\n    byte [] cipher = rc2.doFinal(data);\n\n    return cipher;\n}\n", "public static byte[] encryptAES(SecretKey key, byte[] clear) {\n    try {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getEncoded(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}\n", "public static byte[] decryptAES(SecretKey key, byte[] encrypted) {\n    try {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getEncoded(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}\n", "public SecretKey newAESKey() {\n\n    try {\n        String s_key = new BigInteger(130, random).toString(32);\n\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n\n        sr.setSeed(s_key.getBytes());\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n\n        SecretKey skey = kgen.generateKey();\n        return skey;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n          YOUR_PACKAGE_NAME, PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) \n        {\n           MessageDigest md = MessageDigest.getInstance(\"SHA\");\n           md.update(signature.toByteArray());\n           Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    }\n} catch (NameNotFoundException e) {\n} catch (NoSuchAlgorithmException e) {\n}\n", "public static javax.net.ssl.TrustManager getTrustManager()\n{\n    javax.net.ssl.TrustManager tm = new javax.net.ssl.X509TrustManager() {\n\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n        return null;\n        }\n\n        @Override\n        public void checkClientTrusted(\n                java.security.cert.X509Certificate[] chain, String authType)\n                throws java.security.cert.CertificateException {\n\n        }\n\n        @Override\n        public void checkServerTrusted(\n                java.security.cert.X509Certificate[] chain, String authType)\n                throws java.security.cert.CertificateException {        \n        }\n        };\n        return tm;\n}\n\n\n\npublic static DefaultHttpClient getThreadSafeClient() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, KeyManagementException, UnrecoverableKeyException {\n    DefaultHttpClient client = new DefaultHttpClient();\n    ClientConnectionManager mgr = client.getConnectionManager();\n    HttpParams cleintParams = client.getParams();\n\n    cleintParams.setBooleanParameter(\"http.protocol.expect-continue\", true);\n    cleintParams.setBooleanParameter(\"http.protocol.warn-extra-input\", true);\n    // params.setIntParameter(\"http.socket.receivebuffer\", 999999);\n\n    //----&gt;&gt; SSL\n    KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n    trustStore.load(null, null);\n\n    SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n    sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n    HttpParams params = new BasicHttpParams();\n    HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n   // HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n    SchemeRegistry registry = new SchemeRegistry();\n    registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n    registry.register(new Scheme(\"https\", sf, 443));\n\n    //&lt;&lt;------\n\n\nclient = new DefaultHttpClient(new ThreadSafeClientConnManager(params, registry), cleintParams);\n\n    return client;\n}\n", "public class YahooContacts extends BaseActivity {\nprivate final String TAG = \"yahoo_auth\";\n\nprivate static final String CONSUMER_KEY = \"you_consumer_key\";\nprivate static final String CONSUMER_SECRET = \"your_consumer_secret\";\n\n\n\nprivate static final String CALLBACK_SCHEME = \"http\";\nprivate static final String CALLBACK_HOST = \"www.blablablao.com\";\nprivate static final String CALLBACK_URL = CALLBACK_SCHEME + \"://\"\n        + CALLBACK_HOST;\n\nprivate String AUTH_TOKEN = null;\nprivate String AUTH_TOKEN_SECRET = null;\nprivate String AUTH_URL = null;\nprivate String USER_TOKEN = null;\nprivate String ACCESS_TOKEN = null;\nprivate String ACCESS_TOKEN_SECRET = null;\nprivate String mUSER_GUID = null;\n\nprivate WebView mWebview;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.yahoo_layout);\n    mWebview = (WebView) findViewById(R.id.webview);\n    new getContactsTask().execute();\n\n\n}\n\nclass getContactsTask extends AsyncTask&lt;Void, Void, Void&gt; {\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n    }\n\n    @Override\n    protected Void doInBackground(Void... params) {\n        getAuthorizationToken();\n        getUserAutherization();\n\n        return null;\n    }\n\n    @Override\n    protected void onPostExecute(Void result) {\n\n        super.onPostExecute(result);\n    }\n\n}\n\nprivate void getAuthorizationToken() {\n\n    String requestPath = \"https://api.login.yahoo.com/oauth/v2/get_request_token?oauth_consumer_key=\"\n            + CONSUMER_KEY\n            + \"&amp;oauth_nonce=\"\n            + System.currentTimeMillis()\n            + \"x\"\n            + \"&amp;oauth_signature_method=PLAINTEXT\"\n            + \"&amp;oauth_signature=\"\n            + CONSUMER_SECRET\n            + \"%26\"\n            + \"&amp;oauth_timestamp=\"\n            + System.currentTimeMillis()\n            + \"&amp;oauth_version=1.0\"\n            + \"&amp;xoauth_lang_pref=en-us\"\n            + \"&amp;oauth_callback=\" + CALLBACK_URL;\n    HttpClient httpclient = new DefaultHttpClient();\n    HttpGet httpget = new HttpGet(requestPath);\n    try {\n        ResponseHandler&lt;String&gt; responseHandler = new BasicResponseHandler();\n        String responseBody = httpclient.execute(httpget, responseHandler);\n        String[] data = responseBody.split(\"&amp;\");\n        AUTH_TOKEN = data[0].replace(\"oauth_token=\", \"\");\n        AUTH_TOKEN_SECRET = data[1].replace(\"oauth_token_secret=\", \"\");\n        AUTH_URL = data[3].replace(\"xoauth_request_auth_url=\", \"\");\n        VIPLogger.info(TAG, \"authToken\" + AUTH_TOKEN);\n        VIPLogger.info(TAG, \"authToken secret\" + AUTH_TOKEN_SECRET);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\nprivate void getUserAutherization() {\n    mWebview.getSettings().setJavaScriptEnabled(true);\n    mWebview.setWebViewClient(lWebviewClient);\n    mWebview.loadUrl(\"https://api.login.yahoo.com/oauth/v2/request_auth?oauth_token=\"\n            + AUTH_TOKEN);\n}\n\nprivate void getAccessToken() {\n    String requestPath = \"https://api.login.yahoo.com/oauth/v2/get_token?oauth_consumer_key=\"\n            + CONSUMER_KEY\n            + \"&amp;oauth_nonce=\"\n            + System.currentTimeMillis()\n            + \"x\"\n            + \"&amp;oauth_signature_method=PLAINTEXT\"\n            + \"&amp;oauth_signature=\"\n            + CONSUMER_SECRET\n            + \"%26\"\n            + AUTH_TOKEN_SECRET\n            + \"&amp;oauth_timestamp=\"\n            + System.currentTimeMillis()\n            + \"&amp;oauth_version=1.0\"\n            + \"&amp;oauth_token=\"\n            + AUTH_TOKEN\n            + \"&amp;oauth_verifier=\"\n            + USER_TOKEN;\n    HttpClient httpclient = new DefaultHttpClient();\n    HttpGet httpget = new HttpGet(requestPath);\n    try {\n        ResponseHandler&lt;String&gt; responseHandler = new BasicResponseHandler();\n        String responseBody = httpclient.execute(httpget, responseHandler);\n        String[] data = responseBody.split(\"&amp;\");\n        ACCESS_TOKEN = data[0].replace(\"oauth_token=\", \"\");\n        ACCESS_TOKEN_SECRET = data[1].replace(\"oauth_token_secret=\", \"\");\n        mUSER_GUID = data[5].replace(\"xoauth_yahoo_guid=\", \"\");\n        VIPLogger.info(TAG, \"user guid: \" + responseBody);\n        VIPLogger.info(TAG, \"Access token: \" + ACCESS_TOKEN);\n        getAllContacts();\n    } catch (Exception e) {\n        e.printStackTrace();\n        VIPLogger.error(TAG,\n                \"error while fetching user guid and access token\");\n    }\n}\n\nWebViewClient lWebviewClient = new WebViewClient() {\n\n    public void onPageStarted(WebView view, String url,\n            android.graphics.Bitmap favicon) {\n        if (url.contains(\"vipitservice\")) {\n            mWebview.stopLoading();\n            int lastIndex = url.lastIndexOf(\"=\") + 1;\n            VIPLogger.info(TAG, url.substring(lastIndex, url.length()));\n            USER_TOKEN = url.substring(lastIndex, url.length());\n            mWebview.setVisibility(View.GONE);\n\n            getAccessToken();\n        }\n    };\n\n};\n\nprivate void getAllContacts() {\n\n\n    HttpClient httpclient = new DefaultHttpClient();\n\n    String host_url = \"http://social.yahooapis.com/v1/user/\" + mUSER_GUID+ \"/contacts\";\n\n    String nonce = \"\"+System.currentTimeMillis();\n    String timeStamp = \"\"+(System.currentTimeMillis()/1000L);\n\n    try{\n        String params = \n                \"\"+encode(\"oauth_consumer_key\")+\"=\" + encode(CONSUMER_KEY)\n                + \"&amp;\"+encode(\"oauth_nonce\")+\"=\"+encode(nonce)\n                + \"&amp;\"+encode(\"oauth_signature_method\")+\"=\"+encode(\"HMAC-SHA1\")\n                + \"&amp;\"+encode(\"oauth_timestamp\")+\"=\"+encode(timeStamp)\n                + \"&amp;\"+encode(\"oauth_token\")+\"=\"+ACCESS_TOKEN\n                + \"&amp;\"+encode(\"oauth_version\")+\"=\"+encode(\"1.0\")\n\n                ;\n        String baseString = encode(\"GET\")+\"&amp;\"+encode(host_url)+\"&amp;\"+encode(params);\n        String signingKey = encode(CONSUMER_SECRET)+\"&amp;\"+encode(ACCESS_TOKEN_SECRET);\n        VIPLogger.info(TAG, \"base string: \" + baseString);\n        String lSignature = computeHmac(baseString, signingKey);\n        VIPLogger.info(TAG, \"signature: \" + lSignature);\n        lSignature = encode(lSignature);\n        VIPLogger.info(TAG, \"signature enacoded: \" + lSignature);\n\n        String lRequestUrl = host_url\n                            + \"?oauth_consumer_key=\"+CONSUMER_KEY\n                            + \"&amp;oauth_nonce=\"+nonce\n                            + \"&amp;oauth_signature_method=HMAC-SHA1\"\n                            + \"&amp;oauth_timestamp=\"+timeStamp\n                            + \"&amp;oauth_token=\"+ACCESS_TOKEN\n                            + \"&amp;oauth_version=1.0\"\n                            + \"&amp;oauth_signature=\"+lSignature\n                            ;\n        //VIPLogger.info(TAG, lRequestUrl.substring(1202));\n        HttpGet httpget = new HttpGet(lRequestUrl);\n        ResponseHandler&lt;String&gt; responseHandler = new BasicResponseHandler();\n        String responseBody = httpclient.execute(httpget, responseHandler);\n\n        VIPLogger.info(TAG, \"contacts response: \" + responseBody);\n    }catch(Exception e){\n        e.printStackTrace();\n        VIPLogger.error(TAG, \"error while fetching user contacts\");\n    }\n\n}\n\npublic String computeHmac(String baseString, String key) {\n    try {\n        Mac mac = Mac.getInstance(\"HmacSHA1\");\n        SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(\"UTF-8\"),\n                \"HMAC-SHA1\");\n        mac.init(signingKey);\n        byte[] digest = mac.doFinal(baseString.getBytes());\n        String result = Base64.encodeToString(digest, Base64.DEFAULT);\n        return result;\n    } catch (Exception e) {\n        e.printStackTrace();\n        VIPLogger.error(TAG, \"error while generating sha\");\n    }\n    return null;\n\n}\n\npublic String encodeURIComponent(final String value) {\n    if (value == null) {\n        return \"\";\n    }\n\n    try {\n        return URLEncoder.encode(value, \"utf-8\")\n                // OAuth encodes some characters differently:\n                .replace(\"+\", \"%20\").replace(\"*\", \"%2A\")\n                .replace(\"%7E\", \"~\");\n        // This could be done faster with more hand-crafted code.\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n\n\n    public  String encode(String input) {\n        StringBuilder resultStr = new StringBuilder();\n        for (char ch : input.toCharArray()) {\n            if (isUnsafe(ch)) {\n                resultStr.append('%');\n                resultStr.append(toHex(ch / 16));\n                resultStr.append(toHex(ch % 16));\n            } else {\n                resultStr.append(ch);\n            }\n        }\n        return resultStr.toString().trim();\n    }\n\n    private  char toHex(int ch) {\n        return (char) (ch &lt; 10 ? '0' + ch : 'A' + ch - 10);\n    }\n\n    private  boolean isUnsafe(char ch) {\n        if (ch &gt; 128 || ch &lt; 0)\n            return true;\n        return \" %$&amp;+,/:;=?@&lt;&gt;#%\".indexOf(ch) &gt;= 0;\n    }\n", "public class MovieListActivityTEST extends AppCompatActivity {\n\nViewPager pager;\nViewPagerAdapter adapter;\nSwipeRefreshLayout refreshLayout;\nSlidingTabLayout tabs;\nCharSequence Titles[]={\"Home\",\"Events\"};\nint Numboftabs =2;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_movie_list_activity_test);\n\n    // Creating The ViewPagerAdapter and Passing Fragment Manager, Titles fot the Tabs and Number Of Tabs.\n    adapter =  new ViewPagerAdapter(getSupportFragmentManager(),Titles,Numboftabs);\n\n    // Assigning ViewPager View and setting the adapter\n    pager = (ViewPager) findViewById(R.id.pager);\n    pager.setAdapter(adapter);\n\n    // Assiging the Sliding Tab Layout View\n    tabs = (SlidingTabLayout) findViewById(R.id.tabs);\n    tabs.setDistributeEvenly(true); \n\n    // Setting Custom Color for the Scroll bar indicator of the Tab View\n    tabs.setCustomTabColorizer(new SlidingTabLayout.TabColorizer() {\n        @Override\n        public int getIndicatorColor(int position) {\n            return getResources().getColor(R.color.tabsScrollColor);\n        }\n    });\n\n    // Setting the ViewPager For the SlidingTabsLayout\n    tabs.setViewPager(pager);\n\n    // Assign your refresh layout\n    refreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipeContainer);\n\n    refreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {\n        @Override\n        public void onRefresh() {\n            Refreshable r = (Refreshable) adapter.getItemAt(pager.getCurrentItem());\n            r.refresh();\n        }\n    }); \n}\n", "SSLContext context = SSLContext.getInstance(\"TLS\");\nTrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n    public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return new java.security.cert.X509Certificate[] {};\n    }\n\n    public void checkClientTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {\n    }\n} };\ncontext.init(null, trustAllCerts, null);\n\nSocketFactory factory = context.getSocketFactory();\n...\n", "String encoded = null;\nbyte[] encrypted = null;\nString plaintext = \"...\";\n\ntry {\n    String privKeyPEM = \"...\";\n    byte[] decoded = Base64.decode(privKeyPEM, Base64.DEFAULT);\n    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n    PrivateKey privKey = kf.generatePrivate(spec);\n\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, privKey);\n\n    encrypted = cipher.doFinal(plaintext.getBytes());\n    encoded = Base64.encodeToString(encrypted, Base64.DEFAULT);\n}\ncatch (Exception e) {\n    e.printStackTrace();\n}\n", "package net.milanaleksic.cuc.tools.async.http;\n\nimport java.io.IOException;\nimport java.security.SecureRandom;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.*;\n\nimport org.apache.http.conn.scheme.*;\nimport org.apache.http.conn.ssl.X509HostnameVerifier;\n\npublic class HttpsSecurityOverride {\n\n    private static SchemeRegistry allowAllSchemeRegistry = null;\n\n    private static class AllowAllTrustManager implements X509TrustManager {\n\n        @Override public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[] {};\n        }\n\n        @Override public void checkClientTrusted(X509Certificate[] certs, String authType) {\n        }\n\n        @Override public void checkServerTrusted(X509Certificate[] certs, String authType) {\n        }\n    }\n\n    private static class AllowAllHostnameVerifier implements X509HostnameVerifier {\n\n        @Override public void verify(String arg0, SSLSocket arg1) throws IOException {\n        }\n\n        @Override public void verify(String arg0, X509Certificate arg1) throws SSLException {\n        }\n\n        @Override public void verify(String arg0, String[] arg1, String[] arg2) throws SSLException {\n        }\n\n        @Override public boolean verify(String arg0, SSLSession arg1) {\n            return true;\n        }\n\n    }\n\n    public static SchemeRegistry createAllowAllSchemeRegistry() throws Exception {\n        synchronized (HttpsSecurityOverride.class) {\n            if (allowAllSchemeRegistry != null)\n                return allowAllSchemeRegistry;\n\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n\n            // set up a TrustManager that trusts everything\n            sslContext.init(null, new TrustManager[] { new AllowAllTrustManager() }, new SecureRandom());\n\n            org.apache.http.conn.ssl.SSLSocketFactory sf = new org.apache.http.conn.ssl.SSLSocketFactory(sslContext);\n            sf.setHostnameVerifier(new AllowAllHostnameVerifier());\n            Scheme httpsScheme = new Scheme(\"https\", sf, 443);\n            allowAllSchemeRegistry = new SchemeRegistry();\n            allowAllSchemeRegistry.register(httpsScheme);\n\n            return allowAllSchemeRegistry;\n        }\n    }\n\n}\n", "public void validateCertificate() throws Exception {\n    try {\n        String issuerCertPath = \"Issuer Certifate\";\n        String certPath = \"Issued Certificate\";\n        X509Certificate issuerCert = getCertFromFile(issuerCertPath);\n        X509Certificate c1 = getCertFromFile(certPath);\n        TrustAnchor anchor = new TrustAnchor(issuerCert, null);\n        Set anchors = Collections.singleton(anchor);\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        List list = Arrays.asList(new Certificate[] { c1 });\n        CertPath path = cf.generateCertPath(list);\n        PKIXParameters params = new PKIXParameters(anchors);\n        params.setRevocationEnabled(false);\n        CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\");\n        PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) validator\n                .validate(path, params);\n        // If\n        // not\n        // valid\n        // will\n        // throw\n        System.out.println(\"VALID\");\n    } catch (Exception e) {\n        System.out.println(\"EXCEPTION \" + e.getMessage());\n        e.printStackTrace();\n    }\n}\n\nprivate X509Certificate getCertFromFile(String path) throws Exception {\n    AssetManager assetManager = MyActivity.this.getResources().getAssets();\n    InputStream inputStream = null;\n    try {\n        inputStream = assetManager.open(path);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    InputStream caInput = new BufferedInputStream(inputStream);\n    X509Certificate cert = null;\n    CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n    cert = (X509Certificate) cf.generateCertificate(caInput);\n    cert.getSerialNumber();\n    return cert;\n}\n", " public byte[] keyGen() throws NoSuchAlgorithmException {\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n    keyGenerator.init(192);\n    return keyGenerator.generateKey().getEncoded();\n }\n", "     public byte[] encript(byte[] dataToEncrypt, byte[] key)\n            throws NoSuchAlgorithmException, NoSuchPaddingException,\n            InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    //I'm using AES encription\n    Cipher c = Cipher.getInstance(\"AES\");\n    SecretKeySpec k = new SecretKeySpec(key, \"AES\");\n    c.init(Cipher.ENCRYPT_MODE, k);\n    return c.doFinal(dataToEncrypt);\n    }\n\n    public byte[] decript(byte[] encryptedData, byte[] key)\n            throws NoSuchAlgorithmException, NoSuchPaddingException,\n            InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    Cipher c = Cipher.getInstance(\"AES\");\n    SecretKeySpec k = new SecretKeySpec(key, \"AES\");\n    c.init(Cipher.DECRYPT_MODE, k);\n    return c.doFinal(encryptedData);\n    }\n", "public static RestAdapter createAdapter(Context context) {\n  OkHttpClient okHttpClient = new OkHttpClient();\n\n  // loading CAs from an InputStream\n  CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n  InputStream cert = context.getResources().openRawResource(R.raw.my_cert);\n  Certificate ca;\n  try {\n    ca = cf.generateCertificate(cert);\n  } finally { cert.close(); }\n\n  // creating a KeyStore containing our trusted CAs\n  String keyStoreType = KeyStore.getDefaultType();\n  KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n  keyStore.load(null, null);\n  keyStore.setCertificateEntry(\"ca\", ca);\n\n  // creating a TrustManager that trusts the CAs in our KeyStore\n  String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n  TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n  tmf.init(keyStore);\n\n  // creating an SSLSocketFactory that uses our TrustManager\n  SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n  sslContext.init(null, tmf.getTrustManagers(), null);\n  okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());\n\n  // creating a RestAdapter using the custom client\n  return new RestAdapter.Builder()\n              .setEndpoint(UrlRepository.API_BASE)\n              .setClient(new OkClient(okHttpClient))\n              .build();\n}\n", "import java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.X509TrustManager;\n\nprivate void trustEveryone() {\n    try {\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){\n                public boolean verify(String hostname, SSLSession session) {\n                    return true;\n                }});\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(null, new X509TrustManager[]{new X509TrustManager(){\n            public void checkClientTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {}\n            public void checkServerTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {}\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[0];\n            }}}, new SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(\n                context.getSocketFactory());\n    } catch (Exception e) { // should never happen\n        e.printStackTrace();\n    }\n}\n", "public static KeyPair generateKeyPair() throws NoSuchAlgorithmException {\n    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n    keyPairGenerator.initialize(2048);\n    KeyPair keyPair = keyPairGenerator.genKeyPair();\n    return keyPair;\n}\n", "private static PKCS10CertificationRequest generateCSRFile(KeyPair keyPair) throws IOException, OperatorCreationException {\n    String principal = \"CN=company1, OU=company1, O=company1, C=GB\";\n    AsymmetricKeyParameter privateKey = PrivateKeyFactory.createKey(keyPair.getPrivate().getEncoded());\n    AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder()\n            .find(\"SHA1WITHRSA\");\n    AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(\"SHA-1\");\n    ContentSigner signer = new BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm).build(privateKey);\n\n    PKCS10CertificationRequestBuilder csrBuilder = new JcaPKCS10CertificationRequestBuilder(new X500Name(\n            principal), keyPair.getPublic());\n    ExtensionsGenerator extensionsGenerator = new ExtensionsGenerator();\n    extensionsGenerator.addExtension(X509Extension.basicConstraints, true, new BasicConstraints(true));\n    extensionsGenerator.addExtension(X509Extension.keyUsage, true, new KeyUsage(KeyUsage.keyCertSign\n            | KeyUsage.cRLSign));\n    csrBuilder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensionsGenerator.generate());\n    PKCS10CertificationRequest csr = csrBuilder.build(signer);\n\n    return csr;\n}\n", "KeyStore store = KeyStore.getInstance(\"BKS\");\nInputStream in;\ntry {\n    in = App.getInstance().getApplicationContext().openFileInput(filename);\n        try {\n            store.load(in, password);\n        } finally {\n            in.close();\n        }\n    } catch (FileNotFoundException e) {\n        //create new keystore\n        store.load(null, password);\n    }\n", "KeyStore trustStore = KeyStore.getInstance(\"BKS\");\nInputStream in = App.getInstance().getApplicationContext().getResources().openRawResource(R.raw.truststore);\ntry {\n    trustStore.load(in, trustorePassword);\n} finally {\n    in.close();\n}\n", "OkHttpClient client = new OkHttpClient();\nKeyStore keyStore = App.getInstance().getKeyStoreUtil().getKeyStore();\nKeyStore trustStore = App.getInstance().getKeyStoreUtil().getTrustStore();\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init(trustStore);\n\nKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkmf.init(keyStore, keyStorePassword);\n\nSSLContext sslCtx = SSLContext.getInstance(\"TLS\");\nsslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\nclient.setSslSocketFactory(sslCtx.getSocketFactory());\nclient.setHostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n", "        URL url = new URL(SSL_URL);\n        HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();\n        urlConnection.setDoOutput(true);\n        urlConnection.setSSLSocketFactory(context.getSocketFactory());\n        urlConnection.setHostnameVerifier(hostnameVerifier);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/soap+xml; charset=utf-8\");\n        urlConnection.connect();\n        OutputStream out = new BufferedOutputStream(urlConnection.getOutputStream());\n        if (out != null)\n        {\n           out.write(getReqData());\n           out.flush();\n           out.close();\n        }\n        int res = urlConnection.getResponseCode();\n        String message = urlConnection.getResponseMessage();\n        InputStream in = urlConnection.getInputStream();\n        String msg = convertStreamToString(in);\n", "// Create a trust manager that does not validate certificate chains\n    TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n        @Override\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        @Override\n        public void checkClientTrusted(X509Certificate[] certs, String authType) {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] certs, String authType) {\n        }\n    }\n    };\n\n    // Create all-trusting host name verifier\n    HostnameVerifier allHostsValid = new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    try {\n        // Install the all-trusting trust manager\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        // Install the all-trusting host verifier\n        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n", "@Override\npublic void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState);\n\n// Add code to print out the key hash\n\n    try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.facebook.samples.hellofacebook\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "     public String encryptString(String dataToEncrypt) {\n\n        try {\n            SharedPreferences prefs = context.getSharedPreferences(\"appname\", 0);\n            if (prefs.getString(\"SECRET_KEY\",\"\") == \"\") {\n                secretKeySpec = GenerateSecretKeySpecs();\n                String stringSecretKey = Base64.encodeToString(\n                        secretKeySpec.getEncoded(), Base64.DEFAULT);\n\n                SharedPreferences.Editor editor = prefs.edit();\n                editor.putString(\"SECRET_KEY\", stringSecretKey);\n                editor.commit();\n\n            }\n            if (prefs.getString(\"SECRET_KEY\",\"\") != \"\") {\n                byte[] encodedBytes = null;\n\n                Cipher c = Cipher.getInstance(\"AES\");\n                String key =prefs.getString(\"SECRET_KEY\",\"\");\n\n                byte[] encodedKey = Base64.decode(key, Base64.DEFAULT);\n                SecretKey originalKey = new SecretKeySpec(encodedKey, 0,\n                        encodedKey.length, \"AES\");\n                c.init(Cipher.ENCRYPT_MODE, originalKey);\n                encodedBytes = c.doFinal(dataToEncrypt.getBytes());\n\n                return Base64.encodeToString(encodedBytes, Base64.DEFAULT);\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n//          Log.e(TAG, \"AES encryption error\");\n            return null;\n        }\n    }\n", "public String decryptString(String dataToDecrypt) {\n        SharedPreferences prefs= context.getSharedPreferences(\"appname\", 0);\n        if (prefs.getString(\"SECRET_KEY\",\"\") != \"\") {\n            byte[] decodedBytes = null;\n            try {\n                Cipher c = Cipher.getInstance(\"AES\");\n\n                String key = prefs.getString(\"SECRET_KEY\",\"\")\n                byte[] encodedKey = Base64.decode(key, Base64.DEFAULT);\n                SecretKey originalKey = new SecretKeySpec(encodedKey, 0,\n                        encodedKey.length, \"AES\");\n                c.init(Cipher.DECRYPT_MODE, originalKey);\n\n                byte[] dataInBytes = Base64.decode(dataToDecrypt,\n                        Base64.DEFAULT);\n\n                decodedBytes = c.doFinal(dataInBytes);\n                return new String(decodedBytes);\n            } catch (Exception e) {\n//              Log.e(TAG, \"AES decryption error\");\n                e.printStackTrace();\n                return null;\n            }\n\n        } else\n            return null;\n\n    }\n", "@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.facebook.samples.hellofacebook\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n\n    ...\n}\n", "public X509Certificate x509ReqToX509(PKCS10CertificationRequest csr, int days, PrivateKey pKey) \n{\n  Date notBefore = new Date();\n  Calendar cal = Calendar.getInstance();\n  cal.add(Calendar.DATE, days);\n  Date notAfter = cal.getTime();\n  BigInteger serialNumber = generateCertSerialNumber(); // No implemented here\n\n  X509V3CertificateGenerator certGen = new X509V3CertificateGenerator();\n\n  certGen.setSerialNumber(serialNumber);\n  certGen.setIssuerDN(csr.getCertificationRequestInfo().getSubject());\n  certGen.setSubjectDN(csr.getCertificationRequestInfo().getSubject());\n  certGen.setNotBefore(notBefore);\n  certGen.setNotAfter(notAfter);\n  certGen.setPublicKey(csr.getPublicKey());\n  certGen.setSignatureAlgorithm(\"SHA256WithRSAEncryption\");\n\n  return certGen.generate(pKey, \"BC\");\n}\n", "import android.content.pm.Signature;  \nimport java.security.cert.CertificateException;  \nimport java.security.cert.X509Certificate; \n\nprivate static final X500Principal DEBUG_DN = new X500Principal(\"CN=Android Debug,O=Android,C=US\");  \nprivate boolean isDebuggable(Context ctx)\n{ \nboolean debuggable = false;\n\ntry\n{\n    PackageInfo pinfo = ctx.getPackageManager().getPackageInfo(ctx.getPackageName(),PackageManager.GET_SIGNATURES);\n    Signature signatures[] = pinfo.signatures;\n\n    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n\n    for ( int i = 0; i &lt; signatures.length;i++)\n    {   \n        ByteArrayInputStream stream = new ByteArrayInputStream(signatures[i].toByteArray());\n        X509Certificate cert = (X509Certificate) cf.generateCertificate(stream);       \n        debuggable = cert.getSubjectX500Principal().equals(DEBUG_DN);\n        if (debuggable)\n            break;\n    }\n}\ncatch (NameNotFoundException e)\n{\n    //debuggable variable will remain false\n}\ncatch (CertificateException e)\n{\n    //debuggable variable will remain false\n}\nreturn debuggable;\n}\n", "    XMPPTCPConnectionConfiguration.Builder config = XMPPTCPConnectionConfiguration.builder();\n    config.setSecurityMode(ConnectionConfiguration.SecurityMode.disabled);\n    config.setUsernameAndPassword(USER_ID+ \"@\" + DOMAIN, key);\n    config.setServiceName(DOMAIN);\n    config.setHost(DOMAIN);\n    config.setPort(PORT);\n    config.setDebuggerEnabled(true);\n    config.setSocketFactory(SSLSocketFactory.getDefault());\n\n    mConnection = new XMPPTCPConnection(config.build());\n    try {\n        mConnection.connect();\n    } catch (SmackException | IOException | XMPPException e) {\n        e.printStackTrace();\n    }\n", "/**\n * Encrypt data\n * \n * @param secretKey\n *            - a secret key used for encryption\n * @param data\n *            - data to encrypt\n * @return Encrypted data\n * @throws Exception\n */\npublic String cipher(String secretKey, String data) throws Exception {\n    SecretKeyFactory factory = SecretKeyFactory\n            .getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec spec = new PBEKeySpec(secretKey.toCharArray(),\n            secretKey.getBytes(), 128, 256);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey key = new SecretKeySpec(tmp.getEncoded(), ALGORITHM);\n    Cipher cipher = Cipher.getInstance(ALGORITHM);\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    return toHex(cipher.doFinal(data.getBytes()));\n}\n\n/**\n * Decrypt data\n * \n * @param secretKey\n *            - a secret key used for decryption\n * @param data\n *            - data to decrypt\n * @return Decrypted data\n * @throws Exception\n */\npublic String decipher(String secretKey, String data) throws Exception {\n    SecretKeyFactory factory = SecretKeyFactory\n            .getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec spec = new PBEKeySpec(secretKey.toCharArray(),\n            secretKey.getBytes(), 128, 256);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey key = new SecretKeySpec(tmp.getEncoded(), ALGORITHM);\n    Cipher cipher = Cipher.getInstance(ALGORITHM);\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    return new String(cipher.doFinal(toByte(data)));\n}\n\n// Helper methods\n\nprivate byte[] toByte(String hexString) {\n    int len = hexString.length() / 2;\n    byte[] result = new byte[len];\n    for (int i = 0; i &lt; len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),\n                16).byteValue();\n    return result;\n}\n\npublic String toHex(byte[] stringBytes) {\n    StringBuffer result = new StringBuffer(2 * stringBytes.length);\n    for (int i = 0; i &lt; stringBytes.length; i++) {\n        result.append(HEX.charAt((stringBytes[i] &gt;&gt; 4) &amp; 0x0f)).append(\n                HEX.charAt(stringBytes[i] &amp; 0x0f));\n    }\n    return result.toString();\n}\n\nprivate final static String HEX = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n", "    System.out.println(\"start *****\");\n\n     String text=\"The quick brown fox jumps over the lazy dog\"; \n     StandardPBEByteEncryptor encryptor=new StandardPBEByteEncryptor();     \n     encryptor.setAlgorithm(\"PBEWithMD5AndDES\"); \n     encryptor.setPassword(\"HelloWorld\");      \n     byte[] encrypted=encryptor.encrypt(text.getBytes()); \n\n    System.out.println(\"stop *****\");\n", "/**\n * generates key hash for facebbok\n */\nprivate void GetKeyHash()\n{\n\n    PackageInfo info;\n    try\n    {\n        info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures)\n        {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String keyhash = new String(Base64.encode(md.digest(), 0));\n            // String something = new String(Base64.encodeBytes(md.digest()));\n            Log.e(\"keyhash\", \"keyhash= \" + keyhash);\n            System.out.println(\"keyhash= \" + keyhash);\n        }\n    }\n    catch (NameNotFoundException e1)\n    {\n        Log.e(\"name not found\", e1.toString());\n    }\n    catch (NoSuchAlgorithmException e)\n    {\n        Log.e(\"no such an algorithm\", e.toString());\n    }\n    catch (Exception e)\n    {\n        Log.e(\"exception\", e.toString());\n    }\n\n}\n", "private TrustManager[] trustAllCerts = new TrustManager[]{\n    new X509TrustManager() {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n        public void checkClientTrusted(\n            java.security.cert.X509Certificate[] certs, String authType) {\n        }\n        public void checkServerTrusted(\n            java.security.cert.X509Certificate[] certs, String authType) {\n        }\n    }\n};\n", "    try {\n       SSLContext sc = SSLContext.getInstance(\"TLS\");\n       sc.init(null, trustAllCerts, new java.security.SecureRandom());\n       HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n    } catch (Exception e) {\n       e.getMessage();\n    }\n    connection = (HttpsURLConnection) new URL(url).openConnection();\n    ((HttpsURLConnection) connection).setHostnameVerifier(new AllowAllHostnameVerifier());\n", "SecureRandom rng = new SecureRandom();\n\nbyte[] aesKeyData = new byte[128 / Byte.SIZE];\nrng.nextBytes(aesKeyData);\nSecretKey aesKey = new SecretKeySpec(aesKeyData, \"AES\");\n\n// just to show it works\nCipher aesCBC = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nbyte[] iv = new byte[aesCBC.getBlockSize()];\nrng.nextBytes(iv);\naesCBC.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(iv));\n", "try {\n    KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n    keyStore.load(null);\n\n    String alias = \"key3\";\n\n    int nBefore = keyStore.size();\n\n    // Create the keys if necessary\n    if (!keyStore.containsAlias(alias)) {\n\n        Calendar notBefore = Calendar.getInstance();\n        Calendar notAfter = Calendar.getInstance();\n        notAfter.add(Calendar.YEAR, 1);\n        KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this)\n            .setAlias(alias)\n            .setKeyType(\"RSA\")\n            .setKeySize(2048)\n            .setSubject(new X500Principal(\"CN=test\"))\n            .setSerialNumber(BigInteger.ONE)\n            .setStartDate(notBefore.getTime())\n            .setEndDate(notAfter.getTime())\n            .build();\n        KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\");\n        generator.initialize(spec);\n\n        KeyPair keyPair = generator.generateKeyPair();\n    }\n    int nAfter = keyStore.size();\n    Log.v(TAG, \"Before = \" + nBefore + \" After = \" + nAfter);\n\n    // Retrieve the keys\n    KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null);\n    RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey();\n    RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey();\n\n    Log.v(TAG, \"private key = \" + privateKey.toString());\n    Log.v(TAG, \"public key = \" + publicKey.toString());\n\n    // Encrypt the text\n    String plainText = \"This text is supposed to be a secret!\";\n    String dataDirectory = getApplicationInfo().dataDir;\n    String filesDirectory = getFilesDir().getAbsolutePath();\n    String encryptedDataFilePath = filesDirectory + File.separator + \"keep_yer_secrets_here\";\n\n    Log.v(TAG, \"plainText = \" + plainText);\n    Log.v(TAG, \"dataDirectory = \" + dataDirectory);\n    Log.v(TAG, \"filesDirectory = \" + filesDirectory);\n    Log.v(TAG, \"encryptedDataFilePath = \" + encryptedDataFilePath);\n\n    Cipher inCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"AndroidOpenSSL\");\n    inCipher.init(Cipher.ENCRYPT_MODE, publicKey);\n\n    Cipher outCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"AndroidOpenSSL\");\n    outCipher.init(Cipher.DECRYPT_MODE, privateKey);\n\n    CipherOutputStream cipherOutputStream = \n        new CipherOutputStream(\n            new FileOutputStream(encryptedDataFilePath), inCipher);\n    cipherOutputStream.write(plainText.getBytes(\"UTF-8\"));\n    cipherOutputStream.close();\n\n    CipherInputStream cipherInputStream = \n        new CipherInputStream(new FileInputStream(encryptedDataFilePath),\n            outCipher);\n    byte [] roundTrippedBytes = new byte[1000]; // TODO: dynamically resize as we get more data\n\n    int index = 0;\n    int nextByte;\n    while ((nextByte = cipherInputStream.read()) != -1) {\n        roundTrippedBytes[index] = (byte)nextByte;\n        index++;\n    }\n    String roundTrippedString = new String(roundTrippedBytes, 0, index, \"UTF-8\");\n    Log.v(TAG, \"round tripped string = \" + roundTrippedString);\n\n} catch (NoSuchAlgorithmException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (NoSuchProviderException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (InvalidAlgorithmParameterException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (KeyStoreException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (CertificateException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (IOException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (UnrecoverableEntryException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (NoSuchPaddingException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (InvalidKeyException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (BadPaddingException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (IllegalBlockSizeException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (UnsupportedOperationException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n}\n", "HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n\nDefaultHttpClient client = new DefaultHttpClient();\n\nSchemeRegistry registry = new SchemeRegistry();\nSSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();\nsocketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\nregistry.register(new Scheme(\"https\", socketFactory, 443));\nSingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);\nDefaultHttpClient httpClient = new DefaultHttpClient(mgr, client.getParams());\n\n// Set verifier     \nHttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n\n// Example send http request\nfinal String url = \"https://encrypted.google.com/\";\nHttpPost httpPost = new HttpPost(url);\nHttpResponse response = httpClient.execute(httpPost);\n", "public class MyHttpClient1 extends DefaultHttpClient {\n\n    final Context context;\n\n\n    MyHttpClient1 mHttpClient=null;\n\n    public MyHttpClient1(Context context) {\n          this.context = context;\n    }\n\n    @Override\n    protected ClientConnectionManager createClientConnectionManager() {\n      SchemeRegistry registry = new SchemeRegistry();\n        KeyStore trustStore = null;\n        try {\n            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        } catch (KeyStoreException e) {\n            e.printStackTrace();  \n        }\n        try {\n            trustStore.load(null, null);\n        } catch (IOException e) {\n            e.printStackTrace();  \n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();  \n        } catch (CertificateException e) {\n            e.printStackTrace();  \n        }\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n      // Register for port 443 our SSLSocketFactory with our keystore\n      // to the ConnectionManager\n        try {\n            registry.register(new Scheme(\"https\",new MySSLSocketFactory(trustStore), 443));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();  \n        } catch (KeyManagementException e) {\n            e.printStackTrace();  \n        } catch (KeyStoreException e) {\n            e.printStackTrace();  \n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();  \n        }\n        return new SingleClientConnManager(getParams(), registry);\n    }\n\n    public class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"SSL\");   //or TLS\n\n    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n\n}\n", "private String getShaKey() {\n        //fucnion para saber si esta bien registrado el codigo de googlemaps\n        //ME SALE EXCEPTION DE NOMBRE NO ENCONTRADO?\u00c2\u00bf?\u00c2\u00bf\n        String strRet=\"\";\n         try {\n         PackageInfo info = getPackageManager().getPackageInfo(\"your.package.name\",\n         PackageManager.GET_SIGNATURES);\n         for (Signature signature : info.signatures) {\n         MessageDigest md = MessageDigest.getInstance(\"SHA\");\n         md.update(signature.toByteArray());\n         //Log.v(TAG, \"KeyHash:\" + Base64.encodeToString(md.digest(),\n         strRet=\"KeyHash:\" + Base64.encodeToString(md.digest(),Base64.DEFAULT);\n\n         }\n\n         } catch (NameNotFoundException e) {\n            //e.printStackTrace();\n         strRet=\"EXCEPTION NOMBRE NO ENCONTRADO\";\n             } catch (NoSuchAlgorithmException  e) {\n         //e.printStackTrace();\n         strRet=\"EXCEPTION ALGORITMO NO\";\n         }\n        return strRet;\n\n         }\n", "// lets use the actual key value instead of the platform specific character decoding\nbyte[] secret = Hex.decodeHex(\"25d6c7fe35b9979a161f2136cd13b0ff\".toCharArray());\n\n// that's fine\nSecretKeySpec secretKey = new SecretKeySpec(secret, \"AES\");\n\n// SecureRandom should either be slow or be implemented in hardware\nSecureRandom random = new SecureRandom();\n\n// first create the cipher\nCipher eCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n// filled with 00h characters first, use Cipher instance so you can switch algorithms\nbyte[] realIV = new byte[eCipher.getBlockSize()];\n\n// actually fill with random\nrandom.nextBytes(realIV);\n\n// MISSING: create IvParameterSpec\nIvParameterSpec ivSpec = new IvParameterSpec(realIV);\n\n// create the cipher using the IV\neCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n\n// NOTE: you should really not encrypt passwords for verification\nString stringToEncrypt = \"mypassword\";\n\n// convert to bytes first, but don't use the platform encoding\nbyte[] dataToEncrypt = stringToEncrypt.getBytes(Charset.forName(\"UTF-8\"));\n\n// actually do the encryption using the data\nbyte[] encryptedData = eCipher.doFinal(dataToEncrypt);\n", "PackageInfo info;\ntry {\n    info = getPackageManager().getPackageInfo(\"com.example.yourpackagename\", PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String something = new String(Base64.encode(md.digest(), 0));\n        //String something = new String(Base64.encodeBytes(md.digest()));\n        Log.e(\"hash key\", something);\n    }\n} catch (NameNotFoundException e1) {\n    Log.e(\"name not found\", e1.toString());\n} catch (NoSuchAlgorithmException e) {\n    Log.e(\"no such an algorithm\", e.toString());\n} catch (Exception e) {\n    Log.e(\"exception\", e.toString());\n}  \n", "public String getEncrypt(final byte[] iv, final String message) throws GeneralSecurityException, NullPointerException {\n  if (key.isEmpty())\n    throw new NullPointerException();\n\n  final byte[] rawData = key.getBytes(Charset.forName(\"US-ASCII\"));\n  if (rawData.length != 16) {\n    // If this is not 16 in length, there's a problem with the key size, nothing to do here\n    throw new IllegalArgumentException(\"You've provided an invalid key size\");\n  }\n\n  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, \"AES\");\n  final Cipher ciph = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n  ciph.init(Cipher.ENCRYPT_MODE, seckeySpec, new IvParameterSpec(iv));\n\n  byte[] encryptedBA = ciph.doFinal(message.getBytes(Charset.forName(\"US-ASCII\")));\n  try {\n    final String encryptedText = new String(Base64.encode(encryptedBA, Base64.DEFAULT), \"UTF-8\");\n    return encryptedText.toString();\n  } \n  catch (final UnsupportedEncodingException e1) { }\n  return \"\";\n}\n", "public String getDecrypt(final byte[] encrypted) throws GeneralSecurityException, NullPointerException {\n  if (key.isEmpty())\n    throw new NullPointerException();\n\n  final byte[] rawData = key.getBytes(Charset.forName(\"US-ASCII\"));\n  if (rawData.length != 16) {\n    // If this is not 16 in length, there's a problem with the key size, nothing to do here\n    throw new IllegalArgumentException(\"Invalid key size.\");\n  }\n\n  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, \"AES\");\n\n  final Cipher ciph = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n  ciph.init(Cipher.DECRYPT_MODE, seckeySpec, new IvParameterSpec(new byte[16]));\n  final byte[] decryptedmess = ciph.doFinal(encrypted);\n\n  return new String(decryptedmess, Charset.forName(\"US-ASCII\"));\n}\n", "private static final byte[] CACERTROOTDER = new byte[]{\n        48, -126, 7, 61, 48, -126, 5, 37, -96, 3, 2, 1, 2, 2, 1, 0,\n        // ...\n        };\n\n/**\n * Read x509 certificated file from byte[].\n *\n * @param bytes certificate in der format\n * @return certificate\n */\nprivate static X509Certificate getCertificate(final byte[] bytes)\n        throws IOException, CertificateException {\n    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n    X509Certificate ca;\n    ByteArrayInputStream is = new ByteArrayInputStream(bytes);\n    try {\n        ca = (X509Certificate) cf.generateCertificate(is);\n        Log.d(TAG, \"ca=\", ca.getSubjectDN());\n    } finally {\n        is.close();\n    }\n    return ca;\n}\n\n/**\n * Trust only CAcert's CA. CA cert is injected as byte[]. Following best practices from\n * https://developer.android.com/training/articles/security-ssl.html#UnknownCa\n */\nprivate static void trustCAcert()\n        throws KeyStoreException, IOException,\n        CertificateException, NoSuchAlgorithmException,\n        KeyManagementException {\n    // Create a KeyStore containing our trusted CAs\n    String keyStoreType = KeyStore.getDefaultType();\n    final KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n    keyStore.load(null, null);\n    keyStore.setCertificateEntry(\"CAcert-root\", getCertificate(CACERTROOTDER));\n    // if your HTTPd is not sending the full chain, add class3 cert to the key store\n    // keyStore.setCertificateEntry(\"CAcert-class3\", getCertificate(CACERTCLASS3DER));\n\n    // Create a TrustManager that trusts the CAs in our KeyStore\n    final TrustManagerFactory tmf = TrustManagerFactory.getInstance(\n            TrustManagerFactory.getDefaultAlgorithm());\n    tmf.init(keyStore);\n\n    // Create an SSLContext that uses our TrustManager\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n        // may work on HC+, but there is no AVD or device to test it\n        sslContext.init(null, tmf.getTrustManagers(), null);\n    } else {\n        // looks like CLR is broken in lower APIs. implement out own checks here :x\n        // see http://stackoverflow.com/q/18713966/2331953\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n            public boolean verify(final String hostname, final SSLSession session) {\n                try {\n                    // check if hostname matches DN\n                    String dn = session.getPeerCertificateChain()[0].getSubjectDN().toString();\n\n                    Log.d(TAG, \"DN=\", dn);\n                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD) {\n                        return dn.equals(\"CN=\" + hostname);\n                    } else {\n                        // no SNI on API&lt;9, but I know the first vhost's hostname\n                        return dn.equals(\"CN=\" + hostname)\n                                || dn.equals(\"CN=\" + hostname.replace(\"jsonrpc\", \"rest\"));\n                    }\n                } catch (Exception e) {\n                    Log.e(TAG, \"unexpected exception\", e);\n                    return false;\n                }\n            }\n        });\n\n        // build our own trust manager\n        X509TrustManager tm = new X509TrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                // nothing to do\n                return new X509Certificate[0];\n            }\n\n            @Override\n            public void checkClientTrusted(final X509Certificate[] chain,\n                    final String authType)\n                    throws CertificateException {\n                // nothing to do\n            }\n\n            @Override\n            public void checkServerTrusted(final X509Certificate[] chain,\n                    final String authType) throws CertificateException {\n                // nothing to do\n                Log.d(TAG, \"checkServerTrusted(\", chain, \")\");\n                X509Certificate cert = chain[0];\n\n                cert.checkValidity();\n\n                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                ArrayList&lt;X509Certificate&gt; list = new ArrayList&lt;X509Certificate&gt;();\n                list.add(cert);\n                CertPath cp = cf.generateCertPath(list);\n                try {\n                    PKIXParameters params = new PKIXParameters(keyStore);\n                    params.setRevocationEnabled(false); // CLR is broken, remember?\n                    CertPathValidator cpv = CertPathValidator\n                            .getInstance(CertPathValidator.getDefaultType());\n                    cpv.validate(cp, params);\n                } catch (KeyStoreException e) {\n                    Log.d(TAG, \"invalid key store\", e);\n                    throw new CertificateException(e);\n                } catch (InvalidAlgorithmParameterException e) {\n                    Log.d(TAG, \"invalid algorithm\", e);\n                    throw new CertificateException(e);\n                } catch (NoSuchAlgorithmException e) {\n                    Log.d(TAG, \"no such algorithm\", e);\n                    throw new CertificateException(e);\n                } catch (CertPathValidatorException e) {\n                    Log.d(TAG, \"verification failed\");\n                    throw new CertificateException(e);\n                }\n                Log.d(TAG, \"verification successful\");\n            }\n        };\n        sslContext.init(null, new X509TrustManager[]{tm}, null);\n    }\n\n    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n}\n", "KeyStore androidKeyStore = KeyStore.getInstance(LocalKeyStore.ANDROID_KEYSTORE);\nandroidKeyStore.load(null);\n\nX509Certificate signedClientCertificate = (X509Certificate)androidKeyStore.getCertificate(\"X-Signed\");\nKeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)androidKeyStore.getEntry(\"X\", null);\n\nX509ExtendedKeyManager keyManager = new X509ExtendedKeyManager() {\n    @Override\n    public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {\n        return clientCertificateAlias;\n    }\n    @Override\n    public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {\n        return null; // different if you're validating the server's cert\n    }\n    @Override\n    public X509Certificate[] getCertificateChain(String alias) {\n        return new X509Certificate[] { signedClientCertificate };\n    }\n    @Override\n    public String[] getClientAliases(String keyType, Principal[] issuers) {\n        return new String[]{ \"X\" };\n    }\n\n    @Override\n    public String[] getServerAliases(String keyType, Principal[] issuers) {\n        return null; // different if you're validating server's cert\n    }\n    @Override\n    public PrivateKey getPrivateKey(String alias) {\n        if(alias != clientCertificateAlias) {\n            Log.e(TAG, String.format(\"X509ExtendedKeyManager is asking for privateKey with unknown alias %s. Expecting it to ask for %s\", alias, clientCertificateAlias));\n            return null;\n        }\n        return privateKeyEntry.getPrivateKey();\n    }\n};\n\nX509TrustManager trustServerCertificates = new X509TrustManager() {\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        // do nothing, this method doesn't get called\n    }\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) \n        // code to validate server's cert in here\n    }\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null; // any issuer\n    }\n};\n\nm_sslContext = SSLContext.getInstance(\"TLS\");\nm_sslContext.init(new KeyManager[]{ keyManager }, new TrustManager[] { trustServerCertificates }, null);\n\n// later on\n\nconn = (HttpURLConnection)url.openConnection();\nSSLContext sslContext = m_sslContext;\n\nif(conn instanceof HttpsURLConnection &amp;&amp; sslContext != null) {\n    ((HttpsURLConnection)conn).setSSLSocketFactory(sslContext.getSocketFactory());\n}\n", "    KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"X509\");\n    kmf.init(keystore, \"password\".toCharArray());\n    sslContext.init(kmf.getKeyManagers(), new TrustManager[]{tm}, null);\n", "         public class sha1Calculate {\n\n        public static void main(String[] args)throws Exception\n        {\n             File file = new File(\"D:\\\\Android Links.txt\");\n            String outputTxt= \"\";\n            String hashcode = null;\n\n            try {\n\n                FileInputStream input = new FileInputStream(file);\n\n                ByteArrayOutputStream output = new ByteArrayOutputStream ();\n                byte [] buffer = new byte [65536];\n                int l;\n\n                while ((l = input.read (buffer)) &gt; 0)\n                    output.write (buffer, 0, l);\n\n                input.close ();\n                output.close ();\n\n                byte [] data = output.toByteArray ();\n\n\n                    MessageDigest digest = MessageDigest.getInstance( \"SHA-1\" ); \n\n                byte[] bytes = data;\n\n                digest.update(bytes, 0, bytes.length);\n                bytes = digest.digest();\n\n                StringBuilder sb = new StringBuilder();\n\n                for( byte b : bytes )\n                {\n                    sb.append( String.format(\"%02X\", b) );\n                }\n\n                    System.out.println(\"Digest(in hex format):: \" + sb.toString());\n\n\n            }catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        }\n", "ks = KeyStore.getInstance(\"AndroidKeyStore\");\nks.load(null);\nKeyStore.PrivateKeyEntry keyEntry = (KeyStore.PrivateKeyEntry)ks.getEntry(\"Keys\", null);\npublicKey = (RSAPublicKey) keyEntry.getCertificate().getPublicKey();\n", "SSLContext sslcontext = SSLContext.getInstance(\"TLSv1\");\nsslcontext.init(null, null, null);\nSSLSocketFactory noSSLv3Factory = new TlsOnlySocketFactory(sc.getSocketFactory());\nHttpsURLConnection.setDefaultSSLSocketFactory(noSSLv3Factory);\n", "    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.kartag.gui\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "private byte[] key = { (byte) 141, 75, 21, 92, (byte) 201, (byte) 255,\n        (byte) 129, (byte) 229, (byte) 203, (byte) 246, (byte) 250, 120,\n        25, 54, 106, 62, (byte) 198, 33, (byte) 166, 86, 65, 108,\n        (byte) 215, (byte) 147 };\n\nprivate final byte[] iv = { 0x1E, 0x39, (byte) 0xF3, 0x69, (byte) 0xE9, 0xD,\n        (byte) 0xB3, 0x3A, (byte) 0xA7, 0x3B, 0x44, 0x2B, (byte) 0xBB,\n        (byte) 0xB6, (byte) 0xB0, (byte) 0xB9 };\n   long start = System.currentTimeMillis();\n\n    // create paths\n    backupPath = Environment.getExternalStorageDirectory()\n            .getAbsolutePath() + \"/WhatsApp/Databases/msgstore.db.crypt5\";\n    outputPath = Environment.getExternalStorageDirectory()\n            .getAbsolutePath() + \"/WhatsApp/Databases/msgstore.db.decrypt\";\n\n    File backup = new File(backupPath);\n\n    // check if file exists / is accessible\n    if (!backup.isFile()) {\n        Log.e(TAG, \"Backup file not found! Path: \" + backupPath);\n        return;\n    }\n\n    // acquire account name\n    AccountManager manager = AccountManager.get(this);\n    Account[] accounts = manager.getAccountsByType(\"com.google\");\n\n    if (accounts.length == 0) {\n        Log.e(TAG, \"Unable to fetch account!\");\n        return;\n    }\n\n    String account = accounts[0].name;\n\n    try {\n        // calculate md5 hash over account name\n        MessageDigest message = MessageDigest.getInstance(\"MD5\");\n        message.update(account.getBytes());\n        byte[] md5 = message.digest();\n\n        // generate key for decryption\n        for (int i = 0; i &lt; 24; i++)\n            key[i] ^= md5[i &amp; 0xF];\n\n        // read encrypted byte stream\n        byte[] data = new byte[(int) backup.length()];\n        DataInputStream reader = new DataInputStream(new FileInputStream(\n                backup));\n        reader.readFully(data);\n        reader.close();\n\n        // create output writer\n        File output = new File(outputPath);\n        DataOutputStream writer = new DataOutputStream(\n                new FileOutputStream(output));\n\n        // decrypt file\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec secret = new SecretKeySpec(key, \"AES\");\n        IvParameterSpec vector = new IvParameterSpec(iv);\n        cipher.init(Cipher.DECRYPT_MODE, secret, vector);\n        writer.write(cipher.update(data));\n        writer.write(cipher.doFinal());\n        writer.close();\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(TAG, \"Could not acquire hash algorithm!\", e);\n        return;\n    } catch (IOException e) {\n        Log.e(TAG, \"Error accessing file!\", e);\n        return;\n    } catch (Exception e) {\n        Log.e(TAG, \"Something went wrong during the encryption!\", e);\n        return;\n    }\n\n    long end = System.currentTimeMillis();\n\n    Log.i(TAG, \"Success! It took \" + (end - start) + \"ms\");\n", "URLConnection connection = null;\nconnection =  address.openConnection();\npost = (HttpsURLConnection) connection;\npost.setSSLSocketFactory(context.getSocketFactory()); \npost.setDoInput(true);\npost.setDoOutput(true);\n\n// Connecting to a server will fail with a SocketTimeoutException if the timeout     elapses before a connection is established\npost.setConnectTimeout(Const.CONNECTION_TIMEOUT_DELAY);\npost.setRequestMethod(\"POST\");  // throws ProtocolException\n\n\npost.setRequestProperty(\"soapaction\",\"\");\npost.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\npost.setRequestProperty(\"Authorization\", \"Basic \" +         Base64.encodeToString(strCredentials.getBytes(), Base64.NO_WRAP));\n            post.setRequestProperty(\"Content-Length\",           String.valueOf(requestEnvelope.length()));\n", "public static Direction parseString(String direction){\n    if(direction != null){\n        //trim the input since I never trust user input\n        direction = direction.trim();\n\n        for(Direction d : Direction.values()){\n            if(d.toString().equalsIgnoreCase(direction)){\n                return d;\n            }\n        }\n    }\n\n    return null;\n}\n", "Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);\n\nECGenParameterSpec brainpoolP160R1 = new ECGenParameterSpec(\"brainpoolP256t1\");\nKeyPairGenerator kpg = null;\ntry {\n    kpg = (KeyPairGenerator) KeyPairGenerator.getInstance(\"ECIES\", \"SC\");\n} catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n    e.printStackTrace();\n}\n\ntry {\n    kpg.initialize(brainpoolP160R1, new SecureRandom());\n} catch (InvalidAlgorithmParameterException e) {\n    e.printStackTrace();\n}\n\nKeyPair akey = kpg.generateKeyPair();\nKeyPair bkey = kpg.generateKeyPair();\n// PublicKey publicKey = keyPair.getPublic();\n//PrivateKey privateKey = keyPair.getPrivate();\n\nbyte[] d = new byte[]{1, 2, 3, 4, 5, 6, 7, 8};\nbyte[] e = new byte[]{8, 7, 6, 5, 4, 3, 2, 1};\n\nIESParameterSpec param = new IESParameterSpec(d, e, 256);\n\nCipher c = null;\n\ntry {\n    c = Cipher.getInstance(\"ECIES\");\n} catch (NoSuchAlgorithmException | NoSuchPaddingException f) {\n    f.printStackTrace();\n}\n\ntry {\n    c.init(Cipher.ENCRYPT_MODE, new IEKeySpec(akey.getPrivate(), bkey.getPublic()), param);\n    //c.init(Cipher.ENCRYPT_MODE, c1Key, param);\n    //c.init(Cipher.ENCRYPT_MODE, publicKey, new SecureRandom());\n    // How can i put the AES128_CBC for ies parameter ? is that possible\n} catch (InvalidKeyException | InvalidAlgorithmParameterException f) {\n    f.printStackTrace();\n}\nbyte[] message = theTestText.getBytes();\nbyte[] cipher = new byte[0];\ntry {\n    cipher = c.doFinal(message);//,0,message.length);\n} catch (IllegalBlockSizeException | BadPaddingException f) {\n    f.printStackTrace();\n}\n\nTextView eccencoded = (TextView) findViewById(R.id.eccencoded);\neccencoded.setText(\"[ENCODED]:\\n\" +\n        new String(cipher) + \"\\n\");\n\ntry {\n    c.init(Cipher.DECRYPT_MODE, new IEKeySpec(bkey.getPrivate(), akey.getPublic()), param);\n} catch (InvalidKeyException | InvalidAlgorithmParameterException f) {\n    f.printStackTrace();\n}\n\nbyte[] plaintext = new byte[0];\ntry {\n    plaintext = c.doFinal(cipher);\n} catch (IllegalBlockSizeException | BadPaddingException f) {\n    f.printStackTrace();\n}\nTextView eccdecoded = (TextView) findViewById(R.id.eccdecoded);\neccdecoded.setText(\"[DECODED]:\\n\" +\n        new String(plaintext) + \"\\n\");\n", "public class FakeX509TrustManager implements X509TrustManager { \n\n    private static TrustManager[] trustManagers; \n    private static final X509Certificate[] _AcceptedIssuers = new \nX509Certificate[] {}; \n\n    @Override \n    public void checkClientTrusted(X509Certificate[] chain, String \nauthType) throws CertificateException { \n    } \n\n    @Override \n    public void checkServerTrusted(X509Certificate[] chain, String \nauthType) throws CertificateException { \n    } \n\n    public boolean isClientTrusted(X509Certificate[] chain) { \n            return true; \n    } \n\n    public boolean isServerTrusted(X509Certificate[] chain) { \n            return true; \n    } \n\n    @Override \n    public X509Certificate[] getAcceptedIssuers() { \n            return _AcceptedIssuers; \n    } \n\n    public static void allowAllSSL() { \n            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() \n{ \n                    @Override \n                    public boolean verify(String hostname, SSLSession session) { \n                            return true; \n                    } \n\n            }); \n\n            SSLContext context = null; \n            if (trustManagers == null) { \n                    trustManagers = new TrustManager[] { new FakeX509TrustManager() }; \n            } \n\n            try { \n                    context = SSLContext.getInstance(\"TLS\"); \n                    context.init(null, trustManagers, new SecureRandom()); \n            } catch (NoSuchAlgorithmException e) { \n                    e.printStackTrace(); \n            } catch (KeyManagementException e) { \n                    e.printStackTrace(); \n            } \n\n       HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory()); \n    } \n\n} \n", "public class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        KeyStore ks = null;\n        try {\n            ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null,null);\n\n            // Add certs or keys\n\n            ks.store(new FileOutputStream(new File(getFilesDir(),\"out.bks\")),\"password\".toCharArray());\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static {\n        Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);\n    }\n}\n", "String publicKeyB64 = \"MIGHAoGBAOX+TFdFVIKYyCVxWlnbGYbmgkkmHmEv2qStZzAFt6NVqKPLK989Ow0RcqcDTZaZBfO5\"\n        + \"5JSVHNIKoqULELruACfqtGoATfgwBp4Owfww8M891gKNSlI/M0yzDQHns5CKwPE01jD6qGZ8/2IZ\"\n        + \"OjLJNH6qC9At8iMCbPe9GeXIPFWRAgER\";\n// ok, you may need to use the Base64 decoder of bouncy or Android instead\nbyte[] decoded = Base64.getDecoder().decode(publicKeyB64);\norg.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey.getInstance(decoded);\nBigInteger modulus = pkcs1PublicKey.getModulus();\nBigInteger publicExponent = pkcs1PublicKey.getPublicExponent();\nRSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, publicExponent);\nKeyFactory kf = KeyFactory.getInstance(\"RSA\");\nPublicKey generatedPublic = kf.generatePublic(keySpec);\nSystem.out.printf(\"Modulus: %X%n\", modulus);\nSystem.out.printf(\"Public exponent: %d ... 17? Why?%n\", publicExponent); // 17? OK.\nSystem.out.printf(\"See, Java class result: %s, is RSAPublicKey: %b%n\", generatedPublic.getClass().getName(), generatedPublic instanceof RSAPublicKey);\n", "private void calculateHashKey(String yourPackageName) {\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                yourPackageName,\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\",\n                    Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n}\n", " public class MySSLSocketFactory extends SSLSocketFactory {\n SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n public MySSLSocketFactory(KeyStore truststore)\n        throws NoSuchAlgorithmException, KeyManagementException,\n        KeyStoreException, UnrecoverableKeyException {\n    super(truststore);\n\n    TrustManager tm = new X509TrustManager() {\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain,\n                                       String authType) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain,\n                                       String authType) throws CertificateException {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n\n    sslContext.init(null, new TrustManager[]{tm}, null);\n}\n\n@Override\npublic Socket createSocket(Socket socket, String host, int port,\n                           boolean autoClose) throws IOException, UnknownHostException {\n    return sslContext.getSocketFactory().createSocket(socket, host, port,\n            autoClose);\n}\n\n@Override\npublic Socket createSocket() throws IOException {\n    return sslContext.getSocketFactory().createSocket();\n}\n }\n", "   public static DefaultHttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n\n    } catch (UnrecoverableKeyException e) {\n        return new DefaultHttpClient();\n    } catch (NoSuchAlgorithmException e) {\n        return new DefaultHttpClient();\n    } catch (CertificateException e) {\n        return new DefaultHttpClient();\n    } catch (IOException e) {\n        return new DefaultHttpClient();\n    } catch (KeyStoreException e) {\n        return new DefaultHttpClient();\n    } catch (KeyManagementException e) {\n        return new DefaultHttpClient();\n    }\n}\n", "  private X509Certificate getCertFromFile(String path) throws Exception {\n     AssetManager assetManager = MyActivity.this.getResources().getAssets();\n     InputStream inputStream = null;\n     try {\n         inputStream = assetManager.open(path);\n     } catch (IOException e) {\n         e.printStackTrace();\n     }\n     InputStream caInput = new BufferedInputStream(inputStream);\n     X509Certificate cert = null;\n     CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n     cert = (X509Certificate) cf.generateCertificate(caInput);\n     cert.getSerialNumber();\n     return cert;\n  }\n", "String redirect = urlConnection.getHeaderField(\"Location\");\n        if(redirect != null)    //truth before ICS\n        {\n            urlConnection.disconnect();\n\n            urlConnection = (HttpsURLConnection) (new URL(redirect)).openConnection();\n            urlConnection.setRequestProperty(\"User-Agent\", userAgent);\n            urlConnection.setRequestProperty(\"Cookie\", cookie);\n            urlConnection.setRequestMethod(\"POST\");\n            urlConnection.setDoInput(true);\n            urlConnection.setDoOutput(true);\n\n            urlConnection.setSSLSocketFactory(getSocketFactory());\n\n            OutputStream os2 = urlConnection.getOutputStream();\n            BufferedWriter writer2 = new BufferedWriter(\n                    new OutputStreamWriter(os2, \"UTF-8\"));\n            writer2.write(postData);\n            writer2.flush();\n            writer2.close();\n            os2.close();\n\n            urlConnection.connect();\n        }\n", "    boolean httpYes, httpsYes;\n     try {\n\n      URL url = new URL(weburi);\n      urlConnection = (HttpURLConnection) url.openConnection();\n      inputStream = new BufferedInputStream((urlConnection.getInputStream()));\n    httpYes = True;\n    }\n\n\n    catch (Exception e) {\n    //Toast Message displays and settings intent re-starts\n          URL url = new URL(weburi);\n          urlHttpsConnection = (HttpsURLConnection) url.openConnection();\n          urlHttpsConnection.setSSLSocketFactory(context.getSocketFactory());\n          inputStream = urlHttpsConnection.getInputStream();\n          https=True;\n    }\n", "public class Home extends Activity {\n\n    public List&lt;PeerConnection.IceServer&gt; iceServers;\n    private GLSurfaceView videoView;\n    public static SocketIO socket;\n    ArrayList&lt;String&gt; userIDs = new ArrayList&lt;&gt;();\n    private static final String FIELD_TRIAL_VP9 = \"WebRTC-SupportVP9/Enabled/\";\n    String RoomId = \"\";\n    String sreverURL = \"http://xx.xx.xx.xx:xxxx/\";\n    private EditText roomid;\n    private VideoRenderer.Callbacks remote_view;\n    private VideoRenderer.Callbacks local_view;\n    protected PeerConnectionFactory factory;\n    PeerConnectionFactory.Options options = null;\n    Events pc_events;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_home);\n        videoView = (GLSurfaceView) findViewById(R.id.glview_call_remote);\n        VideoRendererGui.setView(videoView, new Runnable() {\n            @Override\n            public void run() {\n                createPeerConnectionFactory();\n            }\n        });\n\n        remote_view = VideoRendererGui.create(0, 0, 100, 100, ScalingType.SCALE_ASPECT_FIT, false);\n        local_view = VideoRendererGui.create(0, 0, 100, 100, ScalingType.SCALE_ASPECT_FILL, true);\n        iceServers = new ArrayList&lt;&gt;();\n        IceServer icc = new IceServer(\"stun:stun.l.google.com:19302\", \"\", \"\");\n        iceServers.add(icc);\n        roomid = (EditText) findViewById(R.id.roomId);\n        Random rand = new Random();\n        roomid.setText(\"\" + rand.nextInt(9999));\n        pc_events = new peerEventHandler();\n    }\n\n    private void createPeerConnectionFactory() {\n        runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                PeerConnectionFactory.initializeFieldTrials(FIELD_TRIAL_VP9);\n                PeerConnectionFactory.initializeAndroidGlobals(Home.this, true, true, true, VideoRendererGui.getEGLContext());\n                try {\n                    factory = new PeerConnectionFactory();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n\n    public void ondail(View view) {\n\n        try {\n\n            try {\n                SocketIO.setDefaultSSLSocketFactory(SSLContext.getDefault());\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n            }\n\n            socket = new SocketIO();\n\n            socket.connect(sreverURL, new IOCallback() {\n\n                @Override\n                public void onMessage(JSONObject json, IOAcknowledge ack) {\n                }\n                @Override\n                public void onMessage(String data, IOAcknowledge ack) {\n                }\n                @Override\n                public void onError(SocketIOException socketIOException) {\n                    socketIOException.printStackTrace();\n                }\n                @Override\n                public void onDisconnect() {\n                }\n                @Override\n                public void onConnect() {\n                    showToast(\"Connected to \" + sreverURL);\n                }\n                @Override\n                public void on(final String event, IOAcknowledge ack, final Object... args) {\n\n                    Log.e(\"Socked.on\", event + \", \" + args);\n                    switch (getEvent(event)) {\n\n                        case LOG :\n                            break;\n                        case MESSAGE :\n                            if (args instanceof Object[]) {\n                                pc_events.setMessage(args[0].toString());\n                            } else {\n                                pc_events.setMessage(args.toString());\n                            }\n                            break;\n                        case CREATED :\n                            runOnUiThread(new Runnable() {\n                                public void run() {\n                                    showToast(\"Room Created \" + args[0]);\n                                }\n                            });\n                            break;\n                        case BROADCAST :\n                            break;\n                        case JOIN :\n                            break;\n                        case EMIT :\n                            Log.e(\"Socked.onEMIT\", args.toString());\n                            startCall();\n                            pc_events.createOffer();\n                            break;\n\n                        case ERROR :\n                            Log.e(\"Socked.onERROR\", args.toString());\n                            break;\n\n                        default :\n\n                            break;\n                    }\n                }\n            });\n\n            try {\n                RoomId = roomid.getText().toString();\n            } catch (Exception e) {\n            }\n\n            socket.emit(\"create or join\", RoomId);\n\n        } catch (MalformedURLException e) {\n\n            e.printStackTrace();\n        }\n\n    }\n\n    public void oncancel(View view) {\n\n    }\n\n    public SocketEvent getEvent(String eventString) {\n\n        SocketEvent eventType;\n\n        try {\n\n            if (eventString.contains(\"log\")) {\n                eventType = SocketEvent.LOG;\n            } else if (eventString.contains(\"created\")) {\n                eventType = SocketEvent.CREATED;\n            } else if (eventString.contains(\"emit():\")) {\n                eventType = SocketEvent.EMIT;\n            }\n\n            else if (eventString.contains(\"broadcast():\")) {\n                eventType = SocketEvent.BROADCAST;\n            } else if (eventString.contains(\"message\")) {\n                eventType = SocketEvent.MESSAGE;\n            } else if (eventString.toLowerCase().substring(0, 20).contains(\"join\")) {\n                eventType = SocketEvent.JOIN;\n            } else {\n                eventType = SocketEvent.ERROR;\n            }\n\n        } catch (Exception e) {\n            eventType = SocketEvent.ERROR;\n        }\n\n        return eventType;\n\n    }\n\n    public static interface Events {\n\n        public void peerConnectionEvent(VideoRenderer.Callbacks localRender, VideoRenderer.Callbacks remoteRender);\n\n        public void setFactory(PeerConnectionFactory factory);\n\n        public void setMessage(String message);\n        public void createOffer();\n\n        public void sendMessage(String msg);\n    }\n\n    private void startCall() {\n\n        pc_events.setFactory(factory);\n\n        pc_events.peerConnectionEvent(remote_view, local_view);\n\n    }\n\n    public void showToast(final String message) {\n\n        runOnUiThread(new Runnable() {\n            public void run() {\n                Toast.makeText(Home.this, message, Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n\n    public void makeOffer(View v) {\n        pc_events.sendMessage(\"Hello\");\n    }\n\n}\n", "public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.facebook.samples.hellofacebook\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "protected PublicKey generatePublicKey(String encodedPublicKey) {\n    try {\n        byte[] decodedKey = Base64.decode(encodedPublicKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);\n        return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    } catch (InvalidKeySpecException e) {\n        Log.e(BillingController.LOG_TAG, \"Invalid key specification.\");\n        throw new IllegalArgumentException(e);\n    } catch (Base64DecoderException e) {\n        Log.e(BillingController.LOG_TAG, \"Base64 decoding failed.\");\n        throw new IllegalArgumentException(e);\n    }\n}\n", "private static char[] hextable = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\npublic static String byteArrayToHex(byte[] array) {\n    String s = \"\";\n    for (int i = 0; i &lt; array.length; ++i) {\n        int di = (array[i] + 256) &amp; 0xFF; // Make it unsigned\n        s = s + hextable[(di &gt;&gt; 4) &amp; 0xF] + hextable[di &amp; 0xF];\n    }\n    return s;\n}\n\npublic static String digest(String s, String algorithm) {\n    MessageDigest m = null;\n    try {\n        m = MessageDigest.getInstance(algorithm);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n        return s;\n    }\n\n    m.update(s.getBytes(), 0, s.length());\n    return byteArrayToHex(m.digest());\n}\n\npublic static String md5(String s) {\n    return digest(s, \"MD5\");\n}\n", "   /**\n    * @param initialNoise device/app identifier. Use as many sources as possible to\n    *    create this unique identifier.\n    */\n   public PixieObfuscator(String initialNoise) {\n        try {\n            // Hash up the initial noise into something smaller:\n            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n            md.update(initialNoise.getBytes());\n            byte[] hash = md.digest();\n\n            // Allocate a buffer for our actual AES key:\n            byte[] aesKEY = new byte[AES_KEY_LENGTH];   \n\n            // Fill it with our lucky byte to take up whatever slack is not filled by hash:\n            Arrays.fill(aesKEY, LUCKY_BYTE);\n\n            // Copy in as much of the hash as we got (should be twenty bytes, take as much as we can):\n            for (int i = 0; i &lt; hash.length &amp;&amp; i &lt; aesKEY.length; i++)\n                aesKEY[i] = hash[i];\n\n            // Now make the damn AES key object:\n              secret = new SecretKeySpec(aesKEY, \"AES\");\n        }\n        catch (GeneralSecurityException ex) {\n            throw new RuntimeException(\"Exception in PixieObfuscator constructor, invalid environment\");\n        }\n   }\n", "    public static SSLContext getFactory() throws Exception {\n    KeyStore trusted = KeyStore.getInstance(\"BKS\");\n\n    InputStream in = context.getResources().openRawResource(R.raw.myfile);\n\n    try {\n        // Initialisation de notre keystore. On entre le mot de passe (storepass)\n        trusted.load(in, \"mypassword\".toCharArray());\n    } finally {\n        in.close();\n    }\n\n\n    TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");\n    tmf.init(trusted);\n\n    SSLContext ssl_context = SSLContext.getInstance(\"SSL\");\n    ssl_context.init(null, tmf.getTrustManagers(), null);\n\n    return ssl_context;\n}\n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    \"com.your.package\", \n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                }\n        } catch (NameNotFoundException e) {\n            Log.d(\"Error1\", \"NameNotFoundException\");\n\n        } catch (NoSuchAlgorithmException e) {\n            Log.d(\"Error2\", \"Algorthim\");\n\n        }\n", "private static byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\nfinal Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\nIvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\ncipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n\ncipherText = cipher.doFinal(stuffIWantSafe.getBytes(\"UTF-8\"));\n\nString encodedCipherText = Base64.encodeToString(cipherText, Base64.NO_WRAP);\n", "    private SSLSocketFactory newSslSocketFactory() {\n    try {\n        // Get an instance of the Bouncy Castle KeyStore format\n        KeyStore trusted = KeyStore.getInstance(\"BKS\");\n        // Get the raw resource, which contains the keystore with\n        // your trusted certificates (root and any intermediate certs)\n        InputStream in = context.getResources().openRawResource(R.raw.mykeystore);\n        try {\n            // Initialize the keystore with the provided trusted certificates\n            // Also provide the password of the keystore\n            trusted.load(in, \"testtest\".toCharArray());\n        } finally {\n            in.close();\n        }\n        // Pass the keystore to the SSLSocketFactory. The factory is responsible\n        // for the verification of the server certificate.\n        SSLSocketFactory sf = new SSLSocketFactory(trusted);\n        // Hostname verification from certificate\n        // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506\n        sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n        return sf;\n    } catch (Exception e) {\n        throw new AssertionError(e);\n    }\n}\n", "private static SSLSocketFactory createSslSocketFactory() {\n    TrustManager[] byPassTrustManagers = new TrustManager[]{new X509TrustManager() {\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {\n        }\n    }};\n\n    SSLContext sslContext = null;\n    SSLSocketFactory sslSocketFactory = null;\n    try {\n        sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, byPassTrustManagers, new SecureRandom());\n        sslSocketFactory = sslContext.getSocketFactory();\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n        Log.e(TAG, StringUtils.EMPTY, e);\n    } catch (KeyManagementException e) {\n        Log.e(TAG, StringUtils.EMPTY, e);\n    }\n\n    return sslSocketFactory;\n}\n", "public static String SHA256 (String text) throws NoSuchAlgorithmException {\n\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\n    md.update(text.getBytes());\n    byte[] digest = md.digest();\n\n    return Base64.encodeToString(digest, Base64.DEFAULT);\n}\n", "public class MyHttpClient extends DefaultHttpClient {\n\n    private Resources _resources;\n\n    public MyHttpClient(Resources resources) {\n        _resources = resources;\n    }\n\n    @Override\n    protected ClientConnectionManager createClientConnectionManager() {\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory\n            .getSocketFactory(), 80));\n        if (_resources != null) {\n            registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n        } else {\n            registry.register(new Scheme(\"https\", SSLSocketFactory\n                .getSocketFactory(), 443));\n        }\n        return new SingleClientConnManager(getParams(), registry);\n    }\n\n    private SSLSocketFactory newSslSocketFactory() {\n        try {\n            KeyStore trusted = KeyStore.getInstance(\"BKS\");\n            InputStream in = _resources.openRawResource(R.raw.mystore);\n            try {\n                trusted.load(in, \"pwd\".toCharArray());\n            } finally {\n                in.close();\n            }\n            return new SSLSocketFactory(trusted);\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n    }\n}\n", "    SSLContext sslContext = SSLContext.getInstance(\"TLSv1.2\");\n    sslContext.init(null, null, null);\n    SSLEngine engine = sslContext.createSSLEngine();\n", "    public static void encryptFile(String path, byte[] key) throws Exception {\n\n    Cipher c = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    SecretKeySpec k = new SecretKeySpec(key, \"AES\");\n    c.init(Cipher.ENCRYPT_MODE, k);\n    RandomAccessFile raf = new RandomAccessFile(path, \"rw\");\n\n    byte[] buf = new byte[128];\n    int bytesRead = 0;\n    int totalBytes = 0;\n    byte[] output;\n    while ((bytesRead = raf.read(buf)) &gt;= 0) {\n        output = c.update(buf, 0, bytesRead);\n        raf.seek(totalBytes);\n        raf.write(output);\n        totalBytes += output.length;\n        raf.seek(totalBytes+16);\n    }\n    output = c.doFinal();\n    raf.seek(totalBytes);\n    raf.write(output);\n    raf.getFD().sync();\n    raf.close();\n\n}\n", "MessageDigest digester = MessageDigest.getInstance(\"MD5\");\nbyte[] bytes = new byte[8192];\nint byteCount;\nwhile ((byteCount = in.read(bytes)) &gt; 0) {\n  digester.update(bytes, 0, byteCount);\n}\nbyte[] digest = digester.digest();\n", "import android.util.Base64;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\n\n/**\n * Created by sergi.castellsague on 04/05/2014.\n */\npublic class SecurityManager\n{\nprivate static final int ITERATIONS = 1000;\n\npublic enum HashMethod\n{\n    PBKDF2(){\n        @Override\n        public String getHashString()\n        {\n            return \"PBKDF2WithHmacSHA1\";\n        }\n    }, SHA512(){\n        @Override\n        public String getHashString() {\n            return \"SHA-512\";\n        }\n    }, SHA384() {\n        @Override\n        public String getHashString() {\n            return \"SHA-384\";\n        }\n    }, SHA256() {\n        @Override\n        public String getHashString () {\n            return \"SHA-256\";\n        }\n    }\n    , SHA1()\n    {\n        @Override\n        public String getHashString() {\n            return \"SHA-1\";\n        }\n    };\n\n    public abstract String getHashString();\n\n}\n\npublic static HashMethod getAppropriateHash()\n{\n    HashMethod method = null;\n\n    if ( isPBKDFAvailable() )\n    {\n        method = HashMethod.PBKDF2;\n    }\n    else if( isDigestAvailable( HashMethod.SHA512.getHashString() ) )\n    {\n        method = HashMethod.SHA512;\n    }\n    else if( isDigestAvailable( HashMethod.SHA384.getHashString() ) )\n    {\n        method = HashMethod.SHA384;\n    }\n    else if( isDigestAvailable( HashMethod.SHA256.getHashString() ) )\n    {\n        method = HashMethod.SHA256;\n    }\n    else if( isDigestAvailable( HashMethod.SHA1.getHashString() ) )\n    {\n        method = HashMethod.SHA1;\n    }\n\n    return method;\n}\n\n\nprivate static boolean isPBKDFAvailable()\n{\n    try\n    {\n        SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );\n    }\n    catch ( Exception notAvailable)\n    {\n        return false;\n    }\n    return true;\n}\n\nprivate static boolean isDigestAvailable( String method )\n{\n    try\n    {\n        MessageDigest.getInstance( method );\n    }\n    catch ( Exception notAvailable )\n    {\n        return false;\n    }\n\n    return true;\n}\n\npublic static String getHashedPassword( HashMethod method, String password )\n{\n    String hashed;\n\n    if ( HashMethod.PBKDF2.getHashString().equals( method.getHashString() ) )\n    {\n        hashed = generatePBKDF( password );\n    }\n    else\n    {\n        hashed = password;\n        for ( int i = 0; i &lt; ITERATIONS; i++ )\n        {\n            hashed = generateDigestPassword( password, method.getHashString() );\n        }\n    }\n\n    return hashed;\n}\n\nprivate static String generatePBKDF( String password )\n{\n    // Generate a 512-bit key\n    final int outputKeyLength = 512;\n\n    char[] chars = new char[password.length()];\n    password.getChars( 0, password.length(), chars, 0 );\n    byte[] salt = \"salt_on_client_is_funny\".getBytes(); // In security terms, this is worthess. However, it's required.\n\n    byte[] hashedPassBytes = new byte[0];\n    try\n    {\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );\n        KeySpec keySpec = new PBEKeySpec( chars, salt, ITERATIONS, outputKeyLength );\n\n        hashedPassBytes = secretKeyFactory.generateSecret( keySpec ).getEncoded();\n    }\n    catch ( Exception shouldNotHappen )\n    {}\n\n    return Base64.encodeToString( hashedPassBytes, Base64.DEFAULT );\n}\n\nprivate static String generateDigestPassword( String password, String algorithm )\n{\n    byte[] digest = new byte[0];\n    byte[] buffer = password.getBytes();\n\n    try {\n        MessageDigest messageDigest = MessageDigest.getInstance( algorithm );\n        messageDigest.reset();\n        messageDigest.update( buffer );\n        digest = messageDigest.digest();\n    }\n    catch ( NoSuchAlgorithmException ex )\n    {}\n\n    return Base64.encodeToString(digest, Base64.DEFAULT);\n}\n}\n", "public static String printKeyHash(Activity context) {\n    PackageInfo packageInfo;\n    String key = null;\n    try {\n        //getting application package name, as defined in manifest\n        String packageName = context.getApplicationContext().getPackageName();\n\n        //Retriving package info\n        packageInfo = context.getPackageManager().getPackageInfo(packageName,\n                PackageManager.GET_SIGNATURES);\n\n        Log.e(\"Package Name=\", context.getApplicationContext().getPackageName());\n\n        for (android.content.pm.Signature signature : packageInfo.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            key = new String(Base64.encode(md.digest(), 0));\n\n            // String key = new String(Base64.encodeBytes(md.digest()));\n            Log.e(\"Key Hash=\", key);\n        }\n    } catch (PackageManager.NameNotFoundException e1) {\n        Log.e(\"Name not found\", e1.toString());\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(\"No such an algorithm\", e.toString());\n    } catch (Exception e) {\n        Log.e(\"Exception\", e.toString());\n    }\n\n    return key;\n}\n", "PublicKey publicKey = keyPair.getPublic();\nStringWriter writer = new StringWriter();\nPemWriter pemWriter = new PemWriter(writer);\npemWriter.writeObject(new PemObject(\"PUBLIC KEY\", publicKey.getEncoded()));\npemWriter.flush();\npemWriter.close();\nreturn writer.toString();\n", "private void getHashKey() {\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                getPackageName(), PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"RAJAT\",\n                    \"KeyHash: \"\n                            + Base64.encodeToString(md.digest(),\n                                    Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n    } catch (NoSuchAlgorithmException e) {\n    }\n\n}\n", "import sun.misc.BASE64Encoder;\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\n\nString policy = (new BASE64Encoder()).encode(\n    policy_document.getBytes(\"UTF-8\")).replaceAll(\"\\n\",\"\").replaceAll(\"\\r\",\"\");\n\nMac hmac = Mac.getInstance(\"HmacSHA1\");\nhmac.init(new SecretKeySpec(\n    aws_secret_key.getBytes(\"UTF-8\"), \"HmacSHA1\"));\nString signature = (new BASE64Encoder()).encode(\n    hmac.doFinal(policy.getBytes(\"UTF-8\")))\n    .replaceAll(\"\\n\", \"\");\n", "KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\nks.load(null, null);\nEnumeration&lt;String&gt; aliases = ks.aliases();\n", "final KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n    keyStore.load(context.getResources().openRawResource(R.raw.serverkeys), null);\n\n    final KeyManagerFactory keyManager = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n    keyManager.init(keyStore, null);\n\n    final TrustManagerFactory trustFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    trustFactory.init(keyStore);\n\n    sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(keyManager.getKeyManagers(), trustFactory.getTrustManagers(), null);\n", " private static final String ALGORITHM = \"AES\";\n private static final byte[] keyValue =\n        new byte[] { 'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y' };\n\n\n public String encrypt(String valueToEnc) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encValue = c.doFinal(valueToEnc.getBytes());\n    // String encryptedValue = new Base64.encoder();\n\n    return Base64.encodeToString(encValue, Base64.DEFAULT);\n}\n\npublic String decrypt(String encryptedValue) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.DECRYPT_MODE, key);\n    //byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n    byte[] decordedValue = Base64.decode(encryptedValue, Base64.DEFAULT);\n\n    byte[] decValue = c.doFinal(decordedValue);\n    String decryptedValue = new String(decValue);\n    return decryptedValue;\n}\n", "public void setPublicKey(PublicKey publicKey, String key, Context context) {\n\n    byte[] pubKey = publicKey.getEncoded();\n    String pubKeyString = Base64.encodeBytes(pubKey);\n    this.setString(key, pubKeyString, context);\n}\n\npublic PublicKey getPublicKey(String key,Context context) {\n\n    PublicKey pKey = null;\n    try {\n\n        String pubString = this.getString(key, context);\n\n        if(pubString!=null) {\n            byte[] binCpk = Base64.decode(pubString);\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(binCpk);\n            pKey = keyFactory.generatePublic(publicKeySpec);\n        }\n        }catch(Exception e){\n    }\n    return pKey;\n}\n", "public void setPrivateKey(PrivateKey privateKey, String key, Context context) {\n\n    byte[] priKey = privateKey.getEncoded();\n    String priKeyString = Base64.encodeBytes(priKey);\n    this.setString(key, priKeyString, context);\n}\n\npublic PrivateKey getPrivateKey(String key, Context context) {\n\n    PrivateKey privateKey = null;\n\n    try {\n        String privateString = this.getString(key, context);\n        if(privateString!=null){\n            byte[] binCpk = Base64.decode(privateString);\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(binCpk);\n            privateKey = keyFactory.generatePrivate(privateKeySpec);\n        }\n    } \n    catch(Exception e){\n    }\n    return privateKey;\n}\n", "import android.util.Base64;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\nimport java.util.Random;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n/**\nAes encryption\n*/\npublic class AES\n{\n\n    private static SecretKeySpec secretKey ;\n    private static byte[] key ;\n    private static byte[] iv;\n    private static String decryptedString;\n    private static String encryptedString;\n\n    public static void setKey(String myKey){\n\n\n        MessageDigest sha = null;\n        try {\n            key = myKey.getBytes(\"UTF-8\");\n            System.out.println(key.length);\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            key = sha.digest(key);\n            key = Arrays.copyOf(key, 16); // use only first 128 bit\n            secretKey = new SecretKeySpec(key, \"AES\");\n            iv = new byte[]{11,53,63,87,11,69,63,28,0,9,18,99,95,23,45,8};\n\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n\n\n    }\n\n    public static String getDecryptedString() {\n        return decryptedString;\n    }\n    public static void setDecryptedString(String decryptedString) {\n        AES.decryptedString = decryptedString;\n    }\n    public static String getEncryptedString() {\n        return encryptedString;\n    }\n    public static void setEncryptedString(String encryptedString) {\n        AES.encryptedString = encryptedString;\n    }\n    public static String encrypt(String strToEncrypt)\n    {\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\",\"BC\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey,new IvParameterSpec(iv));\n            setEncryptedString(Base64.encodeToString(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\")),Base64.DEFAULT));\n\n        }\n        catch (Exception e)\n        {\n\n            System.out.println(\"Error while encrypting: \"+e.toString());\n        }\n        return null;\n    }\n    public static String decrypt(String strToDecrypt)\n    {\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7PADDING\",\"BC\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey,new IvParameterSpec(iv));\n            String decoded = new String(cipher.doFinal(Base64.decode(strToDecrypt,Base64.DEFAULT)), Charset.forName(\"UTF-8\"));\n            setDecryptedString(decoded);\n\n        }\n        catch (Exception e)\n        {\n\n            System.out.println(\"Error while decrypting: \"+e.toString());\n        }\n        return null;\n    }\n\n}\n", "    static {\n    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);\n}\n", "private void facebookHashKey() {\n\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"com.app.helpcove\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String hashCode  = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n            System.out.println(\"Print the hashKey for Facebook :\"+hashCode);\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"el nombre de su paquete por ejemplo com.tarea.u8\",\n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (PackageManager.NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "public class MySSLSocketFactory extends SSLSocketFactory {\n\n    SSLSocketFactory sslSocketFactory;\n\n    public MySSLSocketFactory(SSLSocketFactory sslSocketFactory) {\n        super();\n        this.sslSocketFactory = sslSocketFactory;\n    }\n\n    @Override\n    public String[] getDefaultCipherSuites() {\n        return sslSocketFactory.getDefaultCipherSuites();\n    }\n\n    @Override\n    public String[] getSupportedCipherSuites() {\n        return sslSocketFactory.getSupportedCipherSuites();\n    }\n\n    @Override\n    public SSLSocket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(s, host, port, autoClose);\n        socket.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(host, port);\n        socket.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException,\n            UnknownHostException {\n        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(host, port, localHost, localPort);\n        socket.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(host, port);\n        socket.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort)\n            throws IOException {\n        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(address, port, localAddress, localPort);\n        socket.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n        return socket;\n    }\n", "    ...\n    urlConnection = (HttpsURLConnection) url.openConnection();\n    urlConnection.setSSLSocketFactory(new MySSLSocketFactory(urlConnection.getSSLSocketFactory()));\n    ...\n", "import java.security.GeneralSecurityException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport android.util.Log;\n\npublic class EncodeDecodeAES {\n\n\n    private static final String TAG_DEBUG = \"TAG\";\n    private IvParameterSpec ivspec;\n    private SecretKeySpec keyspec;\n    private Cipher cipher;\n\n    private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n    private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n    public EncodeDecodeAES() {\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try {\n            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (GeneralSecurityException e) {\n            Log.d(TAG_DEBUG, e.getMessage());\n        }\n    }\n\n    public byte[] encrypt(String text) throws Exception {\n        if (text == null || text.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n            encrypted = cipher.doFinal(padString(text).getBytes());\n        } catch (Exception e) {\n            Log.d(TAG_DEBUG, e.getMessage());\n            throw new Exception(\"[encrypt] \" + e.getMessage());\n        }\n\n        return encrypted;\n    }\n\n    public byte[] decrypt(String code) throws Exception {\n        if (code == null || code.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n            decrypted = cipher.doFinal(hexToBytes(code));\n        } catch (Exception e) {\n            Log.d(TAG_DEBUG, e.getMessage());\n            throw new Exception(\"[decrypt] \" + e.getMessage());\n        }\n        return decrypted;\n    }\n\n    public static String bytesToHex(byte[] data) {\n        if (data == null) {\n            return null;\n        }\n\n        int len = data.length;\n        String str = \"\";\n        for (int i = 0; i &lt; len; i++) {\n            if ((data[i] &amp; 0xFF) &lt; 16)\n                str = str + \"0\" + java.lang.Integer.toHexString(data[i] &amp; 0xFF);\n            else\n                str = str + java.lang.Integer.toHexString(data[i] &amp; 0xFF);\n        }\n        return str;\n    }\n\n    public static byte[] hexToBytes(String str) {\n        if (str == null) {\n            return null;\n        } else if (str.length() &lt; 2) {\n            return null;\n        } else {\n            int len = str.length() / 2;\n            byte[] buffer = new byte[len];\n            for (int i = 0; i &lt; len; i++) {\n                buffer[i] = (byte) Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16);\n            }\n            return buffer;\n        }\n    }\n\n    private static String padString(String source) {\n        char paddingChar = ' ';\n        int size = 16;\n        int x = source.length() % size;\n        int padLength = size - x;\n\n        for (int i = 0; i &lt; padLength; i++) {\n            source += paddingChar;\n        }\n\n        return source;\n    }\n}\n", "public static String convertPassMd5(String pass) {\n        String password = null;\n        MessageDigest mdEnc;\n        try {\n            mdEnc = MessageDigest.getInstance(\"MD5\");\n            mdEnc.update(pass.getBytes(), 0, pass.length());\n            pass = new BigInteger(1, mdEnc.digest()).toString(16);\n            while (pass.length() &lt; 32) {\n                pass = \"0\" + pass;\n            }\n            password = pass;\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n        }\n        return password;\n    }\n", "// Add code to print out the key hash\n  try {\n  PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\n  for (Signature signature : info.signatures) {\n  MessageDigest md = MessageDigest.getInstance(\"SHA\");\n  md.update(signature.toByteArray());\n  Log.e(\"MY KEY HASH:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n      }\n  } catch (NameNotFoundException e) {\n\n  } catch (NoSuchAlgorithmException e) {\n\n  }\n", "public boolean decryptFile(String filePath)\n    {\n\n        try {\n            SecretKeySpec secretKey = new SecretKeySpec(Password.getBytes(\"ASCII\"), \"AES\");\n            dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            dcipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(InitialVector.getBytes(\"ASCII\")));\n\n            //Creating File object to into FileInputStream() constructor\n            String fileDirectory = Environment.getExternalStorageDirectory().getPath() + filePath;\n            String actualFilePath = fileDirectory + \"/\" + \"Text.txt\";\n            File actualFile = new File(actualFilePath);\n\n            //create input stream to read in file that needs to be decrypted\n            FileInputStream inputStream = new FileInputStream(actualFile);\n\n            //create output stream to write out the decrypted results, remove .vault to from file\n            FileOutputStream outputStream = new FileOutputStream(filePath.replace(\".vault\", filePath));\n            //wrap the output stream\n            CipherInputStream encryptedInputStream = new CipherInputStream(inputStream, dcipher);\n\n            //Decrypt the file\n            int bytes;\n            byte[] data = new byte[8];\n            while((bytes = encryptedInputStream.read(data)) != -1)\n            {\n                outputStream.write(data, 0, bytes);\n            }\n\n            // Flush and close streams.\n            outputStream.flush();\n            outputStream.close();\n            inputStream.close();\n            encryptedInputStream.close();\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n            return false;\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n            return false;\n        }catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return false;\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return false;\n        }catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        } \n        return true;\n    }\n", "//================================== To Get Facebook Hash key Programmatically =========================//\n    PackageInfo info;\n\n     try {\n            info = activity.getPackageManager().getPackageInfo(\"com.checkmyplanner\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md;\n                md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String something = new String(Base64.encode(md.digest(), 0));\n                //String something = new String(Base64.encodeBytes(md.digest()));\n                Log.e(\"hash key\", something);\n            }\n        } catch (NameNotFoundException e1) {\n            Log.e(\"name not found\", e1.toString());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(\"no such an algorithm\", e.toString());\n        } catch (Exception e) {\n            Log.e(\"exception\", e.toString());\n        }\n", "static void encrypt(File file, String pass) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n\n        FileInputStream fis = new FileInputStream(file);\n\n\n        FileOutputStream fos = new FileOutputStream(APPPATH+\"/E_\"+file.getName());\n\n\n        SecretKeySpec sks = new SecretKeySpec(pass.getBytes(), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, sks);\n\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n\n        int b;\n        byte[] d = new byte[8];\n        while((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n        }\n\n        cos.flush();\n        cos.close();\n        fis.close();\n\n\n    }\n\n\n\n     static void decrypt(File file, String pass) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n            FileInputStream fis = new FileInputStream(file);\n\n            FileOutputStream fos = new FileOutputStream(APPPATH+\"/D_\"+file.getName());\n            SecretKeySpec sks = new SecretKeySpec(pass.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, sks);\n            CipherInputStream cis = new CipherInputStream(fis, cipher);\n            int b;\n            byte[] d = new byte[8];\n            while((b = cis.read(d)) != -1) {\n                fos.write(d, 0, b);\n            }\n            fos.flush();\n            fos.close();\n            cis.close();\n        }\n", "PackageInfo info = getPackageManager().getPackageInfo(\"&lt;your_package_name&gt;\",  PackageManager.GET_SIGNATURES);\n\nfor (Signature signature : info.signatures)\n    {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n", "@Override\npublic void onCreate() {\n    nuke();\n    super.onCreate();\n}\n\npublic static void nuke() {\n    try {\n        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                X509Certificate[] myTrustedAnchors = new X509Certificate[0];\n                return myTrustedAnchors;\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] certs,\n                    String authType) {}\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] certs,\n                    String authType) {}\n        } };\n\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new SecureRandom());\n        HttpsURLConnection\n                .setDefaultSSLSocketFactory(sc.getSocketFactory());\n        HttpsURLConnection\n                .setDefaultHostnameVerifier(new HostnameVerifier() {\n\n                    @Override\n                    public boolean verify(String arg0, SSLSession arg1) {\n                        return true;\n                    }\n                });\n    } catch (Exception e) {}\n}\n", "private HttpsURLConnection buildSslServerConnection() {\n    HttpsURLConnection urlConnection = null;\n    try {\n        // Load CAs from an InputStream\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        InputStream caInput = new BufferedInputStream(context.getAssets().open(\"ca.pem\"));\n        Certificate ca;\n        try {\n            ca = cf.generateCertificate(caInput);\n        } finally {\n            caInput.close();\n        }\n\n        // Create a KeyStore containing our trusted CAs\n        String keyStoreType = KeyStore.getDefaultType();\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        keyStore.load(null, null);\n        keyStore.setCertificateEntry(\"ca\", ca);\n\n        // Create a TrustManager that trusts the CAs in our KeyStore\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n\n        // Create an SSLContext that uses our TrustManager\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(null, tmf.getTrustManagers(), null);\n\n        // Tell the URLConnection to use a SocketFactory from our SSLContext\n        urlConnection = (HttpsURLConnection) url.openConnection();\n        urlConnection.setSSLSocketFactory(context.getSocketFactory());\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setRequestProperty(\"Authorization\", \"Basic\" + Base64.encodeToString(userpass.getBytes(), Base64.DEFAULT));\n        urlConnection.setConnectTimeout(7000);\n        urlConnection.setReadTimeout(7000);\n        urlConnection.setInstanceFollowRedirects(false);\n        urlConnection.setUseCaches(false);\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setDoOutput(false);\n    } catch (KeyManagementException e) {\n        LOG.error(\"Error while checking server connectivity: \", e);\n    } catch (CertificateException e) {\n        LOG.error(\"Error while checking server connectivity: \", e);\n    } catch (FileNotFoundException e) {\n        LOG.error(\"Error while checking server connectivity: \", e);\n    } catch (KeyStoreException e) {\n        LOG.error(\"Error while checking server connectivity: \", e);\n    } catch (NoSuchAlgorithmException e) {\n        LOG.error(\"Error while checking server connectivity: \", e);\n    } catch (MalformedURLException e) {\n        LOG.error(\"Error while checking server connectivity: \", e);\n    } catch (IOException e) {\n        LOG.error(\"Error while checking server connectivity: \", e);\n    }\n    return urlConnection;\n}\n", "public static void main(String[] args) throws Exception {\n    // Create a trust manager that does not validate certificate chains\n    TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {\n            }\n        }\n    };\n\n    // Install the all-trusting trust manager\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new java.security.SecureRandom());\n    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n    // Create all-trusting host name verifier\n    HostnameVerifier allHostsValid = new HostnameVerifier() {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    // Install the all-trusting host verifier\n    HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);\n\n    URL url = new URL(\"https://www.nakov.com:2083/\");\n    URLConnection con = url.openConnection();\n    Reader reader = new InputStreamReader(con.getInputStream());\n    while (true) {\n        int ch = reader.read();\n        if (ch==-1) {\n            break;\n        }\n        System.out.print((char)ch);\n    }\n}\n", " public static void generateKeyHash(Context context) {\n    try {\n        PackageInfo info = context.getPackageManager().getPackageInfo(\n                \"com.example.user2.testapp\",\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (PackageManager.NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n}\n", "private static char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7',\n    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\nStringBuffer messagebuffer = new StringBuffer();\n\nprivate String makeHTTPSPostRequest(String httpsURL) throws IOException,\n        NoSuchAlgorithmException, CertificateException,\n        CertificateEncodingException {\n    final HttpsURLConnection con = (HttpsURLConnection) new URL(httpsURL)\n            .openConnection();\n    con.connect();\n    final Certificate cert = con.getServerCertificates()[0];\n    final MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n    md.update(cert.getEncoded());\n    InputStream inputStream = con.getInputStream();\n    DataInputStream dis = new DataInputStream(inputStream);\n    int ch;\n    long len = con.getContentLength();\n    if (len != -1) {\n        for (int i = 0; i &lt; len; i++)\n            if ((ch = dis.read()) != -1) {\n                messagebuffer.append((char) ch);\n            }\n    } else {\n        while ((ch = dis.read()) != -1)\n            messagebuffer.append((char) ch);\n    }\n\n    dis.close();\n    return dumpHex(md.digest());\n}\n\nprivate static String dumpHex(byte[] data) {\n    final int n = data.length;\n    final StringBuilder sb = new StringBuilder(n * 3 - 1);\n    for (int i = 0; i &lt; n; i++) {\n        if (i &gt; 0) {\n            sb.append(' ');\n        }\n        sb.append(HEX_CHARS[(data[i] &gt;&gt; 4) &amp; 0x0F]);\n        sb.append(HEX_CHARS[data[i] &amp; 0x0F]);\n    }\n    return sb.toString();\n} \n", "Private key = KeyFactory.getInstance(\"RSA\").generatePrivate(new PKCS8EncodedKeySpec(s_privateKeyIn1t));\nbyte [] xxx = s_privateKey.getEncoded(); //Then I watched this byte array in debugger and inserted it in a source code.\n//Now it works on Jelly Bean\n", "                ByteArrayInputStream derInputStream = new ByteArrayInputStream(app.certificateString.getBytes());\n                CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\",\"BC\");\n                X509Certificate cert = (X509Certificate) certificateFactory.generateCertificate(derInputStream);\n                String alias = \"alias\";//cert.getSubjectX500Principal().getName();\n\n                KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                trustStore.load(null);\n                trustStore.setCertificateEntry(alias, cert);\n                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"X509\");\n                kmf.init(trustStore, null);\n                KeyManager[] keyManagers = kmf.getKeyManagers();\n\n                TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");\n                tmf.init(trustStore);\n                TrustManager[] trustManagers = tmf.getTrustManagers();\n\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(keyManagers, trustManagers, null);\n                URL url = new URL(someURL);\n                conn = (HttpsURLConnection) url.openConnection();\n                conn.setSSLSocketFactory(sslContext.getSocketFactory());\n", "@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"your.package\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n}\n", "try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                  \"com.example.webwerks.facebookintegartiondemoapp\",\n        PackageManager.GET_SIGNATURES);\n        for (android.content.pm.Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n", "public static String getKeyHash(Activity context) {\n    PackageInfo packageInfo;\n    String key = null;\n    try {\n        //getting application package name, as defined in manifest\n        String packageName = context.getApplicationContext().getPackageName();\n\n        //Retriving package info\n        packageInfo = context.getPackageManager().getPackageInfo(packageName,\n                PackageManager.GET_SIGNATURES);\n\n        Log.e(\"Package Name=\", context.getApplicationContext().getPackageName());\n\n        for (Signature signature : packageInfo.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            key = new String(Base64.encode(md.digest(), 0));\n\n            // String key = new String(Base64.encodeBytes(md.digest()));\n            Log.e(\"Key Hash=\", key);\n        }\n    } catch (NameNotFoundException e1) {\n        Log.e(\"Name not found\", e1.toString());\n    }\n    catch (NoSuchAlgorithmException e) {\n        Log.e(\"No such an algorithm\", e.toString());\n    } catch (Exception e) {\n        Log.e(\"Exception\", e.toString());\n    }\n\n    return key;\n}\n", "    public static String getMD5Hash(String s) throws NoSuchAlgorithmException {\n\n    String result = s;\n    if (s != null) {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // or \"SHA-1\"\n        md.update(s.getBytes());\n        BigInteger hash = new BigInteger(1, md.digest());\n        result = hash.toString(16);\n        while (result.length() &lt; 32) { // 40 for SHA-1\n            result = \"0\" + result;\n        }\n    }\n    return result;\n}\n", "import android.content.Context;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.SingleClientConnManager;\n\nimport java.io.InputStream;\nimport java.security.KeyStore;\n\npublic class MyHttpClient extends DefaultHttpClient {\n\n  final Context context;\n\n  public MyHttpClient(Context context) {\n    this.context = context;\n  }\n\n  @Override protected ClientConnectionManager createClientConnectionManager() {\n    SchemeRegistry registry = new SchemeRegistry();\n    registry.register(\n        new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n    registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n    return new SingleClientConnManager(getParams(), registry);\n  }\n\n  private SSLSocketFactory newSslSocketFactory() {\n    try {\n      KeyStore trusted = KeyStore.getInstance(\"BKS\");\n      InputStream in = context.getResources().openRawResource(R.raw.mystore);\n      try {\n        trusted.load(in, \"ez24get\".toCharArray());\n      } finally {\n        in.close();\n      }\n      return new SSLSocketFactory(trusted);\n    } catch (Exception e) {\n      throw new AssertionError(e);\n    }\n  }\n}\n", " try {\n         PackageInfo info = getPackageManager().getPackageInfo(\"your package name\", PackageManager.GET_SIGNATURES);\n         for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", \"KeyHash:  \" + Base64.encodeToString(md.digest(), Base64.DEFAULT));\n         }\n      }\n      catch (PackageManager.NameNotFoundException e) {\n\n      }\n      catch (NoSuchAlgorithmException e) {\n\n      }\n", "KeyStore store = ... ;\nbyte[] target = ... ; // Base-64 decode your string.\nMessageDigest digest = MessageDigest.getInstance(algorithm);\nEnumeration&lt;String&gt; aliases = store.aliases();\nwhile(aliases.hasMoreElements()) {\n  String alias = aliases.nextElement();\n  Certificate c = store.getCertificate(alias);\n  if (c == null)\n    continue;\n  PublicKey pub = c.getPublicKey();\n  byte[] hash = digest.digest(pub.getEncoded());\n  if (MessageDigest.isEqual(hash, target)) {\n    // Certificate \"c\" is a match.\n  }\n}\n", "        // hash pass one\n        byte[] inDigest;\n        MessageDigest digester= MessageDigest.getInstance(\"SHA-256\"); // returns 256bits/ 32 bytes\n        byte[] message= password.getBytes(\"UTF8\");  \n        digester.update(message); // append message\n        inDigest= digester.digest(); // no salt\n        byte[] outDigest= new byte[lengthKey];\n        for (int i=0; i&lt;lengthKey; i++){ // truncate bytes\n            outDigest[i]= inDigest[i];\n        }\n        return outDigest;\n", "private class LongOperation extends AsyncTask&lt;String, Void, String&gt; {\n\n        @Override\n        protected String doInBackground(String... params) {\n            List&lt;NameValuePair&gt; nameValuePairs = new ArrayList&lt;NameValuePair&gt;(4);\n    nameValuePairs.add(new BasicNameValuePair(\"thickness\", params[0]));\n    nameValuePairs.add(new BasicNameValuePair(\"roast\", params[1]));\n    nameValuePairs.add(new BasicNameValuePair(\"oil\", params[2]));\n    nameValuePairs.add(new BasicNameValuePair(\"number\", params[3]));\n\n\n\n        String url=\"https://192.168.0.100/testhttps.php\";\n        HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n\n        DefaultHttpClient client = new DefaultHttpClient();\n\n        SchemeRegistry registry = new SchemeRegistry();\n        SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();\n        socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\n        registry.register(new Scheme(\"https\", socketFactory, 443));\n        SingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);\n        DefaultHttpClient httpClient = new DefaultHttpClient(mgr, client.getParams());\n\n        // Set verifier     \n        HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n\n        // Example send http request\n\n        HttpPost httpPost = new HttpPost(url);\n        try {\n\n            HttpResponse response = httpClient.execute(httpPost);\n        } catch (ClientProtocolException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block  \n            e.printStackTrace();\n        }\n       }\n            return \"\";\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n\n        }\n\n        @Override\n        protected void onPreExecute() {}\n\n        @Override\n        protected void onProgressUpdate(Void... values) {}\n    }\n", "    String getMD5(String data){\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.reset();\n        m.update(data.getBytes());\n        return new BigInteger(1, m.digest()).toString(16);\n    }\n", "public Client hostIgnoringClient() {\n    try\n    {\n        SSLContext sslcontext = SSLContext.getInstance( \"TLS\" );\n        sslcontext.init( null, null, null );\n        DefaultClientConfig config = new DefaultClientConfig();\n        Map&lt;String, Object&gt; properties = config.getProperties();\n        HTTPSProperties httpsProperties = new HTTPSProperties(\n                new HostnameVerifier()\n                {\n                    @Override\n                    public boolean verify( String s, SSLSession sslSession )\n                    {\n                        return true;\n                    }\n                }, sslcontext\n        );\n        properties.put( HTTPSProperties.PROPERTY_HTTPS_PROPERTIES, httpsProperties );\n        config.getClasses().add( JacksonJsonProvider.class );\n        return Client.create( config );\n    }\n    catch ( KeyManagementException | NoSuchAlgorithmException e )\n    {\n        throw new RuntimeException( e );\n    }\n}\n", "String input = \"11252411445171911438526\";\nMessageDigest md = MessageDigest.getInstance(\"SHA-1\");\nmd.reset();\nmd.update(input.getBytes(\"utf8\"));\nString ouput = new BigInteger(1, md.digest()).toString(16);\n", "public class Obfuscator {\n    private final String _P = \"(PUT A RANDOM 16-CHAR STRING HERE)\";\n\n    public String obfuscate(String value) throws GeneralSecurityException {\n        byte[] raw = _P.getBytes(Charset.forName(\"US-ASCII\"));\n        if (raw.length != 16) {\n            throw new IllegalArgumentException(\"Invalid key size.\");\n        }\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(new byte[16]));\n        byte[] bytes = cipher.doFinal(value.getBytes(Charset.forName(\"US-ASCII\")));\n        return Base64.encodeToString(bytes, Base64.NO_WRAP);\n    }\n\n    public String deobfuscate(String encrypted) throws GeneralSecurityException {\n        byte[] bytes = Base64.decode(encrypted, 0);\n        byte[] raw = _P.getBytes(Charset.forName(\"US-ASCII\"));\n        if (raw.length != 16) {\n            throw new IllegalArgumentException(\"Invalid key size.\");\n        }\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec,\n                new IvParameterSpec(new byte[16]));\n        byte[] original = cipher.doFinal(bytes);\n        return new String(original, Charset.forName(\"US-ASCII\"));\n    }\n}\n", "private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n", "ByteArrayOutputStream baos = new ByteArrayOutputStream();  \nbm.compress(Bitmap.CompressFormat.PNG, 100, baos); // bm is the bitmap object   \nbyte[] b = baos.toByteArray();  \n\nbyte[] keyStart = \"this is a key\".getBytes();\nKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\nSecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\nsr.setSeed(keyStart);\nkgen.init(128, sr); // 192 and 256 bits may not be available\nSecretKey skey = kgen.generateKey();\nbyte[] key = skey.getEncoded();    \n\n// encrypt\nbyte[] encryptedData = encrypt(key,b);\n// decrypt\nbyte[] decryptedData = decrypt(key,encryptedData);\n", "HttpsURLConnection.setDefaultHostnameVerifier(new NullHostNameVerifier());\n        try {\n            SSLContext context = SSLContext.getInstance(\"TLS\");\n            TrustManager[] tm = new TrustManager[] {\n                    new X509TrustManager() {\n\n                        @Override\n                        public void checkClientTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {\n                            // not implemented\n                        }\n\n                        @Override\n                        public void checkServerTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {\n                            // not implemented\n                        }\n\n                        @Override\n                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                            return null;\n                        }\n\n                    }\n            };\n            HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n\n        }catch(Exception e){}\n", "private String sha1(String s, String keyString) throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException {\n\nSecretKeySpec key = new SecretKeySpec((keyString).getBytes(\"UTF-8\"), \"HmacSHA1\");\nMac mac = Mac.getInstance(\"HmacSHA1\");\nmac.init(key);\n\nbyte[] bytes = mac.doFinal(s.getBytes(\"UTF-8\"));\n\nreturn new String( Base64.encodeBase64(bytes));\n\n}\n", "javax.net.SocketFactory fact=SSLSocketFactory.getDefault();\n         socket=fact.createSocket(addr, port);\n", "public class Crypto {\n   public static String encrypt(String value, String key) throws GeneralSecurityException {\n    SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(key), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks, cipher.getParameters());\n    byte[] encrypted = cipher.doFinal(value.getBytes());\n    return byteArrayToHexString(encrypted);\n}\n\npublic static String decrypt(String message, String key) throws GeneralSecurityException {\n    SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(key), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n    byte[] decrypted = cipher.doFinal(hexStringToByteArray(message));\n    return new String(decrypted);\n}   \n\nprivate static String byteArrayToHexString(byte[] b){\n    StringBuffer sb = new StringBuffer(b.length * 2);\n    for (int i = 0; i &lt; b.length; i++){\n        int v = b[i] &amp; 0xff;\n        if (v &lt; 16) {\n            sb.append('0');\n        }\n        sb.append(Integer.toHexString(v));\n    }\n    return sb.toString().toUpperCase();\n}\n\nprivate static byte[] hexStringToByteArray(String s) {\n    byte[] b = new byte[s.length() / 2];\n    for (int i = 0; i &lt; b.length; i++){\n        int index = i * 2;\n        int v = Integer.parseInt(s.substring(index, index + 2), 16);\n        b[i] = (byte)v;\n    }\n    return b;\n}\n  }\n", "import android.app.Application;\nimport java.security.Security;\npublic class Dynks extends Application {\n    static { Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1); }\n}\n", "//Call this method for KeyHash  \n    String keyHash = getKeyHashForFacebook(SplashScreen.this);\n    Log.e(\"keyHash  \", keyHash);\n\n\n    public static String getKeyHashForFacebook(Context context) {\n            try {\n                PackageInfo info = context.getPackageManager().getPackageInfo(\n                        context.getApplicationContext().getPackageName(), PackageManager.GET_SIGNATURES);\n                for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    return \"KeyHash:\" + context.getApplicationContext().getPackageName() + \"=&gt;\"\n                            + Base64.encodeToString(md.digest(), Base64.DEFAULT);\n                }\n            } catch (Exception e) {\n    e.printStackTrace();\n\n            }\n            return \"=&gt;\";\n        }\n", "           try {\n              PackageInfo info = getPackageManager().getPackageInfo(\n                \"yourpackagename\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.e(\"KeyHash:\", Base64.encodeToString(md.digest(),Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "private static byte[] hexStringToByteArray(String s) {\n    int len = s.length();\n    byte[] data = new byte[len / 2];\n    for (int i = 0; i &lt; len; i += 2) {\n        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)\n                             + Character.digit(s.charAt(i+1), 16));\n    }\n    return data;\n}\n\npublic void decryptDatabase(String k, String iv) throws InvalidKeyException, InvalidAlgorithmParameterException,\n        NoSuchAlgorithmException, NoSuchPaddingException, IOException {\n\n    File extStore = Environment.getExternalStorageDirectory();\n    FileInputStream fis = new FileInputStream(extStore\n            + \"/WhatsApp/Databases/msgstore.db.crypt7.nohdr\");\n    FileOutputStream fos = new FileOutputStream(extStore + \"/Decrypted.db\");\n\n    SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(k), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    cipher.init(Cipher.DECRYPT_MODE, sks,\n            new IvParameterSpec(hexStringToByteArray(iv)));\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    int b;\n    byte[] d = new byte[8];\n    while ((b = cis.read(d)) != -1) {\n        fos.write(d, 0, b);\n    }\n    fos.flush();\n    fos.close();\n    cis.close();\n}\n", "KeyFactory keyFactory = KeyFactory.getInstance(\"EC\");\nPublicKey publicKey = keyFactory.generatePublic(keySpec);\n", "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.harmony.javax.security.auth.callback.CallbackHandler;\nimport org.apache.harmony.javax.security.sasl.Sasl;\nimport org.jivesoftware.smack.SASLAuthentication;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.sasl.SASLMechanism;\nimport org.jivesoftware.smack.util.Base64;\n\npublic class SASLXFacebookPlatformMechanism extends SASLMechanism\n{\n\n    private static final String NAME              = \"X-FACEBOOK-PLATFORM\";\n\n    private String              apiKey            = \"\";\n    private String              applicationSecret = \"\";\n    private String              sessionKey        = \"\";\n\n    /**\n     * Constructor.\n     */\n    public SASLXFacebookPlatformMechanism(SASLAuthentication saslAuthentication)\n    {\n        super(saslAuthentication);\n    }\n\n    @Override\n    protected void authenticate() throws IOException, XMPPException\n    {\n\n        getSASLAuthentication().send(new AuthMechanism(NAME, \"\"));\n    }\n\n    @Override\n    public void authenticate(String apiKeyAndSessionKey, String host,\n            String applicationSecret) throws IOException, XMPPException\n    {\n        if (apiKeyAndSessionKey == null || applicationSecret == null)\n        {\n            throw new IllegalArgumentException(\"Invalid parameters\");\n        }\n\n        String[] keyArray = apiKeyAndSessionKey.split(\"\\\\|\", 2);\n        if (keyArray.length &lt; 2)\n        {\n            throw new IllegalArgumentException(\n                    \"API key or session key is not present\");\n        }\n\n        this.apiKey = keyArray[0];\n        this.applicationSecret = applicationSecret;\n        this.sessionKey = keyArray[1];\n\n        this.authenticationId = sessionKey;\n        this.password = applicationSecret;\n        this.hostname = host;\n\n        String[] mechanisms = { \"DIGEST-MD5\" };\n        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n        this.sc =\n                Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props,\n                        this);\n        authenticate();\n    }\n\n    @Override\n    public void authenticate(String username, String host, CallbackHandler cbh)\n            throws IOException, XMPPException\n    {\n        String[] mechanisms = { \"DIGEST-MD5\" };\n        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n        this.sc =\n                Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props,\n                        cbh);\n        authenticate();\n    }\n\n    @Override\n    protected String getName()\n    {\n        return NAME;\n    }\n\n    @Override\n    public void challengeReceived(String challenge) throws IOException\n    {\n        byte[] response = null;\n\n        if (challenge != null)\n        {\n            String decodedChallenge = new String(Base64.decode(challenge));\n            Map&lt;String, String&gt; parameters = getQueryMap(decodedChallenge);\n\n            String version = \"1.0\";\n            String nonce = parameters.get(\"nonce\");\n            String method = parameters.get(\"method\");\n\n            long callId = new GregorianCalendar().getTimeInMillis();\n\n            String sig =\n                    \"api_key=\" + apiKey + \"call_id=\" + callId + \"method=\"\n                            + method + \"nonce=\" + nonce + \"session_key=\"\n                            + sessionKey + \"v=\" + version + applicationSecret;\n\n            try\n            {\n                sig = md5(sig);\n            } catch (NoSuchAlgorithmException e)\n            {\n                throw new IllegalStateException(e);\n            }\n\n            String composedResponse =\n                    \"api_key=\" + URLEncoder.encode(apiKey, \"utf-8\")\n                            + \"&amp;call_id=\" + callId + \"&amp;method=\"\n                            + URLEncoder.encode(method, \"utf-8\") + \"&amp;nonce=\"\n                            + URLEncoder.encode(nonce, \"utf-8\")\n                            + \"&amp;session_key=\"\n                            + URLEncoder.encode(sessionKey, \"utf-8\") + \"&amp;v=\"\n                            + URLEncoder.encode(version, \"utf-8\") + \"&amp;sig=\"\n                            + URLEncoder.encode(sig, \"utf-8\");\n\n            response = composedResponse.getBytes(\"utf-8\");\n        }\n\n        String authenticationText = \"\";\n\n        if (response != null)\n        {\n            authenticationText =\n                    Base64.encodeBytes(response, Base64.DONT_BREAK_LINES);\n        }\n\n        // Send the authentication to the server\n        getSASLAuthentication().send(new Response(authenticationText));\n    }\n\n    private Map&lt;String, String&gt; getQueryMap(String query)\n    {\n        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\n        String[] params = query.split(\"\\\\&amp;\");\n\n        for (String param : params)\n        {\n            String[] fields = param.split(\"=\", 2);\n            map.put(fields[0], (fields.length &gt; 1 ? fields[1] : null));\n        }\n\n        return map;\n    }\n\n    private String md5(String text) throws NoSuchAlgorithmException,\n            UnsupportedEncodingException\n    {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(text.getBytes(\"utf-8\"), 0, text.length());\n        return convertToHex(md.digest());\n    }\n\n    private String convertToHex(byte[] data)\n    {\n        StringBuilder buf = new StringBuilder();\n        int len = data.length;\n\n        for (int i = 0; i &lt; len; i++)\n        {\n            int halfByte = (data[i] &gt;&gt;&gt; 4) &amp; 0xF;\n            int twoHalfs = 0;\n\n            do\n            {\n                if (0 &lt;= halfByte &amp;&amp; halfByte &lt;= 9)\n                {\n                    buf.append((char) ('0' + halfByte));\n                }\n                else\n                {\n                    buf.append((char) ('a' + halfByte - 10));\n                }\n                halfByte = data[i] &amp; 0xF;\n            } while (twoHalfs++ &lt; 1);\n        }\n\n        return buf.toString();\n    }\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n                           getPackageName(),\n                           PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n}\ncatch (NameNotFoundException e) {\n\n}\ncatch (NoSuchAlgorithmException e) {\n\n}\n", "private void getHashKey() {\ntry {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            getPackageName(), PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.e(\"MY_KEY_HASH:\",\n                Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (NameNotFoundException e) {\n} catch (NoSuchAlgorithmException e) {\n} }\n", "public class GMailSender extends javax.mail.Authenticator {\n    private String mailhost = \"smtp.gmail.com\";\n    private String user;\n    private String password;\n    private Session session;\n\n    static {\n        Security.addProvider(new JSSEProvider());\n    }\n\n    public GMailSender(String user, String password) {\n        this.user = user;\n        this.password = password;\n\n        Properties props = new Properties();\n        props.setProperty(\"mail.transport.protocol\", \"smtp\");\n        props.setProperty(\"mail.host\", mailhost);\n        props.put(\"mail.smtp.auth\", \"true\");\n        props.put(\"mail.smtp.port\", \"465\");\n        props.put(\"mail.smtp.socketFactory.port\", \"465\");\n        props.put(\"mail.smtp.socketFactory.class\",\n                \"javax.net.ssl.SSLSocketFactory\");\n\n        props.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n        props.setProperty(\"mail.smtp.quitwait\", \"false\");\n\n        session = Session.getDefaultInstance(props, this);\n    }\n\n    protected PasswordAuthentication getPasswordAuthentication() {\n        return new PasswordAuthentication(user, password);\n    }\n\n    public synchronized void sendMail(String subject, String body,\n            String sender, String recipients) throws Exception {\n        Log.d(\"EmailSender\", \"Sending Mail initiallized\");\n\n        try {\n            MimeMessage message = new MimeMessage(session);\n            DataHandler handler = new DataHandler(new ByteArrayDataSource(\n                    body.getBytes(), \"text/plain\"));\n            message.setFrom(new InternetAddress(sender));\n            message.setSender(new InternetAddress(sender));\n            message.setSubject(subject);\n            message.setDataHandler(handler);\n\n            if (recipients.indexOf(',') &gt; 0)\n                message.setRecipients(Message.RecipientType.TO,\n                        InternetAddress.parse(recipients));\n            else\n                message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));\n            Transport.send(message);\n        } catch (Exception e) {\n\n        }\n    }\n\n    public class ByteArrayDataSource implements DataSource {\n        private byte[] data;\n        private String type;\n\n        public ByteArrayDataSource(byte[] data, String type) {\n            super();\n            this.data = data;\n            this.type = type;\n        }\n\n        public ByteArrayDataSource(byte[] data) {\n            super();\n            this.data = data;\n        }\n\n        public void setType(String type) {\n            this.type = type;\n        }\n\n        public String getContentType() {\n            if (type == null)\n                return \"application/octet-stream\";\n            else\n                return type;\n        }\n\n        public InputStream getInputStream() throws IOException {\n            return new ByteArrayInputStream(data);\n        }\n\n        public String getName() {\n            return \"ByteArrayDataSource\";\n        }\n\n        public OutputStream getOutputStream() throws IOException {\n            throw new IOException(\"Not Supported\");\n        }\n    }\n}\n", "KeyStore keyStore = KeyStore.getInstance(\"BKS\");\nInputStream in = getContext().getAssets().open(Constants.KEYSTORE_FILENAME);\nkeyStore.load(in, Constants.KEYSTORE_PASSWORD);\nin.close();\n\nSSLSocketFactory socketFactory = new SSLSocketFactory(keyStore);\nsocketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\nSchemeRegistry registry = new SchemeRegistry();\nregistry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\nregistry.register(new Scheme(\"https\", socketFactory, 443));\nBasicHttpParams basicHttpParams = new BasicHttpParams();\nHttpProtocolParams.setVersion(basicHttpParams, HttpVersion.HTTP_1_1);\nHttpProtocolParams.setContentCharset(basicHttpParams, HTTP.UTF_8);\nThreadSafeClientConnManager ccm = new ThreadSafeClientConnManager(basicHttpParams, registry);\n\nhttpClient = new DefaultHttpClient(ccm, basicHttpParams);\n", "public static byte[] encrypt(byte[] data, byte[] key) {\ntry {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/ZeroBytePadding\");\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n    byte[] empty = new byte[16]; // For better security you should use a random 16 byte key!!!\n    IvParameterSpec ivps = new IvParameterSpec(empty);\n    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivps);\n    return cipher.doFinal(data);\n} catch (Exception e) {\n    // ...\n}\n\nreturn null;\n}\n", "package com.example.mailsenderactivity;\n\nimport javax.activation.DataHandler;   \nimport javax.activation.DataSource;   \nimport javax.mail.Message;   \nimport javax.mail.PasswordAuthentication;   \nimport javax.mail.Session;   \nimport javax.mail.Transport;   \nimport javax.mail.internet.InternetAddress;   \nimport javax.mail.internet.MimeMessage;   \nimport java.io.ByteArrayInputStream;   \nimport java.io.IOException;   \nimport java.io.InputStream;   \nimport java.io.OutputStream;   \nimport java.security.Security;   \nimport java.util.Properties; \n\npublic class GMailSender extends javax.mail.Authenticator {   \n private String mailhost = \"smtp.gmail.com\";   \n private String user;   \n private String password;   \n private Session session;   \n\nstatic {   \n    Security.addProvider(new JSSEProvider());   \n}  \n\npublic GMailSender(String user, String password) {   \n    this.user = user;   \n    this.password = password;   \n\n    Properties props = new Properties();   \n    props.setProperty(\"mail.transport.protocol\", \"smtp\");   \n    props.setProperty(\"mail.host\", mailhost);   \n    props.put(\"mail.smtp.auth\", \"true\");   \n    props.put(\"mail.smtp.port\", \"465\");   \n    props.put(\"mail.smtp.socketFactory.port\", \"465\");   \n    props.put(\"mail.smtp.socketFactory.class\",   \n            \"javax.net.ssl.SSLSocketFactory\");   \n    props.put(\"mail.smtp.socketFactory.fallback\", \"false\");   \n    props.setProperty(\"mail.smtp.quitwait\", \"false\");   \n\n    session = Session.getDefaultInstance(props, this);   \n}   \n\nprotected PasswordAuthentication getPasswordAuthentication() {   \n    return new PasswordAuthentication(user, password);   \n}   \n\npublic synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   \n    try{\n    MimeMessage message = new MimeMessage(session);   \n    DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));   \n    message.setSender(new InternetAddress(sender));   \n    message.setSubject(subject);   \n    message.setDataHandler(handler);   \n    if (recipients.indexOf(',') &gt; 0)   \n        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   \n    else  \n        message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   \n    Transport.send(message);   \n    }catch(Exception e){\n        e.printStackTrace();\n    }\n}   \n\npublic class ByteArrayDataSource implements DataSource {   \n    private byte[] data;   \n    private String type;   \n\n    public ByteArrayDataSource(byte[] data, String type) {   \n        super();   \n        this.data = data;   \n        this.type = type;   \n    }   \n\n    public ByteArrayDataSource(byte[] data) {   \n        super();   \n        this.data = data;   \n    }   \n\n    public void setType(String type) {   \n        this.type = type;   \n    }   \n\n    public String getContentType() {   \n        if (type == null)   \n            return \"application/octet-stream\";   \n        else  \n            return type;   \n    }   \n\n    public InputStream getInputStream() throws IOException {   \n        return new ByteArrayInputStream(data);   \n    }   \n\n    public String getName() {   \n        return \"ByteArrayDataSource\";   \n    }   \n\n    public OutputStream getOutputStream() throws IOException {   \n        throw new IOException(\"Not Supported\");   \n    }   \n  }   \n}  \n", "package com.example.mailsenderactivity;\n\nimport java.security.AccessController;\nimport java.security.Provider;\n\npublic class JSSEProvider extends Provider {\n\n/**\n * \n */\nprivate static final long serialVersionUID = 1L;\n\npublic JSSEProvider() {\n    super(\"HarmonyJSSE\", 1.0, \"Harmony JSSE Provider\");\n    AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {\n        public Void run() {\n            put(\"SSLContext.TLS\",\n                    \"org.apache.harmony.xnet.provider.jsse.SSLContextImpl\");\n            put(\"Alg.Alias.SSLContext.TLSv1\", \"TLS\");\n            put(\"KeyManagerFactory.X509\",\n                    \"org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl\");\n            put(\"TrustManagerFactory.X509\",\n                    \"org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl\");\n            return null;\n        }\n    });\n  }\n}\n", "            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            InputStream caInput = getApplicationContext().getResources()\n                    .openRawResource(R.raw.my_certificate);//new BufferedInputStream(is);\n            Certificate ca;\n            try {\n                ca = cf.generateCertificate(caInput);\n            } finally {\n                caInput.close();\n            }\n\n            /** Create a KeyStore containing our trusted CAs **/\n            String keyStoreType = KeyStore.getDefaultType();\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            keyStore.load(null, null);\n            keyStore.setCertificateEntry(\"ca\", ca);\n\n            /**Create a TrustManager that trusts the CAs in our KeyStore **/\n            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n            tmf.init(keyStore);\n\n            /** Create an SSLContext that uses our TrustManager **/\n            SSLContext context = SSLContext.getInstance(\"TLS\");\n            context.init(null, tmf.getTrustManagers(), null);\n", "final HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {\n             public boolean verify1(String hostname, SSLSession session) {\n                 return true;\n             }\n\n            @Override\n            public boolean verify(String arg0, SSLSession arg1) {\n                // TODO Auto-generated method stub\n                return false;\n            }\n      };\n", "TrustManager tm = new X509TrustManager() {\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n};\n\n// Create a trust manager that does not validate certificate chains\nTrustManager[] trustAllCerts = new TrustManager[] {\n    new X509TrustManager() {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {}\n        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {}\n    }\n};\nSSLContext sslContext = null;\n\ntry {\n    sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, new TrustManager[] { tm }, null);\n} catch (Exception e1) {\n    e1.printStackTrace();\n    return;\n}\n\nAsyncSSLSocketMiddleware sslMiddleWare = Ion.getDefault(context).getHttpClient().getSSLSocketMiddleware();\nsslMiddleWare.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\nsslMiddleWare.setSSLContext(sslContext);\n\nIon.getDefault(context).getHttpClient().getSSLSocketMiddleware().setTrustManagers(trustAllCerts);\nIon.getDefault(context).getHttpClient().getSSLSocketMiddleware().setSSLContext(sslContext);\n\nIon.with(context).load(\"POST\", serverUrl)\n    .setHeader(\"Content-Type\", \"application/json\")\n    .setHeader(\"Accept\", \"application/json\")\n    .setLogging(\"ION_LOGGING\", Log.VERBOSE).setJsonObjectBody(json)\n", "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\n class DESEncryption {\n\n    private static final String UNICODE_FORMAT = \"UTF8\";\n    public static final String DES_ENCRYPTION_SCHEME = \"DES\";\n    private KeySpec myKeySpec;\n    private SecretKeyFactory mySecretKeyFactory;\n    private Cipher cipher;\n    byte[] keyAsBytes;\n    private String myEncryptionKey;\n    private String myEncryptionScheme;\n    SecretKey key;\n\n    public DESEncryption() throws Exception\n    {\n        myEncryptionKey = \"ThisIsSecretEncryptionKey\";\n        myEncryptionScheme = DES_ENCRYPTION_SCHEME;\n        keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);\n        myKeySpec = new DESKeySpec(keyAsBytes);\n        mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);\n        cipher = Cipher.getInstance(myEncryptionScheme);\n        key = mySecretKeyFactory.generateSecret(myKeySpec);\n    }\n\n    /**\n     * Method To Encrypt The String\n     */\n    public String encrypt(String unencryptedString) {\n        String encryptedString = null;\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);\n            byte[] encryptedText = cipher.doFinal(plainText);\n            BASE64Encoder base64encoder = new BASE64Encoder();\n            encryptedString = base64encoder.encode(encryptedText);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n    /**\n     * Method To Decrypt An Ecrypted String\n     */\n    public String decrypt(String encryptedString) {\n        String decryptedText=null;\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            BASE64Decoder base64decoder = new BASE64Decoder();\n            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);\n            byte[] plainText = cipher.doFinal(encryptedText);\n            decryptedText= bytes2String(plainText);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return decryptedText;\n    }\n\n\n    private static String bytes2String(byte[] bytes) {\n        StringBuffer stringBuffer = new StringBuffer();\n        for (int i = 0; i &amp;lt; bytes.length; i++) {\n            stringBuffer.append((char) bytes[i]);\n        }\n        return stringBuffer.toString();\n    }\n\n    /**\n     * Testing the DES Encryption And Decryption Technique\n     */\n    public static void main(String args []) throws Exception\n    {\n        DESEncryption myEncryptor= new DESEncryption();\n\n        String stringToEncrypt=\"Sanjaal.com\";\n        String encrypted=myEncryptor.encrypt(stringToEncrypt);\n        String decrypted=myEncryptor.decrypt(encrypted);\n\n        System.out.println(\"String To Encrypt: \"+stringToEncrypt);\n        System.out.println(\"Encrypted Value :\" + encrypted);\n        System.out.println(\"Decrypted Value :\"+decrypted);\n\n    }  \n\n}\n", "import static org.junit.Assert.assertEquals;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport org.junit.Test;\n\npublic class Sha256Test {\n\n    @Test\n    public void sha256Test() throws NoSuchAlgorithmException {\n        String out = hash256(\"1130_11825_253402300799_1_1bcb4a27d42524de11325ec627b63878770a8651c0a0d8ddfc8fc06b92aea281634ff11f7d874c03851932304601439e\");\n        String in  = \"01a9d698f0587a25ad8ef56b0994ec0022364aff91d668a4b3a4b97c40167672\";\n        assertEquals(in, out);\n    }\n\n    private String hash256(String data) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(data.getBytes());\n        return bytesToHex(md.digest());\n    }\n\n    private String bytesToHex(byte[] bytes) {\n        StringBuffer result = new StringBuffer();\n        for (byte byt : bytes) {\n            result.append(Integer.toString((byt &amp; 0xff) + 0x100, 16).substring(1));\n        }\n        return result.toString();\n    }\n}\n", "private String md5(String in) {\n    MessageDigest digest;\n    try {\n        digest = MessageDigest.getInstance(\"MD5\");\n        digest.reset();        \n        digest.update(in.getBytes());\n        byte[] a = digest.digest();\n        int len = a.length;\n        StringBuilder sb = new StringBuilder(len &lt;&lt; 1);\n        for (int i = 0; i &lt; len; i++) {\n            sb.append(Character.forDigit((a[i] &amp; 0xf0) &gt;&gt; 4, 16));\n            sb.append(Character.forDigit(a[i] &amp; 0x0f, 16));\n        }\n        return sb.toString();\n    } catch (NoSuchAlgorithmException e) { e.printStackTrace(); }\n    return null;\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n          \"com.facebook.login\", PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) \n        {\n           MessageDigest md = MessageDigest.getInstance(\"SHA\");\n           md.update(signature.toByteArray());\n           Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    }\n} catch (NameNotFoundException e) {\n} catch (NoSuchAlgorithmException e) {\n}\n", "private void printKeyHash(){\n    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"YOUR_PACKAGE_NAME\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n        Log.d(\"KeyHash:\", e.toString());\n    } catch (NoSuchAlgorithmException e) {\n        Log.d(\"KeyHash:\", e.toString());\n    }\n}\n", "public class GmailSender extends javax.mail.Authenticator {   \n    private String mailhost = \"smtp.gmail.com\";   \n    private String user;   \n    private String password;   \n    private Session session;   \n\n    static {   \n        Security.addProvider(new com.provider.JSSEProvider());   \n    }  \n\n    public GmailSender(String user, String password) {   \n        this.user = user;   \n        this.password = password;   \n\n        Properties props = new Properties();   \n        props.put(\"mail.smtp.user\", user);\n        props.put(\"mail.smtp.auth\", \"true\");   \n        props.put(\"mail.smtp.host\", mailhost);\n        props.put(\"mail.smtp.starttls.enable\", \"true\");\n        props.put(\"mail.smtp.port\", \"587\");  \n        props.put(\"mail.debug\", \"true\");\n\n        session = Session.getInstance(props, this);    \n    }   \n\n    protected PasswordAuthentication getPasswordAuthentication() {   \n        return new PasswordAuthentication(user, password);   \n    }   \n\n    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   \n        try{\n            MimeMessage message = new MimeMessage(session);   \n            DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));   \n            message.setSender(new InternetAddress(sender));   \n            message.setSubject(subject);   \n            message.setDataHandler(handler);   \n            if (recipients.indexOf(',') &gt; 0)   \n                message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   \n            else  \n                message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   \n            Transport t = session.getTransport(\"smtp\");\n            t.connect(mailhost, user, password);\n            t.sendMessage(message, message.getAllRecipients());\n\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }   \n\n    public class ByteArrayDataSource implements DataSource {   \n        private byte[] data;   \n        private String type;   \n\n        public ByteArrayDataSource(byte[] data, String type) {   \n            super();   \n            this.data = data;   \n            this.type = type;   \n        }   \n\n        public ByteArrayDataSource(byte[] data) {   \n            super();   \n            this.data = data;   \n        }   \n\n        public void setType(String type) {   \n            this.type = type;   \n        }   \n\n        public String getContentType() {   \n            if (type == null)   \n                return \"application/octet-stream\";   \n            else  \n                return type;   \n        }   \n\n        public InputStream getInputStream() throws IOException {   \n            return new ByteArrayInputStream(data);   \n        }   \n\n        public String getName() {   \n            return \"ByteArrayDataSource\";   \n        }   \n\n        public OutputStream getOutputStream() throws IOException {   \n            throw new IOException(\"Not Supported\");   \n        }   \n    }   \n}  \n", "public final class JSSEProvider extends Provider {\n\n    public JSSEProvider() {\n        super(\"HarmonyJSSE\", 1.0, \"Harmony JSSE Provider\");\n        AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {\n            public Void run() {\n                put(\"SSLContext.TLS\",\n                    \"org.apache.harmony.xnet.provider.jsse.SSLContextImpl\");\n                put(\"Alg.Alias.SSLContext.TLSv1\", \"TLS\");\n                put(\"KeyManagerFactory.X509\",\n                    \"org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl\");\n                put(\"TrustManagerFactory.X509\",\n                    \"org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl\");\n                return null;\n            }\n        });\n    }\n}\n", "public class FbManager {\n\nprivate Context context;\nprivate static final String LOGTAG = \"FbManager\";\nprivate CallbackManager callbackManager;\n\npublic FbManager(Context context, CallbackManager callbackManager){\n    this.context = context;\n    this.callbackManager = callbackManager;\n}\n\npublic static void traceKeyHash(Activity activity){\n    try {\n        PackageInfo info = activity.getPackageManager().getPackageInfo(\"com.muv.android\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.i(LOGTAG, \"Share - KeyHash: \" + Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    }\n    catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic void share(final String msg) {\n\n    if (isLoggedIn()) {\n        post(msg);\n    }\n    else{\n        LoginManager.getInstance().registerCallback(callbackManager, new FacebookCallback&lt;LoginResult&gt;() {\n            @Override\n            public void onSuccess(LoginResult loginResult) {\n                Log.d(LOGTAG, \"facebook login success\");\n                post(msg);\n            }\n\n            @Override\n            public void onCancel() {\n                Log.w(LOGTAG, \"facebook login canceled\");\n            }\n\n            @Override\n            public void onError(FacebookException exception) {\n                Log.e(LOGTAG, \"facebook login error\");\n                exception.printStackTrace();\n            }\n        });\n\n        LoginManager.getInstance().logInWithPublishPermissions((Activity) context, Arrays.asList(\"publish_actions\"));\n    }\n}\n\npublic boolean isLoggedIn() {\n    AccessToken accessToken = AccessToken.getCurrentAccessToken();\n    return accessToken != null;\n}\n\nprivate void post(final String msg){\n    Log.d(LOGTAG, \"facebook posting new message\");\n    Set&lt;String&gt; permissions = AccessToken.getCurrentAccessToken().getPermissions();\n    AccessToken accessToken = AccessToken.getCurrentAccessToken();\n\n    Bundle postParams = new Bundle();\n    postParams.putString(\"message\", msg);\n\n    GraphRequest request = new GraphRequest(accessToken, \"me/feed\", postParams, HttpMethod.POST, null);\n    GraphRequestAsyncTask asynTaskGraphRequest = new GraphRequestAsyncTask (request);\n    asynTaskGraphRequest.execute();\n}\n}\n", "public static byte[] getRandomIv() throws InvalidDataException {\n    try {\n        SecureRandom sr = new SecureRandom();\n        byte[] output = new byte[16];\n        sr.nextBytes(output);\n        return output;\n    } catch(Exception ex) {\n        Log.e(TAG, \"Unable to create random IV\", ex);\n        throw new InvalidDataException(\"Unable to create random IV\");\n    }\n}\n", "SecureRandom r = new SecureRandom();\nbyte[] iv = new byte[16];\nr.nextBytes(iv);\n...\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));\n", "public HttpClient getNewHttpClient() {\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            trustStore.load(null, null);\n\n            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n            HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sf, 443));\n\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception e) {\n            return new DefaultHttpClient();\n        }\n    }\n", "ECGenParameterSpec ecGenSpec = new ECGenParameterSpec(\"prime192v1\");\n//using spongycastle provider\nKeyPairGenerator  g = KeyPairGenerator.getInstance(\"ECDSA\", \"SC\");\n\ng.initialize(ecGenSpec, new SecureRandom());\n\nKeyPair pair = g.generateKeyPair();\n", "import java.security.spec.RSAPrivateKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.KeyFactory;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.BadPaddingException;\nimport javax.xml.bind.DatatypeConverter;\nimport java.security.InvalidKeyException;\nimport java.io.BufferedReader;\nimport java.lang.StringBuilder;\nimport java.io.FileReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.nio.charset.StandardCharsets;\n\npublic class RsaTest\n{\n    public static String readTokenFile() throws IOException, FileNotFoundException\n    {\n        BufferedReader br = new BufferedReader(new FileReader(\"token.txt\"));\n        String everything;\n        try {\n            StringBuilder sb = new StringBuilder();\n            String line = br.readLine();\n\n            while (line != null) {\n                sb.append(line);\n                sb.append(System.lineSeparator());\n                line = br.readLine();\n            }\n            everything = sb.toString();\n        } finally {\n            br.close();\n        }\n        return everything;\n    }\n\n    public static void main(String args[])\n    {\n        BigInteger d = new BigInteger(\"295037637291191738956635211796692963240490064989667014592826352469032152\" +\n        \"554302874575878226107217392868462250989293041036431894475130143513053896027950170894654313285696024572\" +\n        \"555534662699797386157658559164375812029364988576033978927620169476835254057350243662602730036794048964\" +\n        \"222696882434825511051317613969394699304819377647584836298910958813068451008480950615750481597424491969\" +\n        \"616122089713036168262562790026376709519880676568817708332018002498979363533291261269633760290508292885\" +\n        \"685631554642526071767451720995816315263034482926025947996376673879307443752926326504743341468067701663\" +\n        \"647011041587666229832948060125468304864468556385524233326117655101116575438068518128417547551238351385\" +\n        \"860308667178310273798307275716775496726007972420724941548071903190058191309574401221590126135595556423\" +\n        \"538805604263913766128874929792845212075676240959916344274635408931764294117768329862724498717467735936\" +\n        \"771182991195111736108715670105340851228608489685386356809638648591870140613333363474891211943508005174\" +\n        \"556955182421433325620501790085286962409667669154804819913241047270891375736816718480232577171854082683\" +\n        \"282930378415208382344040938073467357285325060767468878914840146155371082700586582168876180646622366892\" +\n        \"654491190772272882871959076736231875073\");\n        BigInteger e = new BigInteger(\"65537\");\n        BigInteger N = new BigInteger(\n        \"6118949884542035758228165150480970484775948540894875675750019196760430437326375788316244083667312\" +\n        \"1127912691592042082374698218570305709542452573367037247942794176360141330260796114161991634877520\" +\n        \"9318638985939797245838394186947432815805159715295950796093763256835288557638341359755154607092758\" +\n        \"2125876646350225386205170869478762584625481559337889894643589498753324189655838737003231877149808\" +\n        \"0769782782986004968223577252545632595856348578972986803087375151523130980468315658731145540661959\" +\n        \"6050525545290045046944269076387765616800870979827653118293545195314596061160131055834487112435567\" +\n        \"4188026149535089147013264878621144892167844471212662659174643958985053020651238408715157877344829\" +\n        \"6332175379863190146700888623219388047354669492295105275244771100851445677743253407525918517909312\" +\n        \"1064757322245873728715200541955720319721861626588734157728068815156326358980514571916869090216857\" +\n        \"1674529819233099030185697193927748667568997849788205951188943230054712902846136235791743994018772\" +\n        \"7474047360851939145847078056327450140607700002648843419498134708391530606499524381440473803469993\" +\n        \"9125774781194053568746989605638413082541876600142556111173865505734416200456890738357199900214109\" +\n        \"565602296409823349451352963303084528108078854673626645830490080013931\");\n\n        byte[] encryptedBytes = new byte[]{};\n        try {\n            String encryptedToken = readTokenFile();\n            encryptedBytes = DatatypeConverter.parseBase64Binary(encryptedToken);\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"File token.txt was not found.\");\n        } catch (IOException ex) {\n            System.out.println(\"IO error.\");\n        }\n        RSAPrivateKeySpec privateKeySpec = new RSAPrivateKeySpec(N, d);\n        try {\n            KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n            RSAPrivateKey privateKey = (RSAPrivateKey) factory.generatePrivate(privateKeySpec);\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-1AndMGF1Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n            byte[] token = cipher.doFinal(encryptedBytes);\n            System.out.println(new String(token, StandardCharsets.UTF_8));\n        } catch (NoSuchAlgorithmException ex) {\n            System.out.println(\"Missing algorithm.\");\n        } catch (InvalidKeySpecException ex) {\n            System.out.println(\"Invalid key spec.\");\n        } catch (NoSuchPaddingException ex) {\n            System.out.println(\"No such padding.\");\n        } catch (InvalidKeyException ex) {\n            System.out.println(\"Invalid key.\");\n        } catch (IllegalBlockSizeException ex) {\n            System.out.println(\"Wrong block size.\");\n        } catch (BadPaddingException ex) {\n            System.out.println(\"Bad padding.\");\n        }\n    }\n}\n", "public class EasyX509TrustManager\n    implements X509TrustManager {\n\nprivate X509TrustManager standardTrustManager = null;\n\n/**\n * Constructor for EasyX509TrustManager.\n */\npublic EasyX509TrustManager(KeyStore keystore)\n        throws NoSuchAlgorithmException, KeyStoreException {\n    super();\n    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    factory.init(keystore);\n    TrustManager[] trustmanagers = factory.getTrustManagers();\n    if (trustmanagers.length == 0) {\n        throw new NoSuchAlgorithmException(\"no trust manager found\");\n    }\n    this.standardTrustManager = (X509TrustManager) trustmanagers[0];\n}\n\n/**\n * @see X509TrustManager#checkClientTrusted(X509Certificate[], String authType)\n */\npublic void checkClientTrusted(X509Certificate[] certificates, String authType)\n        throws CertificateException {\n    standardTrustManager.checkClientTrusted(certificates, authType);\n}\n\n/**\n * @see X509TrustManager#checkServerTrusted(X509Certificate[], String authType)\n */\npublic void checkServerTrusted(X509Certificate[] certificates, String authType)\n        throws CertificateException {\n    if ((certificates != null) &amp;&amp; (certificates.length == 1)) {\n        certificates[0].checkValidity();\n    } else {\n        standardTrustManager.checkServerTrusted(certificates, authType);\n    }\n}\n\n/**\n * @see X509TrustManager#getAcceptedIssuers()\n */\npublic X509Certificate[] getAcceptedIssuers() {\n    return this.standardTrustManager.getAcceptedIssuers();\n}\n", "private SSLContext sslcontext = null;\n\nprivate static SSLContext createEasySSLContext() throws IOException {\n    try {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(null, new TrustManager[]{new EasyX509TrustManager(\n                null)}, null);\n        return context;\n    } catch (Exception e) {\n        throw new IOException(e.getMessage());\n    }\n}\n\nprivate SSLContext getSSLContext() throws IOException {\n    if (this.sslcontext == null) {\n        this.sslcontext = createEasySSLContext();\n    }\n    return this.sslcontext;\n}\n\n/**\n * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(Socket,\n * String, int, InetAddress, int,\n * HttpParams)\n */\npublic Socket connectSocket(Socket sock, String host, int port,\n                            InetAddress localAddress, int localPort, HttpParams params)\n        throws IOException, UnknownHostException, ConnectTimeoutException {\n    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n    int soTimeout = HttpConnectionParams.getSoTimeout(params);\n\n    InetSocketAddress remoteAddress = new InetSocketAddress(host, port);\n    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());\n\n    if ((localAddress != null) || (localPort &gt; 0)) {\n        // we need to bind explicitly\n        if (localPort &lt; 0) {\n            localPort = 0; // indicates \"any\"\n        }\n        InetSocketAddress isa = new InetSocketAddress(localAddress,\n                localPort);\n        sslsock.bind(isa);\n    }\n\n    sslsock.connect(remoteAddress, connTimeout);\n    sslsock.setSoTimeout(soTimeout);\n    return sslsock;\n\n}\n\n/**\n * @see org.apache.http.conn.scheme.SocketFactory#createSocket()\n */\npublic Socket createSocket() throws IOException {\n    return getSSLContext().getSocketFactory().createSocket();\n}\n\n/**\n * @see org.apache.http.conn.scheme.SocketFactory#isSecure(Socket)\n */\npublic boolean isSecure(Socket socket) throws IllegalArgumentException {\n    return true;\n}\n\n/**\n * @see LayeredSocketFactory#createSocket(Socket,\n * String, int, boolean)\n */\npublic Socket createSocket(Socket socket, String host, int port,\n                           boolean autoClose) throws IOException, UnknownHostException {\n    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n}\n\n// -------------------------------------------------------------------\n// javadoc in org.apache.http.conn.scheme.SocketFactory says :\n// Both Object.equals() and Object.hashCode() must be overridden\n// for the correct operation of some connection managers\n// -------------------------------------------------------------------\n\npublic boolean equals(Object obj) {\n    return ((obj != null) &amp;&amp; obj.getClass().equals(\n            EasySSLSocketFactory.class));\n}\n\npublic int hashCode() {\n    return EasySSLSocketFactory.class.hashCode();\n}\n", "/* ... */\npublic class MyHostnameVerifier extends AbstractVerifier {\n  boolean verify(String hostname, SSLSession session) {\n    X509Certificate[] chain = session.getPeerCertificateChain();\n    /* made some checks... */\n    return checked;\n  }\n}\nsslSocketFactory.setHostnameVerifier(new MyHostnameVerifier());\n", "static void setKey(byte[] keybytes, byte[] iv) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, NoSuchProviderException\n{\n    /**\n     * crypto is specifically stated here because without using AndroidOpenSSL for the SHA1PRNG breaks on some phones,\n     * PRNGFixes.apply() should be called if using this\n     * https://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html \n     */\n    random = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n    key = new SecretKeySpec(keybytes, \"AES\");\n    ivspec = new IvParameterSpec(iv);\n    encryptcipher = Cipher.getInstance(\"AES/CFB/NoPadding\", \"SC\");\n    encryptcipher.init(Cipher.ENCRYPT_MODE, key, ivspec, random);\n\n    decryptcipher = Cipher.getInstance(\"AES/CFB/NoPadding\", \"SC\");\n    decryptcipher.init(Cipher.DECRYPT_MODE, key, ivspec, random);       \n}\n", "public class HttpsTrustManager implements X509TrustManager {\n\n    private static TrustManager[] trustManagers;\n    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};\n\n    @Override\n    public void checkClientTrusted(\n            java.security.cert.X509Certificate[] x509Certificates, String s)\n            throws java.security.cert.CertificateException {\n\n    }\n\n    @Override\n    public void checkServerTrusted(\n            java.security.cert.X509Certificate[] x509Certificates, String s)\n            throws java.security.cert.CertificateException {\n\n    }\n\n    public boolean isClientTrusted(X509Certificate[] chain) {\n        return true;\n    }\n\n    public boolean isServerTrusted(X509Certificate[] chain) {\n        return true;\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return _AcceptedIssuers;\n    }\n\n    public static void allowAllSSL() {\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n\n            @Override\n            public boolean verify(String arg0, SSLSession arg1) {\n                return true;\n            }\n\n        });\n\n        SSLContext context = null;\n        if (trustManagers == null) {\n            trustManagers = new TrustManager[]{new HttpsTrustManager()};\n        }\n\n        try {\n            context = SSLContext.getInstance(\"TLS\");\n            context.init(null, trustManagers, new SecureRandom());\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (KeyManagementException e) {\n            e.printStackTrace();\n        }\n\n        HttpsURLConnection.setDefaultSSLSocketFactory(context\n                .getSocketFactory());\n    }\n\n}\n", "  try {\n                PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\n                for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n                    Log.e(\"MY KEY HASH:\", sign);\n                    //textInstructionsOrLink = (TextView)findViewById(R.id.textstring);\n                    //textInstructionsOrLink.setText(sign);\n                    Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG).show();\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                Log.d(\"nope\", \"nope\");\n            } catch (NoSuchAlgorithmException e) {\n            }\n", "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.Security;\nimport java.util.List;\nimport java.util.Properties;\n\nimport javax.activation.DataHandler;\nimport javax.activation.DataSource;\nimport javax.activation.FileDataSource;\nimport javax.mail.BodyPart;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Multipart;\nimport javax.mail.PasswordAuthentication;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\n\nimport android.net.Uri;\n\npublic class GMailSender extends javax.mail.Authenticator {\nprivate String mailhost = \"smtp.gmail.com\";\nprivate String user;\nprivate String password;\nprivate Session session;\nString ContentType = \"\";\nstatic {\n    Security.addProvider(new JSSEProvider());\n}\n\npublic GMailSender(String user, String password) {\n    this.user = user;\n    this.password = password;\n\n    Properties props = new Properties();\n    props.setProperty(\"mail.transport.protocol\", \"smtp\");\n    props.setProperty(\"mail.host\", mailhost);\n    props.put(\"mail.smtp.auth\", \"true\");\n    props.put(\"mail.smtp.port\", \"465\");\n    props.put(\"mail.smtp.socketFactory.port\", \"465\");\n    props.put(\"mail.smtp.socketFactory.class\",\n            \"javax.net.ssl.SSLSocketFactory\");\n    props.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n    props.setProperty(\"mail.smtp.quitwait\", \"false\");\n\n    session = Session.getDefaultInstance(props, this);\n}\n\nprotected PasswordAuthentication getPasswordAuthentication() {\n    return new PasswordAuthentication(user, password);\n}\n\npublic synchronized void sendMail(String subject, String body,\n        String sender, String recipients, List&lt;Uri&gt; uriList)\n        throws Exception {\n\n    try {\n        MimeMessage message = new MimeMessage(session);\n        message.setFrom(new InternetAddress(user));\n        message.addRecipient(Message.RecipientType.TO, new InternetAddress(\n                recipients));\n        message.setSubject(subject);\n\n        // 3) create MimeBodyPart object and set your message content\n        BodyPart messageBodyPart1 = new MimeBodyPart();\n        messageBodyPart1.setText(body);\n\n        Multipart multipart = new MimeMultipart();\n        multipart.addBodyPart(messageBodyPart1);\n\n        for (int i = 0; i &lt; uriList.size(); i++) {\n            // 4) create new MimeBodyPart object and set DataHandler object\n            // to this object\n            MimeBodyPart messageBodyPart2 = new MimeBodyPart();\n            String filename = uriList\n                    .get(i)\n                    .getPath()\n                    .substring(\n                            uriList.get(i).getPath().lastIndexOf(\"/\") + 1,\n                            uriList.get(i).getPath().length());// change\n                                                                // accordingly\n            System.out.println(\"filename \" + filename);\n            DataSource source = new FileDataSource(uriList.get(i).getPath());\n            messageBodyPart2.setDataHandler(new DataHandler(source));\n            messageBodyPart2.setFileName(filename);\n            // 5) create Multipart object and add MimeBodyPart objects to\n            // this object\n            multipart.addBodyPart(messageBodyPart2);\n        }\n\n        // 6) set the multiplart object to the message object\n        message.setContent(multipart);\n\n        // 7) send message\n        Transport.send(message);\n\n        System.out.println(\"message sent....\");\n    } catch (MessagingException ex) {\n        ex.printStackTrace();\n    }\n}\n", "  private void generateHashKey() {\n\n        try {\n            PackageInfo info = getPackageManager().getPackageInfo                       (\"loginwith.gplush.android\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String hashCode  = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n                System.out.println(\"Print the hashKey for Facebook :\"+hashCode);\n                Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(),          Base64.DEFAULT));\n            }\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n    }\n", "KeyStore ks = getKeystore();\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init(ks);\nTrustManager[] tms = tmf.getTrustManagers();\nSSLContext ctx = SSLContext.getDefault();\nctx.init(null, tms, null);\nHttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());\n", "private static String generateAndroidId() {\n    String generated = null;\n    try {\n        final SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n        random.setSeed( (System.nanoTime() + new SecureRandom().nextLong()).getBytes() );\n        generated = Long.toHexString(random.nextLong());\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(TAG, \"Unexpected exception\", e);\n    }\n    return generated;\n}\n", "    try {\n        PackageInfo pi = this.getPackageManager().getPackageInfo( this.getPackageName(), PackageManager.GET_SIGNATURES);\n        Signature[] signatures = pi.signatures;\n        byte[] cert = signatures[0].toByteArray();\n        InputStream input = new ByteArrayInputStream(cert);\n        CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n        X509Certificate cf509 = (X509Certificate) cf.generateCertificate(input);\n        Log.d(LOG_TAG, \"Certificate issued by: \" + cf509.getIssuerDN() );\n    } catch ( Exception e ) {\n", "  public void trustEveryone() {\n        try {\n            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){\n                    public boolean verify(String hostname, SSLSession session) {\n                        return true;\n                    }});\n            SSLContext context = SSLContext.getInstance(\"TLS\");\n            context.init(null, new X509TrustManager[]{new X509TrustManager(){\n                public void checkClientTrusted(X509Certificate[] chain,\n                        String authType) throws CertificateException {}\n                public void checkServerTrusted(X509Certificate[] chain,\n                        String authType) throws CertificateException {}\n                public X509Certificate[] getAcceptedIssuers() {\n                    return new X509Certificate[0];\n                }}}, new SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(\n                    context.getSocketFactory());\n        } catch (Exception e) { // should never happen\n            e.printStackTrace();\n        }\n    }\n\nThen call it before opening the URL.\n\n\n\n    public void get() {\n     try \n     { \n         trustEveryone();\n         SAXParserFactory factory = SAXParserFactory.newInstance(); \n         SAXParser mSaxParser = factory.newSAXParser(); \n         XMLReader mXmlReader = mSaxParser.getXMLReader(); \n         mXmlReader.setContentHandler(this); \n         InputStream mInputStream = new URL(URL_MAIN).openStream();\n\n         mXmlReader.parse(new InputSource(mInputStream));\n     } \n     catch(Exception e) \n     { \n         Log.e(TAG, \"Exception: \" + e.getMessage()); \n     } \n } \n", "HttpClient httpclient = getNewHttpClient();\n\nStrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder()\n                .permitAll().build();\n        StrictMode.setThreadPolicy(policy);\n\n\npublic HttpClient getNewHttpClient() {\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore\n                    .getDefaultType());\n            trustStore.load(null, null);\n\n            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n            HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory\n                    .getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sf, 443));\n\n\n\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(\n                    params, registry);\n\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception e) {\n            return new DefaultHttpClient();\n        }\n    }\n", "    MessageDigest md1 = MessageDigest.getInstance(\"MD5\");\n    md1.update(new byte[] {1, 2});\n    md1.update(new byte[] {3, 4});\n    System.out.println(Arrays.toString(md1.digest()));\n\n    MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n    md2.update(new byte[] {1, 2, 3, 4});\n    System.out.println(Arrays.toString(md2.digest()));\n", "private static String toHexString(final byte[] bytes) {\n    final Formatter formatter = new Formatter();\n    for (final byte b : bytes) {\n        formatter.format(\"%02x\", b);\n    }\n    return formatter.toString();\n}\n\npublic static String hmacSha256(final String key, final String s) {\n    try {\n        final Mac mac = Mac.getInstance(\"HmacSHA256\");\n        mac.init(new SecretKeySpec(key.getBytes(), \"HmacSHA256\");\n        return toHexString(mac.doFinal(s.getBytes()));\n    }\n    catch (final Exception e) {\n        // ...\n    }\n}\n", "     void getHasKey()\n     {\n      //Get Has Key \n        try \n        {\n            PackageInfo info = getPackageManager().getPackageInfo(\"your package name\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) \n            {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.e(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } \n        catch (NameNotFoundException e) \n        {\n            e.printStackTrace();\n        } \n        catch (Exception e) \n        {\n            e.printStackTrace();\n        }\n    }\n", "public byte[] crypt(byte[] toCrypt) throws Exception {\n    byte[] key = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    System.arraycopy(this.passphrase.getBytes(), 0, key, 0, ((this.passphrase.getBytes().length &lt; 16) ? this.passphrase.getBytes().length : 16));\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(toCrypt);\n    return encrypted;\n}\n", "public byte[] decryptt(byte[] toDecrypt) throws Exception {\n    byte[] key = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    System.arraycopy(this.passphrase.getBytes(), 0, key, 0, ((this.passphrase.getBytes().length &lt; 16) ? this.passphrase.getBytes().length : 16));\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] original = cipher.doFinal(toDecrypt);\n    return original;\n}\n", "    public class SocketIOClient {\n    private static final String serverUrl = \"http://example-socket-server.jit.su\";\n    private static SocketIO socket;\n    private static SocketIOClient instance;\n    private static Activity act;\n    private static String id;\n\n    public SocketIOClient() {\n    }\n\n    public static void initInstance(String uid) throws MalformedURLException {\n        if (instance == null) {\n            instance = new SocketIOClient();\n            instance.initID(uid);\n            if (SocketIOClient.getSocket() == null) {\n                SocketIOClient.setSocket(new SocketIO());\n            }\n            SocketIOClient.connectIO();\n        }\n    }\n\n    public static void setActivity(Activity a) {\n        SocketIOClient.act = a;\n    }\n\n    public static SocketIO getSocket() {\n        return socket;\n    }\n\n    public static void setSocket(SocketIO socket) {\n        SocketIOClient.socket = socket;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    private void initID(String uid) {\n        if (SocketIOClient.id == null) {\n            SocketIOClient.id = uid;\n        }\n    }\n\n    public static void connectIO() throws MalformedURLException {\n        try {\n            SocketIO.setDefaultSSLSocketFactory(SSLContext.getDefault());\n        } catch (NoSuchAlgorithmException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        }\n        SocketIOClient.getSocket().connect(serverUrl, new IOCallback() {\n            @Override\n            public void onMessage(JSONObject json, IOAcknowledge ack) {\n                // TODO Auto-generated method stub\n            }\n\n            @Override\n            public void onMessage(String data, IOAcknowledge ack) {\n\n            }\n\n            @Override\n            public void onError(SocketIOException socketIOException) {\n            }\n\n            @Override\n            public void onDisconnect() {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public void onConnect() {\n\n            }\n\n            @Override\n            public void on(String event, IOAcknowledge ack, Object... args) {\n\n            }\n        });\n    }\n\n    public static void emit(String event, Object args)\n            throws MalformedURLException {\n        if (SocketIOClient.getSocket().isConnected() == false) {\n            SocketIOClient.getSocket().reconnect();\n        }\n        SocketIOClient.getSocket().emit(event, args);\n    }\n\n    public static void emitWithAcknowledge(String event, Object args)\n            throws MalformedURLException {\n        if (SocketIOClient.getSocket().isConnected() == false) {\n            SocketIOClient.getSocket().reconnect();\n        }\n        SocketIOClient.getSocket().emit(event, new IOAcknowledge() {\n\n            @Override\n            public void ack(Object... args) {\n                // TODO Auto-generated method stub\n\n            }\n        }, args);\n    }\n\n}\n", "public static String encryptPadding(String plaintext, byte[] salt) {\n    try {\n\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        cipher.init(Cipher.ENCRYPT_MODE, SKey, ivSpec);\n\n        byte[] cipherText = cipher.doFinal(PlainText.getBytes(\"UTF-8\"));\n\n        cyphertext = Base64.encodeToString(cipherText, Base64.DEFAULT);\n        edit_txt_enc_string.setText(cyphertext);\n        return cyphertext;\n    } catch (GeneralSecurityException e) {\n        throw new RuntimeException(e);\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(e);\n    }\n}\n\npublic static String decryptPadding(String ctext, byte[] salt) {\n    try {\n\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        cipher.init(Cipher.DECRYPT_MODE, SKey, ivSpec);\n\n        byte[] plaintxt = cipher.doFinal(Base64.decode(cyphertext, Base64.DEFAULT));\n\n        PlainText = new String(plaintxt, \"UTF-8\");\n        edit_txt_dec_string.setText(PlainText);\n        return PlainText;\n    } catch (GeneralSecurityException e) {\n        throw new RuntimeException(e);\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(e);\n    }\n}\n", "try \n        {\n            KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\n            if (ks != null) \n            {\n                ks.load(null, null);\n                Enumeration aliases = ks.aliases();\n                while (aliases.hasMoreElements()) \n                {\n                    String alias = (String) aliases.nextElement();\n                    java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);\n\n                    if (cert.getIssuerDN().getName().contains(\"MyCert\")) \n                    {\n                        isCertExist = true;\n                        break;\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (java.security.cert.CertificateException e) {\n            e.printStackTrace();\n        }\n", "public static final class OAuth2Provider extends Provider {\nprivate static final long serialVersionUID = 1L;\n\npublic OAuth2Provider() {\n  super(\"Google OAuth2 Provider\", 1.0,\n        \"Provides the XOAUTH2 SASL Mechanism\");\n  put(\"SaslClientFactory.XOAUTH2\",\n      \"com.example.testjavamail.OAuth2SaslClientFactory\");\n}\n", "public class OAuth2Authenticator {\nprivate static final Logger logger = Logger\n        .getLogger(OAuth2Authenticator.class.getName());\nprivate static Session mSession;\n\npublic static final class OAuth2Provider extends Provider {\n    private static final long serialVersionUID = 1L;\n\n    public OAuth2Provider() {\n        super(\"Google OAuth2 Provider\", 1.0,\n                \"Provides the XOAUTH2 SASL Mechanism\");\n        put(\"SaslClientFactory.XOAUTH2\",\n                \"com.example.testjavamail.OAuth2SaslClientFactory\");\n    }\n}\n\npublic static void initialize() {\n    Security.addProvider(new OAuth2Provider());\n}\n\npublic static IMAPStore connectToImap(String host, int port,\n        String userEmail, String oauthToken, boolean debug)\n        throws Exception {\n    Properties props = new Properties();\n    props.put(\"mail.imaps.sasl.enable\", \"true\");\n    props.put(\"mail.imaps.sasl.mechanisms\", \"XOAUTH2\");\n    props.put(OAuth2SaslClientFactory.OAUTH_TOKEN_PROP, oauthToken);\n    Session session = Session.getInstance(props);\n    session.setDebug(debug);\n\n    final URLName unusedUrlName = null;\n    IMAPSSLStore store = new IMAPSSLStore(session, unusedUrlName);\n    final String emptyPassword = \"\";\n    store.connect(host, port, userEmail, emptyPassword);\n    return store;\n}\n\npublic static SMTPTransport connectToSmtp(String host, int port,\n        String userEmail, String oauthToken, boolean debug)\n        throws Exception {\n    Properties props = new Properties();\n    props.put(\"mail.smtp.starttls.enable\", \"true\");\n    props.put(\"mail.smtp.starttls.required\", \"true\");\n    props.put(\"mail.smtp.sasl.enable\", \"true\");\n    props.put(\"mail.smtp.sasl.mechanisms\", \"XOAUTH2\");\n    props.put(OAuth2SaslClientFactory.OAUTH_TOKEN_PROP, oauthToken);\n    mSession = Session.getInstance(props);\n    mSession.setDebug(debug);\n\n    final URLName unusedUrlName = null;\n    SMTPTransport transport = new SMTPTransport(mSession, unusedUrlName);\n    // If the password is non-null, SMTP tries to do AUTH LOGIN.\n    final String emptyPassword = null;\n    transport.connect(host, port, userEmail, emptyPassword);\n\n    return transport;\n}\n\npublic synchronized void testImap(String user, String oauthToken) {\n    try {\n\n        initialize();\n\n\n        IMAPStore imapStore = connectToImap(\"imap.gmail.com\", 993, user,\n                oauthToken, true);\n\n    } catch (Exception e) {\n        Log.d(\"test\", e.toString());\n    }\n\n}\n\npublic class ByteArrayDataSource implements DataSource {\n    private byte[] data;\n    private String type;\n\n    public ByteArrayDataSource(byte[] data, String type) {\n        super();\n        this.data = data;\n        this.type = type;\n    }\n\n    public ByteArrayDataSource(byte[] data) {\n        super();\n        this.data = data;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getContentType() {\n        if (type == null)\n            return \"application/octet-stream\";\n        else\n            return type;\n    }\n\n    public InputStream getInputStream() throws IOException {\n        return new ByteArrayInputStream(data);\n    }\n\n    public String getName() {\n        return \"ByteArrayDataSource\";\n    }\n\n    public OutputStream getOutputStream() throws IOException {\n        throw new IOException(\"Not Supported\");\n    }\n}\n", "        try{\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.update(password.getBytes());\n            String newPass = digest.toString();\n            System.out.println(\"**** \" + newPass);\n            return newPass;\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Author.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return \"\";\n", "import java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.Security;\nimport java.util.Properties;\n\nimport javax.activation.DataHandler;\nimport javax.activation.DataSource;\nimport javax.activation.FileDataSource;\nimport javax.mail.Message;\nimport javax.mail.Multipart;\nimport javax.mail.PasswordAuthentication;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\n\npublic class GMailSender extends javax.mail.Authenticator {\n    private String mailhost = \"smtp.gmail.com\";\n    private String user;\n    private String password;\n    private Session session;\n\n    static {\n        Security.addProvider(new JSSEProvider());\n    }\n\n    public GMailSender(String user, String password) {\n        this.user = user;\n        this.password = password;\n\n        Properties props = new Properties();\n        props.setProperty(\"mail.transport.protocol\", \"smtp\");\n        props.setProperty(\"mail.host\", mailhost);\n        props.put(\"mail.smtp.auth\", \"true\");\n        props.put(\"mail.smtp.port\", \"465\");\n        props.put(\"mail.smtp.socketFactory.port\", \"465\");\n        props.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n        props.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n        props.setProperty(\"mail.smtp.quitwait\", \"false\");\n\n        session = Session.getDefaultInstance(props, this);\n    }\n\n    protected PasswordAuthentication getPasswordAuthentication() {\n        return new PasswordAuthentication(user, password);\n    }\n\n    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {\n        try {\n            MimeMessage message = new MimeMessage(session);\n            DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));\n            message.setSender(new InternetAddress(sender));\n            message.setSubject(subject);\n            message.setDataHandler(handler);\n            if (recipients.indexOf(',') &gt; 0)\n                message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));\n            else\n                message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));\n            Transport.send(message);\n        } catch (Exception e) {\n\n        }\n    }\n\n    public synchronized void sendMail(String subject, String body, String senderEmail, String recipients, String filePath,String logFilePath) throws Exception {\n        boolean fileExists = new File(filePath).exists();\n        if (fileExists) {\n\n            String from = senderEmail;\n            String to = recipients;\n            String fileAttachment = filePath;\n\n            // Define message\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n            message.setSubject(subject);\n\n            // create the message part\n            MimeBodyPart messageBodyPart = new MimeBodyPart();\n\n            // fill message\n            messageBodyPart.setText(body);\n\n            Multipart multipart = new MimeMultipart();\n            multipart.addBodyPart(messageBodyPart);\n\n            // Part two is attachment\n            messageBodyPart = new MimeBodyPart();\n            DataSource source = new FileDataSource(fileAttachment);\n            messageBodyPart.setDataHandler(new DataHandler(source));\n            messageBodyPart.setFileName(\"screenShoot.jpg\");\n            multipart.addBodyPart(messageBodyPart);\n\n\n            //part three for logs\n            messageBodyPart = new MimeBodyPart();\n            DataSource sourceb = new FileDataSource(logFilePath);\n            messageBodyPart.setDataHandler(new DataHandler(sourceb));\n            messageBodyPart.setFileName(\"logs.txt\");\n            multipart.addBodyPart(messageBodyPart);\n\n\n            // Put parts in message\n            message.setContent(multipart);\n\n            // Send the message\n            Transport.send(message);\n        }else{\n            sendMail( subject, body,  senderEmail,  recipients);\n        }\n    }\n\n    public class ByteArrayDataSource implements DataSource {\n        private byte[] data;\n        private String type;\n\n        public ByteArrayDataSource(byte[] data, String type) {\n            super();\n            this.data = data;\n            this.type = type;\n        }\n\n        public ByteArrayDataSource(byte[] data) {\n            super();\n            this.data = data;\n        }\n\n        public void setType(String type) {\n            this.type = type;\n        }\n\n        public String getContentType() {\n            if (type == null)\n                return \"application/octet-stream\";\n            else\n                return type;\n        }\n\n        public InputStream getInputStream() throws IOException {\n            return new ByteArrayInputStream(data);\n        }\n\n        public String getName() {\n            return \"ByteArrayDataSource\";\n        }\n\n        public OutputStream getOutputStream() throws IOException {\n            throw new IOException(\"Not Supported\");\n        }\n    }\n}\n", "String plainText = \"Hello, World! This is a Java/Javascript AES test.\";\nSecretKey key = new SecretKeySpec(\n    Base64.decodeBase64(\"u/Gu5posvwDsXUnV5Zaq4g==\"), \"AES\");\nAlgorithmParameterSpec iv = new IvParameterSpec(\n    Base64.decodeBase64(\"5D9r9ZVzEYYgha93/aUK2w==\")); \nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, key, iv);\nSystem.out.println(Base64.encodeBase64String(cipher.doFinal(\n    plainText.getBytes(\"UTF-8\"))));\n", "public ApiService() {\n    mClient = new OkHttpClient();\n    mClient.setConnectTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n    mClient.setReadTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n    mClient.setCache(getCache());\n    mClient.setSslSocketFactory(getSSL());\n}\n\nprotected SSLSocketFactory getSSL() {\n    try {\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        InputStream cert = getAppContext().getResources().openRawResource(R.raw.client);\n        Certificate ca = cf.generateCertificate(cert);\n        cert.close();\n\n        // creating a KeyStore containing our trusted CAs\n        String keyStoreType = KeyStore.getDefaultType();\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        keyStore.load(null, null);\n        keyStore.setCertificateEntry(\"ca\", ca);\n\n        return new AdditionalKeyStore(keyStore);\n    } catch(Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    \"com.josh.myapp\", \n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"joshtag\", \"KeyHash:\"+Base64.encodeToString(md.digest(), Base64.DEFAULT));                              \n                } \n            } \n        catch (NameNotFoundException e) { } \n        catch (NoSuchAlgorithmException e) { }   \n", "    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"your package name, e.g. com.yourcompany.yourapp]\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"com.facebook.samples.hellofacebook\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n\n    ...\n}\n", "public static byte[] encrypt(SecretKey secret, byte[] buffer) throws GeneralSecurityException\n{\n    /* Encrypt the message. */\n    Cipher cipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n\n    SecureRandom rng = new SecureRandom();\n    byte[] ivData = new byte[cipher.getBlockSize()];\n    rng.nextBytes(ivData);\n\n    cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(ivData));\n    byte[] ciphertext = cipher.doFinal(buffer);\n\n    return Arrays.concatenate(ivData, ciphertext);\n}\n\npublic static byte[] decrypt(SecretKey secret, byte[] buffer) throws GeneralSecurityException\n{\n    /* Decrypt the message. - use cipher instance created at encrypt */\n    Cipher cipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n\n    int n = cipher.getBlockSize();\n    byte[] ivData = Arrays.copyOf(buffer, n);\n\n    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivData));\n    byte[] clear = cipher.doFinal(buffer, n, buffer.length - n);\n\n    return clear;\n}\n", "private void HttpLogin() {\n    // Define Progress Dialog\n    ProgressDialog progressDialog = ProgressDialog.show(this, \"Verifying\", \"Loading..\", true);\n\n    // Variable\n    EditText username = (EditText) findViewById(R.id.txtUsername);\n    EditText password = (EditText) findViewById(R.id.txtPassword);\n    Spinner company = (Spinner)findViewById(R.id.ddlCompany);\n    StringBuilder sb = new StringBuilder();\n    String title = \"\";\n    CompanyInfo companyInfo = (CompanyInfo)company.getSelectedItem();\n    final String user = username.getText() + \"\";\n    final String pass = password.getText() + \"\";\n    final String domain = companyInfo.getCompanyDomain();\n    String authorization = domain + \"\\\\\" + user + \":\" + pass;\n\n    TrustManager trustManager = new X509TrustManager() {\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() { return null; }\n    };\n\n    // Check\n    if (user != \"\" &amp;&amp; pass != \"\" &amp;&amp; domain != \"\") {\n\n        // Error Handling\n        try {\n            // Reset Variable\n            sb = new StringBuilder();\n            title = \"\";\n\n            // Certificate\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, new TrustManager[] { trustManager }, new SecureRandom());\n\n            // Add Socket Factory\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n            // Accept All Host Verifier\n            HostnameVerifier allHostValid = new HostnameVerifier() {\n                @Override\n                public boolean verify(String hostname, SSLSession session) { return true; }\n            };\n            HttpsURLConnection.setDefaultHostnameVerifier(allHostValid);\n\n            // Set Urls\n            URL url = new URL(\"https://YourUrlAddess/\");\n\n            // Open Connection\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n            conn.setRequestMethod(Constant._REQUEST_METHOD_GET);\n            conn.setRequestProperty(\"Accept\", \"*/*\");\n            conn.setRequestProperty(\"Authorization\", \"Basic \" + Base64.encodeToString(authorization.getBytes(), Base64.NO_WRAP));\n            conn.connect();\n\n            // Check\n            if (conn.getResponseCode() == 401) {\n                title = \"Login Failed\";\n                sb.append(\"Login username or password invalid.\");\n                conn.disconnect();\n            }\n            else if(conn.getResponseCode() == 200)\n            {\n                title = \"Authorized\";\n                sb.append(\"You have login to SharePoint\");\n                conn.disconnect();\n\n                Intent intent = new Intent(this, eLeave_HomeActivity.class);\n                intent.putExtra(_Username, user);\n                startActivity(intent);\n            }\n            else\n            {\n                title = \"Unknown Error\";\n                sb.append(conn.getResponseCode() + \": \" + conn.getResponseMessage());\n            }\n\n\n        } catch (Exception ex) { sb.append(ex.toString()); }\n    }\n    else\n    {\n        title = \"Login Failed\";\n        sb.append(\"Username or Password or company cannot be empty\");\n    }\n    progressDialog.dismiss();\n    AlertMessage(title, sb.toString());\n}\n", "SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n", "public class GetMethodEx {\n\npublic String getInternetData() throws Exception {\n\n\n    BufferedReader in = null;\n    String data = null;\n\n    try {\n        HttpClient client = new DefaultHttpClient();\n        client.getConnectionManager().getSchemeRegistry().register(getMockedScheme());\n\n        URI website = new URI(\"https://server.com:8443/XoW\"); \n        HttpGet request = new HttpGet();\n        request.setURI(website);\n        HttpResponse response = client.execute(request);\n        response.getStatusLine().getStatusCode();\n\n        in = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        StringBuffer sb = new StringBuffer(\"\");\n        String l = \"\";\n        String nl = System.getProperty(\"line.separator\");\n        while ((l = in.readLine()) != null) {\n            sb.append(l + nl);\n        }\n        in.close();\n        data = sb.toString();\n        return data;\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n                return data;\n            } catch (Exception e) {\n                Log.e(\"GetMethodEx\", e.getMessage());\n            }\n        }\n    }\n}\n\npublic Scheme getMockedScheme() throws Exception {\n    MySSLSocketFactory mySSLSocketFactory = new MySSLSocketFactory();\n    return new Scheme(\"https\", mySSLSocketFactory, 443);\n}\n\nclass MySSLSocketFactory extends SSLSocketFactory {\n    javax.net.ssl.SSLSocketFactory socketFactory = null;\n\n    public MySSLSocketFactory(KeyStore truststore) throws Exception {\n        super(truststore);\n        socketFactory = getSSLSocketFactory();\n    }\n\n    public MySSLSocketFactory() throws Exception {\n        this(null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,\n            UnknownHostException {\n        return socketFactory.createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return socketFactory.createSocket();\n    }\n\n    javax.net.ssl.SSLSocketFactory getSSLSocketFactory() throws Exception {\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n        sslContext.init(null, new TrustManager[] { tm }, null);\n        return sslContext.getSocketFactory();\n    }\n}\n}\n", "public class AesFileIo {\n    private static final String EOL = \"\\n\";\n    private static final String AES_ALGORITHM = \"AES/CTR/NoPadding\";\n    private SecretKeySpec secretKeySpec;\n    private IvParameterSpec ivSpec;\n    private static final String PROVIDER = \"BC\"; \n\n    AesFileIo(byte[] aesKey, byte[] iv) {\n        ivSpec = new IvParameterSpec(iv);\n        secretKeySpec = new SecretKeySpec(aesKey, \"AES\");\n    }\n\n    public String readFile(Context c, String fileName) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try {\n            InputStream is = c.openFileInput(fileName);\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM, PROVIDER);\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\n            CipherInputStream cis = new CipherInputStream(is, cipher);\n            InputStreamReader isr = new InputStreamReader(cis);\n            BufferedReader reader = new BufferedReader(isr);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line).append(EOL);\n            }\n            is.close();\n        } catch (java.io.FileNotFoundException e) {\n            // OK, file probably not created yet\n            Log.i(this.getClass().toString(), e.getMessage(), e);\n        } catch (Exception e) {\n            Log.e(this.getClass().toString(), e.getMessage(), e);\n        }\n        return stringBuilder.toString();\n    }\n\n    public void writeFile(Context c, String fileName, String theFile) {\n        try {\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM, PROVIDER); \n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);\n            byte[] encrypted = cipher.doFinal(theFile.getBytes()); \n            OutputStream os = c.openFileOutput(fileName, 0);\n            os.write(encrypted);\n            os.flush();\n            os.close();\n        } catch (Exception e) {\n            Log.e(this.getClass().toString(), e.getMessage(), e);\n        }\n    }\n}\n", "public class AesFileIo {\n\n    private static final String EOL = \"\\n\";\n    private static final String AES_ALGORITHM = \"AES/CTR/NoPadding\";\n    private SecretKeySpec secretKeySpec;\n    private IvParameterSpec ivSpec;\n\n    AesFileIo(byte[] aesKey, byte[] iv) {\n        Security.addProvider(new org.bouncycastle.jce.provider\n                .BouncyCastleProvider());\n        ivSpec = new IvParameterSpec(iv);\n        secretKeySpec = new SecretKeySpec(aesKey, \"AES\");\n    }\n\n    public String readFile(String fileName) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try {\n            FileInputStream fis = new FileInputStream(fileName);\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\n            CipherInputStream cis = new CipherInputStream(fis, cipher);\n            InputStreamReader isr = new InputStreamReader(cis);\n            BufferedReader reader = new BufferedReader(isr);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line).append(EOL);\n            }\n            fis.close();\n        } catch (java.io.FileNotFoundException e) {\n            System.out.println(\"FileNotFoundException: probably OK\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n\n    public void writeFile(String fileName, String theFile) {\n        try {\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);\n            byte[] encrypted = cipher.doFinal(theFile.getBytes());\n            FileOutputStream fos = new FileOutputStream(fileName);\n            fos.write(encrypted);\n            fos.flush();\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "import java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class AeSimpleSHA1 {\n    private static String convertToHex(byte[] data) {\n        StringBuilder buf = new StringBuilder();\n        for (byte b : data) {\n            int halfbyte = (b &gt;&gt;&gt; 4) &amp; 0x0F;\n            int two_halfs = 0;\n            do {\n                buf.append((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));\n                halfbyte = b &amp; 0x0F;\n            } while (two_halfs++ &lt; 1);\n        }\n        return buf.toString();\n    }\n\n    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        byte[] sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n}\n", "package com.test.util;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AesUtil {\n\n    public static String key = \"0000000000000090\";\n\n    /**\n     * hex to byte[] : 16dd\n     * @param hex    hex string\n     * @return\n     */\n    public static byte[] hexToByteArray(String hex) {\n        if (hex == null || hex.length() == 0) {\n            return null;\n        }\n\n        byte[] ba = new byte[hex.length() / 2];\n        for (int i = 0; i &lt; ba.length; i++) {\n            ba[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16);\n        }\n        return ba;\n    }\n\n    /**\n     * byte[] to hex : unsigned byte\n     *\n     * @param ba        byte[]\n     * @return\n     */\n    public static String byteArrayToHex(byte[] ba) {\n        if (ba == null || ba.length == 0) {\n            return null;\n        }\n\n        StringBuffer sb = new StringBuffer(ba.length * 2);\n        String hexNumber;\n        for (int x = 0; x &lt; ba.length; x++) {\n            hexNumber = \"0\" + Integer.toHexString(0xff &amp; ba[x]);\n\n            sb.append(hexNumber.substring(hexNumber.length() - 2));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * AES \n     *\n     * @param message\n     * @return\n     * @throws Exception\n     */\n    public static String encrypt(String message) throws Exception {\n        //KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        //kgen.init(128);\n        // use key coss2\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n\n        // Instantiate the cipher\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n        byte[] encrypted = cipher.doFinal(message.getBytes());\n        return byteArrayToHex(encrypted);\n    }\n\n    /**\n     * AES \n     *\n     * @param message\n     * @return\n     * @throws Exception\n     */\n    public static String decrypt(String encrypted) throws Exception {\n        //KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        //kgen.init(128);\n        // use key coss2\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] original = cipher.doFinal(hexToByteArray(encrypted));\n        String originalString = new String(original);\n        return originalString;\n    }\n}\n", "       // Get the KeyGenerator\n\n       KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n       kgen.init(128); // 192 and 256 bits may not be available\n\n\n       // Generate the secret key specs.\n       SecretKey skey = kgen.generateKey();\n       byte[] raw = skey.getEncoded();\n\n       SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n\n       // Instantiate the cipher\n\n       Cipher cipher = Cipher.getInstance(\"AES\");\n\n       cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n       byte[] encrypted =\n         cipher.doFinal((args.length == 0 ?\n          \"This is just an example\" : args[0]).getBytes());\n       System.out.println(\"encrypted string: \" + asHex(encrypted));\n\n       cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n       byte[] original =\n         cipher.doFinal(encrypted);\n       String originalString = new String(original);\n       System.out.println(\"Original string: \" +\n         originalString + \" \" + asHex(original));\n", "byte[] decoded = BASE64DecoderStream.decode(KEY.getBytes());\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nPublicKey publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(decoded));\nSignature sig = Signature.getInstance(\"SHA1withRSA\");\nsig.initVerify(publicKey);\nsig.update(signedData.getBytes());\nif (sig.verify(BASE64DecoderStream.decode(signature.getBytes())))\n{\n    // Valid\n}\n", " try\n  {\n\n        PackageInfo info = getPackageManager().getPackageInfo( \"YOUR_PACKAGE_NAME\", \n                PackageManager.GET_SIGNATURES);\n\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n\n            md.update(signature.toByteArray());\n            Log.i(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));//will give developer key hash\n            Toast.makeText(getApplicationContext(),Base64.encodeToString(md.digest(), Base64.DEFAULT), Toast.LENGTH_LONG).show(); //will give app key hash or release key hash\n\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "public static org.apache.http.client.HttpClient wrapClient(org.apache.http.client.HttpClient base) {\n        try {\n            SSLContext ctx = SSLContext.getInstance(\"TLS\");\n            X509TrustManager tm = new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n                public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {}\n                public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {}\n            };\n            ctx.init(null, new TrustManager[] { tm }, null);\n            SSLSocketFactory ssf = new SSLSocketFactory(ctx, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"https\", 443, ssf));\n            ThreadSafeClientConnManager mgr = new ThreadSafeClientConnManager(registry);\n            return new DefaultHttpClient(mgr, base.getParams());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "Cipher cipher;\ncipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n", "private void getShaKey() {\n\n try {\n PackageInfo info = getPackageManager().getPackageInfo(\"YOUR.Package.Name\",\n PackageManager.GET_SIGNATURES);\n for (Signature signature : info.signatures) {\n MessageDigest md = MessageDigest.getInstance(\"SHA\");\n md.update(signature.toByteArray());\n Log.v(TAG, \"KeyHash:\" + Base64.encodeToString(md.digest(),\n Base64.DEFAULT));\n }\n } catch (NameNotFoundException e) {\n e.printStackTrace();\n } catch (NoSuchAlgorithmException e) {\n e.printStackTrace();\n }\n\n }\n", "public class QueueManager {\n\nprivate static final String TAG = QueueManager.class.getName();\nprivate static QueueManager queueManager;\nprivate Context ctx;\nprivate RequestQueue requestQueue;\n\nprivate QueueManager(Context context) {\n    ctx = context.getApplicationContext();\n    requestQueue = Volley.newRequestQueue(ctx);\n    HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n\n            return true;\n        }\n    });\n}\n\npublic static synchronized QueueManager getInstance(Context context) {\n    if (queueManager == null) {\n        queueManager = new QueueManager(context);\n    }\n    return queueManager;\n}\n\npublic RequestQueue getRequestQueue() {\n    return requestQueue;\n}\n", "static {\n     Security.addProvider(new org.spongycastle.jce.provider.BouncyCastleProvider());\n}\n", "import java.security.SecureRandom;\nimport java.security.Security;\n\n\npublic class SHA1PRNG {\n //here i swapped out the bountycastle provider and used the spongycatle\n   static {\n      Security.addProvider(new org.spongycastle.jce.provider.BouncyCastleProvider());\n}\n\npublic static void main(String[] args) throws Exception {\n\n    SecureRandom rng = SecureRandom.getInstance(\"SHA1PRNG\");\n    rng.setSeed(711);\n\n    int numberToGenerate = 999;\n    byte randNumbers[] = new byte[numberToGenerate];\n\n    rng.nextBytes(randNumbers);\n    for(int j=0; j&lt;numberToGenerate; j++) {\n        System.out.print(randNumbers[j] + \" \");\n    }\n\n}\n}\n", "                X509TrustManager trustManager = new X509TrustManager() {\n                @Override\n                public void checkClientTrusted(X509Certificate[] chain,\n                        String authType) throws CertificateException {\n                    for (TrustManager tm : managers) {\n                        if (tm instanceof X509TrustManager) {\n                            ((X509TrustManager) tm).checkClientTrusted(\n                                    chain, authType);\n                        }\n                    }\n                }\n\n                @Override\n                public void checkServerTrusted(\n                        final X509Certificate[] chain, String authType) {\n\n                    for (X509Certificate cert : chain) {\n\n                        final String mCertificatinoType = cert.getType();\n                        Date afterDate = cert.getNotAfter();\n                        Date beforeDate = cert.getNotBefore();\n                        Date currentDate = new Date();\n\n                        try {\n                            cert.checkValidity(new Date());\n                        } catch (CertificateExpiredException e) {\n                            isExpired = true;\n                            e.printStackTrace();\n                        } catch (CertificateNotYetValidException e) {\n                            isInValid = true;\n                            e.printStackTrace();\n                        }\n\n                        if (afterDate.compareTo(currentDate)\n                                * currentDate.compareTo(beforeDate) &gt; 0) {\n                            isExpired = false;\n                        } else {\n                            isExpired = true;\n                        }\n\n                        String dn = cert.getSubjectDN().getName();\n                        String CN = getValByAttributeTypeFromIssuerDN(dn,\n                                \"CN=\");\n\n                        String host = \"\";\n                        if (TextUtils.isEmpty(query)) {\n                            if (baseHostString.equalsIgnoreCase(\"\")) {\n                                final Settings settings = mApplication\n                                        .getSettings();\n                                try {\n                                    URL url = new URL(\n                                            settings.serverAddress\n                                                    .toString());\n                                    host = url.getAuthority();\n                                    if (host.contains(String.valueOf(url\n                                            .getPort()))) {\n                                        String toBeReplaced = \":\"\n                                                + url.getPort();\n                                        host = host.replace(toBeReplaced,\n                                                \"\");\n                                    }\n                                } catch (MalformedURLException e) {\n                                    e.printStackTrace();\n                                }\n                            } else {\n                                try {\n                                    URL url = new URL(baseHostString);\n                                    host = url.getAuthority();\n                                    if (host.contains(String.valueOf(url\n                                            .getPort()))) {\n                                        String toBeReplaced = \":\"\n                                                + url.getPort();\n                                        host = host.replace(toBeReplaced,\n                                                \"\");\n                                    }\n                                } catch (MalformedURLException e) {\n                                    e.printStackTrace();\n                                }\n                            }\n                        } else {\n                            try {\n                                URL url = new URL(query);\n                                host = url.getAuthority();\n                                if (host.contains(String.valueOf(url\n                                        .getPort()))) {\n                                    String toBeReplaced = \":\"\n                                            + url.getPort();\n                                    host = host.replace(toBeReplaced, \"\");\n                                }\n                            } catch (MalformedURLException e) {\n                                e.printStackTrace();\n                            }\n                        }\n\n                        if (CN.equalsIgnoreCase(host)) {\n                            isHostMisMatch = false;\n                        } else {\n                            isHostMisMatch = true;\n                        }\n\n                        for (TrustManager tm : managers) {\n                            if (tm instanceof X509TrustManager) {\n                                try {\n                                    ((X509TrustManager) tm)\n                                            .checkServerTrusted(chain,\n                                                    authType);\n                                } catch (CertificateException e) {\n                                    if (e.getMessage() != null\n                                            &amp;&amp; e.getMessage()\n                                                    .contains(\n                                                            \"Trust anchor for certification path not found.\")) {\n                                        isNotTrusted = true;\n                                        mApplication\n                                                .setCurrentCertificate(chain);\n                                    }\n                                    e.printStackTrace();\n                                }\n                            }\n                        }\n\n                        if (cert.getIssuerX500Principal().equals(\n                                trustedRoot.getIssuerX500Principal())) {\n                            return;\n                        }\n                    }\n\n                }\n\n                @Override\n                public X509Certificate[] getAcceptedIssuers() {\n                    ArrayList&lt;X509Certificate&gt; issuers = new ArrayList&lt;&gt;();\n                    for (TrustManager tm : managers) {\n                        if (tm instanceof X509TrustManager) {\n                            issuers.addAll(Arrays\n                                    .asList(((X509TrustManager) tm)\n                                            .getAcceptedIssuers()));\n                        }\n                    }\n                    return issuers.toArray(new X509Certificate[issuers\n                            .size()]);\n                }\n\n            };\n", "class MyKeyManager implements X509KeyManager {\n\n    private final X509KeyManager keyManager;\n\n    MyKeyManager(X509KeyManager keyManager) {\n        this.keyManager = keyManager;\n    }\n\n    @DebugLog\n    @Override\n    public String chooseClientAlias(String[] strings, Principal[] principals, Socket socket) {\n        return this.keyManager.chooseClientAlias(strings, principals, socket);\n    }\n\n    @DebugLog\n    @Override\n    public String chooseServerAlias(String s, Principal[] principals, Socket socket) {\n        return keyManager.chooseServerAlias(s, principals, socket);\n    }\n\n    @DebugLog\n    @Override\n    public X509Certificate[] getCertificateChain(String s) {\n        return keyManager.getCertificateChain(s);\n    }\n\n    @DebugLog\n    @Override\n    public String[] getClientAliases(String s, Principal[] principals) {\n        return keyManager.getClientAliases(s, principals);\n    }\n\n    @DebugLog\n    @Override\n    public String[] getServerAliases(String s, Principal[] principals) {\n        return keyManager.getServerAliases(s, principals);\n    }\n\n    @DebugLog\n    @Override\n    public PrivateKey getPrivateKey(String s) {\n        return keyManager.getPrivateKey(s);\n    }\n}\n", "KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkmf.init(keyStore, password);\n\nfinal X509KeyManager origKm = (X509KeyManager) kmf.getKeyManagers()[0];\nX509KeyManager km = new MyKeyManager(origKm);\n\nSSLContext sslCtx = SSLContext.getInstance(\"TLS\");\nsslCtx.init(new KeyManager[]{km}, tmf.getTrustManagers(), null);\n", "  void trustCertificate(X509Certificate cert) {\n        if (cert!=null) {\n            try {\n                KeyStore.TrustedCertificateEntry x = new KeyStore.TrustedCertificateEntry(cert);\n                sslKeystore.setEntry(cert.getSubjectDN().getName(), x, null);\n            } catch (KeyStoreException e) {\n                e.printStackTrace();\n            }\n            saveKeystore();\n        }\n    }\n\n    private void createKeystore() {\n        try {\n            sslKeystore.load(null,null);\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            tmf.init((KeyStore)null);\n            // Copy current certs into our keystore so we can use it...\n            // TODO: don't actually do this...\n            X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];\n            for (X509Certificate cert : xtm.getAcceptedIssuers()) {\n                sslKeystore.setCertificateEntry(cert.getSubjectDN().getName(), cert);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        saveKeystore();\n    }\n\n    private void saveKeystore() {\n        try {\n            sslKeystore.store(new FileOutputStream(keystoreFile), KEYSTORE_PASSWORD.toCharArray());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", " CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            InputStream caInput = new BufferedInputStream(cafile);\n            Certificate ca = null;\n            try {\n                ca = cf.generateCertificate(caInput);\n\n            } catch(Exception e) {\n\n            }\n            finally {\n                caInput.close();\n            }\n            certManagerCA.trustCertificate((X509Certificate) ca);\n            KeyStore keyStoreCA = certManagerCA.sslKeystore;\n            tmf = TrustManagerFactory.getInstance(\"X509\");\n            tmf.init(keyStoreCA);\n", "try{ logger.debug(\"Checking signs\");\n    PackageInfo info = getPackageManager().getPackageInfo(this.getPackageName(), PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        logger.debug(Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (NameNotFoundException e) {\n    e.printStackTrace();\n    logger.debug(e.getMessage());\n} catch (NoSuchAlgorithmException e) {\n    e.printStackTrace();\n    logger.debug(e.getMessage());\n}`\n", " //keyStore = KeyStore.getInstance(\"RSA\");\n keyStore = KeyFactory.getInstance(\"RSA\");\n", "private boolean checkAuthorized() throws SecurityException {\n    PackageManager pm = getPackageManager();\n    try {\n        PackageInfo packageInfo = pm.getPackageInfo(pm.getNameForUid(getCallingUid()),\n            PackageManager.GET_SIGNATURES);\n        Signature[] signatures = packageInfo.signatures;\n        byte[] certBytes = signatures[0].toByteArray();\n        CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n        X509Certificate cert = (X509Certificate)cf.generateCertificate(\n            new ByteArrayInputStream(certBytes));\n        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n        byte[] encodedCert = md.digest(cert.getEncoded());\n        String hexString = byte2HexFormatted(encodedCert);\n\n        Log.d(\"public certificate SHA-1: \" + hexString);\n\n        String trustedAppName = trustedCerts.get(hexString);\n        if (trustedAppName != null) {\n            Log.d(\"Found public certificate SHA-1 for \" + trustedAppName);\n            return true;\n        }\n    } catch (Exception e) {\n        Log.e(e, \"Unable to get certificate from client\");\n    }\n\n    Log.w(\"Couldn't find signature in list of trusted certs!\");\n    /* Crash the calling application if it doesn't catch */\n    throw new SecurityException();\n}\n\npublic static String byte2HexFormatted(byte[] arr) {\n    StringBuilder str = new StringBuilder(arr.length * 2);\n    for (int i = 0; i &lt; arr.length; i++) {\n        String h = Integer.toHexString(arr[i]);\n        int l = h.length();\n        if (l == 1) h = \"0\" + h;\n        if (l &gt; 2) h = h.substring(l - 2, l);\n        str.append(h.toUpperCase());\n        if (i &lt; (arr.length - 1)) str.append(':');\n    }\n    return str.toString();\n}\n", "   try {\n        PackageInfo info = context.getPackageManager().getPackageInfo(\n                \"com.facebook.samples.hellofacebook\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.i(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "String hashString = \"\";\n        Map&lt;String, String&gt; sortedMap = null;\n        if (parameters instanceof TreeMap) {\n            sortedMap = (TreeMap&lt;String, String&gt;) parameters; \n        } else {\n            sortedMap = new TreeMap&lt;String, String&gt;(parameters);\n        }\n\n        try {\n            Iterator&lt;String&gt; iter = sortedMap.keySet().iterator();\n            StringBuilder sb = new StringBuilder();\n            synchronized (iter) {\n                while (iter.hasNext()) {\n                    String key = iter.next();\n                    sb.append(key);\n                    sb.append(\"=\");\n                    String value = sortedMap.get(key);\n                    sb.append(value == null ? \"\" : value);\n                }\n            }\n            sb.append(secret);\n\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            byte[] digested = digest.digest(sb.toString().getBytes());\n\n            BigInteger bigInt = new BigInteger(1, digested);\n            hashString = bigInt.toString(16);\n            while (hashString.length() &lt; 32) {\n                hashString = \"0\" + hashString;\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n            // TODO: handle exception\n            logger.error(e.getLocalizedMessage(), e);\n        }\n\n        return hashString;\n", "private String getCertificateSHA1Fingerprint() {\n    PackageManager pm = mContext.getPackageManager();\n    String packageName = mContext.getPackageName();\n    int flags = PackageManager.GET_SIGNATURES;\n    PackageInfo packageInfo = null;\n    try {\n        packageInfo = pm.getPackageInfo(packageName, flags);\n    } catch (PackageManager.NameNotFoundException e) {\n        e.printStackTrace();\n    }\n    Signature[] signatures = packageInfo.signatures;\n    byte[] cert = signatures[0].toByteArray();\n    InputStream input = new ByteArrayInputStream(cert);\n    CertificateFactory cf = null;\n    try {\n        cf = CertificateFactory.getInstance(\"X509\");\n    } catch (CertificateException e) {\n        e.printStackTrace();\n    }\n    X509Certificate c = null;\n    try {\n        c = (X509Certificate) cf.generateCertificate(input);\n    } catch (CertificateException e) {\n        e.printStackTrace();\n    }\n    String hexString = null;\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n        byte[] publicKey = md.digest(c.getEncoded());\n        hexString = byte2HexFormatted(publicKey);\n    } catch (NoSuchAlgorithmException e1) {\n        e1.printStackTrace();\n    } catch (CertificateEncodingException e) {\n        e.printStackTrace();\n    }\n    return hexString;\n}\n\npublic static String byte2HexFormatted(byte[] arr) {\n    StringBuilder str = new StringBuilder(arr.length * 2);\n    for (int i = 0; i &lt; arr.length; i++) {\n        String h = Integer.toHexString(arr[i]);\n        int l = h.length();\n        if (l == 1) h = \"0\" + h;\n        if (l &gt; 2) h = h.substring(l - 2, l);\n        str.append(h.toUpperCase());\n        if (i &lt; (arr.length - 1)) str.append(':');\n    }\n    return str.toString();\n}\n", "    private Bitmap getBitmap(String url)\n            {\n     File f=fileCache.getFile(url);\n     //from SD cache\n    Bitmap b = decodeFile(f);\n    if(b!=null)\n        return b;\n\n    //from web\n    try {\n        Bitmap bitmap=null;\n      //  URL imageUrl = new URL(url);\n\n        /***/\n\n        HttpURLConnection conn = null;\n        URL imageUrl = new URL(url);\n        if (imageUrl.getProtocol().toLowerCase().equals(\"https\")) {\n            trustAllHosts();\n            HttpsURLConnection https = (HttpsURLConnection) imageUrl.openConnection();\n            https.setHostnameVerifier(DO_NOT_VERIFY);\n            conn = https;\n        } else {\n            conn = (HttpURLConnection) imageUrl.openConnection();\n        }\n        /***/\n\n\n\n       // HttpURLConnection conn = (HttpURLConnection)imageUrl.openConnection();\n        conn.setConnectTimeout(30000);\n        conn.setReadTimeout(30000);\n        conn.setInstanceFollowRedirects(true);\n        InputStream is=conn.getInputStream();\n        OutputStream os = new FileOutputStream(f);\n        Utils.CopyStream(is, os);\n        os.close();\n        bitmap = decodeFile(f);\n        return bitmap;\n    } catch (Throwable ex){\n       ex.printStackTrace();\n       if(ex instanceof OutOfMemoryError)\n           memoryCache.clear();\n       return null;\n    }\n}\n", "private static final int AES_BLOCK_SIZE = 16;\n\npublic static final void jumpToOffset(final Cipher c,\n        final SecretKey aesKey, final IvParameterSpec iv, final long offset) {\n    if (!c.getAlgorithm().toUpperCase().startsWith(\"AES/CTR\")) {\n        throw new IllegalArgumentException(\n                \"Invalid algorithm, only AES/CTR mode supported\");\n    }\n\n    if (offset &lt; 0) {\n        throw new IllegalArgumentException(\"Invalid offset\");\n    }\n\n    final int skip = (int) (offset % AES_BLOCK_SIZE);\n    final IvParameterSpec calculatedIVForOffset = calculateIVForOffset(iv,\n            offset - skip);\n    try {\n        c.init(Cipher.ENCRYPT_MODE, aesKey, calculatedIVForOffset);\n        final byte[] skipBuffer = new byte[skip];\n        c.update(skipBuffer, 0, skip, skipBuffer);\n        Arrays.fill(skipBuffer, (byte) 0);\n    } catch (ShortBufferException | InvalidKeyException\n            | InvalidAlgorithmParameterException e) {\n        throw new IllegalStateException(e);\n    }\n}\n\nprivate static IvParameterSpec calculateIVForOffset(final IvParameterSpec iv,\n        final long blockOffset) {\n    final BigInteger ivBI = new BigInteger(1, iv.getIV());\n    final BigInteger ivForOffsetBI = ivBI.add(BigInteger.valueOf(blockOffset\n            / AES_BLOCK_SIZE));\n\n    final byte[] ivForOffsetBA = ivForOffsetBI.toByteArray();\n    final IvParameterSpec ivForOffset;\n    if (ivForOffsetBA.length &gt;= AES_BLOCK_SIZE) {\n        ivForOffset = new IvParameterSpec(ivForOffsetBA, ivForOffsetBA.length - AES_BLOCK_SIZE,\n                AES_BLOCK_SIZE);\n    } else {\n        final byte[] ivForOffsetBASized = new byte[AES_BLOCK_SIZE];\n        System.arraycopy(ivForOffsetBA, 0, ivForOffsetBASized, AES_BLOCK_SIZE\n                - ivForOffsetBA.length, ivForOffsetBA.length);\n        ivForOffset = new IvParameterSpec(ivForOffsetBASized);\n    }\n\n    return ivForOffset;\n}\n", "    import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class DescEncrypter {\n\n    public static final int SALT_LENGTH = 20;\n    public static final int PBE_ITERATION_COUNT = 200; //1024;\n\n    private static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n\n    //algoritmo / modo / relleno \n    private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\n    byte[] iv = \"1234567890asdfgh\".getBytes();\n\n    byte[] salt = \"dfghjklpoiuytgftgyhj\".getBytes();\n\n    public byte[] encrypt(String password, String cleartext) {\n\n        byte[] encryptedText = null;\n\n        try {\n\n\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n\n            //Factoria para crear la SecretKey, debemos indicar el Algoritmo\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n\n            SecretKey tmp = factory.generateSecret(pbeKeySpec);\n\n            //Creamos una llave;\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n            //Obtenemos la llave, solo informativo\n            byte[] key = secret.getEncoded();\n\n            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave sim\u00c3\u00a9trica\n            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);   \n\n            //byte[] iv = generateIv();\n\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n            //Accion, SecretKey, parameter specification for an initialization vector\n            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n\n            //Realizamos el cifrado\n            encryptedText = encryptionCipher.doFinal(cleartext.getBytes());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return encryptedText;\n    }\n\n    public String decrypt(String password, byte[] encryptedText) {\n\n        String cleartext = \"\";\n\n        try {\n\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n\n            //Factoria para crear la SecretKey, debemos indicar el Algoritmo\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n\n            SecretKey tmp = factory.generateSecret(pbeKeySpec);\n\n            //Creamos una llave;\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n            //Obtenemos la llave, solo informativo\n            byte[] key = secret.getEncoded();\n\n            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave sim\u00c3\u00a9trica\n            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            //byte[] iv = generateIv();\n\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n            //Accion, SecretKey, parameter specification for an initialization vector\n            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n\n            //Realizamos el descifrado\n            byte[] decryptedText = decryptionCipher.doFinal(encryptedText);\n\n            cleartext =  new String(decryptedText); \n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return cleartext;\n    }      \n}\n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    \"your package name\", PackageManager.GET_SIGNATURES);\n            for (android.content.pm.Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String sign = Base64\n                        .encodeToString(md.digest(), Base64.DEFAULT);\n\n                Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG)\n                        .show();\n            }\n\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n", "PackageInfo info;\n\n     try {\n            info = activity.getPackageManager().getPackageInfo(\"com.checkmyplanner\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md;\n                md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String something = new String(Base64.encode(md.digest(), 0));\n                //String something = new String(Base64.encodeBytes(md.digest()));\n                Log.e(\"hash key\", something);\n            }\n        } catch (NameNotFoundException e1) {\n            Log.e(\"name not found\", e1.toString());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(\"no such an algorithm\", e.toString());\n        } catch (Exception e) {\n            Log.e(\"exception\", e.toString());\n        }\n", "    private static final String AES = \"AES\";\n\n    private static String encrypt(final String strKey, final String strToEncrypt) {\n        SecretKeySpec secKeySpec = null;\n        Cipher cipher = null;\n        byte[] encrypted = null;\n        try {\n            secKeySpec = new SecretKeySpec(strKey.getBytes(), \"AES\");\n            cipher = Cipher.getInstance(AES);\n            cipher.init(Cipher.ENCRYPT_MODE, secKeySpec);\n            encrypted = cipher.doFinal(strToEncrypt.getBytes());\n\n        } catch (final Exception e) {\n            System.out.println(e);\n        }\n        return Base64.encodeBase64String(encrypted);\n    }\n", "public static String md5(String s) {\n    MessageDigest digest;\n    try {\n        digest = MessageDigest.getInstance(\"MD5\");\n        digest.update(s.getBytes(), 0, s.length());\n        String hash = new BigInteger(1, digest.digest()).toString(16);\n        return hash;\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "import java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class SimpleCrypto {\n\n    private static final int KEY_SIZE = 128;\n\n    public static String encrypt(String seed, String cleartext) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {\n        final byte[] rawKey = getRawKey(seed.getBytes());\n        final byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return bin2hex(result);\n    }\n\n    public static String decrypt(String seed, String encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {\n        final byte[] rawKey = getRawKey(seed.getBytes());\n        final byte[] enc = toByte(encrypted);\n        final byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n    public static String decrypt(String seed, byte[] encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {\n        final byte[] rawKey = getRawKey(seed.getBytes());\n        final byte[] result = decrypt(rawKey, encrypted);\n        return new String(result);\n    }\n\n    private static byte[] getRawKey(byte[] seed) throws NoSuchAlgorithmException {\n        final KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        final SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        kgen.init(KEY_SIZE, sr); // 192 and 256 bits may not be available\n        final SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n    public static byte[] encrypt(byte[] raw, byte[] clear) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n        final SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        final Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        final byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    public static byte[] decrypt(byte[] raw, byte[] encrypted) throws IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n        final SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        final Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        final byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) {\n        return bin2hex(txt.getBytes());\n    }\n\n    public static String fromHex(String hex) {\n        return new String(toByte(hex));\n    }\n\n    public static byte[] toByte(String hexString) {\n        final int len = hexString.length() / 2;\n        final byte[] result = new byte[len];\n        for (int i = 0; i &lt; len; i++) {\n            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();\n        }\n        return result;\n    }\n\n    public static byte[] getHash(String str) {\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        digest.reset();\n        return digest.digest(str.getBytes());\n    }\n\n    static String bin2hex(byte[] data) {\n        return String.format(\"%0\" + (data.length * 2) + \"X\", new BigInteger(1, data));\n    }\n}\n", "import javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Base64;\n//string encryption\npublic class EncryptionHelper {\n\n\n\n    // Encrypts string and encode in Base64\n    public static String encryptText(String plainText) throws Exception {\n        // ---- Use specified 3DES key and IV from other source --------------\n        byte[] plaintext = plainText.getBytes();//input\n        byte[] tdesKeyData = Constants.getKey().getBytes();// your encryption key\n\n        byte[] myIV = Constants.getInitializationVector().getBytes();// initialization vector\n\n        Cipher c3des = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n        SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, \"DESede\");\n        IvParameterSpec ivspec = new IvParameterSpec(myIV);\n\n        c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);\n        byte[] cipherText = c3des.doFinal(plaintext);\n        String encryptedString = Base64.encodeToString(cipherText,\n                Base64.DEFAULT);\n        // return Base64Coder.encodeString(new String(cipherText));\n        return encryptedString;\n    }\n\n}\n", "private static OkHttpClient getUnsafeOkHttpClient() {\n  try {\n    // Create a trust manager that does not validate certificate chains\n    final TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n          @Override\n          public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {\n          }\n\n          @Override\n          public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {\n          }\n\n          @Override\n          public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return new java.security.cert.X509Certificate[]{};\n          }\n        }\n    };\n\n    // Install the all-trusting trust manager\n    final SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n    // Create an ssl socket factory with our all-trusting manager\n    final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n\n    OkHttpClient.Builder builder = new OkHttpClient.Builder();\n    builder.sslSocketFactory(sslSocketFactory);\n    builder.hostnameVerifier(new HostnameVerifier() {\n      @Override\n      public boolean verify(String hostname, SSLSession session) {\n        return true;\n      }\n    });\n\n    OkHttpClient okHttpClient = builder.build();\n    return okHttpClient;\n  } catch (Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n", "public void testKeys() throws Exception {\n    KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"X509\");\n    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n\n    ks.load(getContext().getResources().openRawResource(R.raw.keystore), \"storepass\".toCharArray());\n    kmf.init(ks, \"storepass\".toCharArray());\n\n\n    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    KeyStore ts = KeyStore.getInstance(KeyStore.getDefaultType());\n    ts.load(getContext().getResources().openRawResource(R.raw.keystore), \"storepass\".toCharArray());\n    tmf.init(ts);\n\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n\n    AsyncHttpServer httpServer = new AsyncHttpServer();\n    httpServer.listenSecure(8888, sslContext);\n    httpServer.get(\"/\", new HttpServerRequestCallback() {\n        @Override\n        public void onRequest(AsyncHttpServerRequest request, AsyncHttpServerResponse response) {\n            response.send(\"hello\");\n        }\n    });\n\n    Thread.sleep(1000);\n\n    AsyncHttpClient.getDefaultInstance().getSSLSocketMiddleware().setSSLContext(sslContext);\n    AsyncHttpClient.getDefaultInstance().getSSLSocketMiddleware().setTrustManagers(tmf.getTrustManagers());\n    AsyncHttpClient.getDefaultInstance().executeString(new AsyncHttpGet(\"https://localhost:8888/\"), null).get();\n}\n", "MessageDigest md = MessageDigest.getInstance(\"SHA1\");\nInputStream in = new FileInputStream(\"hereyourinputfilename\");\nbyte[] buf = new byte[8192];\nfor (;;) {\n    int len = in.read(buf);\n    if (len &lt; 0)\n        break;\n    md.update(buf, 0, len);\n}\nin.close();\nbyte[] hash = md.digest();\n", "private HttpClient getHttpClient(){\n    RegistryBuilder&lt;ConnectionSocketFactory&gt; registryBuilder = RegistryBuilder.&lt;ConnectionSocketFactory&gt; create();\n    ConnectionSocketFactory plainSF = new PlainConnectionSocketFactory();\n    registryBuilder.register(\"http\", plainSF);\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        TrustStrategy anyTrustStrategy = new TrustStrategy() {\n            @Override\n            public boolean isTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n                return true;\n            }\n        };\n        SSLContext sslContext = SSLContexts.custom().useTLS().loadTrustMaterial(trustStore, anyTrustStrategy)\n                .build();\n        LayeredConnectionSocketFactory sslSF = new SSLConnectionSocketFactory(sslContext,\n                SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        registryBuilder.register(\"https\", sslSF);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n    Registry&lt;ConnectionSocketFactory&gt; registry = registryBuilder.build();\n    PoolingHttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager(registry);\n    HttpClient httpclient = HttpClientBuilder.create().setConnectionManager(connManager).build();\n\n    return httpclient;\n}\n", "package com.xxx;\n\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * Usage:\n * &lt;pre&gt;\n * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)\n * ...\n * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)\n * &lt;/pre&gt;\n * @author ferenc.hechler\n */\npublic class SimpleCrypto {\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result);\n    }\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n        sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n    public static String fromHex(String hex) {\n        return new String(toByte(hex));\n    }\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i &lt; len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i &lt; buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n    private final static String HEX = \"0123456789ABCDEF\";\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));\n    }\n\n}\n", "try {\n         PackageInfo info = getPackageManager().getPackageInfo(\n         \"my pkg name\",\n        /// android.test.purchased\n         PackageManager.GET_SIGNATURES);\n         for (Signature signature : info.signatures) {\n         MessageDigest md = MessageDigest.getInstance(\"SHA\");\n         md.update(signature.toByteArray());\n\n         Base64.DEFAULT));\n         Base64.DEFAULT));\n         }\n         } catch (NameNotFoundException e) {\n\n         } catch (NoSuchAlgorithmException e) {\n\n         }\n", "PackageInfo info = getPackageManager().getPackageInfo(\n        \"Your Pakage name\", \n        PackageManager.GET_SIGNATURES);\nfor (Signature signature : info.signatures) {\n    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n    md.update(signature.toByteArray());\n    Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n", "MessageDigest sha224 = MessageDigest.getInstance(\"SHA-224\");\n// etc\n", "// Http Client with SSL factory\n\npublic HttpClient getNewHttpClient() {\n try {\n KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n trustStore.load(null, null);\n\n SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n HttpParams params = new BasicHttpParams();\n HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n SchemeRegistry registry = new SchemeRegistry();\n registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n registry.register(new Scheme(\"https\", sf, 443));\n\n ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n return new DefaultHttpClient(ccm, params);\n } catch (Exception e) {\n     return new DefaultHttpClient();\n }\n}\n\n// Post request for multi part entity\n\npublic void postRequest(){\n\n    DefaultHttpClient httpClient = new getNewHttpClient();\n    HttpPost postRequest = new HttpPost(url);\n    String auth = \"USER_NAME\" + \":\" + \"PASSWORD\";\n    byte[] bytes = auth.getBytes();\n    postRequest.setHeader(\"Authorization\", \"Basic \" + new String(Base64.encodeBytes(bytes)));\n\n    try {\n        MultipartEntity mpC = new MultipartEntity();\n        FileBody fb = new FileBody(message);\n        StringBody sbPicID = new StringBody(fb.getFilename());\n        mpC.addPart(\"name\", sbPicID);\n        mpC.addPart(\"file\", fb);\n        postRequest.setEntity(mpC);\n        HttpResponse res;\n        res = httpClient.execute(postRequest);\n        BufferedReader rd = new BufferedReader(new InputStreamReader(res.getEntity().getContent()));\n        String resPictureId = \"\";\n        resPictureId = rd.readLine();\n\n        Session.put(\"PICTURE_\"+position, resPictureId);\n        res.getEntity().getContent().close();\n    }catch (Exception e) {\n        // TODO: handle exception\n    }\n\n}\n\n// SSL factory class\n\npublic class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public MySSLSocketFactory(KeyStore truststore)\n            throws NoSuchAlgorithmException, KeyManagementException,\n            KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port,\n            boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port,\n                autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n\n}\n", "import java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MCrypt {\n\n    private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n    private IvParameterSpec ivspec;\n    private SecretKeySpec keyspec;\n    private Cipher cipher;\n\n    private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n    public MCrypt()\n    {\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try {\n            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n    public byte[] encrypt(String text) throws Exception\n    {\n        if(text == null || text.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n            encrypted = cipher.doFinal(padString(text).getBytes());\n        } catch (Exception e)\n        {           \n            throw new Exception(\"[encrypt] \" + e.getMessage());\n        }\n\n        return encrypted;\n    }\n\n    public byte[] decrypt(String code) throws Exception\n    {\n        if(code == null || code.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n            decrypted = cipher.doFinal(hexToBytes(code));\n        } catch (Exception e)\n        {\n            throw new Exception(\"[decrypt] \" + e.getMessage());\n        }\n        return decrypted;\n    }\n\n\n\n    public static String bytesToHex(byte[] data)\n    {\n        if (data==null)\n        {\n            return null;\n        }\n\n        int len = data.length;\n        String str = \"\";\n        for (int i=0; i&lt;len; i++) {\n            if ((data[i]&amp;0xFF)&lt;16)\n                str = str + \"0\" + java.lang.Integer.toHexString(data[i]&amp;0xFF);\n            else\n                str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);\n        }\n        return str;\n    }\n\n\n    public static byte[] hexToBytes(String str) {\n        if (str==null) {\n            return null;\n        } else if (str.length() &lt; 2) {\n            return null;\n        } else {\n            int len = str.length() / 2;\n            byte[] buffer = new byte[len];\n            for (int i=0; i&lt;len; i++) {\n                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n            }\n            return buffer;\n        }\n    }\n\n\n\n    private static String padString(String source)\n    {\n      char paddingChar = ' ';\n      int size = 16;\n      int x = source.length() % size;\n      int padLength = size - x;\n\n      for (int i = 0; i &lt; padLength; i++)\n      {\n          source += paddingChar;\n      }\n\n      return source;\n    }\n}\n", "import java.io.File;\n\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.os.Environment;\n\npublic class XsltTester extends Activity {\n\n    private static String TAG = XsltTester.class.getSimpleName();\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n\n        try {\n\n            Source xmlSource = new StreamSource(this.getResources().openRawResource(R.raw.weather));\n            Source xsltSource = new StreamSource(this.getResources().openRawResource(R.raw.weatherxsl));\n\n            TransformerFactory transFact = TransformerFactory.newInstance();\n            Transformer trans = transFact.newTransformer(xsltSource);\n//          FileOutputStream fo = new FileOutputStream(f);\n//          fo.write(resizeBitMapImageToByteArray(photoAlbumBean));\n//          fo.close();\n            File f = new File(Environment.getExternalStorageDirectory().getAbsolutePath()+\"/mydata.html\");\n\n//            OutputStream output = new StringOutputStream();\n            StreamResult result = new StreamResult(f);\n            trans.transform(xmlSource, result);\n\n        } catch (TransformerConfigurationException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (TransformerFactoryConfigurationError e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (TransformerException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n}\n", "KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) entry;\n\nCipher output = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\noutput.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey());\n", "Button getKeyHash = (Button) findViewById(R.id.button_key_hash);\n    getKeyHash.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            //Key Hash\n            try {\n                PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),\n                        PackageManager.GET_SIGNATURES);\n                for (Signature signature : packageInfo.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                }\n            } catch (PackageManager.NameNotFoundException e1) {\n                Log.e(\"Name not found\", e1.toString());\n            } catch (NoSuchAlgorithmException e) {\n                Log.e(\"No such an algorithm\", e.toString());\n            } catch (Exception e) {\n                Log.e(\"Exception\", e.toString());\n            }\n        }\n    });\n", "public void RSADecrypt(String inFileName, String outFileName) {\n        try {\n            /* Get the encrypted message from file. */\n            FileInputStream cipherfile = new FileInputStream(inFileName);\n\n            byte[] ciphertext = new byte[cipherfile.available()];\n            cipherfile.read(ciphertext);\n            cipherfile.close();         \n            PrivateKey privatekey =readPrivateKeyFromFile(\"D:\\\\Private.key\");\n\n            /* Create cipher for decryption. */\n            Cipher decrypt_cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            decrypt_cipher.init(Cipher.DECRYPT_MODE, privatekey);\n            FileOutputStream plainfile = new FileOutputStream(outFileName);\n            int n = ciphertext.length / 128;\n            System.out.println(\"len: \" + n);\n            byte[] data1 = new byte[128];\n            for (int i = 0; i &lt; n; i++) {\n                for (int j = 0; j &lt; 128; j++) {\n                    data1[j] = ciphertext[128 * i + j];\n                }\n                byte[] descryptedData = decrypt_cipher.doFinal(data1);\n                plainfile.write(descryptedData);\n\n            }\n\n            plainfile.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\npublic PrivateKey readPrivateKeyFromFile(String fileName)\n            throws IOException {\n        FileInputStream fis = null;\n        ObjectInputStream ois = null;\n        try {\n            fis = new FileInputStream(new File(fileName));\n            ois = new ObjectInputStream(fis);\n\n            BigInteger modulus = (BigInteger) ois.readObject();\n            BigInteger exponent = (BigInteger) ois.readObject();\n\n            // Get Private Key\n            RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(\n                    modulus, exponent);\n            KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n            PrivateKey privateKey = fact.generatePrivate(rsaPrivateKeySpec);\n            System.out.println(\"get key ok: \" + privateKey.toString());\n            return privateKey;\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ois != null) {\n                ois.close();\n                if (fis != null) {\n                    fis.close();\n                }\n            }\n        }\n        return null;\n    }\n", "import java.io.*;\nimport java.security.KeyStore;\n\nimport javax.net.ssl.*;\n\nimport org.apache.http.*;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.params.HttpClientParams;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.params.*;\nimport org.apache.http.conn.scheme.*;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.*;\n\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class SslTestActivity extends Activity {\n\n  /** Called when the activity is first created. */\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.main);\n\n    try {\n      // setup truststore to provide trust for the server certificate\n\n      // load truststore certificate\n      InputStream clientTruststoreIs = getResources().openRawResource(R.raw.truststore);\n      KeyStore trustStore = null;\n      trustStore = KeyStore.getInstance(\"BKS\");\n      trustStore.load(clientTruststoreIs, \"MyPassword\".toCharArray());\n\n      System.out.println(\"Loaded server certificates: \" + trustStore.size());\n\n      // initialize trust manager factory with the read truststore\n      TrustManagerFactory trustManagerFactory = null;\n      trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n      trustManagerFactory.init(trustStore);\n\n      // setup client certificate\n\n      // load client certificate\n      InputStream keyStoreStream = getResources().openRawResource(R.raw.client);\n      KeyStore keyStore = null;\n      keyStore = KeyStore.getInstance(\"BKS\");\n      keyStore.load(keyStoreStream, \"MyPassword\".toCharArray());\n\n      System.out.println(\"Loaded client certificates: \" + keyStore.size());\n\n      // initialize key manager factory with the read client certificate\n      KeyManagerFactory keyManagerFactory = null;\n      keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n      keyManagerFactory.init(keyStore, \"MyPassword\".toCharArray());\n\n\n      // initialize SSLSocketFactory to use the certificates\n      SSLSocketFactory socketFactory = null;\n      socketFactory = new SSLSocketFactory(SSLSocketFactory.TLS, keyStore, \"MyTestPassword2010\",\n          trustStore, null, null);\n\n      // Set basic data\n      HttpParams params = new BasicHttpParams();\n      HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n      HttpProtocolParams.setContentCharset(params, \"UTF-8\");\n      HttpProtocolParams.setUseExpectContinue(params, true);\n      HttpProtocolParams.setUserAgent(params, \"Android app/1.0.0\");\n\n      // Make pool\n      ConnPerRoute connPerRoute = new ConnPerRouteBean(12);\n      ConnManagerParams.setMaxConnectionsPerRoute(params, connPerRoute);\n      ConnManagerParams.setMaxTotalConnections(params, 20);\n\n      // Set timeout\n      HttpConnectionParams.setStaleCheckingEnabled(params, false);\n      HttpConnectionParams.setConnectionTimeout(params, 20 * 1000);\n      HttpConnectionParams.setSoTimeout(params, 20 * 1000);\n      HttpConnectionParams.setSocketBufferSize(params, 8192);\n\n      // Some client params\n      HttpClientParams.setRedirecting(params, false);\n\n      // Register http/s shemas!\n      SchemeRegistry schReg = new SchemeRegistry();\n      schReg.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n      schReg.register(new Scheme(\"https\", socketFactory, 443));\n      ClientConnectionManager conMgr = new ThreadSafeClientConnManager(params, schReg);\n      DefaultHttpClient sClient = new DefaultHttpClient(conMgr, params);\n\n      HttpGet httpGet = new HttpGet(\"https://server/path/service.wsdl\");\n      HttpResponse response = sClient.execute(httpGet);\n      HttpEntity httpEntity = response.getEntity();\n\n      InputStream is = httpEntity.getContent();\n      BufferedReader read = new BufferedReader(new InputStreamReader(is));\n      String query = null;\n      while ((query = read.readLine()) != null)\n        System.out.println(query);\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n\n}\n", "    private static KeyStore loadTrustStore(String[] certificateFilenames) {\n        AssetManager assetsManager = GirdersApp.getInstance().getAssets();\n\n        int length = certificateFilenames.length;\n        List&lt;Certificate&gt; certificates = new ArrayList&lt;Certificate&gt;(length);\n        for (String certificateFilename : certificateFilenames) {\n          InputStream is;\n          try {\n            is = assetsManager.open(certificateFilename, AssetManager.ACCESS_BUFFER);\n            Certificate certificate = KeyStoreManager.loadX509Certificate(is);\n            certificates.add(certificate);\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n\n        Certificate[] certificatesArray = certificates.toArray(new Certificate[certificates.size()]);\n          return new generateKeystore(certificatesArray);\n      }\n\n /**\n   * Generates keystore congaing the specified certificates.\n   *\n   * @param certificates certificates to add in keystore\n   * @return keystore with the specified certificates\n   * @throws KeyStoreException if keystore can not be generated.\n   */\n  public KeyStore generateKeystore(Certificate[] certificates) throws RuntimeException {\n      // construct empty keystore\n      KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n\n      // initialize keystore\n      keyStore.load(null, null);\n\n      // load certificates into keystore\n      int length = certificates.length;\n      for (int i = 0; i &lt; length; i++) {\n        Certificate certificate = certificates[i];\n        keyStore.setEntry(String.valueOf(i), new KeyStore.TrustedCertificateEntry(certificate),\n            null);\n      }\n      return keyStore;\n  }\n", "/**\n * Created by Nevuroth on 1/19/15.\n */\npublic class CustomX509TrustManager implements X509TrustManager{\n\nprivate X509TrustManager defaultManager = null;\n\n/**\n * Custom constructor for the x509 trust manager. This workaround won't take away from security, but it will drop and accept the self signed cert for our test server at the\n * end of the cert chain, as well as allowing\n *\n * @param keyStore\n * @throws NoSuchAlgorithmException\n * @throws KeyStoreException\n */\npublic CustomX509TrustManager(KeyStore keyStore) throws NoSuchAlgorithmException, KeyStoreException{\n    super();\n    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    factory.init(keyStore);\n    TrustManager[] trustManagers = factory.getTrustManagers();\n    if(trustManagers.length ==0){\n        throw new NoSuchAlgorithmException(\"Failed to find Default trust managers\");\n    }\n\n    this.defaultManager = (X509TrustManager) trustManagers[0];\n\n}\n\n\n//we just want the standard functionality for x509\n@Override\npublic void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n    defaultManager.checkClientTrusted(x509Certificates, s);\n}\n\n/**\n *  Here's where the magic happens, we're going to be compensating for out of order certificates in the X509 header\n *  as well as compensating for self-signed certificates (kind of), by passing the certificate before it in the chain\n *  to the chekc servertrusted method\n *  This won't compensate for purely self-signed certs.... but you can do so by adding it to the accepted issuers method.\n * @param x509Certificates\n * @param s\n * @throws CertificateException\n */\n\n@Override\npublic void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n\n    //Clean the certificates and make sure they are in the proper order.\n    int chainln = x509Certificates.length;\n    if(x509Certificates.length &gt; 1){\n        //Clean the chains by matching issuer and subject fields until we can't continue\n        int index;\n        boolean foundNext;\n        for(index=0; index &lt; x509Certificates.length; ++index){\n            foundNext = false;\n            for(int nextIndex = index + 1; nextIndex &lt; x509Certificates.length; ++nextIndex){\n                //look for the next certificate in the chain.\n                if(x509Certificates[index].getIssuerDN().equals(x509Certificates[nextIndex].getSubjectDN())){\n                    foundNext = true;\n                    //exchange certificates so that 0 through index+1 are in proper order.\n                    if(nextIndex != index+1){\n                        X509Certificate tempCert = x509Certificates[nextIndex];\n                        x509Certificates[nextIndex] = x509Certificates[index+1];\n                        x509Certificates[index+1] = tempCert;\n                    }\n                    break;\n                }\n\n            }\n\n            if(!foundNext){\n                break;\n            }\n\n        }\n\n        //if the cert is self signed and if it is expired, if so we drop it and pass the rest to checkServerTrusted, hoping we may have a similar bu unexpired trusted root.\n        chainln = index +1;\n        X509Certificate lastCert = x509Certificates[chainln - 1];\n        Date now = new Date();\n        if(lastCert.getSubjectDN().equals(lastCert.getIssuerDN()) &amp;&amp; now.after(lastCert.getNotAfter())){\n            --chainln;\n        }\n    }\n\n    defaultManager.checkServerTrusted(x509Certificates, s);\n\n}\n\n//you can add an accepted issuer\n@Override\npublic X509Certificate[] getAcceptedIssuers() {\n    return this.defaultManager.getAcceptedIssuers();\n}\n}\n", "/**\n * Created by Nevuroth on 1/19/15.\n */\n    public class CustomSSLSocketFactory extends SSLSocketFactory {\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n\npublic CustomSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, UnrecoverableKeyException, KeyStoreException {\n    super(truststore);\n\n    TrustManager tm = new CustomX509TrustManager(truststore);\n\n    sslContext.init(null, new TrustManager[]{tm}, null);\n\n}\n\n@Override\npublic Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {\n    return sslContext.getSocketFactory().createSocket(socket, host, port,autoClose);\n}\n\n@Override\npublic Socket createSocket() throws IOException{\n    return sslContext.getSocketFactory().createSocket();\n}\n}\n", "public HttpClient getNewHttpClient(){\n    try{\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new CustomSSLSocketFactory(trustStore);\n        //sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(),80));\n        registry.register(new Scheme(\"https\", sf,443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params,registry);\n\n        return new DefaultHttpClient(ccm, params);\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        //if we get an error here then we need to return something or a fatal network error will occur.\n        return new DefaultHttpClient();\n    }\n}\n", "import java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.X509EncodedKeySpec;\nimport org.bouncycastle.util.encoders.Base64;\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.SharedPreferences;\n\npublic class KeyGenerator extends Activity{\n\n    SharedPreferences SP;\n    SharedPreferences.Editor SPE;\n    PublicKey pubKey;\n    PrivateKey privKey; \n    Context context;\n\n    public KeyGenerator(Context context){\n        this.context = context;\n        SP = context.getSharedPreferences(\"KeyPair\", MODE_PRIVATE);\n    }\n\n    public void generateKeys(){\n        try {\n            KeyPairGenerator generator;\n            generator = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n            generator.initialize(256, new SecureRandom());\n            KeyPair pair = generator.generateKeyPair();\n            pubKey = pair.getPublic();\n            privKey = pair.getPrivate();            \n            byte[] publicKeyBytes = pubKey.getEncoded();\n            String pubKeyStr = new String(Base64.encode(publicKeyBytes));\n            byte[] privKeyBytes = privKey.getEncoded();\n            String privKeyStr = new String(Base64.encode(privKeyBytes));            \n            SPE = SP.edit();\n            SPE.putString(\"PublicKey\", pubKeyStr);\n            SPE.putString(\"PrivateKey\", privKeyStr);           \n            SPE.commit();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchProviderException e) {\n            e.printStackTrace();\n        }           \n    }\n    public PublicKey getPublicKey(){\n        String pubKeyStr = SP.getString(\"PublicKey\", \"\");       \n        byte[] sigBytes = Base64.decode(pubKeyStr);\n        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);\n        KeyFactory keyFact = null;\n        try {\n            keyFact = KeyFactory.getInstance(\"RSA\", \"BC\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchProviderException e) {\n            e.printStackTrace();\n        }\n        try {\n            return  keyFact.generatePublic(x509KeySpec);\n        } catch (InvalidKeySpecException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    public String getPublicKeyAsString(){\n        return SP.getString(\"PublicKey\", \"\");       \n    }\n    public PrivateKey getPrivateKey(){\n        String privKeyStr = SP.getString(\"PrivateKey\", \"\");\n        byte[] sigBytes = Base64.decode(privKeyStr);\n        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);\n        KeyFactory keyFact = null;\n        try {\n            keyFact = KeyFactory.getInstance(\"RSA\", \"BC\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchProviderException e) {\n            e.printStackTrace();\n        }\n        try {\n            return  keyFact.generatePrivate(x509KeySpec);\n        } catch (InvalidKeySpecException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    public String getPrivateKeyAsString(){\n        return SP.getString(\"PrivateKey\", \"\");      \n    }\n}\n", "@EBean(scope = Scope.Singleton)\npublic class RestInterceptor implements ClientHttpRequestInterceptor {\n\nprivate int requestCount = 0;\n\n@Pref\nMyPrefs_ myPrefs;\n\nprivate RequestListener mRequestListener;\n\npublic interface RequestListener {\n    void report(int count);\n}\n\npublic void setOnRequestListener(RequestListener requestListener) {\n    this.mRequestListener = requestListener;\n}\n\npublic ClientHttpResponse intercept(HttpRequest request, byte[] data, ClientHttpRequestExecution execution)\n        throws IOException {\n\n    if (mRequestListener != null) {\n        requestCount++;\n        mRequestListener.report(requestCount);\n    }\n\n    HttpHeaders headers = request.getHeaders();\n\n    long unixTime = System.currentTimeMillis() / 1000L;\n\n    headers.add(\"request_time\", String.valueOf(unixTime));\n\n    if (myPrefs.accessToken().exists()) {\n\n        headers.add(\"access_token\", myPrefs.accessToken().get());\n\n\n        String hmacInput; //left this part out but basically do something unique to the request here and do the same on the other side.\n\n        String hmacKey = myPrefs.accessToken().getOr(\"\");\n\n\n        try {\n            String hmacSig = hmacSha1(hmacInput, hmacKey);\n\n            headers.add(\"hmac_sig\", hmacSig);\n\n        }\n        catch (InvalidKeyException e) {\n\n            e.printStackTrace();\n        }\n        catch (NoSuchAlgorithmException e) {\n\n            e.printStackTrace();\n        }\n\n\n    }\n    if (myPrefs.userId().exists()) {\n        headers.add(\"user_id\", String.valueOf(myPrefs.userId().get()));\n    }\n\n    headers.add(\"api_key\", \"somerandomstring\");\n\n    ClientHttpResponse t = execution.execute(request, data);\n\n    if (mRequestListener != null) {\n\n        requestCount--;\n        mRequestListener.report(requestCount);\n    }\n\n    return t;\n}\n\n\npublic void resetRequestCount() {\n    this.requestCount = 0;\n}\n\npublic static String hmacSha1(String value, String key) throws UnsupportedEncodingException,\n        NoSuchAlgorithmException, InvalidKeyException {\n    String type = \"HmacSHA1\";\n    SecretKeySpec secret = new SecretKeySpec(key.getBytes(), type);\n    Mac mac = Mac.getInstance(type);\n    mac.init(secret);\n    byte[] bytes = mac.doFinal(value.getBytes());\n    return bytesToHex(bytes);\n}\n\nprivate final static char[] hexArray = \"0123456789abcdef\".toCharArray();\n\nprivate static String bytesToHex(byte[] bytes) {\n    char[] hexChars = new char[bytes.length * 2];\n    int v;\n    for (int j = 0; j &lt; bytes.length; j++) {\n        v = bytes[j] &amp; 0xFF;\n        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];\n        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];\n    }\n    return new String(hexChars);\n}\n", "package com.example.customssl;\n\nimport android.content.Context;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.AllowAllHostnameVerifier;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpParams;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManagerFactory;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\n\npublic class CustomCAHttpsProvider {\n\n    /**\n     * Creates a {@link org.apache.http.client.HttpClient} which is configured to work with a custom authority\n     * certificate.\n     *\n     * @param context       Application Context\n     * @param certRawResId  R.raw.id of certificate file (*.crt). Should be stored in /res/raw.\n     * @param allowAllHosts If true then client will not check server against host names of certificate.\n     * @return Http Client.\n     * @throws Exception If there is an error initializing the client.\n     */\n    public static HttpClient getHttpClient(Context context, int certRawResId, boolean allowAllHosts) throws Exception {\n\n\n        // build key store with ca certificate\n        KeyStore keyStore = buildKeyStore(context, certRawResId);\n\n        // init ssl socket factory with key store\n        SSLSocketFactory sslSocketFactory = new SSLSocketFactory(keyStore);\n\n        // skip hostname security check if specified\n        if (allowAllHosts) {\n            sslSocketFactory.setHostnameVerifier(new AllowAllHostnameVerifier());\n        }\n\n        // basic http params for client\n        HttpParams params = new BasicHttpParams();\n\n        // normal scheme registry with our ssl socket factory for \"https\"\n        SchemeRegistry schemeRegistry = new SchemeRegistry();\n        schemeRegistry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        schemeRegistry.register(new Scheme(\"https\", sslSocketFactory, 443));\n\n        // create connection manager\n        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(params, schemeRegistry);\n\n        // create http client\n        return new DefaultHttpClient(cm, params);\n    }\n\n    /**\n     * Creates a {@link javax.net.ssl.HttpsURLConnection} which is configured to work with a custom authority\n     * certificate.\n     *\n     * @param urlString     remote url string.\n     * @param context       Application Context\n     * @param certRawResId  R.raw.id of certificate file (*.crt). Should be stored in /res/raw.\n     * @param allowAllHosts If true then client will not check server against host names of certificate.\n     * @return Http url connection.\n     * @throws Exception If there is an error initializing the connection.\n     */\n    public static HttpsURLConnection getHttpsUrlConnection(String urlString, Context context, int certRawResId,\n                                                           boolean allowAllHosts) throws Exception {\n\n        // build key store with ca certificate\n        KeyStore keyStore = buildKeyStore(context, certRawResId);\n\n        // Create a TrustManager that trusts the CAs in our KeyStore\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n\n        // Create an SSLContext that uses our TrustManager\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, tmf.getTrustManagers(), null);\n\n        // Create a connection from url\n        URL url = new URL(urlString);\n        HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();\n        urlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n\n        // skip hostname security check if specified\n        if (allowAllHosts) {\n            urlConnection.setHostnameVerifier(new AllowAllHostnameVerifier());\n        }\n\n        return urlConnection;\n    }\n\n    private static KeyStore buildKeyStore(Context context, int certRawResId) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {\n        // init a default key store\n        String keyStoreType = KeyStore.getDefaultType();\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        keyStore.load(null, null);\n\n        // read and add certificate authority\n        Certificate cert = readCert(context, certRawResId);\n        keyStore.setCertificateEntry(\"ca\", cert);\n\n        return keyStore;\n    }\n\n    private static Certificate readCert(Context context, int certResourceId) throws CertificateException, IOException {\n\n        // read certificate resource\n        InputStream caInput = context.getResources().openRawResource(certResourceId);\n\n        Certificate ca;\n        try {\n            // generate a certificate\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            ca = cf.generateCertificate(caInput);\n        } finally {\n            caInput.close();\n        }\n\n        return ca;\n    }\n\n}\n", "public void storeRSAPublicKey(String alias, BigInteger modulus, BigInteger exponent) \n{\n    /** Load the key to generate the certificate */\n    KeyStore ks = getApplicationKeyStore();\n    KeyStore.PrivateKeyEntry entry = (KeyStore.PrivateKeyEntry)ks.getEntry(MY_PRIVATE_KEY, null);\n    X509Certificate issuerCert = (X509Certificate)entry.getCertificate();\n    PrivateKey skey = entry.getPrivateKey();\n\n    /** Prepare the certificate template */\n    RSAKeyParameters params = new RSAKeyParameters(false, modulus, exponent);\n    SubjectPublicKeyInfo pkInfo = SubjectPublicKeyInfoFactory.SubjectPublicKeyInfo(params);\n    X500Name issuer = new X500Name(issuerCert.getIssuerX500Principal().getName());\n    X500Name subject = new X500Name(\"CN=alias\");\n    X509v3CertificateBuilder builder = new X509v3CertificateBuilder(issuer, randomSeriaNumber(), new Date(), dateIn20years(), subject, pkInfo);\n\n    /** Generate the certificate */\n    JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder(\"SHA256withRSA\");\n    ContentSigner signer = csBuilder.build(skey);\n    X509CertificateHolder holder = builder.build(signer);\n\n    /** Store the certificate in the KeyStore */\n    JcaX509CertificateConverter conv = new JcaX509CertificateConverter();\n    X509Certificate cert = conv.getCertificate(holder);\n    ks.setCertificateEntry(alias, cert);\n    pushKeyStoreToPersistentStorage(ks);\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"YOUR_PACKAGE_NAME\", PackageManager.GET_SIGNATURES);\n    for (Signature signature: info.signatures)  {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.e(\"FACEBOOK APP SIGNATURE\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (Exception e) {\n    // TODO: handle exception\n    e.printStackTrace();\n}\n", "    private TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager()\n    {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers()\n        {\n            return null;\n        }\n\n        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType)\n        {\n\n        }\n\n        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType)\n        {\n\n        }\n    }\n};\n", "            SSLContext sc = SSLContext.getInstance(\"TLS\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n", "public static DefaultHttpClient generateHttpClient(){\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, TIMEOUT_CONNECTION);\n        HttpConnectionParams.setSoTimeout(params, TIMEOUT_SOCKET);\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n\n        try{\n\n\nKeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new EasySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(\n               SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        registry.register(new Scheme(\"https\", sf, 443));\n    }catch (Exception e) {\n        e.printStackTrace();\n    }\n\n//      params.setParameter(CoreProtocolPNames.PROTOCOL_VERSION,             HttpVersion.HTTP_1_1);\n    ClientConnectionManager cm = new ThreadSafeClientConnManager(params, registry);\n    DefaultHttpClient client = new DefaultHttpClient(cm, params);\n    client.setKeepAliveStrategy(new ConnectionKeepAliveStrategy() { \n        @Override \n        public long getKeepAliveDuration(HttpResponse response, HttpContext \n    context) { \n            return 60; // seconds \n        } \n\n    }); \n\n    return client;\n\n}\n", "import java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.conn.ssl.SSLSocketFactory;\npublic class EasySSLSocketFactory extends SSLSocketFactory {\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n        public EasySSLSocketFactory(KeyStore truststore)\n                        throws NoSuchAlgorithmException, KeyManagementException,\n                        KeyStoreException, UnrecoverableKeyException {\n                super(truststore);\n\n\n\n  TrustManager tm = new X509TrustManager() {\n                    public void checkClientTrusted(X509Certificate[] chain,\n                                    String authType) throws CertificateException {\n                    }\n\n                    public void checkServerTrusted(X509Certificate[] chain,\n                                    String authType) throws CertificateException {\n                    }\n\n                    public X509Certificate[] getAcceptedIssuers() {\n                            return null;\n                    }\n            };\n\n            sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port,\n                    boolean autoClose) throws IOException, UnknownHostException {\n            return sslContext.getSocketFactory().createSocket(socket, host, port,\n                            autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n            return sslContext.getSocketFactory().createSocket();\n    }\n", "OkHttpClient client = new OkHttpClient();\n        try {\n            KeyStore keyStore = SSLUtils.getKeyStore(applicationContext);\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            trustManagerFactory.init(keyStore);\n            sslContext.init(null,trustManagerFactory.getTrustManagers(), new SecureRandom());\n            client.setSslSocketFactory(sslContext.getSocketFactory());\n        } catch (Exception e) {\n            Log.d(\"AppName\", \"cannot create http client\", e);\n        }\n", "import android.content.Context;\nimport android.content.res.AssetManager;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.InputStream;\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\n\npublic class SSLUtils {\n\n    private static final Logger LOG = LoggerFactory.getLogger(SSLUtils.class.getSimpleName());\n\n    public static KeyStore getKeyStore(Context context) {\n        KeyStore keyStore = null;\n        try {\n            AssetManager assetManager = context.getAssets();\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            InputStream caInput = assetManager.open(\"cert.pem\");\n            Certificate ca;\n            try {\n                ca = cf.generateCertificate(caInput);\n                LOG.debug(\"ca={}\", ((X509Certificate) ca).getSubjectDN());\n            } finally {\n                caInput.close();\n            }\n\n            String keyStoreType = KeyStore.getDefaultType();\n            keyStore = KeyStore.getInstance(keyStoreType);\n            keyStore.load(null, null);\n            keyStore.setCertificateEntry(\"ca\", ca);\n        } catch (Exception e) {\n            LOG.error(\"Error during getting keystore\", e);\n        }\n        return keyStore;\n    }\n}\n", "/******************************for https request***********************************************/\n    private HttpClient sslClient(HttpClient client) {\n        try {\n            X509TrustManager tm = new X509TrustManager() { \n                public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {\n                }\n\n                public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {\n                }\n\n                public X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n            };\n            SSLContext ctx = SSLContext.getInstance(getString(R.string.tls));\n            ctx.init(null, new TrustManager[]{tm}, null);\n            SSLSocketFactory ssf = new MySSLSocketFactory(ctx);\n            ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n            ClientConnectionManager ccm = client.getConnectionManager();\n            SchemeRegistry sr = ccm.getSchemeRegistry();\n            sr.register(new Scheme(getString(R.string.https), ssf, 443));\n            return new DefaultHttpClient(ccm, client.getParams());\n        } catch (Exception ex) {\n            return null;\n        }\n    }\n    public class MySSLSocketFactory extends SSLSocketFactory {\n        SSLContext sslContext = SSLContext.getInstance(getString(R.string.tls));\n\n        public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n            super(truststore);\n\n            TrustManager tm = new X509TrustManager() {\n                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                public X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n            };\n\n            sslContext.init(null, new TrustManager[] { tm }, null);\n        }\n\n        public MySSLSocketFactory(SSLContext context) throws KeyManagementException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {\n            super(null);\n            sslContext = context;\n        }\n\n        @Override\n        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n        }\n\n        @Override\n        public Socket createSocket() throws IOException {\n            return sslContext.getSocketFactory().createSocket();\n        }\n    }\n    /**********************************end********************************************/\n", "Cipher c = Cipher.getInstance(\"ARC4\");\nc.init(Cipher.DECRYPT_MODE, new SecretKeySpec(\"BrianIsInTheKitchen\".getBytes(), \"ARC4\"));\n", "import java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n//import javax.xml.bind.DatatypeConverter;\nimport android.util.Base64;\n\n\npublic class Support {\n\n    private static final String SALT = \"3D5900AE-111A-45BE-96B3-D9E4606CA793\";\n    private static final int MAX_HASH_ITERATIONS = 10;\n\n    public static void main(String[] args) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        String result = Support.GetPasswordHash(\"test\");\n        System.out.println(result);\n    }\n\n    public static String GetPasswordHash(String plaintextPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        String hashData = plaintextPassword;\n        for (int hashLimit = 0; hashLimit &lt; MAX_HASH_ITERATIONS; hashLimit++) {\n            hashData = GetHash(SALT + hashData);\n        }\n        return hashData;\n    }\n\n    //Gets the hash value of the data using SHA512Managed\n    private static String GetHash(String unhashedData) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        return getMD5Password(unhashedData);\n    }\n\n    //Verifies the hash\n    public static boolean VerifyHashedPassword(String plaintextPassword, String encryptedPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        String hashData = GetPasswordHash(plaintextPassword);\n        return encryptedPassword.equals(hashData);\n    }\n\n\n    public static String getMD5Password(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException{\n        MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA-512\"); \n        digest.update(password.getBytes(\"UTF-16LE\")); \n        byte messageDigest[] = digest.digest();\n\n        StringBuilder sb = new StringBuilder();\n        for(int iPos = 0; iPos &lt; messageDigest.length; iPos++) {\n            String h = Integer.toHexString(0xFF &amp; messageDigest[iPos]);\n            while (h.length() &lt; 2) {\n                h = \"0\" + h;\n            }\n            sb.append(h);\n        }\n\n        String md5String = sb.toString().toUpperCase();     \n        String res = Base64.encodeToString(md5String.getBytes(), Base64.DEFAULT);\n\n        return res;\n    }\n}\n", "@Override\npublic void onCreate() {\n    super.onCreate();\n\n    printHashKey();\n}\n\npublic void printHashKey(){\n\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.parakhidevelopers.happydays\",\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"Key Hash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (PackageManager.NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n}\n", "/**\n * This method is used to encrypt a string value.\n * \n * @param text\n *          - string value to be encrypted.\n *          \n * @return result(encrypted string) as String\n * \n * @throws Exception\n * \n */\n@TargetApi(8)\npublic static String encrytData(String text) throws Exception {\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    byte[] static_key = Constants.AES_KEY.getBytes();\n\n    SecretKeySpec keySpec = new SecretKeySpec(static_key, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n\n    byte[] results = cipher.doFinal(text.getBytes());\n\n    String result = Base64.encodeToString(results, Base64.NO_WRAP|Base64.DEFAULT);\n    return result;\n\n}\n\n/**\n * This method is used to decrypt a string value.\n * \n * @param text\n *          - string value to be decrypted.\n * @return result(decrypted string) as String\n * \n * @throws Exception\n */\n@SuppressLint(\"NewApi\")\npublic static String decryptData(String text)throws Exception{\n\n    byte[] encryted_bytes = Base64.decode(text, Base64.DEFAULT);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    byte[] static_key = Constants.AES_KEY.getBytes();\n\n    SecretKeySpec keySpec = new SecretKeySpec(static_key, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);\n    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\n    byte[] decrypted = cipher.doFinal(encryted_bytes);\n    String result = new String(decrypted);\n\n    return result;\n}\n", "public X509Certificate[] getAcceptedIssuers()\n{\n    X509Certificate[] trustedAnchors =\n        super.getAcceptedIssuers();\n\n    /* Create a new array with room for an additional trusted certificate. */\n    X509Certificate[] myTrustedAnchors = new X509Certificate[trustedAnchors.length + 1];\n    System.arraycopy(trustedAnchors, 0, myTrustedAnchors, 0, trustedAnchors.length);  \n\n    /* Load your certificate.\n\n       Thanks to http://stackoverflow.com/questions/11857417/x509trustmanager-override-without-allowing-all-certs\n       for this bit.\n     */\n    InputStream inStream = new FileInputStream(\"fileName-of-cert\");\n    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n    X509Certificate cert = (X509Certificate)cf.generateCertificate(inStream);\n    inStream.close();\n\n    /* Add your anchor cert as the last item in the array. */\n    myTrustedAnchors[trustedAnchors.length] = cert;\n\n    return myTrustedAnchors;\n}\n", "WifiConfiguration wc = new WifiConfiguration();\nwc.SSID = \"\\\"your_ssid\\\"\";\nwc.allowedKeyManagement.set(KeyMgmt.WPA_EAP);\nwc.allowedKeyManagement.set(KeyMgmt.IEEE8021X);\nwc.enterpriseConfig.setEapMethod(Eap.TLS);\nwc.status = WifiConfiguration.Status.ENABLED;\n\n...\n\nKeyStore pkcs12ks = KeyStore.getInstance(\"pkcs12\");\n\nin = new BufferedInputStream(new FileInputStream(new File(\"/path/to/your.p12\")));\n// alternatively you can read from any input stream, e.g. ByteArrayInputStream to read from String\n\npkcs12ks.load(in, \"pasword\".toCharArray());\n\nEnumeration&lt;String&gt; aliases = pkcs12ks.aliases();\nwhile (aliases.hasMoreElements()) {\n    String alias = aliases.nextElement();\n    Log.d(TAG, \"Processing alias \" + alias);\n\n    X509Certificate cert = (X509Certificate) pkcs12ks.getCertificate(alias);\n    Log.d(TAG, cert.toString());\n\n    PrivateKey key = (PrivateKey) pkcs12ks.getKey(alias, \"password\".toCharArray());\n    Log.d(TAG, key.toString());\n\n    wc.enterpriseConfig.setClientKeyEntry(key, cert);\n    wc.enterpriseConfig.setIdentity(\"WiFi-1\");\n}\n\n...\n\nint netID = wifiManager.addNetwork(wc);\nwifiManager.saveConfiguration();\nwifiManager.enableNetwork(netID, true);\n", "public void decrypt(String filename) throws Exception {\n    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"filename\"));\n    Base64InputStream base64Stream = new Base64InputStream(bis, 0);\n    Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    CipherInputStream cis = new CipherInputStream(base64Stream, c);\n    byte[] plainBuf = new byte[2048];\n    int nRead;\n    while ((nRead = cis.read(plainBuf)) &gt; 0) {\n        // send plainBuf[0] through plainBuf[nRead-1] to the video codec\n    }\n    cis.close();\n}\n", "KeyStore keyStoreFile = KeyStore.getInstance(KeyStore.getDefaultType());\nkeyStoreFile.load(resources.getAssets().open(\"snapzkeystore.bks\"), password);\n", "public static void showHashKey(Context context) {\n    try {\n        PackageInfo info = context.getPackageManager().getPackageInfo(\n                \"com.example.project\", PackageManager.GET_SIGNATURES); //Your package name here\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.v(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n    } catch (NoSuchAlgorithmException e) {\n    }\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"your application package name\",\n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "private static byte[] keyValue = new byte[]{ 'W', 'e', 'l', 'c', 'o', 'm', 'e','t', 'o', 'e', 'n','c', 'r', 'y', 'p', 't' };\n\nprivate String seedWith16Chars = new String(keyValue);\nprivate String textToEncrypt = \"1\";\n\nprivate TextView seed;\nprivate TextView text;\nprivate TextView encryptedValue;\nprivate TextView decryptedValue;\n\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    seed = (TextView) findViewById(R.id.seedName);\n    seed.setText(seedWith16Chars);\n\n    text = (TextView) findViewById(R.id.textToEncrypt);\n    text.setText(textToEncrypt);\n\n    encryptedValue = (TextView) findViewById(R.id.encryptedText);\n    decryptedValue = (TextView) findViewById(R.id.decryptedText);\n\n    try {\n        // This value was got when did run it from an 2.3.3 device a Galaxy SII running Android 4.0.4\n        String encrypted = \"\";\n\n        // Uncomment the line bellow and comment the line above to run it on an Android 4.1.2 or older.\n        // String encrypted = EncodeDecodeAES.encrypt(seedWith16Chars, textToEncrypt);\n        Log.e(\"Encrypt\", encrypted);\n        encrypted = encrypt(textToEncrypt);//EncodeDecodeAES.encrypt(seedWith16Chars, textToEncrypt);\n        encryptedValue.setText(\"Encrypt \"+encrypted);\n\n        String decrypted = decrypt(encrypted);//EncodeDecodeAES.decrypt(seedWith16Chars, encrypted);\n        decryptedValue.setText(\"Decrypt \"+decrypted);\n        Log.e(\"Decrypt\", decrypted);\n    } catch (Exception e) {\n        Log.e(\"Exception\", e.getLocalizedMessage());\n    }\n\n}\n\npublic static String encrypt(String Data) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(\"AES\");\n    c.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encVal = c.doFinal(Data.getBytes());\n    String encryptedValue = Base64.encodeToString(encVal, 0);\n    return encryptedValue;\n}\n\npublic static String decrypt(String encryptedData) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(\"AES\");\n    c.init(Cipher.DECRYPT_MODE, key);\n    byte[] decordedValue = Base64.decode(encryptedData, 0);\n    byte[] decValue = c.doFinal(decordedValue);\n    String decryptedValue = new String(decValue);\n    return decryptedValue;\n}\nprivate static Key generateKey() throws Exception {\n    Key key = new SecretKeySpec(keyValue, \"AES\");\n    return key;\n}\n", "public static  HttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", "public static final String md5(final String s) {\ntry {\n    // Create MD5 Hash\n    MessageDigest digest = java.security.MessageDigest\n            .getInstance(\"MD5\");\n    digest.update(s.getBytes());\n    byte messageDigest[] = digest.digest();\n\n    // Create Hex String\n    StringBuffer hexString = new StringBuffer();\n    for (int i = 0; i &lt; messageDigest.length; i++) {\n        String h = Integer.toHexString(0xFF &amp; messageDigest[i]);\n        while (h.length() &lt; 2)\n            h = \"0\" + h;\n        hexString.append(h);\n    }\n    return hexString.toString();\n\n} catch (NoSuchAlgorithmException e) {\n    e.printStackTrace();\n}\nreturn \"\";\n}\n", "public class ECDHPub {\n\n    private static ECPublicKey decodeECPublicKey(ECParameterSpec params,\n            final byte[] pubkey) throws NoSuchAlgorithmException,\n            InvalidKeySpecException {\n        int keySizeBytes = params.getOrder().bitLength() / Byte.SIZE;\n\n        int offset = 0;\n        BigInteger x = new BigInteger(1, Arrays.copyOfRange(pubkey, offset,\n                offset + keySizeBytes));\n        offset += keySizeBytes;\n        BigInteger y = new BigInteger(1, Arrays.copyOfRange(pubkey, offset,\n                offset + keySizeBytes));\n        ECPoint w = new ECPoint(x, y);\n\n        ECPublicKeySpec otherKeySpec = new ECPublicKeySpec(w, params);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"EC\");\n        ECPublicKey otherKey = (ECPublicKey) keyFactory\n                .generatePublic(otherKeySpec);\n        return otherKey;\n    }\n\n    private static byte[] encodeECPublicKey(ECPublicKey pubKey) {\n        int keyLengthBytes = pubKey.getParams().getOrder().bitLength()\n                / Byte.SIZE;\n        byte[] publicKeyEncoded = new byte[2 * keyLengthBytes];\n\n        int offset = 0;\n\n        BigInteger x = pubKey.getW().getAffineX();\n        byte[] xba = x.toByteArray();\n        if (xba.length &gt; keyLengthBytes + 1 || xba.length == keyLengthBytes + 1\n                &amp;&amp; xba[0] != 0) {\n            throw new IllegalStateException(\n                    \"X coordinate of EC public key has wrong size\");\n        }\n\n        if (xba.length == keyLengthBytes + 1) {\n            System.arraycopy(xba, 1, publicKeyEncoded, offset, keyLengthBytes);\n        } else {\n            System.arraycopy(xba, 0, publicKeyEncoded, offset + keyLengthBytes\n                    - xba.length, xba.length);\n        }\n        offset += keyLengthBytes;\n\n        BigInteger y = pubKey.getW().getAffineY();\n        byte[] yba = y.toByteArray();\n        if (yba.length &gt; keyLengthBytes + 1 || yba.length == keyLengthBytes + 1\n                &amp;&amp; yba[0] != 0) {\n            throw new IllegalStateException(\n                    \"Y coordinate of EC public key has wrong size\");\n        }\n\n        if (yba.length == keyLengthBytes + 1) {\n            System.arraycopy(yba, 1, publicKeyEncoded, offset, keyLengthBytes);\n        } else {\n            System.arraycopy(yba, 0, publicKeyEncoded, offset + keyLengthBytes\n                    - yba.length, yba.length);\n        }\n\n        return publicKeyEncoded;\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        // (only) required for named curves other than those used in JCE\n        Security.addProvider(new BouncyCastleProvider());\n\n        // create local and remote key\n        KeyPairGenerator kpgen = KeyPairGenerator.getInstance(\"ECDH\", \"BC\");\n        ECGenParameterSpec genspec = new ECGenParameterSpec(\"brainpoolp256r1\");\n        kpgen.initialize(genspec);\n        KeyPair localKeyPair = kpgen.generateKeyPair();\n        KeyPair remoteKeyPair = kpgen.generateKeyPair();\n\n        // test generation\n        byte[] encodedRemotePublicKey = encodeECPublicKey((ECPublicKey) remoteKeyPair\n                .getPublic());\n        // test creation\n        ECPublicKey remoteKey = decodeECPublicKey(\n                ((ECPublicKey) localKeyPair.getPublic()).getParams(),\n                encodedRemotePublicKey);\n\n        // local key agreement\n        KeyAgreement localKA = KeyAgreement.getInstance(\"ECDH\");\n        localKA.init(localKeyPair.getPrivate());\n        localKA.doPhase(remoteKey, true);\n        byte[] localSecret = localKA.generateSecret();\n\n        // remote key agreement\n        KeyAgreement remoteKA = KeyAgreement.getInstance(\"ECDH\");\n        remoteKA.init(remoteKeyPair.getPrivate());\n        remoteKA.doPhase((ECPublicKey) localKeyPair.getPublic(), true);\n        byte[] remoteSecret = localKA.generateSecret();\n\n        // validation\n        System.out.println(Arrays.equals(localSecret, remoteSecret));\n    }\n}\n", "private final static String ALGORITM = \"Blowfish\";\nprivate final static String KEY = \"2356a3a42ba5781f80a72dad3f90aeee8ba93c7637aaf218a8b8c18c\";\nprivate final static String PLAIN_TEXT = \"here is your text\";\n\npublic void run(View v) {\n\n    try {\n\n        byte[] encrypted = encrypt(KEY, PLAIN_TEXT);\n        Log.i(\"FOO\", \"Encrypted: \" + bytesToHex(encrypted));\n\n        String decrypted = decrypt(KEY, encrypted);\n        Log.i(\"FOO\", \"Decrypted: \" + decrypted);\n\n    } catch (GeneralSecurityException e) {\n        e.printStackTrace();\n    }\n}\n\nprivate byte[] encrypt(String key, String plainText) throws GeneralSecurityException {\n\n    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);\n\n    Cipher cipher = Cipher.getInstance(ALGORITM);\n    cipher.init(Cipher.ENCRYPT_MODE, secret_key);\n\n    return cipher.doFinal(plainText.getBytes());\n}\n\nprivate String decrypt(String key, byte[] encryptedText) throws GeneralSecurityException {\n\n    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);\n\n    Cipher cipher = Cipher.getInstance(ALGORITM);\n    cipher.init(Cipher.DECRYPT_MODE, secret_key);\n\n    byte[] decrypted = cipher.doFinal(encryptedText);\n\n    return new String(decrypted);\n}\n\npublic static String bytesToHex(byte[] data) {\n\n    if (data == null)\n        return null;\n\n    String str = \"\";\n\n    for (int i = 0; i &lt; data.length; i++) {\n        if ((data[i] &amp; 0xFF) &lt; 16)\n            str = str + \"0\" + java.lang.Integer.toHexString(data[i] &amp; 0xFF);\n        else\n            str = str + java.lang.Integer.toHexString(data[i] &amp; 0xFF);\n    }\n\n    return str;\n\n}\n", "  public static class NukeSSLCerts {\n    protected static final String TAG = \"NukeSSLCerts\";\n\n    public static void nuke() {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[]{\n                    new X509TrustManager() {\n                        public X509Certificate[] getAcceptedIssuers() {\n                            X509Certificate[] myTrustedAnchors = new X509Certificate[0];\n                            return myTrustedAnchors;\n                        }\n\n                        @Override\n                        public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                        }\n\n                        @Override\n                        public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                        }\n                    }\n            };\n\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, trustAllCerts, new SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n                @Override\n                public boolean verify(String arg0, SSLSession arg1) {\n                    return true;\n                }\n            });\n        } catch (Exception e) {\n        }\n    }\n}\n", "    public static String printKeyHash(Activity context) {\n        PackageInfo packageInfo;\n        String key = null;\n        try {\n            //getting application package name\n            String packageName = context.getApplicationContext().getPackageName();\n\n        //Retriving package info\n        packageInfo = context.getPackageManager().getPackageInfo(packageName,\n                PackageManager.GET_SIGNATURES);\n\n        Log.e(\"Package Name=\", context.getApplicationContext().getPackageName());\n\n        for (Signature signature : packageInfo.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            key = new String(Base64.encode(md.digest(), 0));\n\n            // String key = new String(Base64.encodeBytes(md.digest()));\n            Log.e(\"Key Hash=\", key);\n        }\n    } catch (NameNotFoundException e1) {\n        Log.e(\"Name not found\", e1.toString());\n    }\n    catch (NoSuchAlgorithmException e) {\n        Log.e(\"No such an algorithm\", e.toString());\n    } catch (Exception e) {\n        Log.e(\"Exception\", e.toString());\n    }\n\n    return key;\n}\n", "public HttpClient myHttpsClient() {\n    HttpClient client = null;\n    char[] passphrase = \"password\".toCharArray();\n    try {\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        CertificateFactory clientcf = CertificateFactory.getInstance(\"X.509\");\n        InputStream caInput = context.getResources().openRawResource(R.raw.server);\n        InputStream clientcert = context.getResources().openRawResource(R.raw.clientks);\n        Certificate ca;\n        KeyStore keyStoreclient = KeyStore.getInstance(\"BKS\");\n        try {\n            keyStoreclient.load(clientcert, \"password\".toCharArray());\n            ca = cf.generateCertificate(caInput);\n            System.out.println(\"server ca=\"+ ((X509Certificate) ca).getSubjectDN());\n        } finally {\n            caInput.close();\n            clientcert.close();\n        }\n\n        // Create a KeyStore containing our trusted CAs\n        String keyStoreType = KeyStore.getDefaultType();\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        keyStore.load(null, null);\n        keyStore.setCertificateEntry(\"ca\", ca);\n\n\n        String kmfAlgorithm = KeyManagerFactory.getDefaultAlgorithm();\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmfAlgorithm);\n            kmf.init(keyStoreclient,passphrase);\n\n\n        // Create a TrustManager that trusts the CAs in our KeyStore\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory\n                .getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n\n        // Create an SSLContext that uses our TrustManager\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n\n        MySSLSocketFactory socketFactory = new MySSLSocketFactory(context);//,new BrowserCompatHostnameVerifier());\n\n        client = createHttps(socketFactory);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return client;\n\n}\n", "public class GMailSender extends javax.mail.Authenticator \n{   \nprivate String mailhost = \"smtp.gmail.com\";   \nprivate String user;   \nprivate String password;   \nprivate Session session;   \nprivate Multipart _multipart;\n\nstatic \n{   \n    Security.addProvider(new JSSEProvider());   \n}  \n\npublic GMailSender(String user, String password) \n{   \n    this.user = user;   \n    this.password = password;   \n\n    Properties props = new Properties();   \n    props.setProperty(\"mail.transport.protocol\", \"smtp\");   \n    props.setProperty(\"mail.host\", mailhost);   \n    props.put(\"mail.smtp.auth\", \"true\");   \n    props.put(\"mail.smtp.port\", \"465\");   \n    props.put(\"mail.smtp.socketFactory.port\", \"465\");   \n    props.put(\"mail.smtp.socketFactory.class\",\"javax.net.ssl.SSLSocketFactory\");   \n    props.put(\"mail.smtp.socketFactory.fallback\", \"false\");   \n    props.setProperty(\"mail.smtp.quitwait\", \"false\");   \n\n    session = Session.getDefaultInstance(props, this);\n    _multipart = new MimeMultipart();\n}   \n\nprotected PasswordAuthentication getPasswordAuthentication() \n{   \n    return new PasswordAuthentication(user, password);   \n}   \n\npublic synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception \n{   \n    MimeMessage message = new MimeMessage(session);   \n    DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));   \n    message.setSender(new InternetAddress(sender));   \n    message.setSubject(subject);   \n\n    message.setDataHandler(handler);   \n    message.setContent(_multipart);\n    if (recipients.indexOf(',') &gt; 0)   \n        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   \n    else  \n        message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   \n    Transport.send(message);   \n\n}   \n\npublic void addAttachment(String filename) throws Exception \n{\n    BodyPart messageBodyPart = new MimeBodyPart();\n    DataSource source = new FileDataSource(filename);\n    messageBodyPart.setDataHandler(new DataHandler(source));\n    messageBodyPart.setFileName(filename);\n\n    _multipart.addBodyPart(messageBodyPart);\n}\n\npublic class ByteArrayDataSource implements DataSource \n{   \n    private byte[] data;   \n    private String type;   \n\n    public ByteArrayDataSource(byte[] data, String type) \n    {   \n        super();   \n        this.data = data;   \n        this.type = type;   \n    }   \n\n    public ByteArrayDataSource(byte[] data) \n    {   \n        super();   \n        this.data = data;   \n    }   \n\n    public void setType(String type) \n    {   \n        this.type = type;   \n    }   \n\n    public String getContentType() \n    {   \n        if (type == null)   \n            return \"application/octet-stream\";   \n        else  \n            return type;   \n    }   \n\n    public InputStream getInputStream() throws IOException \n    {   \n        return new ByteArrayInputStream(data);   \n    }   \n\n    public String getName() \n    {   \n        return \"ByteArrayDataSource\";   \n    }   \n\n    public OutputStream getOutputStream() throws IOException \n    {   \n        throw new IOException(\"Not Supported\");   \n    }   \n}   \n", "public final class JSSEProvider extends Provider \n{\nprivate static final long serialVersionUID = 1L;\n\npublic JSSEProvider() \n{\n    super(\"HarmonyJSSE\", 1.0, \"Harmony JSSE Provider\");\n    AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() \n    {\n        public Void run() \n        {\n            put(\"SSLContext.TLS\",\n                    \"org.apache.harmony.xnet.provider.jsse.SSLContextImpl\");\n            put(\"Alg.Alias.SSLContext.TLSv1\", \"TLS\");\n            put(\"KeyManagerFactory.X509\",\n                    \"org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl\");\n            put(\"TrustManagerFactory.X509\",\n                    \"org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl\");\n            return null;\n        }\n    });\n}\n}\n", "PublicKey publicKey = KeyFactory.getInstance(\"RSA\").generatePublic(publicKeySpec);\nSignature sign = Signature.getInstance(\"SHA1withRSA\");\nsign.initVerify(publicKey);\nsign.update(someString.getBytes(\"ASCII\"));\nboolean ok = sign.verify(Base64.decode(signature));\n", "public static String fileToMD5(String filePath) {\n    InputStream inputStream = null;\n    try {\n        inputStream = new FileInputStream(filePath);\n        byte[] buffer = new byte[1024];\n        MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        int numRead = 0;\n        while (numRead != -1) {\n            numRead = inputStream.read(buffer);\n            if (numRead &gt; 0)\n                digest.update(buffer, 0, numRead);\n        }\n        byte [] md5Bytes = digest.digest();\n        return convertHashToString(md5Bytes);\n    } catch (Exception e) {\n        return null;\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (Exception e) { }\n        }\n    }\n}\n\nprivate static String convertHashToString(byte[] md5Bytes) {\n    String returnVal = \"\";\n    for (int i = 0; i &lt; md5Bytes.length; i++) {\n        returnVal += Integer.toString(( md5Bytes[i] &amp; 0xff ) + 0x100, 16).substring(1);\n    }\n    return returnVal.toUpperCase();\n}\n", "// utility function\n    private static String bytesToHexString(byte[] bytes) {\n        // http://stackoverflow.com/questions/332079\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; bytes.length; i++) {\n            String hex = Integer.toHexString(0xFF &amp; bytes[i]);\n            if (hex.length() == 1) {\n                sb.append('0');\n            }\n            sb.append(hex);\n        }\n        return sb.toString();\n    }\n\n// generate a hash\n\n    String password=\"asdf\";\n    MessageDigest digest=null;\n    String hash;\n    try {\n        digest = MessageDigest.getInstance(\"SHA-256\");\n        digest.update(password.getBytes());\n\n        hash = bytesToHexString(digest.digest());\n\n        Log.i(\"Eamorr\", \"result is \" + hash);\n    } catch (NoSuchAlgorithmException e1) {\n        // TODO Auto-generated catch block\n        e1.printStackTrace();\n    }\n", "KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\nks.load(null, null);\nbyte[]  sek = \"eru9tyighw34ilty348934i34uiq34q34ri\".getBytes();\n...\n", " try {\n                PackageInfo info = getPackageManager().getPackageInfo(com.domain,\n                        PackageManager.GET_SIGNATURES);\n                for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    Log.i(\"PXR\", com.domain.Base64.encodeBytes(md.digest()));\n                }\n            } catch (NameNotFoundException e) {\n            } catch (NoSuchAlgorithmException e) {\n            }\n", "public String getEntry(String alias) {\n\n    String secretStr = null;\n    byte[] secret = null;\n\n    if (mKeystore != null) {\n\n\n\n        try {\n            if (!mKeystore.containsAlias(alias)) {\n                Log.w(TAG, new StringBuilder().append(\"Keystore \").append(mKeyStoreName)\n                        .append(\" does not contain entry \").append(alias).toString());\n                return null;\n            }\n        } catch (KeyStoreException ex) {\n            Log.e(TAG, \"Failed to read keystore entry \" + alias);\n        }\n\n        // get my entry from the key store\n        KeyStore.ProtectionParameter pp = new KeyStore.PasswordProtection(null);\n        KeyStore.SecretKeyEntry ske = null;\n        try {\n            ske = (KeyStore.SecretKeyEntry) mKeystore.getEntry(alias, pp);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Failed to read keystore entry \" + alias);\n        }\n\n        if (ske != null) {\n            SecretKeySpec sks = (SecretKeySpec) ske.getSecretKey();\n            secret = sks.getEncoded();\n\n            if (secret != null) {\n                secretStr = new String(secret);\n\n\n            } else {\n                Log.e(TAG, new StringBuilder().append(\"Read empty keystore entry \").append(alias).toString());\n            }\n        } else {\n            Log.e(TAG, \"Failed to read keystore entry \" + alias);\n        }\n    }\n    return secretStr;\n}\n", "   try {\n            PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md;\n\n                    md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    String something = new String(Base64.encode(md.digest(), 0));\n                   //Toast.makeText(StartingPlace.this, something,\n                        //  Toast.LENGTH_LONG).show();\n                    Log.e(\"hash key\", something);\n        } \n        }\n        catch (NameNotFoundException e1) {\n            // TODO Auto-generated catch block\n            Log.e(\"name not found\", e1.toString());\n        }\n\n             catch (NoSuchAlgorithmException e1) {\n                // TODO Auto-generated catch block\n                 Log.e(\"no such an algorithm\", e1.toString());\n            }\n             catch (Exception e1){\n                 Log.e(\"exception\", e1.toString());\n             }\n        //code to get hash code\n", "package org.xmlrpc.android;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.TrustManager;\n\nimport org.apache.http.conn.ConnectTimeoutException;\nimport org.apache.http.conn.scheme.LayeredSocketFactory;\nimport org.apache.http.conn.scheme.SocketFactory;\nimport org.apache.http.params.HttpConnectionParams;\nimport org.apache.http.params.HttpParams;\n\n/**\n * This socket factory will create ssl socket that accepts self signed certificate\n *\n * @author olamy\n * @version $Id: EasySSLSocketFactory.java 765355 2009-04-15 20:59:07Z evenisse $\n * @since 1.2.3\n */\npublic class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory {\n\n    private SSLContext sslcontext = null;\n\n    private static SSLContext createEasySSLContext() throws IOException {\n        try {\n            SSLContext context = SSLContext.getInstance(\"TLS\");\n            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);\n            return context;\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n    }\n\n    private SSLContext getSSLContext() throws IOException {\n        if (this.sslcontext == null) {\n            this.sslcontext = createEasySSLContext();\n        }\n        return this.sslcontext;\n    }\n\n    /**\n     * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int,\n     *      java.net.InetAddress, int, org.apache.http.params.HttpParams)\n     */\n    public Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort,\n            HttpParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n        int soTimeout = HttpConnectionParams.getSoTimeout(params);\n        InetSocketAddress remoteAddress = new InetSocketAddress(host, port);\n        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());\n\n        if ((localAddress != null) || (localPort &gt; 0)) {\n            // we need to bind explicitly\n            if (localPort &lt; 0) {\n                localPort = 0; // indicates \"any\"\n            }\n            InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);\n            sslsock.bind(isa);\n        }\n\n        sslsock.connect(remoteAddress, connTimeout);\n        sslsock.setSoTimeout(soTimeout);\n        return sslsock;\n\n    }\n\n    /**\n     * @see org.apache.http.conn.scheme.SocketFactory#createSocket()\n     */\n    public Socket createSocket() throws IOException {\n        return getSSLContext().getSocketFactory().createSocket();\n    }\n\n    /**\n     * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)\n     */\n    public boolean isSecure(Socket socket) throws IllegalArgumentException {\n        return true;\n    }\n\n    /**\n     * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int,\n     *      boolean)\n     */\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,\n            UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    // -------------------------------------------------------------------\n    // javadoc in org.apache.http.conn.scheme.SocketFactory says :\n    // Both Object.equals() and Object.hashCode() must be overridden\n    // for the correct operation of some connection managers\n    // -------------------------------------------------------------------\n\n    public boolean equals(Object obj) {\n        return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));\n    }\n\n    public int hashCode() {\n        return EasySSLSocketFactory.class.hashCode();\n    }\n\n}\n", "public static void printHashKey(Context pContext) {\n        try {\n            PackageInfo info = getPackageInfo(pContext, PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String hashKey = new String(Base64.encode(md.digest(), 0));\n                Log.i(TAG, \"printHashKey() Hash Key: \" + hashKey);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, \"printHashKey()\", e);\n        } catch (Exception e) {\n            Log.e(TAG, \"printHashKey()\", e);\n        }\n    }\n", "import android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.Signature;\nimport android.util.Base64;\nimport android.util.Log;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n public static String printKeyHash(Activity context) {\n        PackageInfo packageInfo;\n        String key = null;\n        try {\n            //getting application package name, as defined in manifest\n            String packageName = context.getApplicationContext().getPackageName();\n\n            //Retriving package info\n            packageInfo = context.getPackageManager().getPackageInfo(packageName,\n                    PackageManager.GET_SIGNATURES);\n\n            Log.e(\"Package Name=\", context.getApplicationContext().getPackageName());\n\n            for (Signature signature : packageInfo.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                key = new String(Base64.encode(md.digest(), 0));\n\n                // String key = new String(Base64.encodeBytes(md.digest()));\n                Log.e(\"Key Hash=\", key);\n            }\n        } catch (PackageManager.NameNotFoundException e1) {\n            Log.e(\"Name not found\", e1.toString());\n        }\n        catch (NoSuchAlgorithmException e) {\n            Log.e(\"No such an algorithm\", e.toString());\n        } catch (Exception e) {\n            Log.e(\"Exception\", e.toString());\n        }\n\n        return key;\n    }\n", " public class DeviceInfo {\n\n        public static String getDeviceInfo(Context activity, Device device) {\n            try {\n                switch (device) {\n                    case DEVICE_LANGUAGE:\n                        return Locale.getDefault().getDisplayLanguage();\n                    case DEVICE_TIME_ZONE:\n                        return TimeZone.getDefault().getID();//(false, TimeZone.SHORT);\n                    case DEVICE_LOCAL_COUNTRY_CODE:\n                        return activity.getResources().getConfiguration().locale.getCountry();\n                    case DEVICE_CURRENT_YEAR:\n                        return \"\" + (Calendar.getInstance().get(Calendar.YEAR));\n                    case DEVICE_CURRENT_DATE_TIME:\n                        Calendar calendarTime = Calendar.getInstance(TimeZone.getDefault(), Locale.getDefault());\n                        long time = (calendarTime.getTimeInMillis() / 1000);\n                        return String.valueOf(time);\n    //                    return DateFormat.getDateTimeInstance().format(new Date());\n                    case DEVICE_CURRENT_DATE_TIME_ZERO_GMT:\n                        Calendar calendarTime_zero = Calendar.getInstance(TimeZone.getTimeZone(\"GMT+0\"), Locale.getDefault());\n                        return String.valueOf((calendarTime_zero.getTimeInMillis() / 1000));\n    //                    DateFormat df = DateFormat.getDateTimeInstance();\n    //                    df.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\n    //                    return df.format(new Date());\n                    case DEVICE_HARDWARE_MODEL:\n                        return getDeviceName();\n                    case DEVICE_NUMBER_OF_PROCESSORS:\n                        return Runtime.getRuntime().availableProcessors() + \"\";\n                    case DEVICE_LOCALE:\n                        return Locale.getDefault().getISO3Country();\n                    case DEVICE_IP_ADDRESS_IPV4:\n                        return getIPAddress(true);\n                    case DEVICE_IP_ADDRESS_IPV6:\n                        return getIPAddress(false);\n                    case DEVICE_MAC_ADDRESS:\n                        String mac = getMACAddress(\"wlan0\");\n                        if (TextUtils.isEmpty(mac)) {\n                            mac = getMACAddress(\"eth0\");\n                        }\n                        if (TextUtils.isEmpty(mac)) {\n                            mac = \"DU:MM:YA:DD:RE:SS\";\n                        }\n                        return mac;\n\n                    case DEVICE_TOTAL_MEMORY:\n                        if (Build.VERSION.SDK_INT &gt;= 16)\n                            return String.valueOf(getTotalMemory(activity));\n                    case DEVICE_FREE_MEMORY:\n                        return String.valueOf(getFreeMemory(activity));\n                    case DEVICE_USED_MEMORY:\n                        if (Build.VERSION.SDK_INT &gt;= 16) {\n                            long freeMem = getTotalMemory(activity) - getFreeMemory(activity);\n                            return String.valueOf(freeMem);\n                        }\n                        return \"\";\n                    case DEVICE_TOTAL_CPU_USAGE:\n                        int[] cpu = getCpuUsageStatistic();\n                        if (cpu != null) {\n                            int total = cpu[0] + cpu[1] + cpu[2] + cpu[3];\n                            return String.valueOf(total);\n                        }\n                        return \"\";\n                    case DEVICE_TOTAL_CPU_USAGE_SYSTEM:\n                        int[] cpu_sys = getCpuUsageStatistic();\n                        if (cpu_sys != null) {\n                            int total = cpu_sys[1];\n                            return String.valueOf(total);\n                        }\n                        return \"\";\n                    case DEVICE_TOTAL_CPU_USAGE_USER:\n                        int[] cpu_usage = getCpuUsageStatistic();\n                        if (cpu_usage != null) {\n                            int total = cpu_usage[0];\n                            return String.valueOf(total);\n                        }\n                        return \"\";\n                    case DEVICE_MANUFACTURE:\n                        return android.os.Build.MANUFACTURER;\n                    case DEVICE_SYSTEM_VERSION:\n                        return String.valueOf(getDeviceName());\n                    case DEVICE_VERSION:\n                        return String.valueOf(android.os.Build.VERSION.SDK_INT);\n                    case DEVICE_IN_INCH:\n                        return getDeviceInch(activity);\n                    case DEVICE_TOTAL_CPU_IDLE:\n                        int[] cpu_idle = getCpuUsageStatistic();\n                        if (cpu_idle != null) {\n                            int total = cpu_idle[2];\n                            return String.valueOf(total);\n                        }\n                        return \"\";\n                    case DEVICE_NETWORK_TYPE:\n                        return getNetworkType(activity);\n                    case DEVICE_NETWORK:\n                        return checkNetworkStatus(activity);\n                    case DEVICE_TYPE:\n                        if (isTablet(activity)) {\n                            if (getDeviceMoreThan5Inch(activity)) {\n                                return \"Tablet\";\n                            } else\n                                return \"Mobile\";\n                        } else {\n                            return \"Mobile\";\n                        }\n                    default:\n                        break;\n                }\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n            return \"\";\n        }\n\n        public static String getDeviceId(Context context) {\n            String device_uuid = Secure.getString(context.getContentResolver(), Secure.ANDROID_ID);\n            if (device_uuid == null) {\n                device_uuid = \"12356789\"; // for emulator testing\n            } else {\n                try {\n                    byte[] _data = device_uuid.getBytes();\n                    MessageDigest _digest = java.security.MessageDigest.getInstance(\"MD5\");\n                    _digest.update(_data);\n                    _data = _digest.digest();\n                    BigInteger _bi = new BigInteger(_data).abs();\n                    device_uuid = _bi.toString(36);\n                } catch (Exception e) {\n                    if (e != null) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            return device_uuid;\n        }\n\n        @SuppressLint(\"NewApi\")\n        private static long getTotalMemory(Context activity) {\n            try {\n                MemoryInfo mi = new MemoryInfo();\n                ActivityManager activityManager = (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);\n                activityManager.getMemoryInfo(mi);\n                long availableMegs = mi.totalMem / 1048576L; // in megabyte (mb)\n\n                return availableMegs;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return 0;\n            }\n        }\n\n        private static long getFreeMemory(Context activity) {\n            try {\n                MemoryInfo mi = new MemoryInfo();\n                ActivityManager activityManager = (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);\n                activityManager.getMemoryInfo(mi);\n                long availableMegs = mi.availMem / 1048576L; // in megabyte (mb)\n\n                return availableMegs;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return 0;\n            }\n        }\n\n        private static String getDeviceName() {\n            String manufacturer = Build.MANUFACTURER;\n            String model = Build.MODEL;\n            if (model.startsWith(manufacturer)) {\n                return capitalize(model);\n            } else {\n                return capitalize(manufacturer) + \" \" + model;\n            }\n        }\n\n        private static String capitalize(String s) {\n            if (s == null || s.length() == 0) {\n                return \"\";\n            }\n            char first = s.charAt(0);\n            if (Character.isUpperCase(first)) {\n                return s;\n            } else {\n                return Character.toUpperCase(first) + s.substring(1);\n            }\n        }\n\n        /**\n         * Convert byte array to hex string\n         *\n         * @param bytes\n         * @return\n         */\n        private static String bytesToHex(byte[] bytes) {\n            StringBuilder sbuf = new StringBuilder();\n            for (int idx = 0; idx &lt; bytes.length; idx++) {\n                int intVal = bytes[idx] &amp; 0xff;\n                if (intVal &lt; 0x10)\n                    sbuf.append(\"0\");\n                sbuf.append(Integer.toHexString(intVal).toUpperCase());\n            }\n            return sbuf.toString();\n        }\n\n        /**\n         * Returns MAC address of the given interface name.\n         *\n         * @param interfaceName eth0, wlan0 or NULL=use first interface\n         * @return mac address or empty string\n         */\n        @SuppressLint(\"NewApi\")\n        private static String getMACAddress(String interfaceName) {\n            try {\n\n                List&lt;NetworkInterface&gt; interfaces = Collections.list(NetworkInterface.getNetworkInterfaces());\n                for (NetworkInterface intf : interfaces) {\n                    if (interfaceName != null) {\n                        if (!intf.getName().equalsIgnoreCase(interfaceName))\n                            continue;\n                    }\n                    byte[] mac = intf.getHardwareAddress();\n                    if (mac == null)\n                        return \"\";\n                    StringBuilder buf = new StringBuilder();\n                    for (int idx = 0; idx &lt; mac.length; idx++)\n                        buf.append(String.format(\"%02X:\", mac[idx]));\n                    if (buf.length() &gt; 0)\n                        buf.deleteCharAt(buf.length() - 1);\n                    return buf.toString();\n                }\n            } catch (Exception ex) {\n                return \"\";\n            } // for now eat exceptions\n            return \"\";\n            /*\n             * try { // this is so Linux hack return\n             * loadFileAsString(\"/sys/class/net/\" +interfaceName +\n             * \"/address\").toUpperCase().trim(); } catch (IOException ex) { return\n             * null; }\n             */\n        }\n\n        /**\n         * Get IP address from first non-localhost interface\n         *\n         * @return address or empty string\n         */\n        private static String getIPAddress(boolean useIPv4) {\n            try {\n                List&lt;NetworkInterface&gt; interfaces = Collections.list(NetworkInterface.getNetworkInterfaces());\n                for (NetworkInterface intf : interfaces) {\n                    List&lt;InetAddress&gt; addrs = Collections.list(intf.getInetAddresses());\n                    for (InetAddress addr : addrs) {\n                        if (!addr.isLoopbackAddress()) {\n                            String sAddr = addr.getHostAddress().toUpperCase();\n                            boolean isIPv4 = InetAddressUtils.isIPv4Address(sAddr);\n                            if (useIPv4) {\n                                if (isIPv4)\n                                    return sAddr;\n                            } else {\n                                if (!isIPv4) {\n                                    int delim = sAddr.indexOf('%'); // drop ip6 port\n                                    // suffix\n                                    return delim &lt; 0 ? sAddr : sAddr.substring(0, delim);\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (Exception ex) {\n            } // for now eat exceptions\n            return \"\";\n        }\n\n        /*\n         *\n         * @return integer Array with 4 elements: user, system, idle and other cpu\n         * usage in percentage.\n         */\n        private static int[] getCpuUsageStatistic() {\n            try {\n                String tempString = executeTop();\n\n                tempString = tempString.replaceAll(\",\", \"\");\n                tempString = tempString.replaceAll(\"User\", \"\");\n                tempString = tempString.replaceAll(\"System\", \"\");\n                tempString = tempString.replaceAll(\"IOW\", \"\");\n                tempString = tempString.replaceAll(\"IRQ\", \"\");\n                tempString = tempString.replaceAll(\"%\", \"\");\n                for (int i = 0; i &lt; 10; i++) {\n                    tempString = tempString.replaceAll(\"  \", \" \");\n                }\n                tempString = tempString.trim();\n                String[] myString = tempString.split(\" \");\n                int[] cpuUsageAsInt = new int[myString.length];\n                for (int i = 0; i &lt; myString.length; i++) {\n                    myString[i] = myString[i].trim();\n                    cpuUsageAsInt[i] = Integer.parseInt(myString[i]);\n                }\n                return cpuUsageAsInt;\n\n            } catch (Exception e) {\n                e.printStackTrace();\n                Log.e(\"executeTop\", \"error in getting cpu statics\");\n                return null;\n            }\n        }\n\n        private static String executeTop() {\n            java.lang.Process p = null;\n            BufferedReader in = null;\n            String returnString = null;\n            try {\n                p = Runtime.getRuntime().exec(\"top -n 1\");\n                in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                while (returnString == null || returnString.contentEquals(\"\")) {\n                    returnString = in.readLine();\n                }\n            } catch (IOException e) {\n                Log.e(\"executeTop\", \"error in getting first line of top\");\n                e.printStackTrace();\n            } finally {\n                try {\n                    in.close();\n                    p.destroy();\n                } catch (IOException e) {\n                    Log.e(\"executeTop\", \"error in closing and destroying top process\");\n                    e.printStackTrace();\n                }\n            }\n            return returnString;\n        }\n\n        public static String getNetworkType(final Context activity) {\n            String networkStatus = \"\";\n\n            final ConnectivityManager connMgr = (ConnectivityManager)\n                    activity.getSystemService(Context.CONNECTIVITY_SERVICE);\n            // check for wifi\n            final android.net.NetworkInfo wifi =\n                    connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI);\n            // check for mobile data\n            final android.net.NetworkInfo mobile =\n                    connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);\n\n            if (wifi.isAvailable()) {\n                networkStatus = \"Wifi\";\n            } else if (mobile.isAvailable()) {\n                networkStatus = getDataType(activity);\n            } else {\n                networkStatus = \"noNetwork\";\n            }\n            return networkStatus;\n        }\n\n        public static String checkNetworkStatus(final Context activity) {\n            String networkStatus = \"\";\n            try {\n                // Get connect mangaer\n                final ConnectivityManager connMgr = (ConnectivityManager)\n                activity.getSystemService(Context.CONNECTIVITY_SERVICE);\n                // // check for wifi\n                final android.net.NetworkInfo wifi =\n                connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI);\n                // // check for mobile data\n                final android.net.NetworkInfo mobile =\n                connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);\n\n                if (wifi.isAvailable()) {\n                networkStatus = \"Wifi\";\n                } else if (mobile.isAvailable()) {\n                networkStatus = getDataType(activity);\n                } else {\n                networkStatus = \"noNetwork\";\n                networkStatus = \"0\";\n               }\n\n\n            } catch (Exception e) {\n                e.printStackTrace();\n                networkStatus = \"0\";\n            }\n            return networkStatus;\n\n        } \n\n public static boolean isTablet(Context context) {\n        return (context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) &gt;= Configuration.SCREENLAYOUT_SIZE_LARGE;\n    }\n\n    public static boolean getDeviceMoreThan5Inch(Context activity) {\n        try {\n            DisplayMetrics displayMetrics = activity.getResources().getDisplayMetrics();\n            // int width = displayMetrics.widthPixels;\n            // int height = displayMetrics.heightPixels;\n\n            float yInches = displayMetrics.heightPixels / displayMetrics.ydpi;\n            float xInches = displayMetrics.widthPixels / displayMetrics.xdpi;\n            double diagonalInches = Math.sqrt(xInches * xInches + yInches * yInches);\n            if (diagonalInches &gt;= 7) {\n                // 5inch device or bigger\n                return true;\n            } else {\n                // smaller device\n                return false;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public static String getDeviceInch(Context activity) {\n        try {\n            DisplayMetrics displayMetrics = activity.getResources().getDisplayMetrics();\n\n            float yInches = displayMetrics.heightPixels / displayMetrics.ydpi;\n            float xInches = displayMetrics.widthPixels / displayMetrics.xdpi;\n            double diagonalInches = Math.sqrt(xInches * xInches + yInches * yInches);\n            return String.valueOf(diagonalInches);\n        } catch (Exception e) {\n            return \"-1\";\n        }\n    }\n\n    public static String getDataType(Context activity) {\n        String type = \"Mobile Data\";\n        TelephonyManager tm = (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);\n        switch (tm.getNetworkType()) {\n            case TelephonyManager.NETWORK_TYPE_HSDPA:\n                type = \"Mobile Data 3G\";\n                Log.d(\"Type\", \"3g\");\n                // for 3g HSDPA networktype will be return as\n                // per testing(real) in device with 3g enable\n                // data\n                // and speed will also matters to decide 3g network type\n                break;\n            case TelephonyManager.NETWORK_TYPE_HSPAP:\n                type = \"Mobile Data 4G\";\n                Log.d(\"Type\", \"4g\");\n                // No specification for the 4g but from wiki\n                // i found(HSPAP used in 4g)\n                break;\n            case TelephonyManager.NETWORK_TYPE_GPRS:\n                type = \"Mobile Data GPRS\";\n                Log.d(\"Type\", \"GPRS\");\n                break;\n            case TelephonyManager.NETWORK_TYPE_EDGE:\n                type = \"Mobile Data EDGE 2G\";\n                Log.d(\"Type\", \"EDGE 2g\");\n                break;\n\n        }\n\n        return type;\n        }\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.facebook.samples.loginhowto\", \n             PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (NameNotFoundException e) {\n} catch (NoSuchAlgorithmException e) {\n}\n", "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\nimport org.apache.commons.net.util.Base64;\n\n   private static SecretKey key;\n\n         try {\n            byte[] secretBytes = \"secret key\".getBytes(\"UTF8\");\n            DESKeySpec keySpec = new DESKeySpec(secretBytes);\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n            key = keyFactory.generateSecret(keySpec);\n         } catch (Exception e) {\n            Log.e(Flashum.LOG_TAG, \"DatabaseHelper \" + e.toString());\n         }\n\n   public byte[] encryptPassword(String userpw) {\n      try {\n         byte[] cleartext = userpw.getBytes(\"UTF8\");      \n\n         Cipher cipher = Cipher.getInstance(\"DES\");\n         cipher.init(Cipher.ENCRYPT_MODE, key);\n         byte[] clearBytes = cipher.doFinal(cleartext);\n         byte[] encryptedPwd = Base64.encodeBase64(clearBytes);\n         return encryptedPwd;\n      } catch (Exception e) {\n         Log.e(Flashum.LOG_TAG, \"DatabaseHelper \" + e.toString());\n      }\n      return null;\n   }\n\n   public String decryptPassword(byte[] userpw) {\n      String pw = \"\";\n      try {\n         byte[] encrypedPwdBytes = Base64.decodeBase64(userpw);\n\n         Cipher cipher = Cipher.getInstance(\"DES\");\n         cipher.init(Cipher.DECRYPT_MODE, key);\n         byte[] plainTextPwdBytes = cipher.doFinal(encrypedPwdBytes);\n         pw = new String(plainTextPwdBytes, \"UTF8\");\n      } catch (Exception e) {\n         Log.e(Flashum.LOG_TAG, \"DatabaseHelper \" + e.toString());\n      }\n      return pw;\n   }\n", "        List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n        list.add(\"Hello\");\n        list.add(\" World!!\");\n\n        System.out.println(list);\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(list);\n        byte[] text = bos.toByteArray();\n\n        KeyGenerator keygenerator = KeyGenerator.getInstance(\"DES\");\n        SecretKey myDesKey = keygenerator.generateKey();\n        Cipher desCipher;\n        desCipher = Cipher.getInstance(\"DES\");\n\n        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);\n        byte[] textEncrypted = desCipher.doFinal(text);\n\n        desCipher.init(Cipher.DECRYPT_MODE, myDesKey);\n        byte[] textDecrypted = desCipher.doFinal(textEncrypted);\n\n        ByteArrayInputStream bis = new ByteArrayInputStream(textDecrypted);\n        ObjectInputStream ois = new ObjectInputStream(bis);\n        List&lt;String&gt; result = (List&lt;String&gt;) ois.readObject();\n\n        System.out.println(result);\n", "try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.facebook.samples.hellofacebook\",\n                PackageManager.GET_SIGNATURES);\n\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.e(\"KeyHash:\",\n                    Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n        Log.d(\"NameNotFoundException\", \"NameNotFoundException\");\n    } catch (NoSuchAlgorithmException e) {\n        Log.d(\"NameNotFoundException\", \"NoSuchAlgorithmException\");\n    }\n", "DocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();\n dbfac.setNamespaceAware(true);\n DocumentBuilder docBuilder = null;\n try {\n    docBuilder = dbfac.newDocumentBuilder();\n} catch (ParserConfigurationException e) {\n    // TODO Auto-generated catch block\n    e.printStackTrace();\n}\n DOMImplementation domImpl = docBuilder.getDOMImplementation();\n Document doc = domImpl.createDocument(\"http://coggl.com/InsertTrack\",\"TrackEntry\", null);\n doc.setXmlVersion(\"1.0\");\n doc.setXmlStandalone(true);\n\n Element trackElement = doc.getDocumentElement();\n\n Element CompanyId = doc.createElement(\"CompanyId\");\n CompanyId.appendChild(doc.createTextNode(\"1\"));\n trackElement.appendChild(CompanyId);\n\n Element CreatedBy = doc.createElement(\"CreatedBy\");\n CreatedBy.appendChild(doc.createTextNode(\"6\"));\n trackElement.appendChild(CreatedBy);\n\n Element DepartmentId = doc.createElement(\"DepartmentId\");\n DepartmentId.appendChild(doc.createTextNode(\"4\"));\n trackElement.appendChild(DepartmentId);\n\n Element IsBillable = doc.createElement(\"IsBillable\");\n IsBillable.appendChild(doc.createTextNode(\"1\"));\n trackElement.appendChild(IsBillable);\n\n Element ProjectId = doc.createElement(\"ProjectId\");\n ProjectId.appendChild(doc.createTextNode(\"1\"));\n trackElement.appendChild(ProjectId);\n\n Element StartTime = doc.createElement(\"StartTime\");\n StartTime.appendChild(doc.createTextNode(\"2012-03-14 10:44:45\"));\n trackElement.appendChild(StartTime);\n\n Element StopTime = doc.createElement(\"StopTime\");\n StopTime.appendChild(doc.createTextNode(\"2012-03-14 11:44:45\"));\n trackElement.appendChild(StopTime);\n\n Element TaskId = doc.createElement(\"TaskId\");\n TaskId.appendChild(doc.createTextNode(\"3\"));\n trackElement.appendChild(TaskId);\n\n Element TotalTime = doc.createElement(\"TotalTime\");\n TotalTime.appendChild(doc.createTextNode(\"1\"));\n trackElement.appendChild(TotalTime);\n\n Element TrackDesc = doc.createElement(\"TrackDesc\");\n TrackDesc.appendChild(doc.createTextNode(\"dello testing\"));\n trackElement.appendChild(TrackDesc);\n\n Element TrackId = doc.createElement(\"TrackId\");\n TrackId.appendChild(doc.createTextNode(\"0\"));\n trackElement.appendChild(TrackId);\n\n TransformerFactory transfac = TransformerFactory.newInstance();\n Transformer trans = null;\ntry {\n    trans = transfac.newTransformer();\n} catch (TransformerConfigurationException e) {\n    // TODO Auto-generated catch block\n    e.printStackTrace();\n}\n trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n trans.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\n //create string from xml tree\n StringWriter sw = new StringWriter();\n StreamResult result = new StreamResult(sw);\n DOMSource source = new DOMSource(doc);\n try {\n    trans.transform(source, result);\n} catch (TransformerException e) {\n    // TODO Auto-generated catch block\n    e.printStackTrace();\n}\n String xmlString = sw.toString();\n\n//posting xml file to server\n\n DefaultHttpClient httpClient = new DefaultHttpClient();\n\n HttpPost httppost = new HttpPost(\"http://192.168.0.19:3334/cogglrestservice.svc/InsertTrack\");     \n // Make sure the server knows what kind of a response we will accept\n httppost.addHeader(\"Accept\", \"text/xml\");\n // Also be sure to tell the server what kind of content we are sending\n httppost.addHeader(\"Content-Type\", \"application/xml\");\n\n try\n {\n StringEntity entity = new StringEntity(xmlString, \"UTF-8\");\n entity.setContentType(\"application/xml\");\n httppost.setEntity(entity);\n\n // execute is a blocking call, it's best to call this code in a thread separate from the ui's\n HttpResponse response = httpClient.execute(httppost);\n\n BasicResponseHandler responseHandler = new BasicResponseHandler();\n    String strResponse = null;\n    if (response != null) {\n        try {\n            strResponse = responseHandler.handleResponse(response);\n        } catch (HttpResponseException e) {\n            e.printStackTrace();  \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    Log.e(\"WCFTEST\", \"WCFTEST ********** Response\" + strResponse);    \n\n\n }\n catch (Exception ex)\n {\n ex.printStackTrace();\n }\n Toast.makeText(EditTask.this, \"Xml posted succesfully.\",Toast.LENGTH_SHORT).show();\n", " /**\n * Generates a PublicKey instance from a string containing the\n * Base64-encoded public key.\n *\n * @param encodedPublicKey Base64-encoded public key\n * @throws IllegalArgumentException if encodedPublicKey is invalid\n */\npublic static PublicKey generatePublicKey(String encodedPublicKey) {\n    try {\n        String str = new String(Base64.decode(encodedPublicKey));\n        byte[] decodedKey = Base64.decode(str);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);\n        return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n        Log.e(TAG, \"Invalid key specification.\");\n        throw new IllegalArgumentException(e);\n    } catch (Base64DecoderException e) {\n        Log.e(TAG, \"Base64 decoding failed.\");\n        throw new IllegalArgumentException(e);\n    }\n}\n", "FileInputStream fis = new FileInputStream(filename);\nBufferedInputStream bis = new BufferedInputStream(fis);\n\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\nCertificate cert = cf.generateCertificate(bis);\n", "        // Add code to print out the key hash\n            try {\n                PackageInfo info = getPackageManager().getPackageInfo(\n                        \"com.example.testhopelast\",\n                        PackageManager.GET_SIGNATURES);\n                for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(),\n                            Base64.DEFAULT));\n                }\n            } catch (NameNotFoundException e) {\n\n            } catch (NoSuchAlgorithmException e) {\n\n            }\n", "private void trustAll() { \n    try { \n            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){ \n                    public boolean verify(String hostname, SSLSession session) { \n                            return true; \n                    }}); \n            SSLContext context = SSLContext.getInstance(\"TLS\"); \n            context.init(null, new X509TrustManager[]{new X509TrustManager(){ \n                    public void checkClientTrusted(X509Certificate[] chain, \n                                    String authType) throws CertificateException {} \n                    public void checkServerTrusted(X509Certificate[] chain, \n                                    String authType) throws CertificateException {} \n                    public X509Certificate[] getAcceptedIssuers() { \n                            return new X509Certificate[0]; \n                    }}}, new SecureRandom()); \n            HttpsURLConnection.setDefaultSSLSocketFactory( \n                            context.getSocketFactory()); \n    } catch (Exception e) { \n            Log.e(\"TAG\",e); \n    } \n}\n", "public static DotNetRSA GenerateDotNetKey(String base64PubKey)\n            throws IOException, NoSuchAlgorithmException,\n            InvalidKeySpecException {\n        /*\n         * String base64PubKey - \n         * Is a Key retrieved from Google Checkout Merchant Account\n         */\n        BASE64Decoder decoder = new BASE64Decoder();\n\n        byte[] publicKeyBytes = decoder.decodeBuffer(base64PubKey);\n\n        EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);\n        RSAPublicKey publicKey = (RSAPublicKey) KeyFactory.getInstance(\"RSA\").generatePublic(publicKeySpec);\n\n        byte[] modulusBytes = publicKey.getModulus().toByteArray();\n        byte[] exponentBytes = publicKey.getPublicExponent().toByteArray();\n\n        modulusBytes = stripLeadingZeros(modulusBytes);\n\n        BASE64Encoder encoder = new BASE64Encoder();\n        String modulusB64 = encoder.encode(modulusBytes);\n        String exponentB64 = encoder.encode(exponentBytes);\n\n        return new DotNetRSA(modulusB64, exponentB64);\n    }\n\n      private static byte[] stripLeadingZeros(byte[] a) {\n        int lastZero = -1;\n        for (int i = 0; i &lt; a.length; i++) {\n          if (a[i] == 0) {\n            lastZero = i;\n          }\n          else {\n            break;\n          }\n        }\n        lastZero++;\n        byte[] result = new byte[a.length - lastZero];\n        System.arraycopy(a, lastZero, result, 0, result.length);\n        return result;\n      }\n", "/*\n * Copyright (C) 2012 The CyanogenMod Project\n *\n * * Licensed under the GNU GPLv2 license\n *\n * The text of the license can be found in the LICENSE file\n * or at https://www.gnu.org/licenses/gpl-2.0.txt\n */\n\npackage com.cyanogenmod.updater.utils;\n\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class MD5 {\n    private static final String TAG = \"MD5\";\n\n    public static boolean checkMD5(String md5, File updateFile) {\n        if (TextUtils.isEmpty(md5) || updateFile == null) {\n            Log.e(TAG, \"MD5 string empty or updateFile null\");\n            return false;\n        }\n\n        String calculatedDigest = calculateMD5(updateFile);\n        if (calculatedDigest == null) {\n            Log.e(TAG, \"calculatedDigest null\");\n            return false;\n        }\n\n        Log.v(TAG, \"Calculated digest: \" + calculatedDigest);\n        Log.v(TAG, \"Provided digest: \" + md5);\n\n        return calculatedDigest.equalsIgnoreCase(md5);\n    }\n\n    public static String calculateMD5(File updateFile) {\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, \"Exception while getting digest\", e);\n            return null;\n        }\n\n        InputStream is;\n        try {\n            is = new FileInputStream(updateFile);\n        } catch (FileNotFoundException e) {\n            Log.e(TAG, \"Exception while getting FileInputStream\", e);\n            return null;\n        }\n\n        byte[] buffer = new byte[8192];\n        int read;\n        try {\n            while ((read = is.read(buffer)) &gt; 0) {\n                digest.update(buffer, 0, read);\n            }\n            byte[] md5sum = digest.digest();\n            BigInteger bigInt = new BigInteger(1, md5sum);\n            String output = bigInt.toString(16);\n            // Fill to 32 chars\n            output = String.format(\"%32s\", output).replace(' ', '0');\n            return output;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unable to process file for MD5\", e);\n        } finally {\n            try {\n                is.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Exception on closing MD5 input stream\", e);\n            }\n        }\n    }\n}\n", "   public static String hashMac(String text, String secretKey)\n                  throws SignatureException {\n\n                 try {\n                  Key sk = new SecretKeySpec(secretKey.getBytes(), HASH_ALGORITHM);\n                  Mac mac = Mac.getInstance(sk.getAlgorithm());\n                  mac.init(sk);\n                  final byte[] hmac = mac.doFinal(text.getBytes());\n                  return toHexString(hmac);\n                 } catch (NoSuchAlgorithmException e1) {\n                  // throw an exception or pick a different encryption method\n                  throw new SignatureException(\n                    \"error building signature, no such algorithm in device \"\n                      + HASH_ALGORITHM);\n                 } catch (InvalidKeyException e) {\n                  throw new SignatureException(\n                    \"error building signature, invalid key \" + HASH_ALGORITHM);\n                 }\n    }\n\n    public static String toHexString(byte[] bytes) {  \n            StringBuilder sb = new StringBuilder(bytes.length * 2);  \n\n            Formatter formatter = new Formatter(sb);  \n            for (byte b : bytes) {  \n                formatter.format(\"%02x\", b);  \n            }  \n\n            return sb.toString();  \n        } \n", "static OkHttpClient getUnsafeOkHttpClient() {\n  try {\n      // Create a trust manager that does not validate certificate chains\n      final TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n          @Override\n          public void checkClientTrusted(java.security.cert.X509Certificate[] chain,\n                  String authType) throws CertificateException {\n          }\n\n          @Override\n          public void checkServerTrusted(java.security.cert.X509Certificate[] chain,\n                  String authType) throws CertificateException {\n          }\n\n          @Override\n          public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n              return null;\n          }\n      } };\n\n      // Install the all-trusting trust manager\n      final SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n      sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n      // Create an ssl socket factory with our all-trusting manager\n      final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n\n      OkHttpClient okHttpClient = new OkHttpClient();\n      okHttpClient.setSslSocketFactory(sslSocketFactory);\n      okHttpClient.setHostnameVerifier(new HostnameVerifier() {\n          @Override\n          public boolean verify(String hostname, SSLSession session) {\n              return true;\n          }\n      });\n\n      return okHttpClient;\n  } catch (Exception e) {\n      throw new RuntimeException(e);\n  }\n}\n", "KeySpec ks = new DESKeySpec(\"key12345\".getBytes(\"UTF-8\"));\nSecretKey key = SecretKeyFactory.getInstance(\"DES\").generateSecret(ks);\n\nIvParameterSpec iv = new IvParameterSpec(\n        Hex.decodeHex(\"1234567890ABCDEF\".toCharArray()));\n\nCipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, key, iv);\n\nbyte[] decoded = cipher.doFinal(Base64.decodeBase64(\"B3xogi/Qfsc=\"));\n\nSystem.out.println(\"Decoded: \" + new String(decoded, \"UTF-8\"));\n", "private void workAroundReverseDnsBugInHoneycombAndEarlier(HttpClient client) {\n    // Android had a bug where HTTPS made reverse DNS lookups (fixed in Ice Cream Sandwich) \n    // http://code.google.com/p/android/issues/detail?id=13117\n    SocketFactory socketFactory = new LayeredSocketFactory() {\n        SSLSocketFactory delegate = SSLSocketFactory.getSocketFactory();\n        @Override public Socket createSocket() throws IOException {\n            return delegate.createSocket();\n        }\n        @Override public Socket connectSocket(Socket sock, String host, int port,\n                InetAddress localAddress, int localPort, HttpParams params) throws IOException {\n            return delegate.connectSocket(sock, host, port, localAddress, localPort, params);\n        }\n        @Override public boolean isSecure(Socket sock) throws IllegalArgumentException {\n            return delegate.isSecure(sock);\n        }\n        @Override public Socket createSocket(Socket socket, String host, int port,\n                boolean autoClose) throws IOException {\n            injectHostname(socket, host);\n            return delegate.createSocket(socket, host, port, autoClose);\n        }\n        private void injectHostname(Socket socket, String host) {\n            try {\n                Field field = InetAddress.class.getDeclaredField(\"hostName\");\n                field.setAccessible(true);\n                field.set(socket.getInetAddress(), host);\n            } catch (Exception ignored) {\n            }\n        }\n    };\n    client.getConnectionManager().getSchemeRegistry()\n            .register(new Scheme(\"https\", socketFactory, 443));\n}\n", "MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\ndigest.update(yourPassword.getBytes(\"UTF-8\"));\nString passwordEncrypted = Base64.encodeToString(digest.digest(), Base64.DEFAULT);\n", "import java.security.MessageDigest;\n\npublic class PasswordToken {\n\n    static public String makeDigest(String password) \n    {\n         String hexStr = \"\";\n\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.reset();\n            byte[] buffer = password.getBytes();\n            md.update(buffer);\n            byte[] digest = md.digest();\n\n\n            for (int i = 0; i &lt; digest.length; i++) {\n                hexStr +=  Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 );\n\n        } \n        } catch(Exception e) // If the algo is not working for some reason on this device\n                             // we have to use the strings hash code, which \n                             // could allow duplicates but at least allows tokens\n        {\n            hexStr = Integer.toHexString(password.hashCode()); \n        }\n\n        return hexStr;\n    }\n\n    static public boolean validate(String password, String token) \n    {\n         String digestToken = \"\";\n         String simpleToken = \"\";\n\n         digestToken = makeDigest(password);\n\n         if (0 == digestToken.compareTo(token)) \n             return true; \n\n         if (0 == simpleToken.compareTo(token))\n             return true;\n\n         return false; \n    }\n}\n", "   try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n            \"COM.YOUR.PACKAGE.NAME\", \n            PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"My Keyhash\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (Exception e) {\n        Log.e(\"My Keyhash\", e.toString());\n    } \n", "String android_id = Settings.Secure.getString(this.getContentResolver(), Settings.Secure.ANDROID_ID);\nMessageDigest md5 = MessageDigest.getInstance(\"MD5\");\nbyte[] digest = md5.digest(android_id.getBytes());\nString deviceId = Base64.encodeToString(digest, 0);\n\nAdRequest adRequest = new dRequest.Builder().addTestDevice(\"17BB429573B0FA8677D27957B98C7005\").build();\nadView.loadAd(adRequest);\n", "MessageDigest md = null;\nString digest = null;\n    try {\n        md = MessageDigest.getInstance(\"MD5\");\n\n        byte[] hash = md.digest(myStringToEncode.getBytes(\"UTF-8\")); //converting byte array to Hexadecimal String\n        StringBuilder sb = new StringBuilder(2*hash.length);\n\n        for(byte b : hash){\n            sb.append(String.format(\"%02x\", b&amp;0xff));\n        }\n\n        digest = sb.toString();\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n\nreturn digest;\n", "try {\n        PackageInfo info = context.getPackageManager().getPackageInfo(\n                \"com.example.sharingapplication\", PackageManager.GET_SIGNATURES); //Your            package name here\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.i(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n\n    } catch (NameNotFoundException e) {\n    } catch (NoSuchAlgorithmException e) {\n    }\n}\n", "public class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\npublic MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n    super(truststore);\n\n    TrustManager tm = new X509TrustManager() {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n\n    sslContext.init(null, new TrustManager[] { tm }, null);\n}\n\n@Override\npublic Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n}\n\n@Override\npublic Socket createSocket() throws IOException {\n    return sslContext.getSocketFactory().createSocket();\n}\n", "HttpsURLConnection yc = (HttpsURLConnection)pocketUrl.openConnection();\nyc.setDoInput(true);\nyc.setRequestMethod(\"GET\");\nyc.setSSLSocketFactory(sslContext.getSocketFactory());\nif (urlConnection.getResponseCode() != 200) {\n    // handle error here\n    final String responseMessage = yc.getResponseMessage();\n    Log.e(TAG, \"Failed Response: \" + responseMessage);\n    return;\n}\n\nBufferedReader in = new BufferedReader(new InputStreamReader(yc.getInputStream()));\n", "public class IntegrityUtils {\npublic static String toASCII(byte b[], int start, int length) {\n    StringBuffer asciiString = new StringBuffer();\n\n    for (int i = start; i &lt; (length + start); i++) {\n        // exclude nulls from the ASCII representation\n        if (b[i] != (byte) 0x00) {\n            asciiString.append((char) b[i]);\n        }\n    }\n\n    return asciiString.toString();\n}\n\npublic static String getMD5Checksum(File file) throws Exception {\n    byte[] b = createChecksum(file);\n    String result = \"\";\n\n    for (int i = 0; i &lt; b.length; i++) {\n        result += Integer.toString((b[i] &amp; 0xff) + 0x100, 16).substring(1);\n    }\n    return result;\n}\n\npublic static byte[] createChecksum(File file) throws Exception {\n    InputStream fis = new FileInputStream(file);\n\n    byte[] buffer = new byte[1024];\n    MessageDigest complete = MessageDigest.getInstance(\"MD5\");\n    int numRead;\n\n    do {\n        numRead = fis.read(buffer);\n        if (numRead &gt; 0) {\n            complete.update(buffer, 0, numRead);\n        }\n    } while (numRead != -1);\n\n    fis.close();\n    return complete.digest();\n}\n}\n", "String _publicKey= base64encoded_publickey;\n\n\n    // InputStream fileInputStream = null;\n    try {\n        // Receiving side\n\n        byte[] decodedBytes = Base64.decode(_publicKey, Base64.DEFAULT);\n\n        fileInputStream = new ByteArrayInputStream(decodedBytes);\n\n        // Print the decoded string\n\n        String decodedString = new String(decodedBytes);\n\n\n        CertificateFactory certFactory = CertificateFactory\n                .getInstance(CERTIFICATE_TYPE);\n        // certFactory.\n        X509Certificate cert = (X509Certificate) certFactory\n                .generateCertificate(fileInputStream);\n        publicKey = cert.getPublicKey();\n        Log.d(\"TAG\", \"Public key of the certificate:\" + publicKey);\n\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        throw new RuntimeException(\"Could not intialize encryption module\",\n                e);\n    } finally {\n        if (keyStream != null) {\n            try {\n                keyStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "String password = \"123456\"; \nMessageDigest md = MessageDigest.getInstance(\"SHA-256\"); \nmd.update(password.getBytes()); \nbyte byteData[] = md.digest();\n", "private static SSLSocketFactory createPinnedSSLCertFactory(Context ctx) {\n    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n    Certificate myCert = //read certificate in;\n    String keyStoreType = KeyStore.getDefaultType();\n    KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n    keyStore.load(null, null); //inputstream null creates new keystore\n    keyStore.setCertificateEntry(\"mycert\", myCert );\n\n    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n    tmf.init(keyStore);\n\n    SSLContext context = SSLContext.getInstance(\"TLS\");\n    context.init(null, tmf.getTrustManagers(), null);\n\n    return context.getSocketFactory();\n}\n", "private void printKeyHashForThisDevice() {\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"com.package\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n\n            String keyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n            Logger.logger(\"============================================\");\n            Logger.logger(\"KeyHash================  \", keyHash);\n            Logger.logger(\"============================================\");\n            System.out.println(\"KeyHash================  \" + keyHash);\n\n        }\n    } catch (NameNotFoundException e) {\n    } catch (NoSuchAlgorithmException e) {\n    }\n}\n", "public static void showHashKey(Context context) {\n        try {\n            PackageInfo info = context.getPackageManager().getPackageInfo(\n                    \"com.example.tryitonjewelry\", PackageManager.GET_SIGNATURES); //Your package name here\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.i(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                }\n        } catch (NameNotFoundException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n    }\n", "private static final int BUFFER_SIZE = 4096;\nprivate static final char[] TERMINATOR = new char[]{'\\r', '\\n', '\\r', '\\n'};\n\n/**\n * Simple SSL connect example to avoid Issue 15356 on Android 2.3.3\n *\n * @param host    The host/server name\n * @param port    The TCP port to use (443 is default for HTTP over SSL)\n * @param file    The file you are requesting (/path/to/file/on/server.doc)\n * @param fileOut Your &lt;code&gt;OutputStream&lt;/code&gt; for the file you are writing to\n * @throws Exception If any error occurs - obviously should be improved for your implementation\n */\nprivate static void downloadFileOverSSL(String host, int port, String file, OutputStream fileOut) throws Exception {\n    PrintWriter socketOut = null;\n    InputStream socketIn = null;\n    try {\n        // create a socket to talk to the server on\n        SocketFactory factory = SSLSocketFactory.getDefault();\n        Socket socket = factory.createSocket(host, port);\n\n        // we'll use this to send our request to the server\n        socketOut = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));\n\n        //This is what Java was sending using URLConnection, and it works here too...\n        //  You can always change this to something both your app and server will understand depending how it is setup\n        // This is the least you need in the request:\n        /*String requestStr = \"GET \" + file + \" HTTP/1.1\\r\\n\" +\n            \"Host: \" + host + \"\\r\\n\" +\n            \"\\r\\n\";*/\n        String requestStr = \"GET \" + file + \" HTTP/1.1\\r\\n\" +\n                \"Host: \" + host + \"\\r\\n\" +\n                \"User-Agent: Java/1.6.0_25\\r\\n\" +\n                \"Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\" +\n                \"Connection: keep-alive\\r\\n\" +\n                \"\\r\\n\";\n        //Log.i(getLogTag(), \"Request being sent: `\" + requestStr + \"\\\"\");\n\n        // send the request to the server\n        socketOut.print(requestStr);\n        socketOut.flush();\n\n        // this reads the server's response\n        socketIn = socket.getInputStream();\n\n        /*\n           Write the results into our local file's output stream\n        */\n\n        // This is the tricky part, the raw socket returns the HTTP 200 response and headers.\n        // This can probably be optimized, but it's just reading through until it finds \\r\\n\\r\\n\n\n        // You can use something like CharTerminatedInputStream\n        //      (ref: http://www.java2s.com/Tutorial/Java/0180__File/AnInputStreamclassthatterminatesthestreamwhenitencountersaparticularbytesequence.htm)\n        CharTerminatedInputStream charTermInput = new CharTerminatedInputStream(socketIn, TERMINATOR);\n        while (charTermInput.read() != -1) {\n            // -1 indicates a match was made, IOException or ProtocolException thrown if match not made by end of stream\n        }\n\n        int numBytesRead;\n        byte[] buffer = new byte[BUFFER_SIZE];\n        while ((numBytesRead = socketIn.read(buffer, 0, BUFFER_SIZE)) != -1) {\n            fileOut.write(buffer, 0, numBytesRead);\n            //Log.d(getLogTag(), \"Reading data [\" + numBytesRead + \"]: \" + new String(buffer, 0, numBytesRead));\n        }\n        fileOut.flush();\n\n    } finally {\n        safeClose(socketOut);\n        safeClose(socketIn);\n        safeClose(fileOut);\n    }\n}\n\nprivate static void safeClose(Closeable closeable) {\n    if (closeable != null) {\n        try {\n            closeable.close();\n        } catch (IOException ioe) {\n            //Log.w(getLogTag(), \"Failed to close stream\", ioe);\n        }\n    }\n}\n", "import android.os.Environment;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\n\n/**\n * Static methods used for common file operations.\n * \n * @author Carl Hartung (carlhartung@gmail.com)\n */\npublic class FileUtils {\n    private final static String t = \"FileUtils\";\n\n    // Used to validate and display valid form names.\n    public static final String VALID_FILENAME = \"[ _\\\\-A-Za-z0-9]*.x[ht]*ml\";\n\n    // Storage paths\n    public static final String FORMS_PATH = Environment.getExternalStorageDirectory() + \"/odk/forms/\";\n    public static final String INSTANCES_PATH = Environment.getExternalStorageDirectory() + \"/odk/instances/\";\n    public static final String CACHE_PATH = Environment.getExternalStorageDirectory() + \"/odk/.cache/\";\n    public static final String TMPFILE_PATH = CACHE_PATH + \"tmp.jpg\";\n\n\n    public static ArrayList&lt;String&gt; getValidFormsAsArrayList(String path) {\n        ArrayList&lt;String&gt; formPaths = new ArrayList&lt;String&gt;();\n        File dir = new File(path);\n\n        if (!storageReady()) {\n            return null;\n        }\n        if (!dir.exists()) {\n            if (!createFolder(path)) {\n                return null;\n            }\n        }\n        File[] dirs = dir.listFiles();\n        for (int i = 0; i &lt; dirs.length; i++) {\n          // skip all the directories\n          if (dirs[i].isDirectory())\n            continue;\n\n            String formName = dirs[i].getName();\n\n          formPaths.add(dirs[i].getAbsolutePath());\n        }\n        return formPaths;\n    }\n\n    public static ArrayList&lt;String&gt; getFoldersAsArrayList(String path) {\n        ArrayList&lt;String&gt; mFolderList = new ArrayList&lt;String&gt;();\n        File root = new File(path);\n\n        if (!storageReady()) {\n            return null;\n        }\n        if (!root.exists()) {\n            if (!createFolder(path)) {\n                return null;\n            }\n        }\n        if (root.isDirectory()) {\n            File[] children = root.listFiles();\n            for (File child : children) {\n                boolean directory = child.isDirectory();\n                if (directory) {\n                    mFolderList.add(child.getAbsolutePath());\n                }\n            }\n        }\n        return mFolderList;\n    }\n\n\n    public static boolean deleteFolder(String path) {\n        // not recursive\n        if (path != null &amp;&amp; storageReady()) {\n            File dir = new File(path);\n            if (dir.exists() &amp;&amp; dir.isDirectory()) {\n                File[] files = dir.listFiles();\n                for (File file : files) {\n                    if (!file.delete()) {\n                        Log.i(t, \"Failed to delete \" + file);\n                    }\n                }\n            }\n            return dir.delete();\n        } else {\n            return false;\n        }\n    }\n\n\n    public static boolean createFolder(String path) {\n        if (storageReady()) {\n            boolean made = true;\n            File dir = new File(path);\n            if (!dir.exists()) {\n                made = dir.mkdirs();\n            }\n            return made;\n        } else {\n            return false;\n        }\n    }\n\n\n    public static boolean deleteFile(String path) {\n        if (storageReady()) {\n            File f = new File(path);\n            return f.delete();\n        } else {\n            return false;\n        }\n    }\n\n\n    public static byte[] getFileAsBytes(File file) {\n        byte[] bytes = null;\n        InputStream is = null;\n        try {\n            is = new FileInputStream(file);\n\n            // Get the size of the file\n            long length = file.length();\n            if (length &gt; Integer.MAX_VALUE) {\n                Log.e(t, \"File \" + file.getName() + \"is too large\");\n                return null;\n            }\n\n            // Create the byte array to hold the data\n            bytes = new byte[(int) length];\n\n            // Read in the bytes\n            int offset = 0;\n            int read = 0;\n            try {\n                while (offset &lt; bytes.length &amp;&amp; read &gt;= 0) {\n                    read = is.read(bytes, offset, bytes.length - offset);\n                    offset += read;\n                }\n            } catch (IOException e) {\n                Log.e(t, \"Cannot read \" + file.getName());\n                e.printStackTrace();\n                return null;\n            }\n\n            // Ensure all the bytes have been read in\n            if (offset &lt; bytes.length) {\n                try {\n                    throw new IOException(\"Could not completely read file \" + file.getName());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return null;\n                }\n            }\n\n            return bytes;\n\n        } catch (FileNotFoundException e) {\n            Log.e(t, \"Cannot find \" + file.getName());\n            e.printStackTrace();\n            return null;\n\n        } finally {\n            // Close the input stream\n            try {\n                is.close();\n            } catch (IOException e) {\n                Log.e(t, \"Cannot close input stream for \" + file.getName());\n                e.printStackTrace();\n                return null;\n            }\n        }\n    }\n\n\n    public static boolean storageReady() {\n        String cardstatus = Environment.getExternalStorageState();\n        if (cardstatus.equals(Environment.MEDIA_REMOVED)\n                || cardstatus.equals(Environment.MEDIA_UNMOUNTABLE)\n                || cardstatus.equals(Environment.MEDIA_UNMOUNTED)\n                || cardstatus.equals(Environment.MEDIA_MOUNTED_READ_ONLY)) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n\n    public static String getMd5Hash(File file) {\n        try {\n            // CTS (6/15/2010) : stream file through digest instead of handing it the byte[]\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            int chunkSize = 256;\n\n            byte[] chunk = new byte[chunkSize];\n\n            // Get the size of the file\n            long lLength = file.length();\n\n            if (lLength &gt; Integer.MAX_VALUE) {\n                Log.e(t, \"File \" + file.getName() + \"is too large\");\n                return null;\n            }\n\n            int length = (int) lLength;\n\n            InputStream is = null;\n            is = new FileInputStream(file);\n\n            int l = 0;\n            for (l = 0; l + chunkSize &lt; length; l += chunkSize) {\n                is.read(chunk, 0, chunkSize);\n                md.update(chunk, 0, chunkSize);\n            }\n\n            int remaining = length - l;\n            if (remaining &gt; 0) {\n                is.read(chunk, 0, remaining);\n                md.update(chunk, 0, remaining);\n            }\n            byte[] messageDigest = md.digest();\n\n            BigInteger number = new BigInteger(1, messageDigest);\n            String md5 = number.toString(16);\n            while (md5.length() &lt; 32)\n                md5 = \"0\" + md5;\n            is.close();\n            return md5;\n\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(\"MD5\", e.getMessage());\n            return null;\n\n        } catch (FileNotFoundException e) {\n            Log.e(\"No Cache File\", e.getMessage());\n            return null;\n        } catch (IOException e) {\n            Log.e(\"Problem reading from file\", e.getMessage());\n            return null;\n        } \n\n\n    }\n\n}\n", "public static String md5(String s) {\n    try {\n        // Create MD5 Hash\n        MessageDigest digest = java.security.MessageDigest\n                .getInstance(\"MD5\");\n        digest.update(s.getBytes());\n        byte messageDigest[] = digest.digest();\n\n        // Create Hex String\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i &lt; messageDigest.length; i++)\n            hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));\n        return hexString.toString();\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "public static final String md5(final String toEncrypt) {\n    try {\n        final MessageDigest digest = MessageDigest.getInstance(\"md5\");\n        digest.update(toEncrypt.getBytes());\n        final byte[] bytes = digest.digest();\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; bytes.length; i++) {\n            sb.append(String.format(\"%02X\", bytes[i]));\n        }\n        return sb.toString().toLowerCase();\n    } catch (Exception exc) {\n        return \"\"; // Impossibru!\n    }\n}\n", "private static final X500Principal DEBUG_DN = new X500Principal(\"CN=Android Debug,O=Android,C=US\");\nprivate boolean isDebuggable(Context ctx)\n{\n    boolean debuggable = false;\n\n    try\n    {\n        PackageInfo pinfo = ctx.getPackageManager().getPackageInfo(ctx.getPackageName(),PackageManager.GET_SIGNATURES);\n        Signature signatures[] = pinfo.signatures;\n\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n\n        for ( int i = 0; i &lt; signatures.length;i++)\n        {   \n            ByteArrayInputStream stream = new ByteArrayInputStream(signatures[i].toByteArray());\n            X509Certificate cert = (X509Certificate) cf.generateCertificate(stream);       \n            debuggable = cert.getSubjectX500Principal().equals(DEBUG_DN);\n            if (debuggable)\n                break;\n        }\n    }\n    catch (NameNotFoundException e)\n    {\n        //debuggable variable will remain false\n    }\n    catch (CertificateException e)\n    {\n        //debuggable variable will remain false\n    }\n    return debuggable;\n}\n", "ProviderInstaller.installIfNeeded(context);\nSSLContext sslContext = SSLContext.getInstance(\"TLSv1.2\");\nsslContext.init(KeyManager[] km, TrustManager[] tm, SecureRandom rm);\nSSLEngine engine = sslContext.createSSLEngine();\nAsyncHttpClient.getDefaultInstance().insertMiddleware((AsyncHttpClientMiddleware) engine); \n", "KeyStore ks = KeyStore.getInstance(\"BKS\");\nInputStream is = new FileInputStream(\"/etc/security/cacerts.bks\");\nks.load(is, \"changeit\".toCharArray());\n\nList&lt;X509Certificate&gt; certs = new ArrayList&lt;X509Certificate&gt;();\nEnumeration&lt;String&gt; aliases = ks.aliases();\nwhile (aliases.hasMoreElements()) {\n  String alias = aliases.nextElement();\n  X509Certificate cert = (X509Certificate) ks.getCertificate(alias);\n  certs.add(cert);\n}\n", "TrustManagerFactory tmf = TrustManagerFactory\n                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init((KeyStore) null);\nX509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];\nfor (X509Certificate cert : xtm.getAcceptedIssuers()) {\n    String certStr = \"S:\" + cert.getSubjectDN().getName() + \"\\nI:\"\n                        + cert.getIssuerDN().getName();\n    Log.d(TAG, certStr);\n}\n", "private SSLSocketFactory getSslSocketFactory() {\n    try {\n        // Load CAs from an InputStream\n        // (could be from a resource or ByteArrayInputStream or ...)\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        // From https://www.washington.edu/itconnect/security/ca/load-der.crt\n        InputStream caInput = getApplicationContext().getResources().openRawResource(R.raw.loadder);\n        Certificate ca = null;\n        try {\n            ca = cf.generateCertificate(caInput);\n            System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } finally {\n            caInput.close();\n        }\n\n        // Create a KeyStore containing our trusted CAs\n        String keyStoreType = KeyStore.getDefaultType();\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        keyStore.load(null, null);\n        if (ca == null)\n            return null;\n        keyStore.setCertificateEntry(\"ca\", ca);\n\n        // Create a TrustManager that trusts the CAs in our KeyStore\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n\n        // Create an SSLContext that uses our TrustManager\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(null, tmf.getTrustManagers(), null);\n\n        return context.getSocketFactory();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (KeyStoreException e) {\n        e.printStackTrace();\n    } catch (KeyManagementException e) {\n        e.printStackTrace();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "You can also run the following code:\ntry {\n         PackageInfo info = getPackageManager().getPackageInfo(\n                           \"yourpackagename\", \n                            PackageManager.GET_SIGNATURES);\n         for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                  }\n            } catch (NameNotFoundException e) {\n\n            } catch (NoSuchAlgorithmException e) {\n\n          }enter code here\n", "final MessageDigest mDigest = MessageDigest.getInstance(\"SHA-224\");\nbyte[] messageDigest = mDigest.digest(toEncrypt.getBytes());\nfinal BigInteger number = new BigInteger(1, messageDigest);\nfinal String sha = number.toString(16);\nfinal int diff = 32 - sha.length();\nfinal StringBuilder finalSHA = new StringBuilder(32);\nfor (int i=0;i&lt;diff;i++) {\n finalSHA.append(\"0\");\n}\nfinalSHA.append(sha);\nreturn finalSHA.toString();\n", "public String crypto(SecretKey key, String inString, boolean decrypt){\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    byte[] inputByte = inString.getBytes(\"UTF-8\");\n    if (decrypt){\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        return new String (cipher.doFinal(Base64.decode(inputByte, Base64.DEFAULT)));\n    } else {\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        return new String (Base64.encode(cipher.doFinal(inputByte), Base64.DEFAULT));\n    }\n}\n", "private static final X500Principal DEBUG_DN = new X500Principal(\"CN=Android Debug,O=Android,C=US\");\n/* ... */\nSignature raw = packageManager.getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES).signatures[0];\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\nX509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(raw.toByteArray()));\nboolean debug = cert.getSubjectX500Principal().equals(DEBUG_DN);\n", "public static PKCS10CertificationRequest generateCSRFile(KeyPair keyPair, KeyUsage keyUsage) throws IOException, OperatorCreationException {\n    String principal = \"CN=\" + Utils.getCertificateCommonName() + \", O=\" + Utils.getCertificateOrganization();\n    AsymmetricKeyParameter privateKey = PrivateKeyFactory.createKey(keyPair.getPrivate().getEncoded());\n    AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder().find(\"SHA1WITHRSA\");\n    AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(\"SHA-1\");\n    ContentSigner signer = new BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm).build(privateKey);\n\n    PKCS10CertificationRequestBuilder csrBuilder = new JcaPKCS10CertificationRequestBuilder(new X500Name(principal), keyPair.getPublic());\n    ExtensionsGenerator extensionsGenerator = new ExtensionsGenerator();\n    extensionsGenerator.addExtension(Extension.basicConstraints, true, new BasicConstraints(true));\n    extensionsGenerator.addExtension(Extension.keyUsage, true, keyUsage);\n    csrBuilder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensionsGenerator.generate());\n    PKCS10CertificationRequest csr = csrBuilder.build(signer);\n\n    return csr;\n}\n", "public static String getMd5OfFile(String filePath)\n{\n    String returnVal = \"\";\n    try \n    {\n        InputStream   input   = new FileInputStream(filePath); \n        byte[]        buffer  = new byte[1024];\n        MessageDigest md5Hash = MessageDigest.getInstance(\"MD5\");\n        int           numRead = 0;\n        while (numRead != -1)\n        {\n            numRead = input.read(buffer);\n            if (numRead &gt; 0)\n            {\n                md5Hash.update(buffer, 0, numRead);\n            }\n        }\n        input.close();\n\n        byte [] md5Bytes = md5Hash.digest();\n        for (int i=0; i &lt; md5Bytes.length; i++)\n        {\n            returnVal += Integer.toString( ( md5Bytes[i] &amp; 0xff ) + 0x100, 16).substring( 1 );\n        }\n    } \n    catch(Throwable t) {t.printStackTrace();}\n    return returnVal.toUpperCase();\n}\n", "   this.client = new WebSocketClient(new SslContextFactory(true){\n        @Override\n        public void customize(SSLEngine sslEngine) {\n            SSLParameters sslParams = sslEngine.getSSLParameters();\n            //sslParams.setEndpointIdentificationAlgorithm(_endpointIdentificationAlgorithm);\n            sslEngine.setSSLParameters(sslParams);\n\n            if (getWantClientAuth())\n                sslEngine.setWantClientAuth(getWantClientAuth());\n            if (getNeedClientAuth())\n                sslEngine.setNeedClientAuth(getNeedClientAuth());\n\n            sslEngine.setEnabledCipherSuites(selectCipherSuites(\n                    sslEngine.getEnabledCipherSuites(),\n                    sslEngine.getSupportedCipherSuites()));\n\n            sslEngine.setEnabledProtocols(selectProtocols(sslEngine.getEnabledProtocols(),sslEngine.getSupportedProtocols()));\n        }\n    });\n", "client.setHostnameVerifier(new HostnameVerifier() {\n            @Override\n            public boolean verify(String hostname, SSLSession session) {\n                //return true;\n                HostnameVerifier hv =\n                        HttpsURLConnection.getDefaultHostnameVerifier();\n                return hv.verify(\"ipage.com\", session);\n            }\n        });\n", "    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mTextView = (TextView) findViewById(R.id.textView);\n        mHandler = new Handler(Looper.getMainLooper());\n        OkHttpClient client = new OkHttpClient();\n        client.setHostnameVerifier(new HostnameVerifier() {\n            @Override\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n        Request request = new Request.Builder()\n                .url(\"https://justedhak.com/Files/users.php\")\n                .build();\n        client.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(Request request, IOException e) {\n                // do something...\n                Log.e(LOG_TAG, e.toString());\n            }\n\n            @Override\n            public void onResponse(Response response) throws IOException {\n                // do something...\n                Log.i(LOG_TAG, response.body().string());\n            }\n        });\n    }\n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(\"com.package.mypackage\",         PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);\n                Log.e(\"MY KEY HASH:\", sign);\n                Toast.makeText(getApplicationContext(),sign,         Toast.LENGTH_LONG).show();\n            }\n} catch (NameNotFoundException e) {\n} catch (NoSuchAlgorithmException e) {\n}\n", "try {\n        TrustManager[] victimizedManager = new TrustManager[]{\n\n                new X509TrustManager() {\n\n                    public X509Certificate[] getAcceptedIssuers() {\n\n                        X509Certificate[] myTrustedAnchors = new X509Certificate[0];\n\n                        return myTrustedAnchors;\n                    }\n\n                    @Override\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                    }\n\n                    @Override\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                    }\n                }\n        };\n\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, victimizedManager, new SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n            @Override\n            public boolean verify(String s, SSLSession sslSession) {\n                return true;\n            }\n        });\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n", "private void stripHeaders(){\n\n    public_key = public_key.replace(\"-----BEGIN PUBLIC KEY-----\", \"\");\n    public_key = public_key.replace(\"-----END PUBLIC KEY-----\", \"\");\n\n}\n\npublic byte[] encryptWithPublicKey(String encrypt) throws Exception {\n    byte[] message = encrypt.getBytes(\"UTF-8\");\n    stripHeaders(); \n    PublicKey apiPublicKey= getRSAPublicKeyFromString(); \n    Cipher rsaCipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\", \"SC\");\n    rsaCipher.init(Cipher.ENCRYPT_MODE, apiPublicKey); \n    return rsaCipher.doFinal(message);\n}\n\nprivate PublicKey getRSAPublicKeyFromString() throws Exception{\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\", \"SC\"); \n    byte[] publicKeyBytes = Base64.decode(public_key.getBytes(\"UTF-8\"), Base64.DEFAULT); \n    X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKeyBytes); \n    return keyFactory.generatePublic(x509KeySpec);\n}\n", "KeyPairGenerator keyGen = null;\nKeyPair kp = null;\n\nkeyGen = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\nECGenParameterSpec ecSpec = new ECGenParameterSpec(\"brainpoolp160r1\");\nkeyGen.initialize(ecSpec, new SecureRandom());\n\nkp = keyGen.generateKeyPair();\n", "static X509TrustManager tm = new X509TrustManager() {\n\n        public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n        return null;\n        }\n};\n\nMyConnectionManager(SchemeRegistry scheme){\n    super(scheme);\n}\n\npublic static MyConnectionManager getInstance() {\n    if (instance == null){\n\n        SSLContext ctx=null;\n        try {\n            ctx = SSLContext.getInstance(\"TLS\");\n            ctx.init(null, new TrustManager[]{tm}, null);\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (KeyManagementException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }                   \n        SchemeRegistry schemeRegistry = new SchemeRegistry();\n        schemeRegistry.register( new Scheme(\"http\", 80,PlainSocketFactory.getSocketFactory()));\n        schemeRegistry.register(new Scheme(\"https\", 443, SSLSocketFactory.getSocketFactory()));\n        instance = new MyConnectionManager(schemeRegistry);\n         // Increase max total connection to 200\n         instance.setMaxTotal(15);\n         // Increase default max connection per route to 20\n         instance.setDefaultMaxPerRoute(15);\n         // Increase max connections for localhost:80 to 50\n         HttpHost localhost = new HttpHost(\"picasaweb.google.com\", 443);\n         instance.setMaxForRoute(new HttpRoute(localhost), 10);\n    }\n    return instance;\n}\n", "public class DecryptUtils{\n    public static String AES ( byte [] cipherText, String encryptionKey ) \n        {\n            String decrypted = null;\n\n            try\n            {\n                Cipher cipher = Cipher.getInstance ( \"AES\");\n                SecretKeySpec key = new SecretKeySpec ( encryptionKey.getBytes ( \"UTF-8\" ), \"AES\" );\n                cipher.init ( Cipher.DECRYPT_MODE, key);\n                decrypted = new String ( cipher.doFinal ( cipherText ), \"UTF-8\" );a\n            }\n            catch ( Exception e )\n            {\n                e.printStackTrace()\n            }\n\n            return decrypted;\n        }\n}\n", "KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DH\");\nkeyGen.initialize(new DHParameterSpec(p, g, l));\nKeyPair ackp = keyGen.generateKeyPair();\n", "AlgorithmParameterGenerator paramGen = AlgorithmParameterGenerator.getInstance(\"DH\");\nparamGen.init(1024, new SecureRandom());\nAlgorithmParameters params = paramGen.generateParameters();\nDHParameterSpec dhSpec = (DHParameterSpec)params.getParameterSpec(DHParameterSpec.class);\nSystem.out.println(\"p: \" + dhSpec.getP() + \"\\ng: \" + dhSpec.getG() + \" \\nl: \" + dhSpec.getL());\n", "InputStream in = new FileInputStream(\"CERT.RSA\");\nCertificateFactory factory = CertificateFactory.getInstance(\"X.509\")\nX509Certificate cert = (X509Certificate) factory.generateCertificate(in);\n", "FileReader fileReader = new FileReader(\"/path/to/cert.pem\");\nPEMReader pemReader = new PEMReader(fileReader);\nObject obj = pemReader.readObject();\npemReader.close(); // sloppy IO handling, be thorough in production code\nX509CertificateObject certObj = (X509CertificateObject) obj;\nSystem.out.println(certObj.getPublicKey());\n", "Calendar calendarValidityStart = Calendar.getInstance();\n\nCalendar calendarValidityEnd = Calendar.getInstance();\ncalendarValidityEnd.add(Calendar.YEAR, 99);\n\nKeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context)\n        .setAlias(\"MyKeyAlias\")\n        .setSubject(new X500Principal(\"CN=\" + \"MyKeyAlias\"))\n        .setSerialNumber(BigInteger.valueOf(1337))\n        .setStartDate(calendarValidityStart.getTime())\n        .setEndDate(calendarValidityEnd.getTime())\n        .build();\n\nKeyPairGenerator kpGenerator = KeyPairGenerator.getInstance(\n        \"RSA\",\n        \"AndroidKeyStore\");\n\nkpGenerator.initialize(spec);\n\nKeyPair keyPair = kpGenerator.generateKeyPair();\n", "KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\nkeyStore.load(null);\nKeyStore.Entry keyStoreEntry = keyStore.getEntry(alias, null);\n", "String keyStoreType = KeyStore.getDefaultType();\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            keyStore.load(null, null);\n            keyStore.setCertificateEntry(\"ca\", ca);// my question shows how to get 'ca'\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(\n    TrustManagerFactory.getDefaultAlgorithm());\n// Initialise the TMF as you normally would, for example:\ntmf.init(ca); \n\nTrustManager[] trustManagers = tmf.getTrustManagers();\nfinal X509TrustManager origTrustmanager = (X509TrustManager)trustManagers[0];\n\nTrustManager[] wrappedTrustManagers = new TrustManager[]{\n   new X509TrustManager() {\n       public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n          return origTrustmanager.getAcceptedIssuers();\n       }\n\n       public void checkClientTrusted(X509Certificate[] certs, String authType) {\n           origTrustmanager.checkClientTrusted(certs, authType);\n       }\n\n       public void checkServerTrusted(X509Certificate[] certs, String authType) {\n           try {\n               origTrustmanager.checkServerTrusted(certs, authType);\n           } catch (CertificateExpiredException e) {}\n       }\n   }\n};\n\nSSLContext sc = SSLContext.getInstance(\"TLS\");\nsc.init(null, wrappedTrustManagers, null);\nHttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());  \n", "import java.nio.charset.Charset;\nimport java.security.AlgorithmParameters;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\n\n/*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will Google be held liable for any damages\n* arising from the use of this software.\n*\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, as long as the origin is not misrepresented.\n* \n* @author: Ricardo Champa\n* \n*/\n\npublic class MyCipher {\n\n    private final static String ALGORITHM = \"AES\";\n    private String mySecret;\n\n    public MyCipher(String mySecret){\n        this.mySecret = mySecret;\n    }\n\n    public MyCipherData encryptUTF8(String data){\n        try{\n            byte[] bytes = data.toString().getBytes(\"utf-8\");\n            byte[] bytesBase64 = Base64.encodeBase64(bytes);\n            return encrypt(bytesBase64);\n        }\n        catch(Exception e){\n            MyLogs.show(e.getMessage());\n            return null;\n        }\n\n    }\n\n    public String decryptUTF8(byte[] encryptedData, IvParameterSpec iv){\n        try {\n            byte[] decryptedData = decrypt(encryptedData, iv);\n            byte[] decodedBytes = Base64.decodeBase64(decryptedData);\n            String restored_data = new String(decodedBytes, Charset.forName(\"UTF8\"));\n            return restored_data;\n        } catch (Exception e) {\n            MyLogs.show(e.getMessage());;\n            return null;\n        }\n    }\n\n    //AES\n    private MyCipherData encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        //solved using PRNGFixes class\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] data = cipher.doFinal(clear);\n\n        AlgorithmParameters params = cipher.getParameters();\n        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n        return new MyCipherData(data, iv);\n    }\n\n    private byte[] decrypt(byte[] raw, byte[] encrypted, IvParameterSpec iv) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    private byte[] getKey() throws Exception{\n        byte[] keyStart = this.mySecret.getBytes(\"utf-8\");\n        KeyGenerator kgen = KeyGenerator.getInstance(ALGORITHM);\n\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n        //      if (android.os.Build.VERSION.SDK_INT &gt;= 17) {\n        //          sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n        //      } else {\n        //          sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        //      }\n        sr.setSeed(keyStart);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] key = skey.getEncoded();\n        return key;\n\n    }\n    ////////////////////////////////////////////////////////////\n    private MyCipherData encrypt(byte[] data) throws Exception{\n        return encrypt(getKey(),data);\n    }\n    private byte[] decrypt(byte[] encryptedData, IvParameterSpec iv) throws Exception{\n        return decrypt(getKey(),encryptedData, iv);\n    }\n}\n", "public static boolean verify(PublicKey publicKey, String signedData, String signature) {\n        Signature sig;\n        try {\n            sig = Signature.getInstance(SIGNATURE_ALGORITHM);\n            sig.initVerify(publicKey);\n            sig.update(signedData.getBytes());\n            if (!sig.verify(Base64.decode(signature))) {\n                Log.e(TAG, \"Signature verification failed.\");\n                return false;\n            }\n            return true;\n        } catch (...) {\n            ...\n        }\n        return false;\n    }\n", "public static boolean verify(PublicKey publicKey, String signedData, String signature) {\n        Signature sig;\n        try {\n            sig = Signature.getInstance(SIGNATURE_ALGORITHM);\n            sig.initVerify(publicKey);\n            sig.update(signedData.getBytes());\n            Method verify = java.security.SignatureSpi.class.getDeclaredMethod(\"engineVerify\", byte[].class);\n            verify.setAccessible(true);\n            Object returnValue = verify.invoke(sig, Base64.decode(signature));\n            if (!(Boolean)returnValue) {\n                Log.e(TAG, \"Signature verification failed.\");\n                return false;\n            }\n            return true;\n        } catch (...) {\n            ...\n        }\n        return false;\n    }\n", "  String serverAddress = \"https://auth.timeface.cn/aliyun/sts\";\n    OkHttpClient httpClient = new OkHttpClient();\n\n    if (serverAddress.contains(\"https\")) {\n        ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)\n                .tlsVersions(TlsVersion.TLS_1_0)\n                .cipherSuites(CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA)\n                .supportsTlsExtensions(true)\n                .build();\n\n        httpClient.setConnectionSpecs(Collections.singletonList(spec));\n        httpClient.setHostnameVerifier(new HostnameVerifier() {\n            @Override\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n        httpClient.setConnectTimeout(1, TimeUnit.HOURS);\n    }\n\n Request request = new Request.Builder()\n        .url(serverAddress)\n        .build();\n\n    httpClient.newCall(request).enqueue(new Callback() {\n      @Override public void onFailure(Request request, Throwable throwable) {\n        throwable.printStackTrace();\n      }\n\n      @Override public void onResponse(Response response) throws IOException {\n        if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n        String responseStr = response.body().string();\n      }\n    });\n", " final protected static char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n\n public byte[] md5x16(String text) {\n    try {\n        MessageDigest digester = MessageDigest.getInstance(\"MD5\");\n        digester.update(text.getBytes());\n        byte[] md5Bytes = digester.digest();\n        String md5Text = new String(md5Bytes); // if you need in String format (PS better use byte[])\n        return md5Bytes;\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "public static String md5(String text) {\n    try {\n        MessageDigest digester = MessageDigest.getInstance(\"MD5\");\n        digester.update(text.getBytes());\n        byte[] md5Bytes = digester.digest();\n        String md5Text = null;\n\n        md5Text = bytesToHex(md5Bytes);\n\n        return md5Text;\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n\npublic static String bytesToHex(byte[] bytes) {\n    char[] hexChars = new char[bytes.length * 2];\n    for (int j = 0; j &lt; bytes.length; j++) {\n        int v = bytes[j] &amp; 0xFF;\n        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];\n        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];\n    }\n    return new String(hexChars);\n}\n", "public static List&lt;Cookie&gt; cookies;\npublic DefaultHttpClient getHttpclient() {\n        if (!isHTTPSEnabled()) {\n            HttpParams httpParameters = new BasicHttpParams();\n            HttpConnectionParams.setConnectionTimeout(httpParameters, timeOut);\n            HttpConnectionParams.setSoTimeout(httpParameters, timeOut);\n            DefaultHttpClient httpclient = new DefaultHttpClient(httpParameters);\n            HttpClientParams.setRedirecting(httpclient.getParams(), false);\n\n            if (cookies != null) {\n                int size = cookies.size();\n                for (int i = 0; i &lt; size; i++) {\n                    httpclient.getCookieStore().addCookie(cookies.get(i));\n                }\n            }\n            httpclient.getParams().setParameter(CoreProtocolPNames.USER_AGENT, \"android\");\n            return httpclient;\n        } else {\n            try {\n                KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                trustStore.load(null, null);\n\n                SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n                sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n                HttpParams httpParameters = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(httpParameters, timeOut);\n                HttpConnectionParams.setSoTimeout(httpParameters, timeOut);\n                HttpProtocolParams.setVersion(httpParameters, HttpVersion.HTTP_1_1);\n                HttpProtocolParams.setContentCharset(httpParameters, HTTP.UTF_8);\n\n                SchemeRegistry registry = new SchemeRegistry();\n                registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n                registry.register(new Scheme(\"https\", sf, 443));\n\n                ClientConnectionManager ccm = new ThreadSafeClientConnManager(httpParameters, registry);\n                DefaultHttpClient httpclient = new DefaultHttpClient(ccm, httpParameters);\n                HttpClientParams.setRedirecting(httpclient.getParams(), false);\n\n                if (cookies != null) {\n                    int size = cookies.size();\n                    for (int i = 0; i &lt; size; i++) {\n                        httpclient.getCookieStore().addCookie(cookies.get(i));\n                    }\n                }\n                httpclient.getParams().setParameter(CoreProtocolPNames.USER_AGENT, \"android\");\n                return httpclient;\n\n            } catch (Exception e) {\n            }\n        }\n        return null;\n\n    }\n", " private static OkHttpClient getUnsafeOkHttpClient() {\n\n    // Create a trust manager that does not validate certificate chains\n    final TrustManager[] trustAllCerts = new TrustManager[]{\n            new X509TrustManager() {\n                @Override\n                public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                @Override\n                public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                @Override\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return new X509Certificate[0];\n                }\n            }\n    };\n\n    // Install the all-trusting trust manager\n    SSLContext sslContext = null;\n    try {\n        sslContext = SSLContext.getInstance(\"SSL\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    try {\n        sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n    } catch (KeyManagementException e) {\n        e.printStackTrace();\n    }\n    // Create an ssl socket factory with our all-trusting manager\n    final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n\n    OkHttpClient client = new OkHttpClient();\n\n    OkHttpClient.Builder builder = client.newBuilder();\n    builder.sslSocketFactory(sslSocketFactory);\n    builder.hostnameVerifier(new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n\n\n        }\n    });\n\n    return builder.build();\n\n}\n", "private static String hmacSha1(String value, String key)\n            throws UnsupportedEncodingException, NoSuchAlgorithmException,\n            InvalidKeyException {\n        String type = \"HmacSHA1\";\n        SecretKeySpec secret = new SecretKeySpec(key.getBytes(), type);\n        Mac mac = Mac.getInstance(type);\n        mac.init(secret);\n        byte[] bytes = mac.doFinal(value.getBytes());\n        return bytesToHex(bytes);\n    }\n\n    private final static char[] hexArray = \"0123456789abcdef\".toCharArray();\n\n    private static String bytesToHex(byte[] bytes) {\n        char[] hexChars = new char[bytes.length * 2];\n        int v;\n        for (int j = 0; j &lt; bytes.length; j++) {\n            v = bytes[j] &amp; 0xFF;\n            hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];\n            hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];\n        }\n        return new String(hexChars);\n    }\n", "SSLSocketFactory sf = new SSLSocketFactory(\nSSLContext.getInstance(\"TLS\"),\nSSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\nScheme sch = new Scheme(\"https\", 443, sf);\nhttpclient.getConnectionManager().getSchemeRegistry().register(sch);\n\nHttpGet httpget = new HttpGet(\"https://host/\");\n", "    private void disableSSLCertCheck() throws NoSuchAlgorithmException, KeyManagementException {\n    // Create a trust manager that does not validate certificate chains\n    TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {\n            }\n        }\n    };\n\n    // Install the all-trusting trust manager\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new java.security.SecureRandom());\n    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n    // Create all-trusting host name verifier\n    HostnameVerifier allHostsValid = new HostnameVerifier() {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    // Install the all-trusting host verifier\n    HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);\n    }\n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    \"com.facebook.scrumptious\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"YOURHASH KEY:\",\n                        Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n\nthanks.\n", "    try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"Your.Packet...\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "DESKeySpec keySpec = new DESKeySpec(\"Your secret Key phrase\".getBytes(\"UTF8\"));\nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\nSecretKey key = keyFactory.generateSecret(keySpec);\nsun.misc.BASE64Encoder base64encoder = new BASE64Encoder();\nsun.misc.BASE64Decoder base64decoder = new BASE64Decoder();\n.........\n\n// ENCODE plainTextPassword String\nbyte[] cleartext = plainTextPassword.getBytes(\"UTF8\");      \n\nCipher cipher = Cipher.getInstance(\"DES\"); // cipher is not thread safe\ncipher.init(Cipher.ENCRYPT_MODE, key);\nString encryptedPwd = base64encoder.encode(cipher.doFinal(cleartext));\n// now you can store it \n......\n\n// DECODE encryptedPwd String\nbyte[] encrypedPwdBytes = base64decoder.decodeBuffer(encryptedPwd);\n\nCipher cipher = Cipher.getInstance(\"DES\");// cipher is not thread safe\ncipher.init(Cipher.DECRYPT_MODE, key);\nbyte[] plainTextPwdBytes = (cipher.doFinal(encrypedPwdBytes));\n", "public static String calculateMD5(File updateFile) {\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(\"calculateMD5\", \"Exception while getting Digest\", e);\n            return null;\n        }\n\n        InputStream is;\n        try {\n            is = new FileInputStream(updateFile);\n        } catch (FileNotFoundException e) {\n            Log.e(\"calculateMD5\", \"Exception while getting FileInputStream\", e);\n            return null;\n        }\n\n        byte[] buffer = new byte[8192];\n        int read;\n        try {\n            while ((read = is.read(buffer)) &gt; 0) {\n                digest.update(buffer, 0, read);\n            }\n            byte[] md5sum = digest.digest();\n            BigInteger bigInt = new BigInteger(1, md5sum);\n            String output = bigInt.toString(16);\n            // Fill to 32 chars\n            output = String.format(\"%32s\", output).replace(' ', '0');\n            return output;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unable to process file for MD5\", e);\n        } finally {\n            try {\n                is.close();\n            } catch (IOException e) {\n                Log.e(\"calculateMD5\", \"Exception on closing MD5 input stream\", e);\n            }\n        }\n    }   \n", "public class MySocketFactory implements SocketFactory, LayeredSocketFactory {\nprivate SSLContext mSslContext = null;\n\n{\n    try {\n        mSslContext = SSLContext.getInstance(\"TLS\");\n\n        TrustManager trustManager = new X509TrustManager() {\n\n            @Override\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType)\n                    throws CertificateException {\n                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n                // NOTE : This is where we can calculate the certificate's fingerprint,\n                // show it to the user and throw an exception in case he doesn't like it\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType)\n                    throws CertificateException {\n            }\n        };\n\n        mSslContext.init(null, new TrustManager[]{ trustManager }, new SecureRandom());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n@Override\npublic Socket connectSocket(Socket socket, String host, int port,\n        InetAddress localAddress, int localPort, HttpParams params)\n                throws IOException, UnknownHostException, ConnectTimeoutException {\n\n    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n    int soTimeout = HttpConnectionParams.getSoTimeout(params);\n\n    SocketAddress socketAddress = new InetSocketAddress(localAddress, localPort);\n    socket.bind(socketAddress);\n    socket.connect(new InetSocketAddress(host, port), connTimeout);\n    socket.setSoTimeout(soTimeout);\n\n    return socket;\n}\n\n@Override\npublic Socket createSocket() throws IOException {\n    return mSslContext.getSocketFactory().createSocket();\n}\n\n@Override\npublic boolean isSecure(Socket sock) throws IllegalArgumentException {\n    return true;\n}\n\n\n\n@Override\npublic Socket createSocket(Socket socket, String host, int port,\n        boolean autoClose) throws IOException, UnknownHostException {\n\n    return mSslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n}\n", "/**\n * Gets a 1-way hashed value of the device's unique ID. This value is\n * encoded using a SHA-256 one way hash and cannot be used to determine what\n * device this data came from.\n * \n * @param appContext\n *            The context used to access the settings resolver\n * @return An 1-way hashed identifier unique to this device or null if an\n *         ID, or the hashing algorithm is not available.\n */\npublic static String getGlobalDeviceId(final Context appContext) {\n    String systemId = System.getString(appContext.getContentResolver(),\n            System.ANDROID_ID);\n    if (systemId == null) {\n        return null;\n    }\n\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] digest = md.digest(systemId.getBytes());\n        BigInteger hashedNumber = new BigInteger(1, digest);\n        return new String(hashedNumber.toString(16));\n\n    } catch (NoSuchAlgorithmException e) {\n        return null;\n    }\n}\n", "void saveCredentials(String username, String password) {\n /* create some random salt bytes - the value doesn't need to be secret (which is\n  why we can save it) but it must be unpredictable and unique per-user */\n SecureRandom sr = new SecureRandom();\n byte[] salt = new byte[16];\n sr.nextBytes(salt);\n\n  // hash the (salt + password)\n  // hashing algorithms vary, but for now, SHA256 is a reasonable choice\n  try {\n     MessageDigest hasher = MessageDigest.getInstance(\"SHA-256\");\n     hasher.update(salt);\n     hasher.update(password.getBytes(\"UTF-8\"));\n     byte[] hashedbytes = hasher.digest();\n\n     // we can now save the salt and the hashed bytes to a file,\n     //  SharedPreference or any other storage location\n     savedata(username, salt, hashedbytes);\n\n  } catch (Exception e) {\n     // do something sensible on errors\n  }\n\n}\n", "boolean checkPassword(String username, String password) {\n  // read the info for the user that we saved in storage\n  byte[] salt = readdata(username, \"salt\");\n  byte[] correcthash = readdata(username, \"pwdhash\");\n\n  // hash the password we are checking in the same way that we did\n  // for the original password\n  try {\n     MessageDigest hasher = MessageDigest.getInstance(\"SHA-256\");\n     hasher.update(salt);\n     hasher.update(password.getBytes(\"UTF-8\"));\n     byte[] testhash = hasher.digest();\n\n     // if the password is correct, the two hashed values will match\n     // - if it's wrong, the hashed values will have one or more\n     // bytes that do not match\n     for (int i=0; i &lt; testhash.length; i++) {\n         if (testhash[i] != correcthash[i])\n             return false;  // mismatch - wrong password\n     }\n\n     // if we reach here, all the hash bytes match, so the password\n     // matches the original\n     return true;\n\n  } catch (Exception e) {\n     // do something sensible on errors\n  }\n\n  return false;\n}\n", "public ServiceConnectionSE(Certificate ca, String url) throws IOException\n{\n\n    // Create a KeyStore containing our trusted CAs\n    String keyStoreType = KeyStore.getDefaultType();\n    KeyStore keyStore;\n    SSLContext context = null;\n    try {\n        keyStore = KeyStore.getInstance(keyStoreType);\n        keyStore.load(null, null);\n        keyStore.setCertificateEntry(\"ca\", ca);\n        // Create a TrustManager that trusts the CAs in our KeyStore\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n\n        // Create an SSLContext that uses our TrustManager\n        context = SSLContext.getInstance(\"TLS\");\n        context.init(null, tmf.getTrustManagers(), null);\n\n\n    } catch (KeyStoreException | NoSuchAlgorithmException | CertificateException | KeyManagementException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n\n\n    // Tell the URLConnection to use a SocketFactory from our SSLContext\n\n\n    connection = (HttpsURLConnection) new URL(url).openConnection();\n    connection.setSSLSocketFactory(context.getSocketFactory());\n\n    connection.setUseCaches(false);\n    connection.setDoOutput(true);\n    connection.setDoInput(true);\n}\n", "CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\nAssetManager assetManager = getAssets();\nInputStream caInput = new BufferedInputStream(assetManager.open(\"your_cert.cer\"));\nCertificate ca = cf.generateCertificate(caInput);\n\nAndroidHttpTransport androidHttpTransport = new AndroidHttpTransport(ca, url);\n", "        PackageInfo packageInfo;\n        String key = null;\n        try {\n            //getting application package name, as defined in manifest\n            String packageName = context.getApplicationContext().getPackageName();\n\n            //Retriving package info\n            packageInfo = context.getPackageManager().getPackageInfo(packageName,\n                    PackageManager.GET_SIGNATURES);\n\n            MyLog.e(\"Package Name=\", context.getApplicationContext().getPackageName());\n\n            for (Signature signature : packageInfo.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                key = new String(Base64.encode(md.digest(), 0));\n\n                // String key = new String(Base64.encodeBytes(md.digest()));\n                MyLog.e(\"Key Hash=\", key);\n            }\n        } catch (NameNotFoundException e1) {\n            MyLog.e(\"Name not found\", e1.toString());\n        }\n        catch (NoSuchAlgorithmException e) {\n            MyLog.e(\"No such an algorithm\", e.toString());\n        } catch (Exception e) {\n            MyLog.e(\"Exception\", e.toString());\n        }\n", "FTPSClient ftpClient = new FTPSClient(\"TLS\", false);\ntry {\n    TrustManager[] trustManager = new TrustManager[] { new X509TrustManager() {\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        @Override\n        public void checkClientTrusted(X509Certificate[] certs, String authType) {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] certs, String authType) {\n        }\n    } };\n\n    ftpClient.setTrustManager(trustManager[0]);\n    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n    kmf.init(null, null);\n    KeyManager km = kmf.getKeyManagers()[0];\n    ftpClient.setKeyManager(km);\n    ftpClient.setBufferSize(1024 * 1024);\n    ftpClient.setConnectTimeout(100000);\n    ftpClient.connect(InetAddress.getByName(\"ipaddress\"), 990);\n    ftpClient.setSoTimeout(100000);\n\n    if (ftpClient.login(\"user\", \"password\")) {\n        ftpClient.execPBSZ(0);\n        ftpClient.execPROT(\"P\");\n        ftpClient.changeWorkingDirectory(\"/\");\n        // 250 = directory succesfully changed\n        if (ftpClient.getReplyString().contains(\"250\")) {\n            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);\n            ftpClient.enterLocalPassiveMode();\n            BufferedInputStream buffIn = null;\n\n            for (File picture : pictures) {\n                buffIn = new BufferedInputStream(new FileInputStream(picture.getAbsolutePath()));\n                boolean result = ftpClient.storeFile(picture.getName(), buffIn);\n                try {\n                    buffIn.close();\n                } catch (Exception e) {\n                }\n                if (result)\n                    picture.delete();\n            }\n        }\n    }\n\n} catch (SocketException e) {\n    Log.e(\"APPTAG\", e.getStackTrace().toString());\n} catch (UnknownHostException e) {\n    Log.e(\"APPTAG\", e.getStackTrace().toString());\n} catch (IOException e) {\n    Log.e(\"APPTAG\", e.getStackTrace().toString());\n} catch (Exception e) {\n    Log.e(\"APPTAG\", e.getStackTrace().toString());\n} finally {\n    try {\n        ftpClient.logout();\n    } catch (Exception e2) {\n    }\n    try {\n        ftpClient.disconnect();\n    } catch (Exception e2) {\n    }\n}\n", "public class MainClass {\n  public static void main(String[] args) {\n    String host = args[0];\n    int port = Integer.parseInt(args[1]);\n\n    try {\n      System.out.println(\"Locating socket factory for SSL...\");\n      SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n\n      System.out.println(\"Creating secure socket to \" + host + \":\" + port);\n      SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n\n      System.out.println(\"Enabling all available cipher suites...\");\n      String[] suites = socket.getSupportedCipherSuites();\n      socket.setEnabledCipherSuites(suites);\n\n      System.out.println(\"Registering a handshake listener...\");\n      socket.addHandshakeCompletedListener(new MyHandshakeListener());\n\n      System.out.println(\"Starting handshaking...\");\n      socket.startHandshake();\n\n      System.out.println(\"Just connected to \" + socket.getRemoteSocketAddress());\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\nclass MyHandshakeListener implements HandshakeCompletedListener {\n  public void handshakeCompleted(HandshakeCompletedEvent e) {\n    System.out.println(\"Handshake succesful!\");\n    System.out.println(\"Using cipher suite: \" + e.getCipherSuite());\n  }\n}\n", "private boolean ValidateHTTPSCertificate()\n    {\n        boolean result = false;\n        String serverCertPublicSerial = \"abcdefghijklmnopqrstuvwxyz\";\n\n        try\n        {\n            URL url = new URL( \"https://your-url-goes-here\" );\n            HttpsURLConnection con = (HttpsURLConnection) url.openConnection();\n\n            if(con!=null){\n\n                try {\n                    con.connect();\n\n                    int respCode =  con.getResponseCode();\n                    String pageResult = convertInputStreamToString(con.getInputStream());\n\n                    Certificate[] certs = con.getServerCertificates();\n                    for(Certificate cert : certs){\n\n                        X509Certificate x509cert = (X509Certificate)cert;\n\n                        BigInteger serialNum = x509cert.getSerialNumber();\n\n                        String name = x509cert.getIssuerDN().getName();\n                        String publicKeySerial = serialNum.toString(16);\n\n                        if (publicKeySerial.toLowerCase().equals(serverCertPublicSerial.toLowerCase()) == true )\n                        {\n                            result = true;\n                            break;\n                        }\n                    }\n                    //con.disconnect();\n                } catch (SSLPeerUnverifiedException e) {\n                    e.printStackTrace();\n                } catch (IOException e){\n                    e.printStackTrace();\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            String  msg = ex.getMessage();\n        }\n\n        return result;\n    }\n", "public class AudioWorker extends Thread\n{ \n    private boolean stopped = false;\n\n    private String host;\n    private int port;\n    private long id=0;\n    boolean run=true;\n    AudioRecord recorder;\n\n    //ulaw encoder stuff\n    private final static String TAG = \"UlawEncoderInputStream\";\n\n    private final static int MAX_ULAW = 8192;\n    private final static int SCALE_BITS = 16;\n\n    private InputStream mIn;\n\n    private int mMax = 0;\n\n    private final byte[] mBuf = new byte[1024];\n    private int mBufCount = 0; // should be 0 or 1\n\n    private final byte[] mOneByte = new byte[1];\n    ////\n    /**\n     * Give the thread high priority so that it's not canceled unexpectedly, and start it\n     */\n    public AudioWorker(String host, int port, long id)\n    { \n        this.host = host;\n        this.port = port;\n        this.id = id;\n        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_AUDIO);\n//        start();\n    }\n\n    @Override\n    public void run()\n    { \n        Log.i(\"AudioWorker\", \"Running AudioWorker Thread\");\n        recorder = null;\n        AudioTrack track = null;\n        short[][]   buffers  = new short[256][160];\n        int ix = 0;\n\n        /*\n         * Initialize buffer to hold continuously recorded AudioWorker data, start recording, and start\n         * playback.\n         */\n        try\n        {\n            int N = AudioRecord.getMinBufferSize(8000,AudioFormat.CHANNEL_IN_MONO,AudioFormat.ENCODING_PCM_16BIT);\n            recorder = new AudioRecord(AudioSource.MIC, 8000, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, N*10);\n            track = new AudioTrack(AudioManager.STREAM_MUSIC, 8000, \n                    AudioFormat.CHANNEL_OUT_MONO, AudioFormat.ENCODING_PCM_16BIT, N*10, AudioTrack.MODE_STREAM);\n            recorder.startRecording();\n            track.play();\n            /*\n             * Loops until something outside of this thread stops it.\n             * Reads the data from the recorder and writes it to the AudioWorker track for playback.\n             */\n\n\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            SSLSocketFactory sslFact = sc.getSocketFactory();\n            SSLSocket socket = (SSLSocket)sslFact.createSocket(host, port);\n\n            socket.setSoTimeout(10000);\n            InputStream inputStream = socket.getInputStream();\n            DataInputStream in = new DataInputStream(new BufferedInputStream(inputStream));\n            OutputStream outputStream = socket.getOutputStream();\n            DataOutputStream os = new DataOutputStream(new BufferedOutputStream(outputStream));\n            PrintWriter socketPrinter = new PrintWriter(os);\n            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n\n//          socketPrinter.println(\"POST /transmitaudio?patient=1333369798370 HTTP/1.0\");\n            socketPrinter.println(\"POST /transmitaudio?id=\"+id+\" HTTP/1.0\");\n            socketPrinter.println(\"Content-Type: AudioWorker/basic\");\n            socketPrinter.println(\"Content-Length: 99999\");\n            socketPrinter.println(\"Connection: Keep-Alive\");\n            socketPrinter.println(\"Cache-Control: no-cache\");\n            socketPrinter.println();\n            socketPrinter.flush();\n\n\n            while(!stopped)\n            { \n                Log.i(\"Map\", \"Writing new data to buffer\");\n                short[] buffer = buffers[ix++ % buffers.length];\n\n                N = recorder.read(buffer,0,buffer.length);\n                track.write(buffer, 0, buffer.length);\n\n                byte[] bytes2 = new byte[buffer.length * 2];\n                ByteBuffer.wrap(bytes2).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer().put(buffer);\n\n                read(bytes2, 0, bytes2.length);\n//              os.write(bytes2,0,bytes2.length);\n                os.write(bytes2,0,bytes2.length);\n\n                System.out.println(\"bytesRead \"+buffer.length);\n                System.out.println(\"data \"+Arrays.toString(buffer));\n            }\n            os.close();\n        }\n        catch(Throwable x)\n        { \n            Log.w(\"AudioWorker\", \"Error reading voice AudioWorker\", x);\n        }\n        /*\n         * Frees the thread's resources after the loop completes so that it can be run again\n         */\n        finally\n        { \n            recorder.stop();\n            recorder.release();\n            track.stop();\n            track.release();\n        }\n    }\n\n    /**\n     * Called from outside of the thread in order to stop the recording/playback loop\n     */\n\n/**\n * Called from outside of the thread in order to stop the recording/playback loop\n */\npublic void close()\n{ \n     stopped = true;\n}\npublic void resumeThread()\n{ \n     stopped = false;\n     run();\n}\n\n    TrustManager[] trustAllCerts = new TrustManager[]{\n            new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n                public void checkClientTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) {\n                }\n                public void checkServerTrusted(\n                        java.security.cert.X509Certificate[] chain, String authType) {\n                    for (int j=0; j&lt;chain.length; j++)\n                    {\n                        System.out.println(\"Client certificate information:\");\n                        System.out.println(\"  Subject DN: \" + chain[j].getSubjectDN());\n                        System.out.println(\"  Issuer DN: \" + chain[j].getIssuerDN());\n                        System.out.println(\"  Serial number: \" + chain[j].getSerialNumber());\n                        System.out.println(\"\");\n                    }\n                }\n            }\n    };\n\n\n    public static void encode(byte[] pcmBuf, int pcmOffset,\n            byte[] ulawBuf, int ulawOffset, int length, int max) {\n\n        // from  'ulaw' in wikipedia\n        // +8191 to +8159                          0x80\n        // +8158 to +4063 in 16 intervals of 256   0x80 + interval number\n        // +4062 to +2015 in 16 intervals of 128   0x90 + interval number\n        // +2014 to  +991 in 16 intervals of  64   0xA0 + interval number\n        //  +990 to  +479 in 16 intervals of  32   0xB0 + interval number\n        //  +478 to  +223 in 16 intervals of  16   0xC0 + interval number\n        //  +222 to   +95 in 16 intervals of   8   0xD0 + interval number\n        //   +94 to   +31 in 16 intervals of   4   0xE0 + interval number\n        //   +30 to    +1 in 15 intervals of   2   0xF0 + interval number\n        //     0                                   0xFF\n\n        //    -1                                   0x7F\n        //   -31 to    -2 in 15 intervals of   2   0x70 + interval number\n        //   -95 to   -32 in 16 intervals of   4   0x60 + interval number\n        //  -223 to   -96 in 16 intervals of   8   0x50 + interval number\n        //  -479 to  -224 in 16 intervals of  16   0x40 + interval number\n        //  -991 to  -480 in 16 intervals of  32   0x30 + interval number\n        // -2015 to  -992 in 16 intervals of  64   0x20 + interval number\n        // -4063 to -2016 in 16 intervals of 128   0x10 + interval number\n        // -8159 to -4064 in 16 intervals of 256   0x00 + interval number\n        // -8192 to -8160                          0x00\n\n        // set scale factors\n        if (max &lt;= 0) max = MAX_ULAW;\n\n        int coef = MAX_ULAW * (1 &lt;&lt; SCALE_BITS) / max;\n\n        for (int i = 0; i &lt; length; i++) {\n            int pcm = (0xff &amp; pcmBuf[pcmOffset++]) + (pcmBuf[pcmOffset++] &lt;&lt; 8);\n            pcm = (pcm * coef) &gt;&gt; SCALE_BITS;\n\n            int ulaw;\n            if (pcm &gt;= 0) {\n                ulaw = pcm &lt;= 0 ? 0xff :\n                        pcm &lt;=   30 ? 0xf0 + ((  30 - pcm) &gt;&gt; 1) :\n                        pcm &lt;=   94 ? 0xe0 + ((  94 - pcm) &gt;&gt; 2) :\n                        pcm &lt;=  222 ? 0xd0 + (( 222 - pcm) &gt;&gt; 3) :\n                        pcm &lt;=  478 ? 0xc0 + (( 478 - pcm) &gt;&gt; 4) :\n                        pcm &lt;=  990 ? 0xb0 + (( 990 - pcm) &gt;&gt; 5) :\n                        pcm &lt;= 2014 ? 0xa0 + ((2014 - pcm) &gt;&gt; 6) :\n                        pcm &lt;= 4062 ? 0x90 + ((4062 - pcm) &gt;&gt; 7) :\n                        pcm &lt;= 8158 ? 0x80 + ((8158 - pcm) &gt;&gt; 8) :\n                        0x80;\n            } else {\n                ulaw = -1 &lt;= pcm ? 0x7f :\n                          -31 &lt;= pcm ? 0x70 + ((pcm -   -31) &gt;&gt; 1) :\n                          -95 &lt;= pcm ? 0x60 + ((pcm -   -95) &gt;&gt; 2) :\n                         -223 &lt;= pcm ? 0x50 + ((pcm -  -223) &gt;&gt; 3) :\n                         -479 &lt;= pcm ? 0x40 + ((pcm -  -479) &gt;&gt; 4) :\n                         -991 &lt;= pcm ? 0x30 + ((pcm -  -991) &gt;&gt; 5) :\n                        -2015 &lt;= pcm ? 0x20 + ((pcm - -2015) &gt;&gt; 6) :\n                        -4063 &lt;= pcm ? 0x10 + ((pcm - -4063) &gt;&gt; 7) :\n                        -8159 &lt;= pcm ? 0x00 + ((pcm - -8159) &gt;&gt; 8) :\n                        0x00;\n            }\n            ulawBuf[ulawOffset++] = (byte)ulaw;\n        }\n    }\n    public static int maxAbsPcm(byte[] pcmBuf, int offset, int length) {\n        int max = 0;\n        for (int i = 0; i &lt; length; i++) {\n            int pcm = (0xff &amp; pcmBuf[offset++]) + (pcmBuf[offset++] &lt;&lt; 8);\n            if (pcm &lt; 0) pcm = -pcm;\n            if (pcm &gt; max) max = pcm;\n        }\n        return max;\n    }\n\n    public int read(byte[] buf, int offset, int length) throws IOException {\n        if (recorder == null) throw new IllegalStateException(\"not open\");\n\n        // return at least one byte, but try to fill 'length'\n        while (mBufCount &lt; 2) {\n            int n = recorder.read(mBuf, mBufCount, Math.min(length * 2, mBuf.length - mBufCount));\n            if (n == -1) return -1;\n            mBufCount += n;\n        }\n\n        // compand data\n        int n = Math.min(mBufCount / 2, length);\n        encode(mBuf, 0, buf, offset, n, mMax);\n\n        // move data to bottom of mBuf\n        mBufCount -= n * 2;\n        for (int i = 0; i &lt; mBufCount; i++) mBuf[i] = mBuf[i + n * 2];\n\n        return n;\n    }\n\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.example.packagename\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n  e.printStackTrace();\n\n} catch (NoSuchAlgorithmException e) {\n    e.printStackTrace();\n}\n", "public HttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        MySSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\n\nimport javax.crypto.Cipher;\n\nimport android.util.Log;\n\n/**\n * Generates Sha1withRSA XML signatures.\n */\npublic final class XmlSigner {\n\n  /** Log tag. */\n  private static final String LOG_TAG = \"XmlSigner\";\n\n  /**\n   * DER encoded ASN.1 identifier for SHA1 digest: \"1.3.14.3.2.26\".\n   */\n  private static final byte[] DER_SHA1_DIGEST_IDENTIFIER = new byte[]{48, 33, 48, 9, 6, 5, 43, 14,\n      3, 2, 26, 5, 0, 4, 20};\n\n  /** The characters needed for base 64 encoding. */\n  private static final char[] CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\n\n  /**\n   * Hide constructor.\n   */\n  private XmlSigner() {\n\n  }\n\n  /**\n   * Generates Sha1withRSA XML signature for the specified XML content and\n   * private key.\n   * \n   * @param xml the XML content\n   * @param privateKey the private key to generate the signature\n   * @return the whole signature node XML string that should be inserted\n   * somewhere in the XML\n   * @throws XmlSignerException if the signature XML can not be generated\n   */\n  public static String generateXmlSignature(String xml, PrivateKey privateKey) throws Throwable {\n\n    try {\n      // get canonized XML\n      int soapBodyStart = xml.indexOf(\"&lt;soap:Body&gt;\");\n      int soapBodyEnd = xml.indexOf(\"&lt;/soap:Body&gt;\");\n      String bodyXml = xml.substring(soapBodyStart + 12, soapBodyEnd - 1);\n\n      // get bytes from the XML\n      byte[] xmlBytes = bodyXml.getBytes(\"UTF-8\");\n\n      // calculate SHA256 digest from the XML bytes\n      byte[] xmlDigestBytes = sha1Digest(xmlBytes);\n\n      // encode the XML digest to base64 string\n      String base64XmlDigest = base64encode(xmlDigestBytes, false);\n\n      // generate SignedInfo node to be signed with signature\n      String signedInfo = \"&lt;ds:SignedInfo xmlns:ds=\\\"http://www.w3.org/2000/09/xmldsig#\\\"&gt;\"\n          + \"&lt;ds:CanonicalizationMethod Algorithm=\\\"http://www.w3.org/2001/10/xml-exc-c14n#\\\"&gt;\"\n          + \"&lt;/ds:CanonicalizationMethod&gt;&lt;ds:SignatureMethod Algorithm=\\\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\\\"&gt;\"\n          + \"&lt;/ds:SignatureMethod&gt;&lt;ds:Reference URI=\\\"\\\"&gt;&lt;ds:Transforms&gt;\"\n          + \"&lt;ds:Transform Algorithm=\\\"http://www.w3.org/2002/06/xmldsig-filter2\\\"&gt;\"\n          + \"&lt;ds:XPath xmlns:ds=\\\"http://www.w3.org/2002/06/xmldsig-filter2\\\" Filter=\\\"intersect\\\"&gt;\"\n          + \"/soap:Envelope/soap:Body/*&lt;/ds:XPath&gt;&lt;/ds:Transform&gt;\"\n          + \"&lt;ds:Transform xmlns:ds=\\\"http://www.w3.org/2002/06/xmldsig-filter2\\\" \"\n          + \"Algorithm=\\\"http://www.w3.org/2001/10/xml-exc-c14n#\\\"&gt;&lt;/ds:Transform&gt;\"\n          + \"&lt;/ds:Transforms&gt;&lt;ds:DigestMethod Algorithm=\\\"http://www.w3.org/2000/09/xmldsig#sha1\\\"&gt;\"\n          + \"&lt;/ds:DigestMethod&gt;&lt;ds:DigestValue&gt;\" + base64XmlDigest\n          + \"&lt;/ds:DigestValue&gt;&lt;/ds:Reference&gt;&lt;/ds:SignedInfo&gt;\";\n\n      // get the bytes from SignedInfo that will be signed\n      byte[] signedInfoBytes = signedInfo.getBytes(\"UTF-8\");\n\n      // calculate SHA1 digest of the signed info bytes\n      byte[] signedInfoSha1Digest = sha1Digest(signedInfoBytes);\n\n      // encode the digest identifier and the SHA1 digest in DER format\n      byte[] signedInfoDerSha1Digest = mergeArrays(DER_SHA1_DIGEST_IDENTIFIER, signedInfoSha1Digest);\n\n      // initialize RSA cipher with the parameters from the private key\n      Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n      cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n\n      // encrypt the DER encoded SHA1 digest of signed info\n      byte[] signatureBytes = cipher.doFinal(signedInfoDerSha1Digest);\n\n      // encode the signature bytes into base64 string\n      String base64RsaSignature = base64encode(signatureBytes, true);\n\n      // generate the whole signature node XML string\n      String signature = \"&lt;wsse:Security xmlns:wsse=\\\"http://docs.oasis-open.org/wss/2004/01/oasis\"\n          + \"-200401-wss-wssecurity-secext-1.0.xsd\\\"&gt;\"\n          + \"&lt;ds:Signature xmlns:ds=\\\"http://www.w3.org/2000/09/xmldsig#\\\"&gt;\" + signedInfo\n          + \"&lt;ds:SignatureValue&gt;\" + base64RsaSignature\n          + \"&lt;/ds:SignatureValue&gt;&lt;/ds:Signature&gt;&lt;/wsse:Security&gt;\";\n\n      return signature;\n    } catch (Throwable e) {\n      Log.e(LOG_TAG, \"Error generating signature for XML\", e);\n      throw e;\n    }\n  }\n\n  /**\n   * Merges two byte arrays in one.\n   * \n   * @param array1 the first array\n   * @param array2 the second array\n   * @return merged array\n   */\n  public static byte[] mergeArrays(byte[] array1, byte[] array2) {\n    byte[] temp = new byte[array1.length + array2.length];\n    System.arraycopy(array1, 0, temp, 0, array1.length);\n    System.arraycopy(array2, 0, temp, array1.length, array2.length);\n    return temp;\n  }\n\n  /**\n   * Generates SHA-1 digest of the provided data.\n   * \n   * @param data the data to digest\n   * @return SHA-1 digest of the provided data.\n   */\n  public static byte[] sha1Digest(byte[] data) {\n    MessageDigest mdSha1 = null;\n    try {\n      mdSha1 = MessageDigest.getInstance(\"SHA-1\");\n    } catch (NoSuchAlgorithmException e1) {\n      Log.e(LOG_TAG, \"Error initializing SHA1 message digest\");\n    }\n    mdSha1.update(data);\n    byte[] sha1hash = mdSha1.digest();\n    return sha1hash;\n  }\n\n\n  /**\n   * Generates SHA-256 digest of the provided data.\n   * \n   * @param data the data to digest\n   * @return SHA-256 digest of the provided data.\n   */\n  public static byte[] sha256Digest(byte[] data) {\n    MessageDigest mdSha256 = null;\n    try {\n      mdSha256 = MessageDigest.getInstance(\"SHA-256\");\n    } catch (NoSuchAlgorithmException e1) {\n      Log.e(LOG_TAG, \"Error initializing SHA1 message digest\");\n    }\n    mdSha256.update(data);\n    byte[] sha256hash = mdSha256.digest();\n    return sha256hash;\n  }\n\n  /**\n   * Encoded byte arrays into Base64 strings.\n   * \n   * @param data the byte array to encode\n   * @param wrapLines &lt;code&gt;true&lt;/code&gt; to add \\r\\n\n   * @return base64 encoded string\n   */\n  public static String base64encode(byte[] data, boolean wrapLines) {\n    int length = data.length;\n    StringBuilder sb = new StringBuilder(length * 3 / 2);\n    int end = length - 3;\n    int i = 0;\n    int n = 0;\n\n    while (i &lt;= end) {\n      int d = ((((int) data[i]) &amp; 0x0ff) &lt;&lt; 16) | ((((int) data[i + 1]) &amp; 0x0ff) &lt;&lt; 8)\n          | (((int) data[i + 2]) &amp; 0x0ff);\n\n      sb.append(CHARS[(d &gt;&gt; 18) &amp; 63]);\n      sb.append(CHARS[(d &gt;&gt; 12) &amp; 63]);\n      sb.append(CHARS[(d &gt;&gt; 6) &amp; 63]);\n      sb.append(CHARS[d &amp; 63]);\n\n      i += 3;\n\n      if (n++ &gt;= 14) {\n        n = 0;\n        if (wrapLines) {\n          sb.append(\"\\r\\n\");\n        }\n      }\n    }\n\n    if (i == length - 2) {\n      int d = ((((int) data[i]) &amp; 0x0ff) &lt;&lt; 16) | ((((int) data[i + 1]) &amp; 255) &lt;&lt; 8);\n      sb.append(CHARS[(d &gt;&gt; 18) &amp; 63]);\n      sb.append(CHARS[(d &gt;&gt; 12) &amp; 63]);\n      sb.append(CHARS[(d &gt;&gt; 6) &amp; 63]);\n      sb.append(\"=\");\n    } else if (i == length - 1) {\n      int d = (((int) data[i]) &amp; 0x0ff) &lt;&lt; 16;\n\n      sb.append(CHARS[(d &gt;&gt; 18) &amp; 63]);\n      sb.append(CHARS[(d &gt;&gt; 12) &amp; 63]);\n      sb.append(\"==\");\n    }\n\n    return sb.toString();\n  }\n}\n", "protected org.apache.http.conn.ssl.SSLSocketFactory createAdditionalCertsSSLSocketFactory() {\ntry {\n    final KeyStore ks = KeyStore.getInstance(\"BKS\");\n\n    // the bks file we generated above\n    final InputStream in = context.getResources().openRawResource( R.raw.mystore);  \n    try {\n        // don't forget to put the password used above in strings.xml/mystore_password\n        ks.load(in, context.getString( R.string.mystore_password ).toCharArray());\n    } finally {\n        in.close();\n    }\n\n    return new AdditionalKeyStoresSSLSocketFactory(ks);\n\n} catch( Exception e ) {\n    throw new RuntimeException(e);\n}\n}\n", "PackageInfo info;\ntry {\n    info = getPackageManager().getPackageInfo(\"com.you.name\", PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String something = new String(Base64.encode(md.digest(), 0));\n        //String something = new String(Base64.encodeBytes(md.digest()));\n        Log.e(\"hash key\", something);\n    }\n} catch (NameNotFoundException e1) {\n    Log.e(\"name not found\", e1.toString());\n} catch (NoSuchAlgorithmException e) {\n    Log.e(\"no such an algorithm\", e.toString());\n} catch (Exception e) {\n    Log.e(\"exception\", e.toString());\n}\n", "@Override\npublic void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\n\ntry {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.facebook.samples.loginhowto\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n...\n", " HttpsTransportSE  androidHttpTransport = new HttpsTransportSE(10.0.2.2, 8181, \"/server/?wsdl\", 10000);\n             ((HttpsServiceConnectionSE) androidHttpTransport.getServiceConnection()).setSSLSocketFactory(trustAllHosts().getSocketFactory());\n\n\nprotected  SSLContext trustAllHosts()\n{   \n    return allowAllSSL();\n}\n\n public SSLContext allowAllSSL() {\n        SSLContext context = null; \n        TrustManager[] trustManagers = null;\n        KeyManagerFactory mgrFact;\n        try{\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        mgrFact = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n\n         KeyStore keyStore = KeyStore.getInstance(\"pkcs12\");\n         InputStream in = cntx.getResources().openRawResource(R.raw.keystore);\n         try {\n         keyStore.load(in, \"password\".toCharArray());\n         mgrFact.init(keyStore, \"password\".toCharArray());\n         } catch (CertificateException e) {\n         // TODO Auto-generated catch block\n         e.printStackTrace();\n         } finally {\n         in.close();\n         }\n         tmf.init(keyStore);\n\n\n            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() \n            {    \n                    @Override \n                    public boolean verify(String hostname, SSLSession session) { \n\n                            return true; \n                    } \n\n            }); \n\n\n            if (trustManagers == null) { \n                    trustManagers = new TrustManager[] { new FakeX509TrustManager() }; \n            }\n\n            final TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() {\n                    System.out.println(\"getAcceptedIssuers\");\n                     return null;\n                }\n                public void checkServerTrusted(X509Certificate[] chain, String authType)\n                        throws CertificateException {\n                    System.out.println(\"\u00d0\u00a1\u00d0\u00b2\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d0\u00b8\u00d1\u008f \u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d1\u0080\u00d1\u0082\u00d0\u00b8\u00d1\u0084\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0\u00d1\u0082\u00d0\u00b5 : \" +       chain[0].getIssuerX500Principal().getName() + \"\\n \u00d0\u00a2\u00d0\u00b8\u00d0\u00bf \u00d0\u00b0\u00d0\u00b2\u00d1\u0082\u00d0\u00be\u00d1\u0080\u00d0\u00b8\u00d0\u00b7\u00d0\u00b0\u00d1\u0086\u00d0\u00b8\u00d0\u00b8 : \" + authType);\n                }\n                public void checkClientTrusted(X509Certificate[] chain, String authType)\n                        throws CertificateException {\n                    System.out.println(\"checkClientTrusted : \" + authType);\n                }\n            } };\n            //tmf.getTrustManagers()\n            try { \n                    context = SSLContext.getInstance(\"TLS\"); \n                    context.init(mgrFact.getKeyManagers(), trustAllCerts, new SecureRandom()); \n            } catch (NoSuchAlgorithmException e) { \n                    e.printStackTrace(); \n            } catch (KeyManagementException e) { \n                    e.printStackTrace(); \n            } \n\n       HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n       HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n           public boolean verify(String hostname, SSLSession session) {\n                return true;\n              }\n            });\n        }catch(Exception ex)\n        {\n            Log.e(TAG,\"allowAllSSL failed: \"+ex.toString());\n        }\n       return context;\n    } \n", "private String getMD5(String file){\n    String md5 = \"\";\n\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        FileInputStream is = this.openFileInput(file);\n\n        DigestInputStream dis = new DigestInputStream(is, md);\n        byte data[] = new byte[1024];\n        @SuppressWarnings(\"unused\")\n        int count;\n        while ((count = dis.read(data)) != -1) {\n\n        }\n        byte[] digest = md.digest();\n\n        for (int i=0; i &lt; digest.length; i++) {\n            md5 += Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 );\n        }\n        return md5;\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return md5;\n}\n", "    private TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {\n        final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];\n        return new TrustManager[]{\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return originalTrustManager.getAcceptedIssuers();\n                    }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                        try {\n                            originalTrustManager.checkClientTrusted(certs, authType);\n                        } catch (CertificateException ignored) {\n                        }\n                    }\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                        try {\n                            originalTrustManager.checkServerTrusted(certs, authType);\n                        } catch (CertificateException ignored) {\n                        }\n                    }\n                }\n        };\n    }\n\n    private SSLSocketFactory getSSLSocketFactory()\n            throws CertificateException, KeyStoreException, IOException,\n                    NoSuchAlgorithmException, KeyManagementException {\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        InputStream caInput = getResources().openRawResource(R.raw.your_cert); // your certificate file\n        Certificate ca = cf.generateCertificate(caInput);\n        caInput.close();\n        KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n        keyStore.load(null, null);\n        keyStore.setCertificateEntry(\"ca\", ca);\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n        TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, wrappedTrustManagers, null);\n        return sslContext.getSocketFactory();\n    }\n", "private class MobHawkCheck extends AsyncTask&lt;String, Void, JSONObject&gt; {\n\n        protected JSONObject doInBackground(String... params) {\n            JSONObject json = null;\n            try {\n                // Load CAs from an InputStream\n                // (could be from a resource or ByteArrayInputStream or ...)\n                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                // From https://www.washington.edu/itconnect/security/ca/load-der.crt\n                InputStream cert = mActivity.getResources().openRawResource(R.raw.mycertificate);\n                InputStream caInput = new BufferedInputStream(cert);\n                Certificate ca;\n                try {\n                    ca = cf.generateCertificate(caInput);\n                    System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n                } finally {\n                    caInput.close();\n                }\n                // Create a KeyStore containing our trusted CAs\n                String keyStoreType = KeyStore.getDefaultType();\n                KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n                keyStore.load(null, null);\n                keyStore.setCertificateEntry(\"ca\", ca);\n\n                // Create a TrustManager that trusts the CAs in our KeyStore\n                String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n                TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n                tmf.init(keyStore);\n\n                // Create an SSLContext that uses our TrustManager\n                SSLContext context = SSLContext.getInstance(\"TLS\");\n                context.init(null, tmf.getTrustManagers(), null);\n\n                // Tell the URLConnection to use a SocketFactory from our SSLContext\n                URL url = new URL(\"https://mysecureurl.com\");\n                HttpsURLConnection urlConnection =\n                        (HttpsURLConnection)url.openConnection();\n                urlConnection.setSSLSocketFactory(context.getSocketFactory());\n\n                BufferedReader r = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n                StringBuilder total = new StringBuilder();\n                String line;\n                while ((line = r.readLine()) != null) {\n                    total.append(line);\n                }\n                json = new JSONObject(total.toString());\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (JSONException e) {\n                e.printStackTrace();\n            } catch (KeyManagementException e) {\n                e.printStackTrace();\n            } catch (NoSuchAlgorithmException e) {\n                e.printStackTrace();\n            } catch (KeyStoreException e) {\n                e.printStackTrace();\n            } catch (CertificateException e) {\n                e.printStackTrace();\n            }\n            return json;\n        }\n\n        protected void onPostExecute(JSONObject result) {\n            //TODO parse the result JSONObject\n        }\n    }\n", "package com.example.https;\n\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.KeyStore;\nimport java.security.cert.X509Certificate;\nimport java.util.Date;\nimport java.util.Enumeration;\n\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.SingleClientConnManager;\n\nimport android.content.Context;\nimport android.os.Build;\n\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.TrustManagerFactory;\n\npublic class MyHttpClient extends DefaultHttpClient {\n\n    final Context context;\n\n    public MyHttpClient(Context context) {\n        this.context = context;\n    }\n\n    @Override\n    protected ClientConnectionManager createClientConnectionManager() {\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        // Register for port 443 our SSLSocketFactory with our keystore\n        // to the ConnectionManager\n        registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n        return new SingleClientConnManager(getParams(), registry);\n    }\n\n    private SSLSocketFactory newSslSocketFactory() {\n        try {\n            // Trust manager / truststore\n            KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());\n\n            // If we're on an OS version prior to Ice Cream Sandwich (4.0) then use the standard way to get the system\n            //   trustStore -- System.getProperty() else we need to use the special name to get the trustStore KeyStore\n            //   instance as they changed their trustStore implementation.\n            if (Build.VERSION.RELEASE.compareTo(\"4.0\") &lt; 0) {\n                TrustManagerFactory trustManagerFactory=TrustManagerFactory\n                        .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                FileInputStream trustStoreStream=new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\"));\n                trustStore.load(trustStoreStream, null);\n                trustManagerFactory.init(trustStore);\n                trustStoreStream.close();\n            } else {\n                trustStore=KeyStore.getInstance(\"AndroidCAStore\");\n            }\n\n            InputStream certificateStream = context.getResources().openRawResource(R.raw.mykst);\n            KeyStore keyStore=KeyStore.getInstance(\"BKS\");\n            try {\n                keyStore.load(certificateStream, \"mypassword\".toCharArray());\n                Enumeration&lt;String&gt; aliases=keyStore.aliases();\n                while (aliases.hasMoreElements()) {\n                    String alias=aliases.nextElement();\n                    if (keyStore.getCertificate(alias).getType().equals(\"X.509\")) {\n                        X509Certificate cert=(X509Certificate)keyStore.getCertificate(alias);\n                        if (new Date().after(cert.getNotAfter())) {\n                            // This certificate has expired\n                            return null;\n                        }\n                    }\n                }\n            } catch (IOException ioe) {\n                // This occurs when there is an incorrect password for the certificate\n                return null;\n            } finally {\n                certificateStream.close();\n            }\n\n            KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, \"mypassword\".toCharArray());\n\n            return new SSLSocketFactory(keyStore, \"mypassword\", trustStore);\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n    }\n}\n", "public class TrustSSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public TrustSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n}\n", "KeyStore trustStore = KeyStore.getInstance(KeyStore\n                    .getDefaultType());\n            trustStore.load(null, null);\n        SSLSocketFactory sf = new TrustSSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory\n                .getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(\n                params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n", "public final class PubKeyManager implements X509TrustManager\n{\n  private static String PUB_KEY = \"30820122300d06092a864886f70d0101\" +\n    \"0105000382010f003082010a0282010100b35ea8adaf4cb6db86068a836f3c85\" +\n    \"5a545b1f0cc8afb19e38213bac4d55c3f2f19df6dee82ead67f70a990131b6bc\" +\n    \"ac1a9116acc883862f00593199df19ce027c8eaaae8e3121f7f329219464e657\" +\n    \"2cbf66e8e229eac2992dd795c4f23df0fe72b6ceef457eba0b9029619e0395b8\" +\n    \"609851849dd6214589a2ceba4f7a7dcceb7ab2a6b60c27c69317bd7ab2135f50\" +\n    \"c6317e5dbfb9d1e55936e4109b7b911450c746fe0d5d07165b6b23ada7700b00\" +\n    \"33238c858ad179a82459c4718019c111b4ef7be53e5972e06ca68a112406da38\" +\n    \"cf60d2f4fda4d1cd52f1da9fd6104d91a34455cd7b328b02525320a35253147b\" +\n    \"e0b7a5bc860966dc84f10d723ce7eed5430203010001\";\n\n  public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException\n  {\n    if (chain == null) {\n      throw new IllegalArgumentException(\"checkServerTrusted: X509Certificate array is null\");\n    }\n\n    if (!(chain.length &gt; 0)) {\n      throw new IllegalArgumentException(\"checkServerTrusted: X509Certificate is empty\");\n    }\n\n    if (!(null != authType &amp;&amp; authType.equalsIgnoreCase(\"RSA\"))) {\n      throw new CertificateException(\"checkServerTrusted: AuthType is not RSA\");\n    }\n\n    // Perform customary SSL/TLS checks\n    try {\n      TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");\n      tmf.init((KeyStore) null);\n\n      for (TrustManager trustManager : tmf.getTrustManagers()) {\n        ((X509TrustManager) trustManager).checkServerTrusted(chain, authType);\n      }\n    } catch (Exception e) {\n      throw new CertificateException(e);\n    }\n\n    // Hack ahead: BigInteger and toString(). We know a DER encoded Public Key begins\n    // with 0x30 (ASN.1 SEQUENCE and CONSTRUCTED), so there is no leading 0x00 to drop.\n    RSAPublicKey pubkey = (RSAPublicKey) chain[0].getPublicKey();\n    String encoded = new BigInteger(1 /* positive */, pubkey.getEncoded()).toString(16);\n\n    // Pin it!\n    final boolean expected = PUB_KEY.equalsIgnoreCase(encoded);\n    if (!expected) {\n      throw new CertificateException(\"checkServerTrusted: Expected public key: \"\n                + PUB_KEY + \", got public key:\" + encoded);\n      }\n    }\n  }\n}\n", " package com.telpoo.frame.net;\n\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.HttpVersion;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpParams;\nimport org.apache.http.params.HttpProtocolParams;\nimport org.apache.http.protocol.HTTP;\n\npublic class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n\n    public static  HttpClient getNewHttpClient() {\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            trustStore.load(null, null);\n\n            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n            HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sf, 443));\n\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception e) {\n            return new DefaultHttpClient();\n        }\n    }\n\n}\n", "BigInteger modBigInteger = new BigInteger(1, modulus);//modulus must be byte array\nBigInteger exBigInteger = new BigInteger(1, exponent);//exp must be byte array\n\nRSAPublicKeySpec spec = new RSAPublicKeySpec(modBigInteger, exBigInteger);\nKeyFactory factory = KeyFactory.getInstance(\"RSA\");\nPublicKey publicKey = factory.generatePublic(spec);\n", "    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"com.mycompany.mypackage\",    \nPackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "/**\n * This Activity is being used to show an alert about certificate exception\n * while communicating to server. User can take action on the alert and\n * {@link X509Certificate} will be added to trust zone if user proceed.\n */\npublic class SSLCertificateErrorDialogActivity extends Activity {\n\n    private static final String TAG = SSLCertificateErrorDialogActivity.class\n            .getSimpleName();\n    /** Key to send certificate via Intent between activities */\n    private static final String CERTIFICATE_INTENT_EXTRA = \"ssl_certificate\";\n    /** Key to send failing url via Intent between activities */\n    private static final String FAILING_URL_INTENT_EXTRA = \"failing_url\";\n    /** Request code for install certificate */\n    private static final int INSTALL_CERTIFICATE = 100;\n    private AlertDialog mCertificateDialog;\n    /**\n     * Certificate which needs to added to trust zone.\n     */\n    private X509Certificate mX509Certificate;\n    /**\n     * Url which is being failed for the SSL handshake\n     */\n    private String mFailingUrl;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        // This is UI less Activity. Layout should not be set.\n        // Read certificate intent and install\n        handleIntent(getIntent());\n    }\n\n    @Override\n    protected void onNewIntent(Intent intent) {\n        super.onNewIntent(intent);\n        handleIntent(intent);\n    }\n\n    private void handleIntent(Intent intent) {\n        if (intent == null) {\n            Log.d(TAG, \"Can not show dialog, intent is null\");\n            finish();\n            return;\n        }\n        this.mX509Certificate = (X509Certificate) intent\n                .getSerializableExtra(CERTIFICATE_INTENT_EXTRA);\n        this.mFailingUrl = (String) intent.getStringExtra(FAILING_URL_INTENT_EXTRA);\n        if ((this.mX509Certificate == null) || (this.mFailingUrl == null)) {\n            Log.d(TAG,\n                    \"Can not show dialog, certificate or failingurl is null\");\n            finish();\n            return;\n        }\n        // Inform user for certificate error\n        if ((mCertificateDialog == null)\n                || (mCertificateDialog.isShowing() == false)) {\n            // Show dialog only when if it it not showing.\n            // Certificate will be updated, and will be read\n            // from dialog when click on ok. So no need to\n            // dismiss current dialog.\n            showSSLCertificateAcceptDialog();\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        // Prevent back press\n    }\n\n    @Override\n    protected void onDestroy() {\n        if ((mCertificateDialog != null)\n                &amp;&amp; (mCertificateDialog.isShowing() == true)) {\n            mCertificateDialog.dismiss();\n        }\n        super.onDestroy();\n    }\n\n    /**\n     * Shows an alert dialog about SSL certificate issue. If user proceed,\n     * certificate will be added to trust zone, and this dialog will not be\n     * shown for same certificate.\n     */\n    private void showSSLCertificateAcceptDialog() {\n\n        AlertDialog.Builder builder = new AlertDialog.Builder(\n                SSLCertificateErrorDialogActivity.this);\n        builder.setIcon(R.drawable.abouthp_icon);\n        builder.setTitle(R.string.untrusted_cert_dialog_title);\n        builder.setMessage(msg);\n        builder.setPositiveButton(R.string.untrusted_cert_dialog_action_ok,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int id) {\n                        installCertificate();\n                    }\n                });\n        builder.setNegativeButton(R.string.untrusted_cert_dialog_action_cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.dismiss();\n                        // TODO Retry the failing url\n                        finish();\n                    }\n                });\n        mCertificateDialog = builder.create();\n        mCertificateDialog.setCancelable(false);\n        mCertificateDialog.show();\n    }\n\n    /**\n     * Install {@link X509Certificate} to trust zone. First this method will try\n     * to add certificate from background and on fail it will show a dialog to\n     * add certificate. This method must be called from an Activity, as it need\n     * an activity instance.\n     */\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    private void installCertificate() {\n        X509Certificate certificate = SSLCertificateErrorDialogActivity.this.mX509Certificate;\n        if (certificate != null) {\n            byte[] encodedCert = null;\n            try {\n                encodedCert = certificate.getEncoded();\n            } catch (CertificateEncodingException e) {\n                e.printStackTrace();\n            }\n            if (encodedCert != null) {\n                installUsingIntent(encodedCert, INSTALL_CERTIFICATE);\n            }\n        } else {\n            // TODO Retry the failing url\n            finish();\n        }\n    }\n\n    /**\n     * Install certificate to trust zone using intent. User action will be\n     * required while installing.\n     * \n     * @param encodedCert\n     *            of {@link X509Certificate}\n     * @param requestCode\n     */\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    private void installUsingIntent(byte[] encodedCert, int requestCode) {\n        Intent intent = KeyChain.createInstallIntent();\n        // Default Alias name. User can change it.\n        intent.putExtra(KeyChain.EXTRA_NAME, \"MY Certificate\");\n        intent.putExtra(KeyChain.EXTRA_CERTIFICATE, encodedCert);\n        startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        switch (requestCode) {\n        case INSTALL_CERTIFICATE:\n            // No matter if action was success or not, retry to connect with\n            // failed url and finish this activity.\n            // You can retry the failiing url\n            finish();\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    /**\n     * Show {@link SSLCertificateErrorDialogActivity} to inform user that, while\n     * communicating to server there is untrusted certificate exception. User\n     * can take action, certificate will be added to trust zone if user proceed.\n     * \n     * @param context\n     * @param certificate\n     *            {@link X509Certificate} to be added to trust zone.\n     * @param failingUrl\n     *            is an url for SSL certificate error occurred, purpose of this\n     *            url is to retry the same url after user action either\n     *            cancelled or proceed.\n     */\n    public static void show(Context context, X509Certificate certificate,\n            String failingUrl) {\n        Context appContext = context.getApplicationContext();\n        Intent intent = new Intent(appContext,\n                SSLCertificateErrorDialogActivity.class);\n        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\n        intent.putExtra(CERTIFICATE_INTENT_EXTRA, certificate);\n        intent.putExtra(FAILING_URL_INTENT_EXTRA, failingUrl);\n        appContext.startActivity(intent);\n    }\n}\n", "import java.io.IOException;\nimport java.net.Socket;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Enumeration;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.AllowAllHostnameVerifier;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpConnectionParams;\nimport org.apache.http.params.HttpParams;\n\nimport android.content.Context;\nimport android.util.Log;\n\n/**\n * This class will perform all network related calls like post, get and put.\n */\npublic class NetworkUtility {\n    protected static final String TAG = NetworkUtility.class.getSimpleName();\n    /**\n     * Connection timeout. 15 seconds\n     */\n    private static final int HTTP_CONNECTION_TIMEOUT = 150000;\n\n    /**\n     * Returns Default HTTP client with socket factories initialised.\n     * \n     * @param context\n     * @param targetUrl\n     *            to do request\n     * @return Default HTTP Client\n     */\n    private static HttpClient getDefaultHttpClient(Context context,\n            String targetUrl) {\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params,\n                HTTP_CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(params, HTTP_CONNECTION_TIMEOUT);\n        try {\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory\n                    .getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", new MySSLSocketFactory(\n                    context.getApplicationContext(), targetUrl), 443));\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(\n                    params, registry);\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return new DefaultHttpClient(params);\n        }\n    }\n\n    /**\n     * TrustManager to accept all certificates. It does not do any certificates\n     * validation.\n     * \n     * TODO: Once we have actual certificates this implementation should be\n     * changed accordingly.\n     */\n    private static class MyTrustManager implements X509TrustManager {\n        private X509TrustManager mOriginalX509TrustManager;\n        private Context mContext;\n        private String mTargetUrl;\n\n        /**\n         * @param context\n         *            - application context.\n         * @param targetUrl\n         *            - to do request.\n         */\n        public MyTrustManager(Context context, String targetUrl) {\n            try {\n                this.mContext = context;\n                this.mTargetUrl = targetUrl;\n                TrustManagerFactory originalTrustManagerFactory = TrustManagerFactory\n                        .getInstance(\"X509\");\n                originalTrustManagerFactory.init((KeyStore) null);\n                TrustManager[] originalTrustManagers = originalTrustManagerFactory\n                        .getTrustManagers();\n                this.mOriginalX509TrustManager = (X509TrustManager) originalTrustManagers[0];\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        public void checkClientTrusted(X509Certificate[] cert, String authType)\n                throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] cert, String authType)\n                throws CertificateException {\n            try {\n                // Verify if the certificate has been trusted.\n                // This validation will pass if certificate has\n                // been added by user or system.\n                mOriginalX509TrustManager.checkServerTrusted(cert, authType);\n            } catch (CertificateException originalException) {\n                // Certificate has not present into trust zone.\n                // Find first certificate from the array of certificates which\n                // needs to install.\n                X509Certificate certificate = getCertificateToInstall(cert);\n                Log.d(TAG, \"Showing dialog for certificate exception...\");\n                // Show dialog where user can install this certificate\n                SSLCertificateErrorDialogActivity.show(this.mContext,\n                        certificate, this.mTargetUrl);\n                throw originalException;\n            }\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n\n    /**\n     * Get certificate to be installed from the given list of certificates. It\n     * iterates all certificates from CA and if a certificate, from the given\n     * array is not present into CA, this method returns that certificate.\n     * \n     * @param certificates\n     * @return {@link X509Certificate} to install.\n     */\n    private static X509Certificate getCertificateToInstall(\n            X509Certificate[] certificates) {\n        X509Certificate result = null;\n        try {\n            KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\n            if (ks != null) {\n                ks.load(null, null);\n                boolean certFound = false;\n                for (X509Certificate certificate : certificates) {\n                    Enumeration&lt;String&gt; aliases = ks.aliases();\n                    while (aliases.hasMoreElements()) {\n                        String alias = (String) aliases.nextElement();\n                        X509Certificate cert = (X509Certificate) ks\n                                .getCertificate(alias);\n                        if (certificate.equals(cert) == true) {\n                            certFound = true;\n                            break;\n                        }\n                    }\n                    if (certFound == false) {\n                        Log.d(TAG, \"Not found certificate\");\n                        // Need to install this certificate\n                        result = certificate;\n                        break;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n\n    private static class MySSLSocketFactory extends SSLSocketFactory {\n        private javax.net.ssl.SSLSocketFactory mFactory;\n\n        public MySSLSocketFactory(Context context, String targetUrl)\n                throws KeyManagementException, NoSuchAlgorithmException,\n                KeyStoreException, UnrecoverableKeyException {\n            super((KeyStore) null);\n            try {\n                SSLContext sslcontext = SSLContext.getInstance(\"TLS\");\n                sslcontext.init(null, new TrustManager[] { new MyTrustManager(\n                        context, targetUrl) }, null);\n                mFactory = sslcontext.getSocketFactory();\n                setHostnameVerifier(new AllowAllHostnameVerifier());\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n\n        @Override\n        public Socket createSocket() throws IOException {\n            return mFactory.createSocket();\n        }\n\n        @Override\n        public Socket createSocket(Socket socket, String s, int i, boolean flag)\n                throws IOException {\n            return mFactory.createSocket(socket, s, i, flag);\n        }\n    }\n}\n", "final byte[] officalkey = {-58, -42, -44, -106, 90, -88, -87, -88, -52, -124, 84, 117, 66, 79, -112, -111, -46, 86, -37, 109};\nfinal byte[] officaldebugkey = {-99, -69, 45, 71, 114, -116, 82, 66, -99, -122, 50, -70, -56, -111, 98, -35, -65, 105, 82, 43};\n\nSignature raw = c.getPackageManager().getPackageInfo(c.getPackageName(), PackageManager.GET_SIGNATURES).signatures[0];\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\nX509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(raw.toByteArray()));\nMessageDigest md = MessageDigest.getInstance(\"SHA-1\");\nbyte[] der = cert.getEncoded();\nmd.update(der);\nbyte[] digest = md.digest();\n\n\nif (Arrays.equals(digest, officalkey))\n    apksign = c.getString(R.string.official_build);\nelse if (Arrays.equals(digest, officaldebugkey))\n    apksign = c.getString(R.string.debug_build);\nelse\n    apksign = c.getString(R.string.built_by,cert.getSubjectX500Principal().getName());\n", "TrustManagerFactory tmf =  TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); \ntmf.init((KeyStore) null); \nX509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0]; \nfor (X509Certificate cert : xtm.getAcceptedIssuers()) { \n    String certStr = \"S:\" + cert.getSubjectDN().getName() + \"\\nI:\" \n                        + cert.getIssuerDN().getName(); \n    Log.d(TAG, certStr); \n} \n", "import java.security.Key;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport javax.crypto.Cipher;\n\npublic class Test {\n\n    private static final String RSA_ECB_PKCS1_PADDING = \"RSA/ECB/PKCS1Padding\";\n\n    public static void main(String[] args) {\n        String data = \"Hello World\";\n\n        KeyPair kp = generateRSAKeyPair();\n\n        PublicKey publicKey = kp.getPublic();\n        PrivateKey privateKey = kp.getPrivate();\n\n        byte[] encryptedValue = encryptRSA(publicKey, data.getBytes());\n        byte[] decrytpedValue = decryptRSA(privateKey, encryptedValue);\n\n        String decryptedData = new String(decrytpedValue);\n\n        System.out.println(decryptedData);\n    }\n\n    public static KeyPair generateRSAKeyPair() {\n        KeyPairGenerator keyGen;\n        try {\n            keyGen = KeyPairGenerator.getInstance(\"RSA\");\n            SecureRandom rnd = new SecureRandom();\n            keyGen.initialize(2048, rnd);\n            KeyPair keyPair = keyGen.genKeyPair();\n            return keyPair;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static byte[] encryptRSA(Key key, byte[] data) {\n        byte[] cipherText = null;\n        try {\n            final Cipher cipher = Cipher.getInstance(RSA_ECB_PKCS1_PADDING);\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            cipherText = cipher.doFinal(data);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return cipherText;\n    }\n\n    public static byte[] decryptRSA(Key key, byte[] data) {\n        byte[] decryptedText = null;\n        try {\n            final Cipher cipher = Cipher.getInstance(RSA_ECB_PKCS1_PADDING);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            decryptedText = cipher.doFinal(data);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return decryptedText;\n    }\n\n}\n", "ByteArrayOutputStream blob = new ByteArrayOutputStream();\nDataOutputStream dataBlob = new DataOutputStream(blob);\n\n// Get the salt\nSecureRandom random = new SecureRandom();\nbyte[] salt = new byte[saltLength];\nrandom.nextBytes(salt);\n\ndataBlob.writeShort(saltLength);\ndataBlob.write(salt);\n\n// Secret key\nSecretKey secretKey = getSecretKey(seed, salt);\n\n// Get Cipher instance for AES with Padding algorithm PKCS5\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n// Initialization vector, as CBC requires IV\nbyte[] iv = new byte[cipher.getBlockSize()];\nrandom.nextBytes(iv);\n\ndataBlob.write(iv.length);\ndataBlob.write(iv);\n\n// Algorithm spec for IV\nIvParameterSpec ivParams = new IvParameterSpec(iv);\n\ncipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParams);\n\n// Encrypt the text\nbyte[] encryptedTextInBytes = cipher.doFinal(textToBeEncrypted\n        .getBytes(StandardCharsets.UTF_8));\n\ndataBlob.writeInt(encryptedTextInBytes.length);\ndataBlob.write(encryptedTextInBytes);\n\n\n// out of scope: add HMAC protection over current contents of blob here\n// (or while writing it to dataBlob, also update a HMAC) \n\n// Base64Encoder encode;\nreturn Base64Encoder.encode(blob.toByteArray());\n", "public class MacOutputStream extends FilterOutputStream {\n\n    private final Mac mac;\n\n    public MacOutputStream(OutputStream out, Mac mac) {\n        super(out);\n        this.mac = mac;\n    }\n\n    @Override\n    public void write(byte[] b) throws IOException {\n        mac.update(b);\n        out.write(b);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        mac.update((byte) b);\n        out.write(b);\n    }\n\n    public byte[] getMac() {\n        return mac.doFinal();\n    }\n}\n", "final HttpsURLConnection https = (HttpsURLConnection) requestedUrl.openConnection();\n\ntry {\n\n    https.setConnectTimeout(timeout);\n    https.setReadTimeout(timeout);\n    https.setRequestMethod(method);\n\n    if (sslSocketFactory != null) {\n        https.setSSLSocketFactory(sslSocketFactory);\n    }\n\n    https.setHostnameVerifier(new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();\n            return hv.verify(\"localhost\", session);\n        }\n    });\n...\n", "public static SSLContext loadCertificate(String password)\n            throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException,\n            UnrecoverableKeyException, KeyManagementException {\n\n        final FileInputStream fis = new FileInputStream(new File(CERT_FILE_DIRECTORY, CERT_FILE_NAME));\n\n        final KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n        keyStore.load(fis, password.toCharArray());\n\n        final KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"X509\");\n        kmf.init(keyStore, null);\n        final KeyManager[] keyManagers = kmf.getKeyManagers();\n        final SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(keyManagers, new TrustManager[]{new MyTrustManager()}, null);\n        return sslContext;\n    }\n", " import java.io.IOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.Socket;\n import java.net.UnknownHostException;\n\n import javax.net.ssl.SSLContext;\n import javax.net.ssl.SSLSocket;\n import javax.net.ssl.TrustManager;\n\n import org.apache.http.conn.ConnectTimeoutException;\n import org.apache.http.conn.scheme.LayeredSocketFactory;\n import org.apache.http.conn.scheme.SocketFactory;\n import org.apache.http.params.HttpConnectionParams;\n import org.apache.http.params.HttpParams;\n\npublic class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory {\n\nprivate SSLContext sslcontext = null;\n\nprivate static SSLContext createEasySSLContext() throws IOException {\n    try {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);\n        return context;\n    } catch (Exception e) {\n        throw new IOException(e.getMessage());\n    }\n}\n\nprivate SSLContext getSSLContext() throws IOException {\n    if (this.sslcontext == null) {\n        this.sslcontext = createEasySSLContext();\n    }\n    return this.sslcontext;\n}\n\n/**\n * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int,\n *      java.net.InetAddress, int, org.apache.http.params.HttpParams)\n */\npublic Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort,\n        HttpParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n    int soTimeout = HttpConnectionParams.getSoTimeout(params);\n    InetSocketAddress remoteAddress = new InetSocketAddress(host, port);\n    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());\n\n    if ((localAddress != null) || (localPort &gt; 0)) {\n        // we need to bind explicitly\n        if (localPort &lt; 0) {\n            localPort = 0; // indicates \"any\"\n        }\n        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);\n        sslsock.bind(isa);\n    }\n\n    sslsock.connect(remoteAddress, connTimeout);\n    sslsock.setSoTimeout(soTimeout);\n    return sslsock;\n\n}\n\n/**\n * @see org.apache.http.conn.scheme.SocketFactory#createSocket()\n */\npublic Socket createSocket() throws IOException {\n    return getSSLContext().getSocketFactory().createSocket();\n}\n\n/**\n * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)\n */\npublic boolean isSecure(Socket socket) throws IllegalArgumentException {\n    return true;\n}\n\n/**\n * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int,\n *      boolean)\n */\npublic Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,\n        UnknownHostException {\n    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n}\n\n// -------------------------------------------------------------------\n// javadoc in org.apache.http.conn.scheme.SocketFactory says :\n// Both Object.equals() and Object.hashCode() must be overridden\n// for the correct operation of some connection managers\n// -------------------------------------------------------------------\n\npublic boolean equals(Object obj) {\n    return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));\n}\n\npublic int hashCode() {\n    return EasySSLSocketFactory.class.hashCode();\n}\n\n}\n", "import java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\n\npublic class EasyX509TrustManager implements X509TrustManager {\n\nprivate X509TrustManager standardTrustManager = null;\n\n/**\n * Constructor for EasyX509TrustManager.\n */\npublic EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException {\n    super();\n    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    factory.init(keystore);\n    TrustManager[] trustmanagers = factory.getTrustManagers();\n    if (trustmanagers.length == 0) {\n        throw new NoSuchAlgorithmException(\"no trust manager found\");\n    }\n    this.standardTrustManager = (X509TrustManager) trustmanagers[0];\n}\n\n/**\n * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType)\n */\npublic void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException {\n    standardTrustManager.checkClientTrusted(certificates, authType);\n}\n\n/**\n * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType)\n */\npublic void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException {\n    if ((certificates != null) &amp;&amp; (certificates.length == 1)) {\n        certificates[0].checkValidity();\n    } else {\n        standardTrustManager.checkServerTrusted(certificates, authType);\n    }\n}\n\n/**\n * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()\n */\npublic X509Certificate[] getAcceptedIssuers() {\n    return this.standardTrustManager.getAcceptedIssuers();\n}\n\n}\n", "ECGenParameterSpec ecParamSpec = new ECGenParameterSpec(\"secp384r1\");\nKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECDH\", \"SC\");\nkpg.initialize(ecParamSpec);\n\nKeyPair kpA = kpg.generateKeyPair();\n\nBCECPublicKey publicKey = (BCECPublicKey)kpA.getPublic();\nBCECPrivateKey privateKey = (BCECPrivateKey)kpA.getPrivate();\n\nbyte[] publicKeyBytes = publicKey.getQ().getEncoded(true);\nbyte[] privateKeyBytes = privateKey.getD().toByteArray();\n", "public String StringToMD5(String s) {\n try {\n     // Create MD5 Hash\n     MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n     digest.update(s.getBytes());\n     byte messageDigest[] = digest.digest();\n\n    // Create Hex String\n     StringBuffer hexString = new StringBuffer();\n     for (int i=0; i&lt;messageDigest.length; i++)\n            M hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));\n    return hexString.toString();\n\n} catch (NoSuchAlgorithmException e) {\n    e.printStackTrace();\n}\nreturn \"\";\n}\n", " public class PicassoTrustAll {\n\n    private static Picasso mInstance = null;\n\n    private PicassoTrustAll(Context context) {\n        OkHttpClient client = new OkHttpClient();\n        client.setHostnameVerifier(new HostnameVerifier() {\n            @Override\n            public boolean verify(String s, SSLSession sslSession) {\n                return true;\n            }\n        });\n        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n            @Override\n            public void checkClientTrusted(\n                    java.security.cert.X509Certificate[] x509Certificates,\n                    String s) throws java.security.cert.CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(\n                    java.security.cert.X509Certificate[] x509Certificates,\n                    String s) throws java.security.cert.CertificateException {\n            }\n\n            @Override\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return new java.security.cert.X509Certificate[] {};\n            }\n        } };\n        try {\n            SSLContext sc = SSLContext.getInstance(\"TLS\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            client.setSslSocketFactory(sc.getSocketFactory());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        mInstance = new Picasso.Builder(context)\n                .downloader(new OkHttpDownloader(client))\n                .listener(new Picasso.Listener() {\n                    @Override\n                    public void onImageLoadFailed(Picasso picasso, Uri uri, Exception exception) {\n                        Log.e(\"PICASSO\", exception);\n                    }\n                }).build();\n\n    }\n\n    public static Picasso getInstance(Context context) {\n        if (mInstance == null) {\n             new PicassoTrustAll(context);\n        }\n        return mInstance;\n    }\n}\n", "public static String getAppKeyHash(Context context) {\n    // Add code to print out the key hash\n    try {\n        PackageInfo info = context.getPackageManager().getPackageInfo(\n                \"com.example.app\", PackageManager.GET_SIGNATURES);\n        String hash = null;\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            hash = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n            Log.d(\"KeyHash:\", hash);\n        }\n        return hash;\n    } catch (NameNotFoundException e) {\n        return null;\n    } catch (NoSuchAlgorithmException e) {\n        return null;\n    }\n}\n", "MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nString text = \"This is some text\";\nmd.update(text.getBytes(\"UTF-8\")); // Change this to \"UTF-16\" if needed\nbyte[] digest = md.digest();\n", "public static Picasso getInstance(Context context) {\n        if (sPicasso == null) {\n            InputStream keyStore = context.getResources().openRawResource(R.raw.my_keystore);\n            Picasso.Builder builder = new Picasso.Builder(context);\n            OkHttpClient okHttpClient = new OkHttpClient();\n            SSLContext sslContext;\n            try {\n                sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(null, new TrustManager[]{new SsX509TrustManager(keyStore, password)}, null);\n                okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());\n                OkHttpDownloader okHttpDownloader = new OkHttpDownloader(okHttpClient);\n                builder.downloader(okHttpDownloader);\n                sPicasso = builder.build();\n            } catch (NoSuchAlgorithmException e) {\n                throw new IllegalStateException(\"Failure initializing default SSL context\", e);\n            } catch (KeyManagementException e) {\n                throw new IllegalStateException(\"Failure initializing default SSL context\", e);\n            } catch (GeneralSecurityException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return sPicasso;\n    }\n", "  TrustManager[] trustAllCerts = new TrustManager[]\n   { new X509TrustManager()\n      {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers()  { return null; }\n        public void checkClientTrusted( X509Certificate[] chain, String authType) {}\n        public void checkServerTrusted( X509Certificate[] chain, String authType) {}\n      }\n   };\n\n  try\n    {\n      SSLContext sc = SSLContext.getInstance( \"SSL\"); // \"TLS\" \"SSL\"\n      sc.init( null, trustAllCerts, null);\n      // sc.init( null, trustAllCerts, new java.security.SecureRandom());\n      HttpsURLConnection.setDefaultSSLSocketFactory( sc.getSocketFactory());\n      HttpsURLConnection.setDefaultHostnameVerifier( \n       new HostnameVerifier() \n        {\n          public boolean verify( String hostname, SSLSession session) { return true; }\n        } );\n    }\n   catch (Exception e) {}\n", "public String md5(String s) {\n        try {\n            // Create MD5 Hash\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(s.getBytes());\n            byte messageDigest[] = digest.digest();\n\n            // Create Hex String\n            StringBuffer hexString = new StringBuffer();\n            for (int i=0; i&lt;messageDigest.length; i++)\n                hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));\n            return hexString.toString();\n\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n", "try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.matainja.facebooklogin\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmExceptio`enter code here`n e) {\n\n    }\n", "public static String sStringToHMACMD5(String s, String keyString)\n    {\n        String sEncodedString = null;\n        try\n        {\n            SecretKeySpec key = new SecretKeySpec((keyString).getBytes(\"UTF-8\"), \"HmacMD5\");\n            Mac mac = Mac.getInstance(\"HmacMD5\");\n            mac.init(key);\n\n            byte[] bytes = mac.doFinal(s.getBytes(\"ASCII\"));\n\n            StringBuffer hash = new StringBuffer();\n\n            for (int i=0; i&lt;bytes.length; i++) {\n                String hex = Integer.toHexString(0xFF &amp;  bytes[i]);\n                if (hex.length() == 1) {\n                    hash.append('0');\n                }\n                hash.append(hex);\n            }\n            sEncodedString = hash.toString();\n        }\n        catch (UnsupportedEncodingException e) {}\n        catch(InvalidKeyException e){}\n        catch (NoSuchAlgorithmException e) {}\n        return sEncodedString ;\n    }\n", "public final class ProviderUtils {\n\n    private ProviderUtils() {} // not instantiable, it is a utility class\n\n    public static void print(Provider provider) {\n        String name = provider.getName();\n        // print the name\n    }\n}\n", "try {\n        PackageInfo info = getActivity().getPackageManager().getPackageInfo(\n                \"com.yourappname.app\",\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash\", \"KeyHash:\" + Base64.encodeToString(md.digest(),\n                    Base64.DEFAULT));\n            Toast.makeText(getActivity().getApplicationContext(), Base64.encodeToString(md.digest(),\n                    Base64.DEFAULT), Toast.LENGTH_LONG).show();\n        }\n    } catch (PackageManager.NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "public byte[] RSAEncrypt(final String plain) throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(1024);\n    kp = kpg.genKeyPair();\n    publicKey = kp.getPublic();\n    privateKey = kp.getPrivate();\n\n    cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    encryptedBytes = cipher.doFinal(plain.getBytes());\n    System.out.println(\"EEncrypted?????\" + org.apache.commons.codec.binary.Hex.encodeHexString(encryptedBytes));\n    return encryptedBytes;\n}\n\npublic String RSADecrypt(final byte[] encryptedBytes) throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n    cipher1 = Cipher.getInstance(\"RSA\");\n    cipher1.init(Cipher.DECRYPT_MODE, privateKey);\n    decryptedBytes = cipher1.doFinal(encryptedBytes);\n    decrypted = new String(decryptedBytes);\n    System.out.println(\"DDecrypted?????\" + decrypted);\n    return decrypted;\n}\n", "package test;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class TestCrypt{\n\n    private static final String salt = \"t784\";\n    private static final String cryptPassword = \"873147cbn9x5'2 79'79314\";\n    private static final String fileToBeCrypted = \"c:\\\\Temp\\\\sampleFile.conf\";\n    private static final String fileToBeDecrypted = \"c:\\\\Temp\\\\sampleFile.conf.crypt\";\n    private static final String fileDecryptedOutput = \"c:\\\\Temp\\\\sampleFile.conf.decrypted\";\n\n    public static void main(String[] args) throws Exception\n    {\n        for (int i=0; i&lt;100; i++)\n        {\n            encryptfile(fileToBeCrypted, cryptPassword);\n            decrypt(fileToBeDecrypted, cryptPassword, fileDecryptedOutput);\n            System.out.println(i);\n        }\n    }\n\n    public static void encryptfile(String path,String password) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n        FileInputStream fis = new FileInputStream(path);\n        FileOutputStream fos = new FileOutputStream(path.concat(\".crypt\"));\n        byte[] key = (salt + password).getBytes(\"UTF-8\");\n        MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n        key = sha.digest(key);\n        key = Arrays.copyOf(key,16);\n        SecretKeySpec sks = new SecretKeySpec(key, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, sks);\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n        int b;\n        byte[] d = new byte[8];\n        while((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n        }\n        cos.flush();\n        cos.close();\n        fis.close();\n    }\n\n    public static void decrypt(String path,String password, String outPath) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n        FileInputStream fis = new FileInputStream(path);\n        FileOutputStream fos = new FileOutputStream(outPath);\n        byte[] key = (salt + password).getBytes(\"UTF-8\");\n        MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n        key = sha.digest(key);\n        key = Arrays.copyOf(key,16);\n        SecretKeySpec sks = new SecretKeySpec(key, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, sks);\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n        int b;\n        byte[] d = new byte[8];\n        while((b = cis.read(d)) != -1) {\n            fos.write(d, 0, b);\n        }\n        fos.flush();\n        fos.close();\n        cis.close();\n    }\n\n}\n", " /**\n * Initialize the HTTP/S connection (if needed)\n *\n * @param  keystoreFile  the full path of the keystore file\n * @param  keystorePass  the password for the keystore file\n */\nprivate void initHttps(String keystoreFile, String keystorePass)\n{\n    // check if the URL uses HTTP/S\n    if (url.toLowerCase().startsWith(HTTPS_PROTOCOL))\n    {\n        print(\"Initializing HTTP/S protocol...\");\n        // set the system properties needed for HTTP/S\n        System.setProperty(\"javax.net.ssl.keyStore\", keystoreFile);\n        System.setProperty(\"javax.net.ssl.keyStorePassword\", keystorePass);\n        System.setProperty(\"javax.net.ssl.keyStoreType\", \"JKS\");\n        System.setProperty(\"javax.net.ssl.trustStore\", keystoreFile);\n        System.setProperty(\"javax.net.ssl.trustStorePassword\", keystorePass);\n        System.setProperty(\"javax.protocol.handler.pkgs\",\n            \"com.sun.net.ssl.internal.www.protocol\");\n        //int addProvider = Security.addProvider(new       com.sun.net.ssl.internal.ssl.Provider());\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier()\n        {   // fix a HTTP/S handshake issue\n            public boolean verify(String hostName, SSLSession session)\n            {   // Verify that the host name is acceptable \n                return true;\n            }\n        });\n    }\n}\n", "/* generate secretkey */\nPBEKeySpec keySpec=new PBEKeySpec(username.toCharArray(),salt.getBytes(),1000,256);\nSecretKeyFactory keyFactory=SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nSecretKey tmp=keyFactory.generateSecret(keySpec);\n\n/*transform key to keySpec*/\nSecretKey key=new SecretKeySpec(tmp.getEncoded(),\"AES\");\n", "private String hashString(String s) {\n        try {\n            // Create SHA-1 Hash\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA-1\");\n            digest.update(s.getBytes(\"UTF-8\"));\n            byte messageDigest[] = digest.digest();\n\n            // Create Hex String\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i &lt; messageDigest.length; i++)\n                hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));\n            return hexString.toString();\n\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n", "protected void ShowHash(android.net.Uri uri) {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance(\"MD5\");\n        BufferedInputStream is = new BufferedInputStream(getContentResolver().openInputStream(uri));\n        DigestInputStream dis = new DigestInputStream(is, md);\n        byte[] buffer = new byte[1024];\n        while(dis.read(buffer, 0, buffer.length) != -1) ;\n        Toast.makeText(getApplicationContext(), bytesToHex(md.digest()),\n                Toast.LENGTH_LONG).show();\n    } catch(Exception e) {\n        Toast.makeText(getApplicationContext(), e.toString(),\n                Toast.LENGTH_LONG).show();\n    }\n    return;\n}\n", "private static TrustManager[] trustManagers;\n\npublic static class _FakeX509TrustManager implements\n        javax.net.ssl.X509TrustManager {\n    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};\n\n    public void checkClientTrusted(X509Certificate[] arg0, String arg1)\n            throws CertificateException {\n    }\n\n    public void checkServerTrusted(X509Certificate[] arg0, String arg1)\n            throws CertificateException {\n    }\n\n    public boolean isClientTrusted(X509Certificate[] chain) {\n        return (true);\n    }\n\n    public boolean isServerTrusted(X509Certificate[] chain) {\n        return (true);\n    }\n\n    public X509Certificate[] getAcceptedIssuers() {\n        return (_AcceptedIssuers);\n    }\n}\n\npublic static void allowAllSSL() {\n\n    javax.net.ssl.HttpsURLConnection\n            .setDefaultHostnameVerifier(new HostnameVerifier() {\n                public boolean verify(String hostname, SSLSession session) {\n                    return true;\n                }\n            });\n\n    javax.net.ssl.SSLContext context = null;\n\n    if (trustManagers == null) {\n        trustManagers = new javax.net.ssl.TrustManager[] { new _FakeX509TrustManager() };\n    }\n\n    try {\n        context = javax.net.ssl.SSLContext.getInstance(\"TLS\");\n        context.init(null, trustManagers, new SecureRandom());\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(\"allowAllSSL\", e.toString());\n    } catch (KeyManagementException e) {\n        Log.e(\"allowAllSSL\", e.toString());\n    }\n    javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(context\n            .getSocketFactory());\n}\n", "SSLContext ctx = SSLContext.getInstance(\"TLS\");\nctx.init(null, new TrustManager[] {\nnew X509TrustManager() {\n     public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n     public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n     public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; }\n     }\n}, null);\nHttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());\n\nHttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n     public boolean verify(String hostname, SSLSession session) {\n          return true;\n     }\n});\n", "public static String encrypt(final String plainMessage,\n        final String symKeyHex) {\n\n\n    try {\n\n    final byte[] symKeyData = Hex.decodeHex(symKeyHex.toCharArray());\n\n    final byte[] encodedMessage = plainMessage.getBytes(Charset.forName(\"UTF-8\"));\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        final int blockSize = cipher.getBlockSize();\n\n        // create the key\n        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, \"AES\");\n\n        // generate random IV using block size (possibly create a method for\n        // this)\n        final byte[] ivData = new byte[blockSize];\n        final SecureRandom rnd = SecureRandom.getInstance(\"SHA1PRNG\");\n        rnd.nextBytes(ivData);\n        final IvParameterSpec iv = new IvParameterSpec(ivData);\n\n        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);\n\n        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);\n\n        // concatenate IV and encrypted message\n        final byte[] ivAndEncryptedMessage = new byte[ivData.length\n                + encryptedMessage.length];\n        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);\n        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,\n                blockSize, encryptedMessage.length);\n\n        final String ivAndEncryptedMessageBase64 = Base64.encodeBase64String(ivAndEncryptedMessage);\n\n        return ivAndEncryptedMessageBase64;\n    } catch (InvalidKeyException e) {\n        throw new IllegalArgumentException(\n                \"key argument does not contain a valid AES key\");\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(\n                \"Unexpected exception during encryption\", e);\n    } catch (DecoderException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return \"\";\n\n}\n\npublic static String decrypt(final String ivAndEncryptedMessageBase64,\n        final String symKeyHex) {\n\n    try {\n        final byte[] symKeyData = Hex.decodeHex(symKeyHex.toCharArray());\n        final byte[] ivAndEncryptedMessage = Base64.decodeBase64(ivAndEncryptedMessageBase64);\n\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        final int blockSize = cipher.getBlockSize();\n\n        // create the key\n        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, \"AES\");\n\n        // retrieve random IV from start of the received message\n        final byte[] ivData = new byte[blockSize];\n        System.arraycopy(ivAndEncryptedMessage, 0, ivData, 0, blockSize);\n        final IvParameterSpec iv = new IvParameterSpec(ivData);\n\n        // retrieve the encrypted message itself\n        final byte[] encryptedMessage = new byte[ivAndEncryptedMessage.length\n                - blockSize];\n        System.arraycopy(ivAndEncryptedMessage, blockSize,\n                encryptedMessage, 0, encryptedMessage.length);\n\n        cipher.init(Cipher.DECRYPT_MODE, symKey, iv);\n\n        final byte[] encodedMessage = cipher.doFinal(encryptedMessage);\n\n        // concatenate IV and encrypted message\n        final String message = new String(encodedMessage,\n                Charset.forName(\"UTF-8\"));\n\n        return message;\n    } catch (InvalidKeyException e) {\n        throw new IllegalArgumentException(\n                \"key argument does not contain a valid AES key\");\n    } catch (BadPaddingException e) {\n        // you'd better know about padding oracle attacks\n        return null;\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(\n                \"Unexpected exception during decryption\", e);\n    } catch (DecoderException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "public static String encrypt(final String plainMessage,\n                             final String symKeyHex) {\n\n\n    try {\n\n        final byte[] symKeyData = Hex.decodeHex(symKeyHex.toCharArray());\n\n        final byte[] encodedMessage = plainMessage.getBytes(Charset.forName(\"UTF-8\"));\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        final int blockSize = cipher.getBlockSize();\n\n        // create the key\n        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, \"AES\");\n\n        // generate random IV using block size (possibly create a method for\n        // this)\n        final byte[] ivData = new byte[blockSize];\n        final SecureRandom rnd = SecureRandom.getInstance(\"SHA1PRNG\");\n        rnd.nextBytes(ivData);\n        final IvParameterSpec iv = new IvParameterSpec(ivData);\n\n        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);\n\n        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);\n\n        // concatenate IV and encrypted message\n        final byte[] ivAndEncryptedMessage = new byte[ivData.length\n                + encryptedMessage.length];\n        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);\n        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,\n                blockSize, encryptedMessage.length);\n\n        //final String ivAndEncryptedMessageBase64 = Base64.encodeBase64String(ivAndEncryptedMessage);\n        final String ivAndEncryptedMessageBase64 = Base64.encodeToString(ivAndEncryptedMessage,Base64.DEFAULT);\n\n        return ivAndEncryptedMessageBase64;\n    } catch (InvalidKeyException e) {\n        throw new IllegalArgumentException(\n                \"key argument does not contain a valid AES key\");\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(\n                \"Unexpected exception during encryption\", e);\n    } catch (DecoderException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return \"\";\n\n}\n\npublic static String decrypt(final String ivAndEncryptedMessageBase64,\n                             final String symKeyHex) {\n\n\n    try {\n\n        final byte[] symKeyData = Hex.decodeHex(symKeyHex.toCharArray());\n        //final byte[] ivAndEncryptedMessage = Base64.decodeBase64(ivAndEncryptedMessageBase64);\n        final byte[] ivAndEncryptedMessage = Base64.decode(ivAndEncryptedMessageBase64,Base64.DEFAULT);\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        final int blockSize = cipher.getBlockSize();\n\n        // create the key\n        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, \"AES\");\n\n        // retrieve random IV from start of the received message\n        final byte[] ivData = new byte[blockSize];\n        System.arraycopy(ivAndEncryptedMessage, 0, ivData, 0, blockSize);\n        final IvParameterSpec iv = new IvParameterSpec(ivData);\n\n        // retrieve the encrypted message itself\n        final byte[] encryptedMessage = new byte[ivAndEncryptedMessage.length\n                - blockSize];\n        System.arraycopy(ivAndEncryptedMessage, blockSize,\n                encryptedMessage, 0, encryptedMessage.length);\n\n        cipher.init(Cipher.DECRYPT_MODE, symKey, iv);\n\n        final byte[] encodedMessage = cipher.doFinal(encryptedMessage);\n\n        // concatenate IV and encrypted message\n        final String message = new String(encodedMessage,\n                Charset.forName(\"UTF-8\"));\n\n        return message;\n    } catch (InvalidKeyException e) {\n        throw new IllegalArgumentException(\n                \"key argument does not contain a valid AES key\");\n    } catch (BadPaddingException e) {\n        // you'd better know about padding oracle attacks\n        return null;\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(\n                \"Unexpected exception during decryption\", e);\n    } catch (DecoderException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "public static String md5(String input) throws NoSuchAlgorithmException {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] messageDigest = md.digest(input.getBytes());\n    BigInteger number = new BigInteger(1, messageDigest);\n    return number.toString(16);\n}\n\npublic String decrypt(String encryptedData, String initialVectorString, String secretKey) {\n    String decryptedData = null;\n    try {\n        SecretKeySpec skeySpec = new SecretKeySpec(md5(secretKey).getBytes(), \"AES\");\n        IvParameterSpec initialVector = new IvParameterSpec(initialVectorString.getBytes());\n        Cipher cipher = Cipher.getInstance(\"AES/CFB8/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, initialVector);\n        byte[] encryptedByteArray = (new org.apache.commons.codec.binary.Base64()).decode(encryptedData.getBytes());\n        byte[] decryptedByteArray = cipher.doFinal(encryptedByteArray);\n        decryptedData = new String(decryptedByteArray, \"UTF8\");\n    } catch (Exception e) {\n        LOGGER.debug(\"Problem decrypting the data\", e);\n    }\n    return decryptedData;\n}\n", "byte[] keyBytes = KeyGenerator.getInstance(\"AES\").getEncoded();\n\n...\n\nSecretKeySpec skeySpec = new SecretKeySpec(keyBytes, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.DECRYPT_MODE, skeySpec);\n", "import java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\n\npublic class CustomSSLSocketFactory extends SSLSocketFactory{\n      SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n      /**\n       * Generate Certificate for ssl connection\n       * @param truststore\n       * @throws NoSuchAlgorithmException\n       * @throws KeyManagementException\n       * @throws KeyStoreException\n       * @throws UnrecoverableKeyException\n       */\n      public CustomSSLSocketFactory(KeyStore truststore)\n                  throws NoSuchAlgorithmException, KeyManagementException,\n                  KeyStoreException, UnrecoverableKeyException {\n            super(truststore);\n            TrustManager tm = new X509TrustManager(){\n                  @Override\n                  public void checkClientTrusted(X509Certificate[] arg0, String arg1)\n                              throws CertificateException {\n                  }\n                  @Override\n                  public void checkServerTrusted(X509Certificate[] chain,\n                              String authType) throws CertificateException {\n                  }\n                  @Override\n                  public X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                  }\n            };\n            sslContext.init(null, new TrustManager[] {tm}, null);\n      }\n\n      @Override\n      public Socket createSocket(Socket socket, String host, int port,\n                  boolean autoClose) throws IOException, UnknownHostException {\n            return sslContext.getSocketFactory().createSocket(socket, host, port,\n                        autoClose);\n      }\n\n      @Override\n      public Socket createSocket() throws IOException {\n            return sslContext.getSocketFactory().createSocket();\n      }\n}\n", "import java.security.KeyStore;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpParams;\n\npublic class HTTPUtils {\n      /**\n       * HttpClient\n       * @param isHTTPS\n       * @return\n       */\n      public static HttpClient getNewHttpClient(boolean isHTTPS) {\n            try {\n                  if(!isHTTPS){\n                        return getNewHttpClient();\n                  }\n                  KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                  trustStore.load(null, null);\n                  SSLSocketFactory sf = new CustomSSLSocketFactory(trustStore);\n                  sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n                  HttpParams params = new BasicHttpParams();\n                  SchemeRegistry registry = new SchemeRegistry();\n                  registry.register(new Scheme(\"https\", sf, 443));\n\n                  ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n                  return new DefaultHttpClient(ccm, params);\n            } catch (Exception e) {\n                  return null;\n            }\n      }\n      /**\n       * HttpClient for http request\n       * @return\n       */\n      private static HttpClient getNewHttpClient(){\n            HttpParams params = new BasicHttpParams();\n            return new DefaultHttpClient(params);\n      }\n}\n", "try {\n    // Taken from: http://blog.alcor.se/index.php/2013/08/09/using-java-to-connect-with-sslsocket-trusting-all-certificates/\n    // Create a trust manager that does not validate certificate chains\n    TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n        @Override\n        public void checkClientTrusted(java.security.cert.X509Certificate[]\n                                               chain, String authType) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(java.security.cert.X509Certificate[]\n                                               chain, String authType) throws CertificateException {\n        }\n\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n    };\n\n    // Install the all-trusting trust manager\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new java.security.SecureRandom());\n\n    SSLSocketFactory sslsocketfactory = sc.getSocketFactory();\n    sslsocket = (SSLSocket) sslsocketfactory.createSocket(targetIp, port);\n    sslsocket.setKeepAlive(true);\n    // Sets this socket's read timeout in milliseconds.\n    // sslsocket.setSoTimeout(timeoutSocket);\n\n    Log.d(TAG, \"Sending: \" + xmlAction + xmlValue + XmlConstants.NEW_LINE);\n    String line;\n    ArrayList&lt;String&gt; receivedLines = new ArrayList&lt;String&gt;();\n\n    DataOutputStream outToServerSSL = new DataOutputStream(sslsocket.getOutputStream());\n    BufferedReader inFromServerSSL = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n    outToServerSSL.writeBytes(xmlAction + xmlValue + XmlConstants.NEW_LINE + XmlConstants.NEW_LINE);\n\n    while ((line = inFromServerSSL.readLine()) != null) {\n        receivedLines.add(line);\n        Log.d(TAG, \"Received: \" + line);\n    }\n\n    Log.d(TAG, \"Closing tha sizzle\");\n    inFromServerSSL.close();\n    outToServerSSL.close();\n\n    return ParseXmlForStatusCode(receivedLines);\n\n} catch (NoSuchAlgorithmException e) {\n    e.printStackTrace();\n} catch (UnknownHostException e) {\n    e.printStackTrace();\n} catch (KeyManagementException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (sslsocket != null) {\n        try {\n            sslsocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "public static SSLContext getSSLContext() throws Exception {\n        if (sslContext==null) {\n            // loading CA from an InputStream\n            InputStream is = AVApplication.getContext().getResources().openRawResource(R.raw.wildcard);\n            String certificates = Converter.convertStreamToString(is);\n            String certificateArray[] = certificates.split(\"-----BEGIN CERTIFICATE-----\");\n\n            // creating a KeyStore containing our trusted CAs\n            KeyStore ks = KeyStore.getInstance(\"BKS\");\n            ks.load(null, null);\n            for (int i = 1; i &lt; certificateArray.length; i++) {\n                certificateArray[i] = \"-----BEGIN CERTIFICATE-----\" + certificateArray[i];\n                //LogAV.d(\"cert:\" + certificateArray[i]);\n\n                // generate input stream for certificate factory\n                InputStream stream = IOUtils.toInputStream(certificateArray[i]);\n\n                // CertificateFactory\n                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                // certificate\n                Certificate ca;\n                try {\n                    ca = cf.generateCertificate(stream);\n                } finally {\n                    is.close();\n                }\n\n                ks.setCertificateEntry(\"av-ca\" + i, ca);\n            }\n            // TrustManagerFactory\n            String algorithm = TrustManagerFactory.getDefaultAlgorithm();\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);\n            // Create a TrustManager that trusts the CAs in our KeyStore\n            tmf.init(ks);\n\n            // Create a SSLContext with the certificate that uses tmf (TrustManager)\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, tmf.getTrustManagers(), new SecureRandom());\n        }\n\n        return sslContext;\n    }\n", "byte[] cipherTextBytes = DatatypeConverter.parseBase64Binary(cipherText);\nbyte[] privateKeyBytes = DatatypeConverter.parseBase64Binary(privateKeyStr);\n\nKeyFactory kf = KeyFactory.getInstance(\"RSA\");\nPKCS8EncodedKeySpec ks = new PKCS8EncodedKeySpec(privateKeyBytes);\nPrivateKey privateKey = kf.generatePrivate(ks);\n\nCipher c = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\nc.init(Cipher.DECRYPT_MODE, privateKey, new OAEPParameterSpec(\"SHA-256\",\n        \"MGF1\", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT));\nbyte[] plainTextBytes = c.doFinal(cipherTextBytes);\nString plainText = new String(plainTextBytes);\n\nSystem.out.println(plainText);\n", "/**\n * Same security, twice the speed.\n */\npublic static String generateStorngPasswordHashWithSHA256(String password) {\n    try {\n        char[] chars = password.toCharArray();\n        byte[] salt = getSalt();\n\n        PBEKeySpec spec = new PBEKeySpec(chars, salt, 1010101,\n                20 * Byte.SIZE);\n        SecretKeyFactory skf = SecretKeyFactory\n                .getInstance(\"PBKDF2WithHmacSHA1\");\n        byte[] hash = skf.generateSecret(spec).getEncoded();\n\n        MessageDigest sha256 = MessageDigest.getInstance(\"SHA-256\");\n        hash = sha256.digest();\n\n        return toHex(salt) + \":\" + toHex(hash);\n    } catch (Exception e) {\n        System.out.println(\"Exception: Error in generating password\"\n                + e.toString());\n    }\n    return \"\";\n}\n", "public static byte[] encrypt(byte[] bytes, byte[] key, byte[] iv)\n        throws Exception\n{\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/ISO10126Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"),\n            new IvParameterSpec(iv));\n    return cipher.doFinal(bytes);\n}\n", "KeyStore selfsignedKeys = KeyStore.getInstance(\"BKS\");\nselfsignedKeys.load(context.getResources().openRawResource(R.raw.selfsignedcertsbks),\n\"genericPassword\".toCharArray());\nTrustManagerFactory trustMgr = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntrustMgr.init(selfsignedKeys);\nSSLContext selfsignedSSLcontext = SSLContext.getInstance(\"TLS\");\nselfsignedSSLcontext.init(null, trustMgr.getTrustManagers(), new SecureRandom());\nHttpsURLConnection.setDefaultSSLSocketFactory(selfsignedSSLcontext.getSocketFactory());\nURL serverURL = new URL(\"https://server.example.com/endpointTest\");\nHttpsURLConnection serverConn = (HttpsURLConnection)serverURL.openConnection();\n", "SecretKey key = getEncryptionKey(); \nbyte[] iv = new byte[] { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, (byte)144, (byte)233, 122, 100 };\nbyte[] cipherBytes = readEncryptedFile();\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nIvParameterSpec ivParams = new IvParameterSpec(iv);\ncipher.init(Cipher.DECRYPT_MODE, key, ivParams);\nbyte[] plaintext = cipher.doFinal(cipherBytes);\n", "MessageDigest md = MessageDigest.getInstance(\"SHA\");\nmd.update(signatures[0].toByteArray());\nString signature = Base64.encodeToString(md.digest(), Base64.DEFAULT);\nif (!signature.equals(SIGNATURE_KEY)){\n    //do your logic\n}\n", "public class SimpleOTPGenerator {\n\n\n    protected SimpleOTPGenerator() {\n    }\n\n    public static String random(int size) {\n\n        StringBuilder generatedToken = new StringBuilder();\n        try {\n            SecureRandom number = SecureRandom.getInstance(\"SHA1PRNG\");\n            // Generate 20 integers 0..20\n            for (int i = 0; i &lt; size; i++) {\n                generatedToken.append(number.nextInt(9));\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n\n        return generatedToken.toString();\n    }\n}\n", "public class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public MySSLSocketFactory(KeyStore truststore)\n                    throws NoSuchAlgorithmException, KeyManagementException,\n                    KeyStoreException, UnrecoverableKeyException {\n            super(truststore);\n\n            TrustManager tm = new X509TrustManager() {\n                    public void checkClientTrusted(X509Certificate[] chain,\n                                    String authType) throws CertificateException {\n                    }\n\n                    public void checkServerTrusted(X509Certificate[] chain,\n                                    String authType) throws CertificateException {\n                    }\n\n                    public X509Certificate[] getAcceptedIssuers() {\n                            return null;\n                    }\n            };\n\n            sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port,\n                    boolean autoClose) throws IOException, UnknownHostException {\n            return sslContext.getSocketFactory().createSocket(socket, host, port,\n                            autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n            return sslContext.getSocketFactory().createSocket();\n    }\n\n}\n", "public class WebClientDevWrapper {\n\n    public static HttpClient getNewHttpClient() {\n         try {\n             KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n             trustStore.load(null, null);\n\n             SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n             sf.setHostnameVerifier(\n                    SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n             HttpParams params = new BasicHttpParams();\n             HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n             HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n             SchemeRegistry registry = new SchemeRegistry();\n             registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n             registry.register(new Scheme(\"https\", sf, 443));\n\n             ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n             return new DefaultHttpClient(ccm, params);\n         } catch (Exception e) {\n             return new DefaultHttpClient();\n         }\n     }\n\n}\n", "PackageInfo info;\ntry {\n    info = getPackageManager().getPackageInfo(\"com.your.project.package\", PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String something = new String(Base64.encode(md.digest(), 0));\n        //String something = new String(Base64.encodeBytes(md.digest()));\n        Log.e(\"hash key\", something);\n    }\n} catch (PackageManager.NameNotFoundException e1) {\n    Log.e(\"name not found\", e1.toString());\n} catch (NoSuchAlgorithmException e) {\n    Log.e(\"no such an algorithm\", e.toString());\n} catch (Exception e) {\n    Log.e(\"exception\", e.toString());\n}\n", "static void encrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    // Here you read the cleartext.\n    FileInputStream fis = new FileInputStream(\"data/cleartext\");\n    // This stream write the encrypted text. This stream will be wrapped by another stream.\n    FileOutputStream fos = new FileOutputStream(\"data/encrypted\");\n\n    // Length is 16 byte\n    // Careful when taking user input!!! http://stackoverflow.com/a/3452620/1188357\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n    // Create cipher\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);\n    // Wrap the output stream\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n    // Write bytes\n    int b;\n    byte[] d = new byte[8];\n    while((b = fis.read(d)) != -1) {\n        cos.write(d, 0, b);\n    }\n    // Flush and close streams.\n    cos.flush();\n    cos.close();\n    fis.close();\n}\n", "private static char[] hexDigits = \"0123456789abcdef\".toCharArray();\n\npublic String md5(InputStream is) throws IOException\n{\n    byte[] bytes = new byte[4096];\n    int read = 0;\n    MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n    while ((read = is.read(bytes)) != -1)\n    {\n        digest.update(bytes, 0, read);\n    }\n\n    byte[] messageDigest = digest.digest();\n\n    StringBuilder sb = new StringBuilder(32);\n\n    // Oh yeah, this too.  Integer.toHexString doesn't zero-pad, so\n    // (for example) 5 becomes \"5\" rather than \"05\".\n    for (byte b : messageDigest)\n    {\n        sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);\n        sb.append(hexDigits[b &amp; 0x0f]);\n    }\n\n    return sb.toString();\n}\n", "private void printHashKey()\n{\n    try\n    {\n        PackageInfo info = getPackageManager().getPackageInfo(\"com.your.package\",\n            PackageManager.GET_SIGNATURES);\n        for (Signature signature: info.signatures)\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"YOUR HASH KEY:\",\n                Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    }\n    catch (NameNotFoundException e)\n    {\n\n    }\n    catch (NoSuchAlgorithmException e)\n    {\n\n    }\n}\n", "final MessageDigest digest = MessageDigest.getInstance(\"SHA-1\");\nresult = digest.digest(stringToHash.getBytes(\"UTF-8\");\n\n// Another way to make HEX, my previous post was only the method like your solution\nStringBuilder sb = new StringBuilder();\n\nfor (byte b : result) // This is your byte[] result..\n{\n    sb.append(String.format(\"%02X\", b));\n}\n\nString messageDigest = sb.toString();\n", "try {\n        info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md;\n\n                md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String something = new String(Base64.encode(md.digest(), 0));\n                Log.e(\"hash key\", something);\n        } \n    } catch (NameNotFoundException e1) {            \n        Log.e(\"name not found\", e1.toString());\n    } catch (NoSuchAlgorithmException e) {\n             Log.e(\"no such an algorithm\", e.toString());\n     }catch (Exception e){\n             Log.e(\"exception\", e.toString());\n     }\n", "public class SecurityUtils {\n\npublic static final String KEY_DERIVATION_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n\nprivate static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\nprivate static final String DELIMITER = \"]\";\n\nprivate static final int KEY_LENGTH = 256;\n\nprivate static final int ITERATION_COUNT = 1000;\n\nprivate static final int SALT_LENGTH = 8;\n\nprivate static SecureRandom random = new SecureRandom();\n\nstatic {\n    Security.addProvider(new org.spongycastle.jce.provider.BouncyCastleProvider());\n}\n\n\npublic static String encrypt(Context context, String plaintext)\n        throws Exception {\n    byte[] salt = generateSalt();\n    return encrypt(plaintext, getKey(salt, getPassword(context)), salt);\n}\n\nprivate static String encrypt(String plaintext, SecretKey key, byte[] salt)\n        throws Exception {\n    try {\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM, \"BC\");\n\n        byte[] iv = generateIv(cipher.getBlockSize());\n        IvParameterSpec ivParams = new IvParameterSpec(iv);\n\n        cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);\n        byte[] cipherText = cipher.doFinal(plaintext.getBytes(\"UTF-8\"));\n\n        if (salt != null) {\n            return String.format(\"%s%s%s%s%s\",\n                    new String(Base64.encode(salt)), DELIMITER, new String(\n                            Base64.encode(iv)), DELIMITER, new String(\n                            Base64.encode(cipherText)));\n        }\n\n        return String.format(\"%s%s%s\", new String(Base64.encode(iv)),\n                DELIMITER, new String(Base64.encode(cipherText)));\n    } catch (Throwable e) {\n        throw new Exception(\"Error while encryption\", e);\n    }\n}\n\npublic static String decrypt(Context context, String ciphertext)\n        throws Exception {\n    return decrypt(ciphertext, getPassword(context));\n}\n\nprivate static String decrypt(String ciphertext, String password)\n        throws Exception {\n    String[] fields = ciphertext.split(DELIMITER);\n    if (fields.length != 3) {\n        throw new IllegalArgumentException(\"Invalid encypted text format\");\n    }\n    try {\n        byte[] salt = Base64.decode(fields[0]);\n        byte[] iv = Base64.decode(fields[1]);\n        byte[] cipherBytes = Base64.decode(fields[2]);\n\n        SecretKey key = getKey(salt, password);\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM, \"BC\");\n        IvParameterSpec ivParams = new IvParameterSpec(iv);\n        cipher.init(Cipher.DECRYPT_MODE, key, ivParams);\n        byte[] plaintext = cipher.doFinal(cipherBytes);\n        String plainrStr = new String(plaintext, \"UTF-8\");\n\n        return plainrStr;\n    } catch (Throwable e) {\n        throw new Exception(\"Error while decryption\", e);\n    }\n}\n\nprivate static String getPassword(Context context) {\n\n    return \"My secret password\";\n}\n\nprivate static SecretKey getKey(byte[] salt, String password)\n        throws Exception {\n    try {\n        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,\n                ITERATION_COUNT, KEY_LENGTH);\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\n                KEY_DERIVATION_ALGORITHM, \"BC\");\n        byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\n        return new SecretKeySpec(keyBytes, \"AES\");\n    } catch (Throwable e) {\n        throw new Exception(\"Error while generating key\", e);\n    }\n}\n\nprivate static byte[] generateIv(int length) {\n    byte[] b = new byte[length];\n    random.nextBytes(b);\n\n    return b;\n}\n\nprivate static byte[] generateSalt() {\n    byte[] b = new byte[SALT_LENGTH];\n    random.nextBytes(b);\n\n    return b;\n}\n", "  private void getHashKey()\n   {\n           PackageInfo info;\n           try {\n           info = getPackageManager().getPackageInfo(\"Your_Package_Name\", PackageManager.GET_SIGNATURES);\n           for (Signature signature : info.signatures) {MessageDigest md;\n           md = MessageDigest.getInstance(\"SHA\");\n           md.update(signature.toByteArray());\n                      //String something = new String(Base64.encode(md.digest(), 0));\n                        String something = new String(Base64.encode(md.digest(),0));\n                      Log.e(\"** Hash Key\", something);\n           }\n           }\n           catch (NameNotFoundException e1) {\n           Log.e(\"name not found\", e1.toString());\n           }\n\n           catch (NoSuchAlgorithmException e) {\n           Log.e(\"no such an algorithm\", e.toString());\n           }\n           catch (Exception e){\n           Log.e(\"exception\", e.toString());\n           }\n\n   }\n", "//use to encrypt key\npublic static byte[] encryptA(byte[] value) throws GeneralSecurityException, IOException\n{\n    SecretKeySpec sks = getSecretKeySpec(true);\n    System.err.println(\"encrypt():\\t\" + sks.toString());\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks, cipher.getParameters());\n    byte[] encrypted = cipher.doFinal(value);\n    return encrypted;\n}\n\n//use to encrypt data\npublic static byte[] encrypt2(byte[] value) throws GeneralSecurityException, IOException\n{\n    SecretKeySpec key1 = getSecretKeySpec(true);\n    System.err.println(\"encrypt():\\t\" + key1.toString());\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key1, cipher.getParameters());\n    byte[] encrypted = cipher.doFinal(value);\n\n    SecretKeySpec key2 = getSecretKeySpec(false);\n    System.err.println(\"encrypt():\\t\" + key2.toString());\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, key2, new IvParameterSpec(getIV()));\n    byte[] encrypted2 = cipher.doFinal(encrypted);\n\n    return encrypted2;//Base64Coder.encode(encrypted2);\n}\n//use to decrypt data\npublic static byte[] decrypt2(byte[] message, boolean A) throws GeneralSecurityException, IOException\n{\n    SecretKeySpec key1 = getSecretKeySpec(false);\n    System.err.println(\"decrypt():\\t\" + key1.toString());\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, key1, new IvParameterSpec(getIV()));\n    byte[] decrypted = cipher.doFinal(message);\n\n    SecretKeySpec key2 = getSecretKeySpec(true);\n    System.err.println(\"decrypt():\\t\" + key2.toString());\n    cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key2);\n    byte[] decrypted2 = cipher.doFinal(decrypted);\n\n    return decrypted2;\n}\n\n    //use to decrypt key\npublic static byte[] decryptKey(String message, byte[] key) throws GeneralSecurityException\n{\n    SecretKeySpec sks = new SecretKeySpec(key, ALGORITHM);\n    System.err.println(\"decryptKey()\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n    byte[] decrypted = cipher.doFinal(Base64Coder.decode(message));\n    return decrypted;\n}\n\n//method for fetching keys\nprivate static SecretKeySpec getSecretKeySpec(boolean fromSO) throws NoSuchAlgorithmException, IOException, GeneralSecurityException\n{\n    return new SecretKeySpec(fromSO ? getKeyBytesFromSO() : getKeyBytesFromAssets(), \"AES\");\n}\n", "KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\nks.load(null, null);\nEnumeration aliases = ks.aliases();\nwhile (aliases.hasMoreElements()) {\n    String alias = aliases.nextElement();\n    X509Certificate cert = (X509Certificate) \n       ks.getCertificate(alias);\n    Log.d(TAG, \"Subject DN: \" + \n       cert.getSubjectDN().getName());\n    Log.d(TAG, \"Subject SN: \" + \n       cert.getSerialNumber().toString());\n    Log.d(TAG, \"Issuer DN: \" + \n       cert.getIssuerDN().getName());\n}\n", "public class MultipartUtility {\n\n    FileUploadListener listener;\n    private static final int BUFFER_SIZE = 1024;\n    private static final int TIME_OUT = 3 * 60 * 1000;\n    private final String boundary;\n    private static final String LINE_FEED = \"\\r\\n\";\n    private HttpURLConnection httpConn;\n    private String charset;\n    private OutputStream outputStream;\n    private PrintWriter writer;\n    public int statusCode;\n    public String mURL;\n\n    public interface FileUploadListener {\n        void onUpdateProgress(int percentage, long kb);\n\n        boolean isCanceled();\n    }\n\n    /**\n     * This constructor initializes a new HTTP POST request with content type\n     * is set to multipart/form-data\n     *\n     * @param requestURL\n     * @param charset\n     * @throws IOException\n     */\n    public MultipartUtility(String requestURL, String charset, FileUploadListener listener)\n            throws IOException {\n        this.charset = charset;\n        this.listener = listener;\n        mURL = requestURL;\n        // creates a unique boundary based on time stamp\n        boundary = \"\" + System.currentTimeMillis() + \"\";\n\n        URL url = new URL(requestURL);\n        httpConn = null;\n        if (url.getProtocol().toLowerCase().equals(\"https\")) {\n            trustAllHosts();\n            HttpsURLConnection https = (HttpsURLConnection) url.openConnection();\n            https.setHostnameVerifier(new HostnameVerifier() {\n                @Override\n                public boolean verify(String hostname, SSLSession session) {\n                    return true;\n                }\n            });\n            httpConn = https;\n        } else {\n            httpConn = (HttpURLConnection) url.openConnection();\n        }\n\n        // httpConn.setConnectTimeout(TIME_OUT);\n        //httpConn.setReadTimeout(TIME_OUT);\n        httpConn.setUseCaches(false);\n        httpConn.setDoOutput(true); // indicates POST method\n        httpConn.setDoInput(true);\n        httpConn.setChunkedStreamingMode(BUFFER_SIZE);\n        httpConn.setRequestMethod(\"POST\");\n        httpConn.setRequestProperty(\"Content-Type\",\n                \"multipart/form-data; boundary=\" + boundary);\n        httpConn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        outputStream = httpConn.getOutputStream();\n        writer = new PrintWriter(new OutputStreamWriter(outputStream, charset),\n                true);\n    }\n\n    private static void trustAllHosts() {\n        // Create a trust manager that does not validate certificate chains\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return new java.security.cert.X509Certificate[]{};\n            }\n\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n        }};\n\n        // Install the all-trusting trust manager\n        try {\n            SSLContext sc = SSLContext.getInstance(\"TLS\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    /**\n     * Adds a form field to the request\n     *\n     * @param name  field name\n     * @param value field value\n     */\n    public void addFormField(String name, String value) {\n        writer.append(\"--\" + boundary).append(LINE_FEED);\n        writer.append(\"Content-Disposition: form-data; name=\\\"\" + name + \"\\\"\")\n                .append(LINE_FEED);\n        writer.append(\"Content-Type: text/plain; charset=\" + charset).append(\n                LINE_FEED);\n        writer.append(LINE_FEED);\n        writer.append(value).append(LINE_FEED);\n        writer.flush();\n    }\n\n    /**\n     * Adds a upload file section to the request\n     *\n     * @param fieldName name attribute in &lt;input type=\"file\" name=\"...\" /&gt;\n     * @param uploadFile a File to be uploaded\n     * @throws IOException\n     */\n    private long lastProgressUpdateTime = 0;\n\n    public void addFilePart(String fieldName, File uploadFile)\n            throws IOException {\n        String fileName = uploadFile.getName();\n        writer.append(\"--\" + boundary).append(LINE_FEED);\n        writer.append(\n                \"Content-Disposition: form-data; name=\\\"\" + fieldName\n                        + \"\\\"; filename=\\\"\" + fileName + \"\\\"\")\n                .append(LINE_FEED);\n        writer.append(\n                \"Content-Type: \"\n                        + URLConnection.guessContentTypeFromName(fileName))\n                .append(LINE_FEED);\n        writer.append(\"charset=\" + charset).append(\n                LINE_FEED);\n        writer.append(LINE_FEED);\n        writer.flush();\n\n        outputStream.flush();\n        byte[] buffer = new byte[BUFFER_SIZE];\n\n        try {\n            final FileInputStream inputStream = new FileInputStream(uploadFile);\n            long totalRead = 0;\n            long totalSize = uploadFile.length();\n\n            int read;\n            while ((read = inputStream.read(buffer)) &gt; 0) {\n                totalRead += read;\n                int percentage = (int) ((totalRead / (float) totalSize) * 100);\n                outputStream.write(buffer, 0, read);\n\n                long now = System.currentTimeMillis();\n                if (lastProgressUpdateTime == 0 || lastProgressUpdateTime &lt; now - 100) {\n                    lastProgressUpdateTime = now;\n\n                    Log.e(\"\", totalRead + \" \" + \" \" + percentage);\n\n                    if (listener != null)\n                        this.listener.onUpdateProgress(percentage, totalRead);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            outputStream.flush();\n        }\n\n        writer.append(LINE_FEED);\n        writer.flush();\n    }\n\n\n    /**\n     * Adds a header field to the request.\n     *\n     * @param name  - name of the header field\n     * @param value - value of the header field\n     */\n    public void addHeaderField(String name, String value) {\n        writer.append(name + \": \" + value).append(LINE_FEED);\n        writer.flush();\n    }\n\n    /**\n     * Completes the request and receives response from the server.\n     *\n     * @return a list of Strings as response in case the server returned\n     * status OK, otherwise an exception is thrown.\n     * @throws IOException\n     */\n    public String Execute() throws IOException {\n        String responses = \"\";\n\n        writer.append(LINE_FEED).flush();\n        writer.append(\"--\" + boundary + \"--\").append(LINE_FEED);\n        writer.close();\n        StringBuilder sb = new StringBuilder();\n        try {\n            // checks server's status code first\n            statusCode = httpConn.getResponseCode();\n            if (Constants.IS_DEBUG) {\n                Log.v(Constants.TAG, \"Url: \" + mURL);\n                Log.e(\"\", \"response code :\" + statusCode);\n            }\n            //responses = ;\n\n            sb.append(\"\" + Utility.convertStreamToString(httpConn.getInputStream()) + \"\\n\");\n\n            if (statusCode == HttpURLConnection.HTTP_OK) {\n                httpConn.disconnect();\n            }\n            responses = sb.toString();\n            Log.v(Constants.TAG, \" response: \" + responses);\n            return responses;\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n            sb = new StringBuilder();\n\n            sb.append(\"\" + Utility.convertStreamToString(httpConn.getErrorStream()) + \"\\n\");\n\n            responses = sb.toString();\n            Log.v(Constants.TAG, \"Error response: \" + responses);\n        }\n        return responses;\n    }\n}\n", "    // Create a trust manager that does not validate certificate chains\n    TrustManager[] trustAllCerts = new TrustManager[]{\n        new X509TrustManager() {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n            public void checkClientTrusted(\n                java.security.cert.X509Certificate[] certs, String authType) {\n            }\n            public void checkServerTrusted(\n                java.security.cert.X509Certificate[] certs, String authType) {\n            }\n        }\n    };\n\n    // Install the all-trusting trust manager\n    // Try \"SSL\" or Replace with \"TLS\"\n    try {\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n    } catch (Exception e) {\n    }\n\n    // Now you can access an https URL without having the certificate in the truststore \n           // Your Code Goes Here\n", "public void generateHashKeyForFacebook(Context context) throws Exception {\n        try {   \n            PackageInfo info = context.getPackageManager().getPackageInfo(\"com.yourPackageName\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"FBKeyHash &gt;&gt;&gt; \", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "public class MySSLSocketFactory extends SSLSocketFactory {\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n        ...\n\n        @Override\n        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n            final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n            sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());\n            return sslSocket;\n        }\n\n        @Override\n        public Socket createSocket() throws IOException {\n            final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket();\n            sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());\n            return sslSocket;\n        }\n}\n", "    public class SimpleSSLSocketFactory extends\n    org.apache.http.conn.ssl.SSLSocketFactory {\nprivate javax.net.ssl.SSLSocketFactory sslFactory = HttpsURLConnection\n        .getDefaultSSLSocketFactory();\n\npublic SimpleSSLSocketFactory(KeyStore truststore)\n        throws NoSuchAlgorithmException, KeyManagementException,\n        KeyStoreException, UnrecoverableKeyException {\n    super(null);\n    try {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        TrustManager[] trustAllCerts = new TrustManager[] { new  \n\n                 X509TrustManager() {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return new java.security.cert.X509Certificate[] {};\n            }\n            public void checkClientTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n        } };\n\n        // Initialize the socket factory\n        context.init(null, trustAllCerts, new SecureRandom());\n        sslFactory = context.getSocketFactory();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n@Override\npublic Socket createSocket(Socket socket, String host, int port,\n        boolean autoClose) throws IOException, UnknownHostException {\n    return sslFactory.createSocket(socket, host, port, autoClose);\n}\n\n@Override\npublic Socket createSocket() throws IOException {\n    return sslFactory.createSocket();\n}\n", "public class DataLoader {\nDefaultHttpClient sslClient;\nprivate boolean silent;\n\npublic class CustomX509TrustManager implements X509TrustManager {\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n    }\n\n    @Override\n    public void checkServerTrusted(\n            java.security.cert.X509Certificate[] certs, String authType)\n            throws CertificateException {\n    }\n\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}\n\npublic class CustomSSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public CustomSSLSocketFactory(KeyStore truststore)\n            throws NoSuchAlgorithmException, KeyManagementException,\n            KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n        TrustManager tm = new CustomX509TrustManager();\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    public CustomSSLSocketFactory(SSLContext context)\n            throws KeyManagementException, NoSuchAlgorithmException,\n            KeyStoreException, UnrecoverableKeyException {\n        super(null);\n        sslContext = context;\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port,\n            boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host,\n                port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n}\n\npublic HttpResponse execute(HttpUriRequest request) {\n    if (!(silent)) {\n        Log.i(\"Performing request\", \"Performing request\");\n        for (Header header : request.getAllHeaders())\n            Log.i(\"Performing request\",\n                    \"Performing request \"\n                            + new StringBuilder()\n                                    .append(\"Request header: \")\n                                    .append(header.getName()).append(\" - \")\n                                    .append(header.getValue()).toString());\n    }\n    HttpResponse response = null;\n    try {\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n        ctx.init(null, new TrustManager[] { new CustomX509TrustManager() },\n                new SecureRandom());\n        HttpClient client = new DefaultHttpClient();\n        SSLSocketFactory ssf = new CustomSSLSocketFactory(ctx);\n        ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        ClientConnectionManager ccm = client.getConnectionManager();\n        SchemeRegistry sr = ccm.getSchemeRegistry();\n        sr.register(new Scheme(\"https\", ssf, 443));\n        sslClient = new DefaultHttpClient(ccm, client.getParams());\n        response = sslClient.execute(request);\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return response;\n}\n", "private PackageInfo INFO = null; //global declaration\n    public void generateHashKeyForFacebook(Context context) throws Exception {\n            try {\n                INFO = context.getPackageManager().getPackageInfo(\"com.bito1.Shoplu\", PackageManager.GET_SIGNATURES);\n                if (INFO == null) {\n                    Toast.makeText(context.getApplicationContext(), \"Invalid Package Name / Package not found\", Toast.LENGTH_LONG).show();\n                    return;\n                }\n                for (Signature signature : INFO.signatures) {\n                    MessageDigest _md = MessageDigest.getInstance(\"SHA\");\n                    _md.update(signature.toByteArray());\n                    Log.d(\"KeyHash: =&gt;\", Base64.encodeToString(_md.digest(), Base64.DEFAULT));\n                }\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n            } catch (NoSuchAlgorithmException e) {\n                e.printStackTrace();\n            }\n        }\n", "/**\n * Parses an Android public RSA key like stored under .android/adbkey.pub and returns a Java public RSA key.\n * @param inputKey The Android public key.\n * @return the public RSA key.\n * @throws Exception\n */\npublic static PublicKey parseAndroidPubKey(String inputKey) {\n    BufferedReader bufferedReader = new BufferedReader(new StringReader(inputKey));\n    String line = null;\n    try {\n        line = bufferedReader.readLine();\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n    line = line.replaceAll(\" .*@.*\", \"\");\n    byte[] raw = Base64.getDecoder().decode(line);\n    ByteBuffer bb = ByteBuffer.wrap(raw);\n    bb.order(ByteOrder.LITTLE_ENDIAN);\n    IntBuffer intBuffer = bb.asIntBuffer();\n    int len = intBuffer.get();\n    BigInteger n0Inv = BigInteger.valueOf(intBuffer.get());\n    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(len*4);\n    int[] dst = new int[len];\n    intBuffer.get(dst);\n    ArrayUtils.reverse(dst);\n    for (int i = 0; i &lt; len; i++) {\n        int value = dst[i];\n        byte[] convertedBytes = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(value).array();\n        byteArrayOutputStream.write(convertedBytes, 0, convertedBytes.length);\n    }\n    byte[] n = byteArrayOutputStream.toByteArray();\n    byteArrayOutputStream.reset();\n    dst = new int[len];\n    intBuffer.get(dst);\n    ArrayUtils.reverse(dst);\n    for (int i = 0; i &lt; len; i++) {\n        int value = dst[i];\n        byte[] convertedBytes = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(value).array();\n        byteArrayOutputStream.write(convertedBytes, 0, convertedBytes.length);\n    }\n    int e = intBuffer.get();\n\n    RSAPublicKey publicKey;\n    try {\n        publicKey = (RSAPublicKey) KeyFactory.getInstance(\"RSA\").generatePublic(new RSAPublicKeySpec(new BigInteger(1, n), BigInteger.valueOf(e)));\n    } catch (Exception ex) {\n        throw new RuntimeException(ex);\n    }\n    return publicKey;\n}\n", "public HttpClient getNewHttpClient() throws SocketException, UnknownHostException {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", "public static String decrypt(String seed, String encrypted) throws Exception {\n  byte[] keyb = seed.getBytes(\"UTF-8\");\n  MessageDigest md = MessageDigest.getInstance(\"MD5\");\n  byte[] thedigest = md.digest(keyb);\n  SecretKeySpec skey = new SecretKeySpec(thedigest, \"AES/ECB/PKCS7Padding\");\n  Cipher dcipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\");\n  dcipher.init(Cipher.DECRYPT_MODE, skey);\n\n  byte[] clearbyte = dcipher.doFinal(toByte(encrypted));\n  return new String(clearbyte);\n}\n\npublic static byte[] toByte(String hexString) {\n  int len = hexString.length()/2;\n  byte[] result = new byte[len];\n  for (int i = 0; i &lt; len; i++)\n    result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n  return result;\n}\n", "// aesKey is 128, 196 or 256-bit key (8, 12 or 16 byte array)\nSecretKeySpec key = new SecretKeySpec(aesKey, \"AES\");\n\n// initialization vector\nIvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n// create and initialize cipher object\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\ncipher.init(Cipher.DECRYPT_MODE, key, ivSpec);\n", "// Algorithm, mode and padding must match encryption.\n// Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n\n// If you have Bouncycastle library installed, you can use\n// Rijndael/CBC/PKCS7PADDING directly.\nCipher cipher = Cipher.getInstance(\"Rijndael/CBC/PKCS7PADDING\");\n\n// convertedSecureString and initVector must be byte[] with correct length\ncipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(convertedSecureString, \"AES\"),\n    new IvParameterSpec(initVector));\n\nCipherInputStream cryptoStream = new CipherInputStream(inputStream, cipher);\nbyte[] buffer = new byte[1024];\nint len = cryptoStream.read(buffer, 0, buffer.length);\nwhile (len &gt; 0) {\n    outputStream.write(buffer, 0, len);\n    len = cryptoStream.read(buffer, 0, buffer.length);\n}\n\noutputStream.flush();\ncryptoStream.close();\n// no need to close inputStream here, as cryptoStream will close it\n", "public static String getMd5Hash(String input) {\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] messageDigest = md.digest(input.getBytes());\n        BigInteger number = new BigInteger(1, messageDigest);\n        String md5 = number.toString(16);\n        while (md5.length() &lt; 32)\n           md5 = \"0\" + md5;\n        return md5;\n        } catch (NoSuchAlgorithmException e) {\n         Log.e(\"MD5\", e.getLocalizedMessage());\n      return null;\n    }\n    }\n", "private static byte[] key = \"12345678\".getBytes();// 64 bit \nprivate static byte[] iv = \"12345678\".getBytes();\n\npublic static String encrypt(String in) {\n    String cypert = in;\n    try {\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        SecretKeySpec k = new SecretKeySpec(key, \"DES\");\n        Cipher c = Cipher.getInstance(\"DES/CBC/PKCS7Padding\");\n        c.init(Cipher.ENCRYPT_MODE, k, ivSpec);\n        byte[] encryptedData = c.doFinal(in.getBytes());\n        cypert = Base64.encodeLines(encryptedData);\n    } catch (Exception e) {\n        Debugger.error(e);\n    }\n    return cypert;\n}\n\n\npublic static String decrypt(String in) throws Exception {\n    String plain=in;\n    try {\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        SecretKeySpec keys = new SecretKeySpec(key, \"DES\");\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS7Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, keys, ivSpec);\n        // decryption pass\n        byte[] cipherText = Base64.decodeLines(in);\n        int ctLength = cipherText.length;\n        byte[] plainText = new byte[cipher.getOutputSize(ctLength)];\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        bos.write(cipher.doFinal(cipherText));\n        plainText = bos.toByteArray();\n        bos.close();\n        plain = new String(plainText, \"UTF8\");\n    } catch (Exception e) {\n        Debugger.error(e);\n    }\n    return plain;\n}\n", "public void generateKeys(){\n        try {\n     SharedPreferences SP;\n     SharedPreferences.Editor SPE;\n     KeyPairGenerator generator;\n                generator = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n                generator.initialize(256, new SecureRandom());\n                KeyPair pair = generator.generateKeyPair();\n                pubKey = pair.getPublic();\n                privKey = pair.getPrivate();            \n                byte[] publicKeyBytes = pubKey.getEncoded();\n                String pubKeyStr = new String(Base64.encode(publicKeyBytes));\n                byte[] privKeyBytes = privKey.getEncoded();\n                String privKeyStr = new String(Base64.encode(privKeyBytes));            \n                SPE = SP.edit();\n                SPE.putString(\"PublicKey\", pubKeyStr);\n                SPE.putString(\"PrivateKey\", privKeyStr);           \n                SPE.commit();\n\n  } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchProviderException e) {\n            e.printStackTrace();\n        }           \n    }\n\npublic PublicKey getPublicKey(){\n        String pubKeyStr = SP.getString(\"PublicKey\", \"\");       \n        byte[] sigBytes = Base64.decode(pubKeyStr);\n        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);\n        KeyFactory keyFact = null;\n        try {\n            keyFact = KeyFactory.getInstance(\"RSA\", \"BC\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchProviderException e) {\n            e.printStackTrace();\n        }\n        try {\n            return  keyFact.generatePublic(x509KeySpec);\n        } catch (InvalidKeySpecException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    public String getPublicKeyAsString(){\n        return SP.getString(\"PublicKey\", \"\");       \n    }\n    public PrivateKey getPrivateKey(){\n        String privKeyStr = SP.getString(\"PrivateKey\", \"\");\n        byte[] sigBytes = Base64.decode(privKeyStr);\n        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);\n        KeyFactory keyFact = null;\n        try {\n            keyFact = KeyFactory.getInstance(\"RSA\", \"BC\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchProviderException e) {\n            e.printStackTrace();\n        }\n        try {\n            return  keyFact.generatePrivate(x509KeySpec);\n        } catch (InvalidKeySpecException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n    public String getPrivateKeyAsString(){\n        return SP.getString(\"PrivateKey\", \"\");      \n    }\n", "Security.addProvider(new BouncyCastleProvider());\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    trustManagerFactory.init((KeyStore)null); //this is where you would add the truststore\n    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n    KeyStore keyStore = KeyStore.getInstance(\"PKCS12\"); //spongyCastle library\n    keyStore.load(new FileInputStream(\"D:\\\\Documents\\\\VISA Direct Api\\\\cabcentralcert.p12\"), \"cabcentral\".toCharArray()); //inputStream to PKCS12\n    keyManagerFactory.init(keyStore, \"cabcentral\".toCharArray());\n    //TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n    TrustManager[] trustAllCertManagers = { new X509TrustManager() { // this is vulnerable to MITM attack\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }};\n\n    sslContext.init(keyManagerFactory.getKeyManagers(), trustAllCertManagers, new SecureRandom());\n    URL url = new URL(strUrl);\n    HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) url.openConnection();\n    httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n\n    System.out.println(\"Response Code : \" + httpsUrlConnection.getResponseCode());\n    System.out.println(\"Cipher Suite : \" + httpsUrlConnection.getCipherSuite());\n", "        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }});\n    SSLContext context = SSLContext.getInstance(\"TLS\");\n    context.init(null, new X509TrustManager[]{new X509TrustManager(){\n        public void checkClientTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException {}\n        public void checkServerTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException {}\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }}}, new SecureRandom());\n    HttpsURLConnection.setDefaultSSLSocketFactory(\n            context.getSocketFactory());\n", "/**\n * @param input\n * @return decoded string\n */\npublic static String decode(String input) {\n    // Receiving side\n    String text = \"\";\n    try {\n        byte[] data = Decoder.decode(input);\n        text = new String(data, \"UTF-8\");\n        return text;\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n    return \"Error\";\n}\n", "try {\n   PackageInfo info = getPackageManager().getPackageInfo(\"com.yourcompany.client\", PackageManager.GET_SIGNATURES);\n   for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"Hash Key:\", Base64.encode(md.digest()));\n   }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "public String md5(String toConvert) {\n\n    String retVal = \"\";\n\n    MessageDigest algorithm;\n    try {\n        algorithm = MessageDigest.getInstance(\"MD5\");\n        algorithm.reset();\n        algorithm.update(toConvert.getBytes());\n        byte messageDigest[] = algorithm.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i &lt; messageDigest.length; i++) {\n            hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));\n        }\n        retVal = hexString + \"\";\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return retVal;\n}\n", "/**\n * The server has a SSL certificate. This method add SSL certificate to HTTP\n * Request\n */\npublic static void addSLLCertificateToHttpRequest() {\n    // Code to use verifier which return true.\n    try {\n        SSLContext sslctx = null;\n        try {\n            sslctx = SSLContext.getInstance(\"TLS\");\n            sslctx.init(null, new TrustManager[] { new X509TrustManager() {\n                public void checkClientTrusted(X509Certificate[] chain, String authType)\n                {\n                }\n\n                public void checkServerTrusted(X509Certificate[] chain, String authType)\n                {\n                }\n\n                public X509Certificate[] getAcceptedIssuers() {\n                    return new X509Certificate[] {};\n                }\n            } }, null);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        HttpsURLConnection.setDefaultSSLSocketFactory(sslctx.getSocketFactory());\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n", "import java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\n\npublic class StringEncrypter {\n\nCipher ecipher;\nCipher dcipher;\n\nStringEncrypter(String password) {\n\n    // 8-bytes Salt\n    byte[] salt = {\n        (byte)0xA9, (byte)0x9B, (byte)0xC8, (byte)0x32,\n        (byte)0x56, (byte)0x34, (byte)0xE3, (byte)0x03\n    };\n\n    // Iteration count\n    int iterationCount = 19;\n\n    try {\n\n        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, iterationCount);\n        SecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\n\n        ecipher = Cipher.getInstance(key.getAlgorithm());\n        dcipher = Cipher.getInstance(key.getAlgorithm());\n\n        // Prepare the parameters to the cipthers\n        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);\n\n        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n\n    } catch (InvalidAlgorithmParameterException e) {\n        System.out.println(\"EXCEPTION: InvalidAlgorithmParameterException\");\n    } catch (InvalidKeySpecException e) {\n        System.out.println(\"EXCEPTION: InvalidKeySpecException\");\n    } catch (NoSuchPaddingException e) {\n        System.out.println(\"EXCEPTION: NoSuchPaddingException\");\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println(\"EXCEPTION: NoSuchAlgorithmException\");\n    } catch (InvalidKeyException e) {\n        System.out.println(\"EXCEPTION: InvalidKeyException\");\n    }\n}\n\n\n/**\n * Takes a single String as an argument and returns an Encrypted version\n * of that String.\n * @param str String to be encrypted\n * @return &lt;code&gt;String&lt;/code&gt; Encrypted version of the provided String\n */\npublic byte[] encrypt(String str) {\n    try {\n        // Encode the string into bytes using utf-8\n        byte[] utf8 = str.getBytes(\"UTF8\");\n\n        // Encrypt\n        byte[] enc = ecipher.doFinal(utf8);\n\n        // Encode bytes to base64 to get a string\n        //return new sun.misc.BASE64Encoder().encode(enc);\n        return enc;\n\n    } catch (BadPaddingException e) {\n    } catch (IllegalBlockSizeException e) {\n    } catch (UnsupportedEncodingException e) {\n    }\n    return null;\n}\n\n\n/**\n * Takes a encrypted String as an argument, decrypts and returns the\n * decrypted String.\n * @param str Encrypted String to be decrypted\n * @return &lt;code&gt;String&lt;/code&gt; Decrypted version of the provided String\n */\npublic String decrypt(byte[] dec) {\n\n    try {\n\n        // Decode base64 to get bytes\n        //byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);\n        //byte[] dec = Base64Coder.decode(str);\n\n        // Decrypt\n        byte[] utf8 = dcipher.doFinal(dec);\n\n        // Decode using utf-8\n        return new String(utf8, \"UTF8\");\n\n    } catch (BadPaddingException e) {\n    } catch (IllegalBlockSizeException e) {\n    } catch (UnsupportedEncodingException e) {\n    }\n    return null;\n}\n", "PackageInfo info;\ntry {\n\n    info = getPackageManager().getPackageInfo(\n        \"com.example.worldmission\", PackageManager.GET_SIGNATURES);\n\n    for (Signature signature : info.signatures) {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String something = new String(Base64.encode(md.digest(), 0));\n        Log.e(\"Hash key\", something);\n        System.out.println(\"Hash key\" + something);\n    }\n\n} catch (NameNotFoundException e1) {\n    Log.e(\"name not found\", e1.toString());\n} catch (NoSuchAlgorithmException e) {\n    Log.e(\"no such an algorithm\", e.toString());\n} catch (Exception e) {\n    Log.e(\"exception\", e.toString());\n}\n", "YOUR PACKAGE;\n\nimport javax.activation.DataHandler;   \nimport javax.activation.DataSource;   \nimport javax.mail.Message;   \nimport javax.mail.PasswordAuthentication;   \nimport javax.mail.Session;   \nimport javax.mail.Transport;   \nimport javax.mail.internet.InternetAddress;   \nimport javax.mail.internet.MimeMessage;   \nimport java.io.ByteArrayInputStream;   \nimport java.io.IOException;   \nimport java.io.InputStream;   \nimport java.io.OutputStream;   \nimport java.security.Security;   \nimport java.util.Properties;   \n\npublic class GMailSender extends javax.mail.Authenticator {   \n    private String mailhost = \"smtp.gmail.com\";   \n    private String user;   \n    private String password;   \n    private Session session;   \n\n    static {   \n        Security.addProvider(new com.provider.JSSEProvider());   \n    }  \n\n    public GMailSender(String user, String password) {   \n        this.user = user;   \n        this.password = password;   \n\n        Properties props = new Properties();   \n        props.setProperty(\"mail.transport.protocol\", \"smtp\");   \n        props.setProperty(\"mail.host\", mailhost);   \n        props.put(\"mail.smtp.auth\", \"true\");   \n        props.put(\"mail.smtp.port\", \"465\");   \n        props.put(\"mail.smtp.socketFactory.port\", \"465\");   \n        props.put(\"mail.smtp.socketFactory.class\",   \n                \"javax.net.ssl.SSLSocketFactory\");   \n        props.put(\"mail.smtp.socketFactory.fallback\", \"false\");   \n        props.setProperty(\"mail.smtp.quitwait\", \"false\");   \n\n        session = Session.getDefaultInstance(props, this);   \n    }   \n\n    protected PasswordAuthentication getPasswordAuthentication() {   \n        return new PasswordAuthentication(user, password);   \n    }   \n\n    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   \n        try{\n        MimeMessage message = new MimeMessage(session);   \n        DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));   \n        message.setSender(new InternetAddress(sender));   \n        message.setSubject(subject);   \n        message.setDataHandler(handler);   \n        if (recipients.indexOf(',') &gt; 0)   \n            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   \n        else  \n            message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   \n        Transport.send(message);   \n        }catch(Exception e){\n\n        }\n    }   \n\n    public class ByteArrayDataSource implements DataSource {   \n        private byte[] data;   \n        private String type;   \n\n        public ByteArrayDataSource(byte[] data, String type) {   \n            super();   \n            this.data = data;   \n            this.type = type;   \n        }   \n\n        public ByteArrayDataSource(byte[] data) {   \n            super();   \n            this.data = data;   \n        }   \n\n        public void setType(String type) {   \n            this.type = type;   \n        }   \n\n        public String getContentType() {   \n            if (type == null)   \n                return \"application/octet-stream\";   \n            else  \n                return type;   \n        }   \n\n        public InputStream getInputStream() throws IOException {   \n            return new ByteArrayInputStream(data);   \n        }   \n\n        public String getName() {   \n            return \"ByteArrayDataSource\";   \n        }   \n\n        public OutputStream getOutputStream() throws IOException {   \n            throw new IOException(\"Not Supported\");   \n        }   \n    }   \n}  \n", " // Put this code on oncreate method\n\ntry {\n    //Replace your.package.name with your base packege name.\n    PackageInfo appPkgInfo = getPackageManager().getPackageInfo(\"your.package.name\", PackageManager.GET_SIGNATURES);\n\n\n    for (Signature signature : appPkgInfo.signatures) {\n\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n\n        // See Logcat for your hash key and put in on Facebook developer console.\n        Log.d(\"Your Hash key\", Base64.encodeToString(messageDigest.digest(), Base64.DEFAULT));\n    }\n    } catch (NameNotFoundException e) {\n\n    Log.e(\"ERROR\",e.getMessage());\n\n    } catch (NoSuchAlgorithmException e) {\n\n    Log.e(\"ERROR\",e.getMessage());\n\n}\n", "import java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.security.cert.X509Certificate;\n\npublic class Example {\n    public static void main(String[] args) throws Exception {\n        // Create a trust manager that does not validate certificate chains\n        TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n                public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                }\n                public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                }\n            }\n        };\n\n        // Install the all-trusting trust manager\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n        // Create all-trusting host name verifier\n        HostnameVerifier allHostsValid = new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        };\n\n        // Install the all-trusting host verifier\n        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);\n\n        URL url = new URL(\"https_url_here\");\n        URLConnection con = url.openConnection();\n        Reader reader = new InputStreamReader(con.getInputStream());\n        while (true) {\n            int ch = reader.read();\n            if (ch==-1) {\n                break;\n            }\n            System.out.print((char)ch);\n        }\n    }\n}\n", "HttpsURLConnection.setDefaultHostnameVerifier(new AllVerifier());\ntry {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, new TrustManager[] { new AllTrustManager() }, null);\n    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n} catch (KeyManagementException e) {\n    e.printStackTrace();\n} catch (NoSuchAlgorithmException e) {\n    e.printStackTrace();\n}\n", "static void encrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    // Here you read the cleartext.\n    FileInputStream fis = new FileInputStream(\"data/cleartext\");\n    // This stream write the encrypted text. This stream will be wrapped by another stream.\n    FileOutputStream fos = new FileOutputStream(\"data/encrypted\");\n\n    // Length is 16 byte\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n    // Create cipher\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);\n    // Wrap the output stream\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n    // Write bytes\n    int b;\n    byte[] d = new byte[8];\n    while((b = fis.read(d)) != -1) {\n        cos.write(d, 0, b);\n    }\n    // Flush and close streams.\n    cos.flush();\n    cos.close();\n    fis.close();\n}\n\nstatic void decrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    FileInputStream fis = new FileInputStream(\"data/encrypted\");\n\n    FileOutputStream fos = new FileOutputStream(\"data/decrypted\");\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    int b;\n    byte[] d = new byte[8];\n    while((b = cis.read(d)) != -1) {\n        fos.write(d, 0, b);\n    }\n    fos.flush();\n    fos.close();\n    cis.close();\n}\n", "try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"your package\", \n                PackageManager.GET_SIGNATURES);\n        for (android.content.pm.Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK :\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "    // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.example.assessment\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\",\n                    Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\nKeyStore ks = KeyStore.getInstance(\"JKS\");\nFileInputStream in = new FileInputStream(\"&lt;path to your key store&gt;\");\nks.load(in, \"password\".toCharArray);\nin.close();\ntmf.init(ks);\nTrustManager[] tms = tmf.getTrustManagers();\n", "        File file=new File(getApplicationContext().getPackageCodePath());  \n        FileInputStream input = new FileInputStream(file);\n        ByteArrayOutputStream output = new ByteArrayOutputStream ();\n        byte [] buffer = new byte [65536];\n        int l;\n        while ((l = input.read (buffer)) &gt; 0)\n               output.write (buffer, 0, l);\n        input.close ();\n        output.close ();\n        byte [] data = output.toByteArray ();\n        MessageDigest digest = MessageDigest.getInstance( \"SHA-1\" );\n        byte[] bytes = data;\n        digest.update(bytes, 0, bytes.length);\n        bytes = digest.digest();\n        StringBuilder sb = new StringBuilder();\n        for( byte b : bytes )\n           sb.append( String.format(\"%02X\", b) );\n        hash = sb.toString();\n", "public static String encrypt(final String plainMessage,\n        final String symKeyHex) {\n    final byte[] symKeyData = DatatypeConverter.parseHexBinary(symKeyHex);\n\n    final byte[] encodedMessage = plainMessage.getBytes(Charset\n            .forName(\"UTF-8\"));\n    try {\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        final int blockSize = cipher.getBlockSize();\n\n        // create the key\n        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, \"AES\");\n\n        // generate random IV using block size (possibly create a method for\n        // this)\n        final byte[] ivData = new byte[blockSize];\n        final SecureRandom rnd = SecureRandom.getInstance(\"SHA1PRNG\");\n        rnd.nextBytes(ivData);\n        final IvParameterSpec iv = new IvParameterSpec(ivData);\n\n        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);\n\n        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);\n\n        // concatenate IV and encrypted message\n        final byte[] ivAndEncryptedMessage = new byte[ivData.length\n                + encryptedMessage.length];\n        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);\n        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,\n                blockSize, encryptedMessage.length);\n\n        final String ivAndEncryptedMessageBase64 = DatatypeConverter\n                .printBase64Binary(ivAndEncryptedMessage);\n\n        return ivAndEncryptedMessageBase64;\n    } catch (InvalidKeyException e) {\n        throw new IllegalArgumentException(\n                \"key argument does not contain a valid AES key\");\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(\n                \"Unexpected exception during encryption\", e);\n    }\n}\n\npublic static String decrypt(final String ivAndEncryptedMessageBase64,\n        final String symKeyHex) {\n    final byte[] symKeyData = DatatypeConverter.parseHexBinary(symKeyHex);\n\n    final byte[] ivAndEncryptedMessage = DatatypeConverter\n            .parseBase64Binary(ivAndEncryptedMessageBase64);\n    try {\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        final int blockSize = cipher.getBlockSize();\n\n        // create the key\n        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, \"AES\");\n\n        // retrieve random IV from start of the received message\n        final byte[] ivData = new byte[blockSize];\n        System.arraycopy(ivAndEncryptedMessage, 0, ivData, 0, blockSize);\n        final IvParameterSpec iv = new IvParameterSpec(ivData);\n\n        // retrieve the encrypted message itself\n        final byte[] encryptedMessage = new byte[ivAndEncryptedMessage.length\n                - blockSize];\n        System.arraycopy(ivAndEncryptedMessage, blockSize,\n                encryptedMessage, 0, encryptedMessage.length);\n\n        cipher.init(Cipher.DECRYPT_MODE, symKey, iv);\n\n        final byte[] encodedMessage = cipher.doFinal(encryptedMessage);\n\n        // concatenate IV and encrypted message\n        final String message = new String(encodedMessage,\n                Charset.forName(\"UTF-8\"));\n\n        return message;\n    } catch (InvalidKeyException e) {\n        throw new IllegalArgumentException(\n                \"key argument does not contain a valid AES key\");\n    } catch (BadPaddingException e) {\n        // you'd better know about padding oracle attacks\n        return null;\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(\n                \"Unexpected exception during decryption\", e);\n    }\n}\n", "        Data before = new Data();\n        before.setName(\"Joseph Wallflower\");\n        before.setNameOperation(new UpperCaseStringOperation());\n        before.setEmail(\"Joseph.Wallflower@SomeCompany.com\");\n        before.setEmailOperation(new LowerCaseStringOperation());\n\n        System.out.format(\"BEFORE: %s%n\", before.toString());\n\n        Serializer serializer = new Persister();\n        File file = new File(System.getenv(\"USERPROFILE\")+File.separator+\"Documents\"+File.separator+\"simple.xml\");\n        serializer.write(before, file);\n", "// convert key to bytes\nbyte[] keyBytes = key.getBytes(\"UTF-8\");\n// Use the first 16 bytes (or even less if key is shorter)\nbyte[] keyBytes16 = new byte[16];\nSystem.arraycopy(keyBytes, 0, keyBytes16, 0, Math.min(keyBytes.length, 16));\n\n// convert plain text to bytes\nbyte[] plainBytes = plainText.getBytes(\"UTF-8\");\n\n// setup cipher\nSecretKeySpec skeySpec = new SecretKeySpec(keyBytes16, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nbyte[] iv = new byte[16]; // initialization vector with all 0\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));\n\n// encrypt\nbyte[] encrypted = cipher.doFinal(plainBytes);\n", "HttpClient httpclient = getNewHttpClient();  \n\nHttpGet httpget = new HttpGet(URL);\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            is = entity.getContent();\n\npublic HttpClient getNewHttpClient() {\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore\n                    .getDefaultType());\n            trustStore.load(null, null);\n\n            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n            HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory\n                    .getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sf, 443));\n\n\n\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(\n                    params, registry);\n\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception e) {\n            return new DefaultHttpClient();\n        }\n    }\n", " private void getShaKey() {\n\n try {\n PackageInfo info = getPackageManager().getPackageInfo(\"your.package.name\",\n PackageManager.GET_SIGNATURES);\n for (Signature signature : info.signatures) {\n MessageDigest md = MessageDigest.getInstance(\"SHA\");\n md.update(signature.toByteArray());\n Log.v(TAG, \"KeyHash:\" + Base64.encodeToString(md.digest(),\n Base64.DEFAULT));\n }\n } catch (NameNotFoundException e) {\n e.printStackTrace();\n\n } catch (NoSuchAlgorithmException e) {\n e.printStackTrace();\n\n }\n\n }\n", "SecureRandom saltGen = SecureRandom.getInstance(randomAlgorithm);\nthis.salt = new byte[SALT_LENGTH];\nsaltGen.nextBytes(this.salt);\n", "KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\ntry {\nFileInputStream fis = ctx.getApplicationContext().openFileInput(\"bs.keystore\");\nks.load(fis, ksPassword);\n} catch(FileNotFoundException e) {\n    ks.load(null, ksPassword);\n}\n", "try {\nPackageInfo info = getPackageManager().getPackageInfo(\"your package\", PackageManager.GET_SIGNATURES);\nfor (Signature signature : info.signatures) {\n    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n    md.update(signature.toByteArray());\n    Log.e(\"MY KEY HASH:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n}\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "PackageInfo info;\ntry {\ninfo = getPackageManager().getPackageInfo(\"com.myname.lolo\", PackageManager.GET_SIGNATURES);\nfor (Signature signature : info.signatures) {\n           MessageDigest md;\nmd = MessageDigest.getInstance(\"SHA\");\nmd.update(signature.toByteArray());\n           //String something = new String(Base64.encode(md.digest(), 0));\n            * String something = new String(Base64.encodeBytes(md.digest()));\n           Log.e(\"hash key\", something);\n} \n}\ncatch (NameNotFoundException e1) {\nLog.e(\"name not found\", e1.toString());\n}\n\ncatch (NoSuchAlgorithmException e) {\nLog.e(\"no such an algorithm\", e.toString());\n}\ncatch (Exception e){\nLog.e(\"exception\", e.toString());\n}\n", "public static void decrypt() {\n    try {\n        Log.d(C.TAG, \"Decrypt Started\");\n\n        byte[] bytes = new BigInteger(&lt;your key&gt;, 16).toByteArray();\n\n        FileInputStream fis = new FileInputStream(&lt;location of encrypted file&gt;);\n\n        FileOutputStream fos = new FileOutputStream(&lt;location of decrypted file&gt;);\n        SecretKeySpec sks = new SecretKeySpec(bytes, &lt;encryption type&gt;);\n        Cipher cipher = Cipher.getInstance(&lt;encryption type&gt;);\n        cipher.init(Cipher.DECRYPT_MODE, sks);\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n        int b;\n        byte[] d = new byte[8];\n        while ((b = cis.read(d)) != -1) {\n            fos.write(d, 0, b);\n        }\n        fos.flush();\n        fos.close();\n        cis.close();\n        Log.d(C.TAG, \"Decrypt Ended\");\n    } catch (NoSuchAlgorithmException e) {\n        Log.d(C.TAG, \"NoSuchAlgorithmException\");\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        Log.d(C.TAG, \"InvalidKeyException\");\n        e.printStackTrace();\n    } catch (IOException e) {\n        Log.d(C.TAG, \"IOException\");\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        Log.d(C.TAG, \"NoSuchPaddingException\");\n        e.printStackTrace();\n    }\n}\n", "    SecretKeySpec sks = null;\n    try {\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(\"Complex Key for encryption\".getBytes());\n        KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n        kg.init(128, sr);\n        sks = new SecretKeySpec((kg.generateKey()).getEncoded(), \"AES\");\n    } catch (Exception e) {\n        Log.e(TAG, \"AES secret key spec error\");\n    }\n\n    // Encode the original data with AES\n    byte[] encodedBytes = null;\n    try {\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.ENCRYPT_MODE, sks);\n        encodedBytes = c.doFinal(theTestText.getBytes());\n    } catch (Exception e) {\n        Log.e(TAG, \"AES encryption error\");\n    }\n    TextView tvencoded = (TextView)findViewById(R.id.textitem2);\n    tvencoded.setText(\"[ENCODED]:\\n\" +\n            Base64.encodeToString(encodedBytes, Base64.DEFAULT) + \"\\n\");\n\n    // Decode the encoded data with AES\n    byte[] decodedBytes = null;\n    try {\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.DECRYPT_MODE, sks);\n        decodedBytes = c.doFinal(encodedBytes);\n    } catch (Exception e) {\n        Log.e(TAG, \"AES decryption error\");\n    }\n    TextView tvdecoded = (TextView)findViewById(R.id.textitem3);\n    tvdecoded.setText(\"[DECODED]:\\n\" + new String(decodedBytes) + \"\\n\");\n", "private initCipher(int mode) {\n    try {\n        byte[] iv;\n        mCipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + \"/\"\n                + KeyProperties.BLOCK_MODE_CBC + \"/\"\n                + KeyProperties.ENCRYPTION_PADDING_PKCS7);\n        IvParameterSpec ivParams;\n        if(mode == Cipher.ENCRYPT_MODE) {\n            mCipher.init(mode, generateKey());\n            ivParams = mCipher.getParameters().getParameterSpec(IvParameterSpec.class);\n            iv = ivParams.getIV();\n            fos = getContext().openFileOutput(IV_FILE, Context.MODE_PRIVATE);\n            fos.write(iv);\n            fos.close();\n        }\n        else {\n            key = (SecretKey)keyStore.getKey(KEY_NAME, null);\n            File file = new File(getContext().getFilesDir()+\"/\"+IV_FILE);\n            int fileSize = (int)file.length();\n            iv = new byte[fileSize];\n            FileInputStream fis = getContext().openFileInput(IV_FILE);\n            fis.read(iv, 0, fileSize);\n            fis.close();\n            ivParams = new IvParameterSpec(iv);\n            mCipher.init(mode, key, ivParams);\n        }\n        mCryptoObject = new FingerprintManager.CryptoObject(mCipher);\n    } catch(....)\n}\n", "SecureRandom r = new SecureRandom();\nbyte[] ivBytes = new byte[16];\nr.nextBytes(ivBytes);\n\ncipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(ivBytes));\n", "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Encrypter {\n    private final static int IV_LENGTH = 16; // Default length with Default 128\n                                                // key AES encryption\n    private final static int DEFAULT_READ_WRITE_BLOCK_BUFFER_SIZE = 1024;\n\n    private final static String ALGO_RANDOM_NUM_GENERATOR = \"SHA1PRNG\";\n    private final static String ALGO_SECRET_KEY_GENERATOR = \"AES\";\n    private final static String ALGO_VIDEO_ENCRYPTOR = \"AES/CBC/PKCS5Padding\";\n\n    @SuppressWarnings(\"resource\")\n    public static void encrypt(SecretKey key, AlgorithmParameterSpec paramSpec, InputStream in, OutputStream out)\n            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n            InvalidAlgorithmParameterException, IOException {\n        try {\n            // byte[] iv = new byte[] { (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,\n            // 0x07, 0x72, 0x6F, 0x5A, (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,\n            // 0x07, 0x72, 0x6F, 0x5A };\n            // AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);\n            Cipher c = Cipher.getInstance(ALGO_VIDEO_ENCRYPTOR);\n            c.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n            out = new CipherOutputStream(out, c);\n            int count = 0;\n            byte[] buffer = new byte[DEFAULT_READ_WRITE_BLOCK_BUFFER_SIZE];\n            while ((count = in.read(buffer)) &gt;= 0) {\n                out.write(buffer, 0, count);\n            }\n        } finally {\n            out.close();\n        }\n    }\n\n    @SuppressWarnings(\"resource\")\n    public static void decrypt(SecretKey key, AlgorithmParameterSpec paramSpec, InputStream in, OutputStream out)\n            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n            InvalidAlgorithmParameterException, IOException {\n        try {\n            // byte[] iv = new byte[] { (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,\n            // 0x07, 0x72, 0x6F, 0x5A, (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,\n            // 0x07, 0x72, 0x6F, 0x5A };\n            // AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);\n            Cipher c = Cipher.getInstance(ALGO_VIDEO_ENCRYPTOR);\n            c.init(Cipher.DECRYPT_MODE, key, paramSpec);\n            out = new CipherOutputStream(out, c);\n            int count = 0;\n            byte[] buffer = new byte[DEFAULT_READ_WRITE_BLOCK_BUFFER_SIZE];\n            while ((count = in.read(buffer)) &gt;= 0) {\n                out.write(buffer, 0, count);\n            }\n        } finally {\n            out.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        File inFile = new File(\"C:/enc_test/video.swf\");\n        File outFile = new File(\"C:/enc_test/enc_video.swf\");\n        File outFile_dec = new File(\"C:/enc_test/dec_video.swf\");\n\n        try {\n            SecretKey key = KeyGenerator.getInstance(ALGO_SECRET_KEY_GENERATOR).generateKey();\n\n            byte[] keyData = key.getEncoded();\n            SecretKey key2 = new SecretKeySpec(keyData, 0, keyData.length, ALGO_SECRET_KEY_GENERATOR); //if you want to store key bytes to db so its just how to //recreate back key from bytes array\n\n            byte[] iv = new byte[IV_LENGTH];\n            SecureRandom.getInstance(ALGO_RANDOM_NUM_GENERATOR).nextBytes(iv); // If\n                                                                                // storing\n                                                                                // separately\n            AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);\n\n            Encrypter.encrypt(key, paramSpec, new FileInputStream(inFile), new FileOutputStream(outFile));\n            Encrypter.decrypt(key2, paramSpec, new FileInputStream(outFile), new FileOutputStream(outFile_dec));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n", "public void traceKeyHash(Activity activity){\n    try {\n        PackageInfo info = activity.getPackageManager().getPackageInfo(\"your.package.here\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.i(getClass().getName(), \"Share - KeyHash: \" + Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    }\n    catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "  try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.yourpackage.name\",\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }  \n", "package com.neocodenetworks.smsfwd;\n\nimport java.security.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\nimport android.util.Log;\n\npublic class Crypto {\n    public static final String TAG = \"smsfwd\";\n\n    private static Cipher aesCipher;\n    private static SecretKey secretKey;\n    private static IvParameterSpec ivParameterSpec;\n\n    private static String CIPHER_TRANSFORMATION = \"AES/CBC/PKCS5Padding\";\n    private static String CIPHER_ALGORITHM = \"AES\";\n    // Replace me with a 16-byte key, share between Java and C#\n    private static byte[] rawSecretKey = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n    private static String MESSAGEDIGEST_ALGORITHM = \"MD5\";\n\n    public Crypto(String passphrase) {\n        byte[] passwordKey = encodeDigest(passphrase);\n\n        try {\n            aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, \"No such algorithm \" + CIPHER_ALGORITHM, e);\n        } catch (NoSuchPaddingException e) {\n            Log.e(TAG, \"No such padding PKCS5\", e);\n        }\n\n        secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);\n        ivParameterSpec = new IvParameterSpec(rawSecretKey);\n    }\n\n    public String encryptAsBase64(byte[] clearData) {\n        byte[] encryptedData = encrypt(clearData);\n        return net.iharder.base64.Base64.encodeBytes(encryptedData);\n    }\n\n    public byte[] encrypt(byte[] clearData) {\n        try {\n            aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);\n        } catch (InvalidKeyException e) {\n            Log.e(TAG, \"Invalid key\", e);\n            return null;\n        } catch (InvalidAlgorithmParameterException e) {\n            Log.e(TAG, \"Invalid algorithm \" + CIPHER_ALGORITHM, e);\n            return null;\n        }\n\n        byte[] encryptedData;\n        try {\n            encryptedData = aesCipher.doFinal(clearData);\n        } catch (IllegalBlockSizeException e) {\n            Log.e(TAG, \"Illegal block size\", e);\n            return null;\n        } catch (BadPaddingException e) {\n            Log.e(TAG, \"Bad padding\", e);\n            return null;\n        }\n        return encryptedData;\n    }\n\n    private byte[] encodeDigest(String text) {\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);\n            return digest.digest(text.getBytes());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, \"No such algorithm \" + MESSAGEDIGEST_ALGORITHM, e);\n        }\n\n        return null;\n    }\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.play.fabin\",  //Replace your package name here\n            PackageManager.GET_SIGNATURES);\n\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        System.out.println(\"key hash = \" + Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (PackageManager.NameNotFoundException e) {\n    e.printStackTrace();\n\n} catch (NoSuchAlgorithmException e) {\n    e.printStackTrace();\n}\n", "public class Obscure {\nprivate byte[] k = \"Now is the time for all good men to come to the aid of their country.\"\n        .getBytes();\n\npublic Obscure(String keyString) {\n    k = keyString.getBytes();\n}\n\npublic boolean encryptFile(String source, String target)\n        throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IOException {\n    Cipher encoding;\n    byte[] buffer = new byte[8192];\n\n    FileInputStream fis = new FileInputStream(source);\n    FileOutputStream fos = new FileOutputStream(target);\n\n    SecretKeySpec key = new SecretKeySpec(k, \"DES\");\n    encoding = Cipher.getInstance(\"DES\");\n    encoding.init(Cipher.ENCRYPT_MODE, key);\n    CipherOutputStream cos = new CipherOutputStream(fos, encoding);\n    int numBytes;\n    while ((numBytes = fis.read(buffer)) != -1) {\n        cos.write(buffer, 0, numBytes);\n    }\n    fos.flush();\n    fis.close();\n    fos.close();\n    cos.close();\n    return true;\n}\n}\n", "KeyStore trustStore = loadTrustStore();\nKeyStore keyStore = loadKeyStore();\n\nTrustManagerFactory tmf = TrustManagerFactory\n                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init(trustStore);\n\nKeyManagerFactory kmf = KeyManagerFactory\n                    .getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkmf.init(keyStore, KEYSTORE_PASSWORD.toCharArray());\n\nSSLContext sslCtx = SSLContext.getInstance(\"TLS\");\nsslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n", "try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"Your package name\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"Your Tag\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "private static String decrypt(String seed, String encrypted) throws Exception {\n    byte[] keyb = seed.getBytes(\"UTF-8\");\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] thedigest = md.digest(keyb);\n    SecretKeySpec skey = new SecretKeySpec(thedigest, \"AES\");\n    Cipher dcipher = Cipher.getInstance(\"AES\");\n    dcipher.init(Cipher.DECRYPT_MODE, skey);\n\n    byte[] clearbyte = dcipher.doFinal(toByte(encrypted));\n    return new String(clearbyte);\n}\n\nprivate static byte[] toByte(String hexString) {\n    int len = hexString.length()/2;\n    byte[] result = new byte[len];\n    for (int i = 0; i &lt; len; i++) {\n        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n    }\n    return result;\n}\n", "private void getCertsFromP12(String pathToFile, String passphrase){\n  try {\n        KeyStore p12 = KeyStore.getInstance(\"pkcs12\");\n        p12.load(new FileInputStream(pathToFile), passphrase.toCharArray());\n        Enumeration e = p12.aliases();\n        while (e.hasMoreElements()) {\n            String alias = (String) e.nextElement();\n            X509Certificate c = (X509Certificate) p12.getCertificate(alias);\n            addCertificateToKeyStore(c);\n        }\n    } catch (Exception e) {}\n}\n\nprivate void addCertificateToKeyStore(X509Certificate c) {\n    try {\n        KeyStore ks = KeyStore.getInstance(\"AndroidKeyStore\");\n        ks.load(null);\n        ks.setCertificateEntry(\"myCertAlias\", c);\n    } catch (Exception e){}\n}\n", "private static String convertToHex(byte[] data) { \n    StringBuffer buf = new StringBuffer();\n    int length = data.length;\n    for(int i = 0; i &lt; length; ++i) { \n        int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;\n        int two_halfs = 0;\n        do { \n            if((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9)) \n                buf.append((char) ('0' + halfbyte));\n            else \n                buf.append((char) ('a' + (halfbyte - 10)));\n            halfbyte = data[i] &amp; 0x0F;\n        }\n        while(++two_halfs &lt; 1);\n    } \n    return buf.toString();\n}\n\npublic static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException  { \n    MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n    byte[] sha1hash = new byte[40];\n    md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n    sha1hash = md.digest();\n    return convertToHex(sha1hash);\n} \n", "import java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * Usage:\n * &lt;pre&gt;\n * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)\n * ...\n * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)\n * &lt;/pre&gt;\n * @author ferenc.hechler\n */\npublic class SimpleCrypto {\n\n\n    public static void main(String args[])\n    {\n\n\n        try {\n\n            String sr=encrypt(\"username\", \"The AsyncTask isn\u00e2\u0080\u0099t the only way to do background processing in Android, though. The Loader class is a much newer construct in Android (although now it\u00e2\u0080\u0099s getting a bit dated). It was released with Honeycomb(3.0) and is now included in the Support Library. The beauty of the Loader is that it handles some of the \u00e2\u0080\u0098gotchas\u00e2\u0080\u0099 that usually are missed when using the AsyncTask. Mainly, it handles activity configuration changes (IE when the user rotates the screen)\");\n            System.out.println(\" &amp;&amp;&amp;&amp; \" + sr);\n            System.out.println(\"88888 \"+decrypt(\"username\", sr));\n\n\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n        public static String encrypt(String seed, String cleartext) throws Exception {\n                byte[] rawKey = getRawKey(seed.getBytes());\n                byte[] result = encrypt(rawKey, cleartext.getBytes());\n                return toHex(result);\n        }\n\n        public static String decrypt(String seed, String encrypted) throws Exception {\n                byte[] rawKey = getRawKey(seed.getBytes());\n                byte[] enc = toByte(encrypted);\n                byte[] result = decrypt(rawKey, enc);\n                return new String(result);\n        }\n\n        private static byte[] getRawKey(byte[] seed) throws Exception {\n                KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n                SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n                sr.setSeed(seed);\n            kgen.init(128, sr); // 192 and 256 bits may not be available\n            SecretKey skey = kgen.generateKey();\n            byte[] raw = skey.getEncoded();\n            return raw;\n        }\n\n\n        private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n            SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n                Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n            byte[] encrypted = cipher.doFinal(clear);\n                return encrypted;\n        }\n\n        private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n            SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n                Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n            byte[] decrypted = cipher.doFinal(encrypted);\n                return decrypted;\n        }\n\n        public static String toHex(String txt) {\n                return toHex(txt.getBytes());\n        }\n        public static String fromHex(String hex) {\n                return new String(toByte(hex));\n        }\n\n        public static byte[] toByte(String hexString) {\n                int len = hexString.length()/2;\n                byte[] result = new byte[len];\n                for (int i = 0; i &lt; len; i++)\n                        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n                return result;\n        }\n\n        public static String toHex(byte[] buf) {\n                if (buf == null)\n                        return \"\";\n                StringBuffer result = new StringBuffer(2*buf.length);\n                for (int i = 0; i &lt; buf.length; i++) {\n                        appendHex(result, buf[i]);\n                }\n                return result.toString();\n        }\n        private final static String HEX = \"0123456789ABCDEF\";\n        private static void appendHex(StringBuffer sb, byte b) {\n                sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));\n        }\n\n}\n", "String sha1Hash( String toHash )\n{\n    String hash = null;\n    try\n    {\n        MessageDigest digest = MessageDigest.getInstance( \"SHA-1\" );\n        byte[] bytes = toHash.getBytes(\"UTF-8\");\n        digest.update(bytes, 0, bytes.length);\n        bytes = digest.digest();\n\n        // This is ~55x faster than looping and String.formating()\n        hash = bytesToHex( bytes );\n    }\n    catch( NoSuchAlgorithmException e )\n    {\n        e.printStackTrace();\n    }\n    catch( UnsupportedEncodingException e )\n    {\n        e.printStackTrace();\n    }\n    return hash;\n}\n\n// http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java\nfinal protected static char[] hexArray = \"0123456789ABCDEF\".toCharArray();\npublic static String bytesToHex( byte[] bytes )\n{\n    char[] hexChars = new char[ bytes.length * 2 ];\n    for( int j = 0; j &lt; bytes.length; j++ )\n    {\n        int v = bytes[ j ] &amp; 0xFF;\n        hexChars[ j * 2 ] = hexArray[ v &gt;&gt;&gt; 4 ];\n        hexChars[ j * 2 + 1 ] = hexArray[ v &amp; 0x0F ];\n    }\n    return new String( hexChars );\n}\n", "/**\n * Disables the SSL certificate checking for new instances of {@link HttpsURLConnection} This has been created to\n * aid testing on a local box, not for use on production.\n */\nprivate static void disableSSLCertificateChecking() {\n    TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n\n            @Override\n            public void checkClientTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {\n                // not implemented\n            }\n\n            @Override\n            public void checkServerTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {\n                // not implemented\n            }\n\n            @Override\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n        }\n    };\n\n    try {\n\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n\n            @Override\n            public boolean verify(String s, SSLSession sslSession) {\n                return true;\n            }\n\n        });\n        SSLContext sc = SSLContext.getInstance(\"TLS\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n    } catch (KeyManagementException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n}\n", "public void run() {\n    try {\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keyStore.load(service.getBaseContext().getResources().openRawResource(R.raw.keystore),\n                \"password\".toCharArray());\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        keyManagerFactory.init(keyStore, \"password\".toCharArray());\n\n        SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n        sslContext.init(keyManagerFactory.getKeyManagers(), null, null);\n\n        ServerSocketFactory socketFactory = sslContext.getServerSocketFactory();\n        SSLServerSocket mServerSocket = (SSLServerSocket) socketFactory.createServerSocket(8080);\n        while (!mServerSocket.isClosed()) {\n\n            System.out.println(\"waiting\");\n            SSLSocket client = (SSLSocket) mServerSocket.accept();\n\n            client.addHandshakeCompletedListener(new HandshakeCompletedListener() {\n\n                public void handshakeCompleted(HandshakeCompletedEvent arg0) {\n                    System.out.println(\"handshakeCompleted\");\n\n                }\n\n            });\n            client.startHandshake(); // MultiThreadWebServer.java:136\n\n            client.getOutputStream().flush();\n\n            client.close();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "package com.example.id;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport android.os.Bundle;\nimport android.app.Activity;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.Signature;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\npublic class MainActivity extends Activity {\n    PackageInfo info;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button btn = (Button)findViewById(R.id.button1);\n        final EditText et = (EditText)findViewById(R.id.editText1);\n\n        btn.setOnClickListener(new OnClickListener() {\n\n            @Override\n            public void onClick(View v) {\n                // TODO Auto-generated method stub\n\n                try {\n                    info = getPackageManager().getPackageInfo(\"com.example.id\", PackageManager.GET_SIGNATURES);\n                    for (Signature signature : info.signatures) {\n                        MessageDigest md;\n                        md = MessageDigest.getInstance(\"SHA\");\n                        md.update(signature.toByteArray());\n                        String something = new String(Base64.encode(md.digest(), 0));\n                        //String something = new String(Base64.encodeBytes(md.digest()));\n                        et.setText(something);\n                       Toast.makeText(getBaseContext(), \"\" + something, 2000).show();\n                    }\n                } catch (NameNotFoundException e1) {\n                    Log.e(\"name not found\", e1.toString());\n                } catch (NoSuchAlgorithmException e) {\n                    Log.e(\"no such an algorithm\", e.toString());\n                } catch (Exception e) {\n                    Log.e(\"exception\", e.toString());\n                }\n            }\n        });\n    }\n\n\n}\n", "public static String fileToMD5(String filePath) {\nInputStream inputStream = null;\ntry {\n    inputStream = new FileInputStream(filePath);\n    byte[] buffer = new byte[1024];\n    MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n    int numRead = 0;\n    while (numRead != -1) {\n        numRead = inputStream.read(buffer);\n        if (numRead &gt; 0)\n            digest.update(buffer, 0, numRead);\n    }\n    byte [] md5Bytes = digest.digest();\n    return convertHashToString(md5Bytes);\n} catch (Exception e) {\n    return null;\n} finally {\n    if (inputStream != null) {\n        try {\n            inputStream.close();\n        } catch (Exception e) { }\n    }\n}\n}\n\nprivate static String convertHashToString(byte[] md5Bytes) {\nString returnVal = \"\";\nfor (int i = 0; i &lt; md5Bytes.length; i++) {\n    returnVal += Integer.toString(( md5Bytes[i] &amp; 0xff ) + 0x100, 16).substring(1);\n}\nreturn returnVal;\n}\n", "private void getHashKey()\n{\n        PackageInfo info;\n        try {\n        info = getPackageManager().getPackageInfo(\"your app package name\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n                   MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n                   //String something = new String(Base64.encode(md.digest(), 0));\n                     String something = new String(Base64.encode(md.digest(),0));\n                   Log.e(\"**** Hash Key\", something);\n        } \n        }\n        catch (NameNotFoundException e1) {\n        Log.e(\"name not found\", e1.toString());\n        }\n\n        catch (NoSuchAlgorithmException e) {\n        Log.e(\"no such an algorithm\", e.toString());\n        }\n        catch (Exception e){\n        Log.e(\"exception\", e.toString());\n        }\n\n}\n", "SSLSocketFactory sf = new SSLSocketFactory(SSLContext.getInstance(\"TLS\"));\nsf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n", "    MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n    DigestInputStream stream = new DigestInputStream(new FileInputStream(new File(\"/path/to/file\")),dig);\n    while(stream.read() != -1);\n    byte[] digest = dig.digest();\n    String md5 = new BigInteger(1, digest).toString(16);\n    System.out.print(md5);\n", "public static String getMD5EncryptedString(String encTarget){\n        MessageDigest mdEnc = null;\n        try {\n            mdEnc = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Exception while encrypting to md5\");\n            e.printStackTrace();\n        } // Encryption algorithm\n        mdEnc.update(encTarget.getBytes(), 0, encTarget.length());\n        String md5 = new BigInteger(1, mdEnc.digest()).toString(16);\n        while ( md5.length() &lt; 32 ) {\n            md5 = \"0\"+md5;\n        }\n        return md5;\n    }\n", "try{\n\n        System.setProperty(\"http.keepAlive\", \"false\");\n        HttpsURLConnection\n                .setDefaultHostnameVerifier(new HostnameVerifier() {\n\n                    public boolean verify(String hostname,\n                            SSLSession session) {\n                        return true;\n                    }\n                });\n\n        char[] passwKey = \"password\".toCharArray();\n        KeyStore ts = KeyStore.getInstance(\"BKS\");\n                InputStream in = getResources().openRawResource(\n            R.raw.YOUR_CERTIFICATE_FILE);\n                InputStream is = getResources().openRawResource(\n            R.raw.YOUR_CERTIFICATE_FILE);\n        ts.load(in, passwKey);\n        KeyManagerFactory tmf = KeyManagerFactory.getInstance(\"X509\");\n        tmf.init(ts, passwKey);\n\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(tmf.getKeyManagers(),\n                new X509TrustManager[] { new MyX509TrustManager(is,\n                        \"password\".toCharArray()) }, new SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(context\n                .getSocketFactory());\n\n                URL url = new URL(Commons.ApiCall);\n\n        HttpsURLConnection connection = (HttpsURLConnection) url\n                .openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Username\", Username);\n        connection.setRequestProperty(\"Password\", Password);\n\n         BufferedReader bin = new BufferedReader(new InputStreamReader(\n                connection.getInputStream()));\n\n         StringBuffer sb = new StringBuffer();\n\n        while ((line = bin.readLine()) != null) {\n            sb.append(line);\n        }\n\n\n        in.close();  \n                is.close();  \n    } catch (Exception e) { // should never happen\n        e.printStackTrace();\n        Log.d(\"Err\", e.toString());\n    }\n", "public class MyX509TrustManager implements X509TrustManager {\n    X509TrustManager pkixTrustManager;\n\n    public MyX509TrustManager(InputStream trustStore, char[] password)\n            throws Exception {\n        // create a \"default\" JSSE X509TrustManager.\n\n        KeyStore ks = KeyStore.getInstance(\"BKS\");\n\n        ks.load(trustStore, password);\n\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");\n        tmf.init(ks);\n\n        TrustManager tms[] = tmf.getTrustManagers();\n\n        /*\n         * Iterate over the returned trustmanagers, look for an instance of\n         * X509TrustManager. If found, use that as our \"default\" trust manager.\n         */\n        for (int i = 0; i &lt; tms.length; i++) {\n            if (tms[i] instanceof X509TrustManager) {\n                pkixTrustManager = (X509TrustManager) tms[i];\n                return;\n            }\n        }\n\n        /*\n         * Find some other way to initialize, or else we have to fail the\n         * constructor.\n         */\n        throw new Exception(\"Couldn't initialize\");\n    }\n\n    public void checkClientTrusted(X509Certificate[] arg0, String arg1)\n            throws CertificateException {\n        // TODO Auto-generated method stub\n        try {\n            pkixTrustManager.checkClientTrusted(arg0, arg1);\n        } catch (CertificateException excep) {\n            // do any special handling here, or rethrow exception.\n        }\n\n    }\n\n    public void checkServerTrusted(X509Certificate[] arg0, String arg1)\n            throws CertificateException {\n        // TODO Auto-generated method stub\n        try {\n            pkixTrustManager.checkServerTrusted(arg0, arg1);\n        } catch (CertificateException excep) {\n            /*\n             * Possibly pop up a dialog box asking whether to trust the cert\n             * chain.\n             */\n        }\n    }\n\n    public X509Certificate[] getAcceptedIssuers() {\n        // TODO Auto-generated method stub\n        return pkixTrustManager.getAcceptedIssuers();\n    }\n}\n", " // creating a KeyStore containing our trusted CAs\n    String keyStoreType = KeyStore.getDefaultType();\n    KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n    keyStore.load(null, null);\n\n    // creating a TrustManager that trusts the CAs in our KeyStore\n    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n    tmf.init(keyStore);\n\n    // creating an SSLSocketFactory that uses our TrustManager\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, tmf.getTrustManagers(), null);\n    okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());\n    // creating a RestAdapter using the custom client\n    return new RestAdapter.Builder()\n            .setEndpoint(UrlRepository.API_BASE)\n            .setClient(new OkClient(okHttpClient))\n            .build();\n", "    public static String xmlToString(Node node) {\n        try {\n            Source source = new DOMSource(node);\n            StringWriter stringWriter = new StringWriter();\n            Result result = new StreamResult(stringWriter);\n            TransformerFactory factory = TransformerFactory.newInstance();\n            //factory.setAttribute(\"indent-number\", \"4\");\n            Transformer transformer = factory.newTransformer();\n            transformer.transform(source, result);\n            return stringWriter.getBuffer().toString();\n        } catch (TransformerConfigurationException e) {\n            e.printStackTrace();\n        } catch (TransformerException e) {\n             e.printStackTrace();\n        }\n        return null;\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"ENTER.YOUR.PACKAGE.NAME\", PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.e(\"MY KEY HASH:\",\n                Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n", "public class AESCrypt {\n\n  private final Cipher cipher;\n  private final SecretKeySpec key;\n  private AlgorithmParameterSpec spec;\n\n\n  public AESCrypt(String password) throws Exception\n  {\n    // hash password with SHA-256 and crop the output to 128-bit for key\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n    digest.update(password.getBytes(\"UTF-8\"));\n    byte[] keyBytes = new byte[32];\n    System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);\n\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    key = new SecretKeySpec(keyBytes, \"AES\");\n    spec = getIV();\n  }       \n\n  public AlgorithmParameterSpec getIV()\n  {\n    byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };\n    IvParameterSpec ivParameterSpec;\n    ivParameterSpec = new IvParameterSpec(iv);\n\n    return ivParameterSpec;\n  }\n\n  public String encrypt(String plainText) throws Exception\n  {\n    cipher.init(Cipher.ENCRYPT_MODE, key, spec);\n    byte[] encrypted = cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n    String encryptedText = new String(Base64.encode(encrypted, Base64.DEFAULT), \"UTF-8\");\n\n    return encryptedText;\n  }\n\n  public String decrypt(String cryptedText) throws Exception\n  {\n    cipher.init(Cipher.DECRYPT_MODE, key, spec);\n    byte[] bytes = Base64.decode(cryptedText, Base64.DEFAULT);\n    byte[] decrypted = cipher.doFinal(bytes);\n    String decryptedText = new String(decrypted, \"UTF-8\");\n\n    return decryptedText;\n  }\n}\n", "    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"com.your.package\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n    } catch (NoSuchAlgorithmException e) {\n    }\n", "static {\n    Security.addProvider(new JSSEProvider()); \n}\n", "public static String md5(String s) \n{\n    MessageDigest digest;\n    try\n    {\n        digest = MessageDigest.getInstance(\"MD5\");\n        digest.update(s.getBytes(Charset.forName(\"US-ASCII\")),0,s.length());\n        byte[] magnitude = digest.digest();\n        BigInteger bi = new BigInteger(1, magnitude);\n        String hash = String.format(\"%0\" + (magnitude.length &lt;&lt; 1) + \"x\", bi);\n        return hash;\n    }\n    catch (NoSuchAlgorithmException e)\n    {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "MessageDigest sha224 = MessageDigest.getInstance(\"SHA-224\");\nsha224.update(key.getBytes());\n\nbyte[] digest = sha224.digest();\nStringBuffer buffer = new StringBuffer();\n\nfor(int i = 0; i &lt; digest.length; i++) {\n  String hex_string = Integer.toHexString(0xFF &amp; digest[i]);\n  if(hex_string.length()==1) hex_string = \"0\"+hex_string;\n  buffer.append(hex_string);\n}\n\nreturn buffer.toString();\n", "public class AESEncrtptor {\n    String strKey = \"1234567890123456\";\n    byte[] byteKey;\n    byte[] byteVector = new byte[] { 59, 12, (byte) 129, 77, 39, 119, 82, 6,\n            23, 1, 55, 24, 12, (byte) 154, (byte) 224, 14 };\n\n    public AESEncrtptor() {\n        try {\n            byteKey = strKey.getBytes(\"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public enum EnumCipherMode {\n        CBC, ECB\n    }\n\n    public String Encrypt(String strdata, EnumCipherMode CipherMode) {\n        try {\n            String strAlgorithm = \"AES/CBC/PKCS7Padding\";\n            switch (CipherMode) {\n            case CBC:\n                strAlgorithm = \"AES/CBC/PKCS7Padding\";\n                break;\n            case ECB:\n                strAlgorithm = \"AES/ECB/PKCS7Padding\";\n                break;\n            }\n            Cipher c = Cipher.getInstance(strAlgorithm);\n            SecretKeySpec keySpec = new SecretKeySpec(byteKey, strAlgorithm);\n            switch (CipherMode) {\n            case CBC:\n                c.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(\n                        byteVector));\n                break;\n            case ECB:\n                c.init(Cipher.ENCRYPT_MODE, keySpec);\n                break;\n            }\n            byte[] data = strdata.getBytes();\n\n            byte[] encrypted = c.doFinal(data);\n            return Base64.encodeToString(encrypted, Base64.DEFAULT);\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String Decrypt(String strdata, EnumCipherMode CipherMode) {\n        try {\n            String strAlgorithm = \"AES/CBC/PKCS7Padding\";\n            switch (CipherMode) {\n            case CBC:\n                strAlgorithm = \"AES/CBC/PKCS7Padding\";\n                break;\n            case ECB:\n                strAlgorithm = \"AES/ECB/PKCS7Padding\";\n                break;\n            }\n            Cipher d_c = Cipher.getInstance(strAlgorithm);\n            SecretKeySpec d_keySpec = new SecretKeySpec(byteKey, strAlgorithm);\n            switch (CipherMode) {\n            case CBC:\n                d_c.init(Cipher.DECRYPT_MODE, d_keySpec, new IvParameterSpec(\n                        byteVector));\n                break;\n            case ECB:\n                d_c.init(Cipher.DECRYPT_MODE, d_keySpec);\n                break;\n            }\n\n            byte[] decrypted = d_c.doFinal(Base64.decode(strdata,\n                    Base64.DEFAULT));\n            String decryptedStr = \"\";\n            for (int i = 0; i &lt; decrypted.length; i++)\n                decryptedStr += (char) decrypted[i];\n            return decryptedStr;\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}\n", "    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"your.root.package\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "package com.myapp;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.*;\n\n\n/**\n * DummySSLSocketFactory\n */\npublic class DummySSLSocketFactory extends SSLSocketFactory {\n    private SSLSocketFactory factory;\n\n    public DummySSLSocketFactory() {\n    try {\n        SSLContext sslcontext = SSLContext.getInstance(\"TLS\");\n        sslcontext.init(null,\n                 new TrustManager[] { new DummyTrustManager()},\n                 null);\n        factory = (SSLSocketFactory)sslcontext.getSocketFactory();\n    } catch(Exception ex) {\n        // ignore\n    }\n    }\n\n    public static SocketFactory getDefault() {\n    return new DummySSLSocketFactory();\n    }\n\n    public Socket createSocket() throws IOException {\n    return factory.createSocket();\n    }\n\n        public Socket createSocket(Socket socket, String s, int i, boolean flag)\n                throws IOException {\n    return factory.createSocket(socket, s, i, flag);\n    }\n\n    public Socket createSocket(InetAddress inaddr, int i,\n                InetAddress inaddr1, int j) throws IOException {\n    return factory.createSocket(inaddr, i, inaddr1, j);\n    }\n\n    public Socket createSocket(InetAddress inaddr, int i)\n                throws IOException {\n    return factory.createSocket(inaddr, i);\n    }\n\n    public Socket createSocket(String s, int i, InetAddress inaddr, int j)\n                throws IOException {\n    return factory.createSocket(s, i, inaddr, j);\n    }\n\n    public Socket createSocket(String s, int i) throws IOException {\n    return factory.createSocket(s, i);\n    }\n\n    public String[] getDefaultCipherSuites() {\n    return factory.getDefaultCipherSuites();\n    }\n\n    public String[] getSupportedCipherSuites() {\n    return factory.getSupportedCipherSuites();\n    }\n}\n", "       private HttpResponse getResponse(HttpPost request) {\n    try {\n        BasicHttpParams httpParams = new BasicHttpParams();\n\n        ConnManagerParams.setTimeout(httpParams, connectionTimeout);\n        HttpConnectionParams.setSoTimeout(httpParams, connectionTimeout);\n        HttpConnectionParams.setConnectionTimeout(httpParams, connectionTimeout);\n        HttpConnectionParams.setTcpNoDelay(httpParams, true);\n        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);\n\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory socketFactory = new CustomSSLSocketFactory(trustStore);\n        socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        SchemeRegistry schemeRegistry = new SchemeRegistry();\n        schemeRegistry.register(new Scheme(\"https\", socketFactory, Integer.parseInt(Constants.PORT_NUMBER)));\n        ThreadSafeClientConnManager cManager = new ThreadSafeClientConnManager(httpParams, schemeRegistry);\n\n        HttpClient httpClient = new DefaultHttpClient(cManager, httpParams);\n        return httpClient.execute(request);\n    } catch (Exception e) {\n        if (Constants.DEBUG) {\n            Log.e(TAG, \"\", e);\n        }\n    }\n    return null;\n}\n", "    import java.io.IOException;\n    import java.net.Socket;\n    import java.net.UnknownHostException;\n    import java.security.KeyManagementException;\n    import java.security.KeyStore;\n    import java.security.KeyStoreException;\n    import java.security.NoSuchAlgorithmException;\n    import java.security.UnrecoverableKeyException;\n    import java.security.cert.CertificateException;\n    import java.security.cert.X509Certificate;\n\n    import javax.net.ssl.SSLContext;\n    import javax.net.ssl.TrustManager;\n    import javax.net.ssl.X509TrustManager;\n\n    import org.apache.http.conn.ssl.SSLSocketFactory;\n\n    public class CustomSSLSocketFactory extends SSLSocketFactory {\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\npublic CustomSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n    super(truststore);\n\n    TrustManager tm = new X509TrustManager() {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n\n    sslContext.init(null, new TrustManager[] { tm }, null);\n}\n\n@Override\npublic Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n}\n\n@Override\npublic Socket createSocket() throws IOException {\n    return sslContext.getSocketFactory().createSocket();\n}\n", "public static String decrypt(String text){\n    try {           \n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] keyBytes= new byte[16];\n        byte[] b= KEY.getBytes(\"UTF-8\");\n        int len= b.length;\n        if (len &gt; keyBytes.length) len = keyBytes.length;\n        System.arraycopy(b, 0, keyBytes, 0, len);\n        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n        cipher.init(Cipher.DECRYPT_MODE,keySpec,ivSpec);\n        byte[] results = cipher.doFinal(Base64.decode(text, 0));\n        return new String(results, \"UTF-8\");\n    } catch (Exception e) {\n        // TODO: handle exception\n        Log.d(\"decryption\", e.getMessage());\n        return null;\n    }\n}   \n", "// Use RSA/NONE/NoPadding as algorithm and BouncyCastle as crypto provider\nCipher asymmetricCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\", \"BC\");\n\n// asume, that publicKeyBytes contains a byte array representing\n// your public key\nX509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);\n\nKeyFactory keyFactory;\nkeyFactory = KeyFactory.getInstance(publicKeySpec.getFormat());\nKey key = keyFactory.generatePublic(publicKeySpec);\n\n// initialize your cipher\nasymmetricCipher.init(Cipher.DECRYPT_MODE, key);\n// asuming, cipherText is a byte array containing your encrypted message\nbyte[] plainText = asymmetricCipher.doFinal(cipherText);\n", "static public PublicKey publicKey(String publicKeyString) {\n    try {\n        byte[] decodedPublicKey = Base64.decode(publicKeyString, 0);\n        ASN1InputStream in = new ASN1InputStream(decodedPublicKey);\n        ASN1Primitive obj = in.readObject();\n        RSAPublicKeyStructure keyStruct = RSAPublicKeyStructure.getInstance(obj);\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(keyStruct.getModulus(), keyStruct.getPublicExponent());\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        return keyFactory.generatePublic(keySpec);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "public static String getMD5(String input) {\n\n byte[] source;\n try {\n     source = input.getBytes(\"UTF-8\");\n } catch (UnsupportedEncodingException e) {\n     System.out.println(\"Error!\");\n }\n\n String result = null;\n char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n         '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n try {\n     MessageDigest md = MessageDigest.getInstance(\"MD5\");\n     md.update(source);\n     byte temp[] = md.digest();\n     char str[] = new char[16 * 2];\n     int k = 0;\n     for (int i = 0; i &lt; 16; i++) {\n         byte byte0 = temp[i];\n         str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];\n         str[k++] = hexDigits[byte0 &amp; 0xf];\n     }\n     result = new String(str);\n } catch (Exception e) {\n System.out.println(\"Error!\");\n}\nreturn result;\n}\n", "    try {\n            ECGenParameterSpec ecParamSpec = new ECGenParameterSpec(\"secp224k1\");\n            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECDH\",\"SC\");\n            kpg.initialize(ecParamSpec);\n\n            KeyPair kpair=kpg.generateKeyPair();\n            pkey=kpair.getPublic();\n            skey=kpair.getPrivate();\n        }catch(Exception e){e.printStackTrace();}\n", "import android.content.Context;\nimport android.util.Log;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateFactory;\nimport java.util.Scanner;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManagerFactory;\n\n/**\n * Created by Rinomancer on 20.08.2015.\n */\npublic class ConnectionBuilder {\n    private static SSLSocketFactory sslSocketFactory;\n    private Context context;\n    private URL url;\n    private String parameters = \"\";\n    private String response;\n    private HttpsURLConnection connection;\n\n    public ConnectionBuilder() {\n\n    }\n\n    public ConnectionBuilder(Context context, URL url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    private SSLSocketFactory getSSLSocketFactory() throws Exception {\n        if (sslSocketFactory == null) {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            InputStream caInput = new BufferedInputStream(context.getAssets().open(\"my_certificate.crt\"));\n            Certificate ca = cf.generateCertificate(caInput);\n\n            // Create a KeyStore containing our trusted CAs\n            String keyStoreType = KeyStore.getDefaultType();\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            keyStore.load(null, null);\n            keyStore.setCertificateEntry(\"ca\", ca);\n\n            // Create a TrustManager that trusts the CAs in our KeyStore\n            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n            tmf.init(keyStore);\n\n            // Create an SSLContext that uses our TrustManager\n            SSLContext context = SSLContext.getInstance(\"TLS\");\n            context.init(null, tmf.getTrustManagers(), null);\n\n            sslSocketFactory = context.getSocketFactory();\n        }\n        return sslSocketFactory;\n    }\n\n    public ConnectionBuilder connect() throws Exception {\n        connection = null;\n        try {\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(getSSLSocketFactory());\n            connection.setConnectTimeout(5000);\n\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n\n            connection.setRequestMethod(\"POST\");\n            connection.setFixedLengthStreamingMode(parameters.getBytes().length);\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            if (sessionId != null &amp;&amp; !sessionId.isEmpty()) {\n                connection.setRequestProperty(\"Session-Id\", sessionId);\n            }\n\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.print(parameters);\n            out.close();\n\n            String response = \"\";\n            Scanner inStream = new Scanner(connection.getInputStream());\n            while (inStream.hasNextLine()) {\n                response += inStream.nextLine();\n            }\n            this.response = response;\n\n            return this;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public ConnectionBuilder context(Context context) {\n        this.context = context;\n        return this;\n    }\n\n    public ConnectionBuilder url(URL url) {\n        this.url = url;\n        return this;\n    }\n\n    public ConnectionBuilder url(String url) throws MalformedURLException {\n        this.url = new URL(url);\n        return this;\n    }\n\n    public ConnectionBuilder parameter(String parameter, String value) throws UnsupportedEncodingException {\n        if (parameters.isEmpty()) {\n            parameters = parameter + \"=\" + URLEncoder.encode(value, \"UTF-8\");\n        } else {\n            parameters += \"&amp;\" + parameter + \"=\" + URLEncoder.encode(value, \"UTF-8\");\n        }\n        return this;\n    }\n\n    public String getResponse() {\n        return response;\n    }\n\n    public String getHeader(String headerName) {\n        return connection.getHeaderField(headerName);\n    }\n\n    public int getStatusCode() throws IOException{\n        return connection.getResponseCode();\n    }\n}\n", "public class SampleApplication extends Application {\n\npublic void onCreate(){   \nFacebookSdk.sdkInitialize(getApplicationContext());\nprintKeyHash();\n}\n public void printKeyHash() {\ntry {\n    PackageInfo info = getPackageManager().getPackageInfo(\"your package name\", PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.e(\"Hash Key\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n    } catch (PackageManager.NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n}\n}\n", " package com.infovale.cripto;\n\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n import java.math.BigInteger;\n import java.util.Arrays;\n\n import javax.crypto.Cipher;\n import javax.crypto.CipherInputStream;\n import javax.crypto.CipherOutputStream;\n import javax.crypto.KeyGenerator;\n import javax.crypto.SecretKey;\n import javax.crypto.spec.SecretKeySpec;\n\n import android.content.Context;\n\n public class AES extends Cripto {\n\npublic static String encrypt(Context c, String nomeArquivo) {\n    String caminhoArquivoPuro = new _Path().getPathFilePure() + \"/\"\n            + nomeArquivo;\n    String caminhoArquivoCriptografado = new _Path().getPathFileCripto()\n            + \"/\" + nomeArquivo;\n\n    String key = null;\n    ;\n\n    try {\n        FileInputStream fis = new FileInputStream(new File(\n                caminhoArquivoPuro));\n        File outfile = new File(caminhoArquivoCriptografado);\n\n        int read;\n        if (!outfile.exists())\n            outfile.createNewFile();\n\n        FileOutputStream fos = new FileOutputStream(outfile);\n        FileInputStream encfis = new FileInputStream(outfile);\n\n        Cipher encipher = Cipher.getInstance(\"AES\");\n\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecretKey skey = kgen.generateKey();\n        encipher.init(Cipher.ENCRYPT_MODE, skey);\n        CipherInputStream cis = new CipherInputStream(fis, encipher);\n\n        key = bytesToString(skey.getEncoded());\n\n        byte[] b = stringToBytes(key);\n\n        while ((read = cis.read()) != -1) {\n            fos.write((char) read);\n            fos.flush();\n        }\n        fos.close();\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        entityFiles file = new entityFiles();\n\n        file.setCaminhoArquivoPuro(caminhoArquivoPuro);\n        file.setCaminhoArquivoCriptografado(caminhoArquivoCriptografado);\n        file.setKeyArquivo(key);\n        file.setNomeArquivo(nomeArquivo);\n\n        ArquivoDataSource datasource = new ArquivoDataSource(c);\n\n        datasource.open();\n\n        file = datasource.createRegistro(file);\n\n        datasource.close();\n    }\n\n    return key;\n}\n\npublic static void decrypt(Context c, String nomeArquivo, String key) {\n\n    String caminhoArquivoPuro = new _Path().getPathFileCripto() + \"/\"\n            + nomeArquivo;\n    String caminhoArquivoCriptografado = new _Path().getPathFileDescripto()\n            + \"/\" + nomeArquivo;\n\n    try {\n        FileInputStream fis = new FileInputStream(new File(\n                caminhoArquivoPuro));\n        File outfile = new File(caminhoArquivoPuro);\n\n        int read;\n        if (!outfile.exists()) {\n            outfile.createNewFile();\n        }\n\n        File decfile = new File(caminhoArquivoCriptografado);\n\n        if (!decfile.exists()) {\n            decfile.createNewFile();\n        }\n\n        FileInputStream encfis = new FileInputStream(outfile);\n        FileOutputStream decfos = new FileOutputStream(decfile);\n\n        Cipher decipher = Cipher.getInstance(\"AES\");            \n\n\n\n        SecretKey originalKey = new SecretKeySpec(stringToBytes(key), 0,\n                stringToBytes(key).length, \"AES\");\n\n\n        decipher.init(Cipher.DECRYPT_MODE, originalKey);\n        CipherOutputStream cos = new CipherOutputStream(decfos, decipher);\n\n        while ((read = encfis.read()) != -1) {\n            cos.write(read);\n            cos.flush();\n        }\n        cos.close();\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic static String bytesToString(byte[] b) {\n    byte[] b2 = new byte[b.length + 1];\n    b2[0] = 1;\n    System.arraycopy(b, 0, b2, 1, b.length);\n    return new BigInteger(b2).toString(36);\n}\n\npublic static byte[] stringToBytes(String s) {\n    byte[] b2 = new BigInteger(s, 36).toByteArray();\n    return Arrays.copyOfRange(b2, 1, b2.length);\n}\n\n }\n", "    try {\n        Log.d(\"Checking signs\", \"Signs\");\n        PackageInfo info = getPackageManager().getPackageInfo(\n                this.getPackageName(), PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            System.out.print(Base64.encodeToString(md.digest(),\n                    Base64.DEFAULT));\n\n        }\n    } catch (NameNotFoundException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n}\n", "KeyStore keyStore = KeyStore.getInstance(\"BKS\");\nkeyStore.load(null, password);\n", " public WebsocketTransport(URI uri, IOConnection connection) {\n    super(uri);\n    this.connection = connection;\n    SSLContext context = null;\n    try {\n        context = SSLContext.getInstance(\"TLS\", \"HarmonyJSSE\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchProviderException e) {\n        e.printStackTrace();\n    } \n    try {\n        context.init(null, null, null);\n    } catch (KeyManagementException e) {\n        e.printStackTrace();\n    }\n    if(\"wss\".equals(uri.getScheme()) &amp;&amp; context != null) {\n        this.setWebSocketFactory(new DefaultSSLWebSocketClientFactory(context));\n    }\n}\n", "socket = new SocketIO();\nsocket.setDefaultSSLSocketFactory(SSLContext.getDefault());\nsocket.connect(\"https://www.myHttpsServer.com:443/\");\n", "final Socket tcpSocket = SSLSocketFactory.getDefault().createSocket(\"host ip\", 443);\nString connect = \"custom CONNECT header\";\n\ntcpSocket.getOutputStream().write((connect).getBytes());\ntcpSocket.getOutputStream().flush();\n", "package blabla.fileencrypter;\n\nimport lots;\n\n/**\n * The FileEncoder class provides an interface to allow for easy encrypting and decrypting of files. To use this class, first call both {@link #setSalts(String, String)} and {@link #setFolders(String, String)}.\n * @author Dani\u00c3\u00abl van den Berg\n * @since Nov 26, 2015\n *\n */\npublic class FileEncrypter {\n    private static String encryptedFolder = \"\";\n    private static String decryptedFolder = \"\";\n    private static byte[] salt = null;\n    private static String encryptedPostfix = \"\";\n    private static final HashMap&lt;Integer, HashMap&lt;String,Cipher&gt;&gt; ciphers = new HashMap&lt;Integer, HashMap&lt;String, Cipher&gt;&gt;();\n\n    /**\n     * Sets the folders the documents have to be placed in.\n     * @param encryptedFolder The folder encrypted files have to be placed in.\n     * @param decryptedFolder The folder decrypted files have to be placed in.\n     */\n    public static void setFolders(String encryptedFolder, String decryptedFolder){\n        FileEncrypter.encryptedFolder = encryptedFolder;\n        FileEncrypter.decryptedFolder = decryptedFolder;\n    }\n\n    /**\n     * A postfix to give to encrypted files. Can be \"\" for no postfix.\n     * @param extension The postfix to append to encrypted files.\n     */\n    public static void setEncryptedPostfix(String extension){\n        if (extension != null){\n            FileEncrypter.encryptedPostfix = extension;\n        }else{\n            FileEncrypter.encryptedPostfix = \"\";\n        }\n    }\n\n    /**\n     * The salts to use when encrypting/decrypting files.\n     * @param salt The salt to use.\n     * @param ivParameterSpec The buffer with the IV.\n     * @throws FileEncryptingException When the ivParameterSpec is smaller than 16 bytes.\n     */\n    public static void setSalts(String salt) throws FileEncryptingException{\n        FileEncrypter.salt = salt.getBytes();\n    }\n\n    /**\n     * Encode the given inputFile with the given key.\n     * @param inputFile The file to encrypt.\n     * @param key The key to use for encrypting the file.\n     * @return The encrypted file.\n     * @throws FileEncryptingException\n     * @throws NoSuchAlgorithmException\n     * @throws NoSuchPaddingException\n     * @throws InvalidKeyException\n     * @throws IOException\n     * @throws InvalidKeySpecException\n     * @throws InvalidAlgorithmParameterException\n     */\n    public static File encrypt(File inputFile, String key) throws FileEncryptingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException, InvalidKeySpecException, InvalidAlgorithmParameterException{\n        if (isEncrypted(inputFile)){\n            throw new FileEncryptingException(\"File not decrypted: \"+inputFile.getAbsolutePath());\n        }\n\n        FileInputStream inputStream = new FileInputStream(inputFile);\n        BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);\n\n        File outputFile = new File(inputFile.getAbsolutePath().replace(decryptedFolder,encryptedFolder) + encryptedPostfix);\n        outputFile.getParentFile().mkdirs();\n        FileOutputStream outputStream = new FileOutputStream(outputFile);\n        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(outputStream);\n        processStream(Cipher.ENCRYPT_MODE,key,bufferedInputStream,bufferedOutputStream);\n        inputStream.close();\n        outputStream.close();\n        bufferedInputStream.close();\n        bufferedOutputStream.close();\n        return outputFile;\n    }\n\n    /**\n     * Decrypt the given inputFile with the given key.\n     * @param inputFile The file to decrypt.\n     * @param key The key to use for decrypting the file.\n     * @return The decrypted file.\n     * @throws FileEncryptingException\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws NoSuchPaddingException\n     * @throws InvalidKeyException\n     * @throws InvalidKeySpecException\n     * @throws InvalidAlgorithmParameterException\n     */\n    public static File decrypt(File inputFile, String key) throws FileEncryptingException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidKeySpecException, InvalidAlgorithmParameterException{\n        if (!isEncrypted(inputFile)){\n            throw new FileEncryptingException(\"File not encrypted: \"+inputFile.getAbsolutePath());\n        }\n\n        if (!inputFile.exists() &amp;&amp; !inputFile.getAbsolutePath().contains(encryptedPostfix)){\n            inputFile = new File(inputFile.getAbsolutePath()+encryptedPostfix);\n        }\n\n        FileInputStream inputStream = new FileInputStream(inputFile);\n        BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);\n\n        File outputFile = new File(inputFile.getAbsolutePath().replace(encryptedPostfix, \"\").replace(encryptedFolder,decryptedFolder));\n        outputFile.getParentFile().mkdirs();\n        FileOutputStream outputStream = new FileOutputStream(outputFile);\n        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(outputStream);\n        processStream(Cipher.DECRYPT_MODE,key,bufferedInputStream,bufferedOutputStream);\n        inputStream.close();\n        outputStream.close();\n        bufferedInputStream.close();\n        bufferedOutputStream.close();\n        return outputFile;\n    }\n\n    /**\n     * Used for generating a cipher.\n     * @param cipherMode The cipher mode to use. Either &lt;code&gt;Cipher.DECRYPT_MODE&lt;/code&gt; or &lt;code&gt;Cipher.ENCRYPT_MODE&lt;/code&gt;\n     * @param key The key to generate the cipher with.\n     * @return The generated cipher.\n     * @throws NoSuchAlgorithmException\n     * @throws InvalidKeySpecException\n     * @throws NoSuchPaddingException\n     * @throws InvalidKeyException\n     * @throws InvalidAlgorithmParameterException\n     */\n    private static Cipher getCipher(int cipherMode, String key) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n        if (!ciphers.containsKey(cipherMode)){\n            synchronized (ciphers){\n                if (!ciphers.containsKey(cipherMode)){\n                    ciphers.put(cipherMode, new HashMap&lt;String,Cipher&gt;());\n                }\n            }\n        }\n        HashMap&lt;String, Cipher&gt; hashMap = ciphers.get(cipherMode);\n        if (!hashMap.containsKey(key)){\n            synchronized (hashMap) {\n                if (!hashMap.containsKey(key)){\n                    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n                    KeySpec spec = new PBEKeySpec(key.toCharArray(), salt, 65536, 128);\n                    SecretKey tmp = factory.generateSecret(spec);\n                    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"RC4\");\n\n                    Cipher c = Cipher.getInstance(\"RC4\");\n                    c.init(cipherMode, secret);\n                    hashMap.put(key, c);\n                }\n            }\n        }\n        return hashMap.get(key);\n    }\n\n    /**\n     * Process a stream. This will encrypt or decrypt the stream, depending on the given cipherMode. The output will be available in the given {@link OutputStream}.\n     * @param cipherMode The cipher mode to use. Either &lt;code&gt;Cipher.DECRYPT_MODE&lt;/code&gt; or &lt;code&gt;Cipher.ENCRYPT_MODE&lt;/code&gt;\n     * @param key The key to use for decryption/encryption.\n     * @param inputStream The stream to read from.\n     * @param outputStream The stream to write the encrypted/decrypted result to.\n     * @throws InvalidKeyException\n     * @throws NoSuchAlgorithmException\n     * @throws InvalidKeySpecException\n     * @throws NoSuchPaddingException\n     * @throws InvalidAlgorithmParameterException\n     * @throws IOException\n     */\n    public static void processStream(int cipherMode, String key, InputStream inputStream, OutputStream outputStream) throws InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidAlgorithmParameterException, IOException{\n        Cipher c = getCipher(cipherMode,key);\n        CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, c);\n        int b = 0;\n        while ((b = inputStream.read()) !=-1){\n            cipherOutputStream.write(b);\n        }\n        cipherOutputStream.close();\n    }\n\n    /**\n     * Returns a file, no matter whether it's encrypted or not. See {@link #isEncrypted(File)} to detect if the file is encrypted.\n     * @param filenameDecrypted The filename the decrypted file would have.\n     * @return The file that corresponds with the given filename.\n     */\n    public static File getFile(String filenameDecrypted){\n        if (!filenameDecrypted.contains(decryptedFolder) &amp;&amp; !filenameDecrypted.contains(encryptedFolder)){\n            filenameDecrypted = decryptedFolder + filenameDecrypted;\n        }\n        File file = new File(filenameDecrypted);\n        if (!file.exists()){\n            file = new File(filenameDecrypted.replace(decryptedFolder, encryptedFolder)+encryptedPostfix);\n        }\n        return file;\n    }\n\n    /**\n     * Checks if the file is encrypted or not.\n     * @param file The file to check.\n     * @return True if the file is encrypted, false otherwise.\n     */\n    public static boolean isEncrypted(File file){\n        return file.getAbsolutePath().contains(encryptedFolder) || (!encryptedPostfix.isEmpty() &amp;&amp; file.getAbsolutePath().contains(encryptedPostfix));\n    }\n}\n", "RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(mod,exp);\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\",\"BS\");\nPublicKey publicKey = keyFactory.generatePublic(rsaPublicKeySpec);\nCipher cipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\", \"BS\");\ncipher.init(Cipher.ENCRYPT_MODE, publicKey);\nbyte[] encryptedBytes = cipher.doFinal(plainText.getBytes(\"UTF-8\"));//\nbyte[] coded = Base64.encodeBase64(encryptedBytes);  //used library encode decode\nString encryptedData = new String(encodedBytes);\n", "package il.co.falk;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.*;\nimport java.security.spec.KeySpec;\nimport java.security.spec.PKCS8EncodedKeySpec;\n\npublic class SecureFile {\nprivate PublicKey publicKey;\nprivate byte[] privateKeyArray;\nprivate byte[] salt = {1,2,3,4,5,6,7,8};\n\n\npublic static void main(String[] args) {\n    String password = \"PASSWORD\";\n    SecureFile secureFile = new SecureFile(password);\n    secureFile.test();\n}\n\n\npublic void test() {\n    String password = \"PASSWORD\";\n    String imageFile = \"348756348975634897562398479623896\";\n\n    ImageAndKey imageAndKey = encryptImage(imageFile.getBytes());\n    byte[] decryptedImage = decryptImage(imageAndKey, password);\n\n    System.out.println(new String(imageFile));\n    System.out.println(new String(decryptedImage));\n}\n\npublic SecureFile(String password) {\n    try {\n        generateRSAKeys(password);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n\n\npublic ImageAndKey encryptImage(byte[] imageBytes) {\n    try {\n        byte[] secretKeyBytes = generateAESKey();\n        byte[] encryptedFile = aesEncrypt(imageBytes, secretKeyBytes);\n        byte[] encryptedKey = rsaEncrypt(secretKeyBytes);\n\n        return new ImageAndKey(encryptedFile, encryptedKey);\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n\n}\n\npublic byte[] decryptImage(ImageAndKey imageAndKey, String password) {\n    try {\n        byte[] secretKeyBytes = generateAESKey(password);\n        byte[] decryptedPrivateKey = aesDecrypt(privateKeyArray, secretKeyBytes);\n        byte[] decryptedKey = rsaDecrypt(imageAndKey.aesKey, decryptedPrivateKey);\n\n        SecretKey secretKey = new SecretKeySpec(decryptedKey, \"AES\");\n        secretKeyBytes = secretKey.getEncoded();\n\n        byte[] decryptedBytes = aesDecrypt(imageAndKey.imageBytes, secretKeyBytes);\n\n        return  decryptedBytes;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\n\n\n// RSA\nprivate void generateRSAKeys(String password) throws Exception {\n    final KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n    keyGen.initialize(512); // TODO: make this 2048 at least\n    final KeyPair keyPair = keyGen.generateKeyPair();\n    publicKey = keyPair.getPublic();\n    PrivateKey privateKey = keyPair.getPrivate();\n\n    byte[] secretKeyBytes = generateAESKey(password);\n    byte[] privateKeyBytes = privateKey.getEncoded();\n    privateKeyArray = aesEncrypt(privateKeyBytes, secretKeyBytes);\n}\n\npublic byte[] rsaEncrypt(byte[] plainText) throws Exception {\n    final Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    byte[] cipherText = cipher.doFinal(plainText);\n    return cipherText;\n}\n\npublic byte[] rsaDecrypt(byte[] cipherText, byte[] decryptedPrivateKeyArray) throws Exception {\n    PrivateKey privateKey = KeyFactory.getInstance(\"RSA\").generatePrivate(new PKCS8EncodedKeySpec(decryptedPrivateKeyArray));\n\n    final Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, privateKey);\n    byte[]  plainText = cipher.doFinal(cipherText);\n    return plainText;\n}\n\n// AES\nprivate byte[] aesEncrypt(byte[] plainText, byte[] secretKeyBytes) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(secretKeyBytes));\n    byte[] cipherText = cipher.doFinal(plainText);\n    return cipherText;\n}\n\npublic byte[] aesDecrypt(byte[] cipherText, byte[] secretKeyBytes) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, getSecretKey(secretKeyBytes));\n    byte[] plainText = cipher.doFinal(cipherText);\n    return plainText;\n}\n\nprivate byte[] generateAESKey() throws Exception {\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    keyGen.init(256);\n    SecretKey secretKey = keyGen.generateKey();\n    return secretKey.getEncoded();\n}\n\nprivate byte[] generateAESKey(String password) throws Exception {\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 65536, 256);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n    return secret.getEncoded();\n}\n\nprivate SecretKey getSecretKey(byte[] secretKeyBytes) throws Exception {\n    SecretKey secretKey = new SecretKeySpec(secretKeyBytes, \"AES\");\n    return secretKey;\n}\n\n\n\n// Classes\nclass ImageAndKey {\n    public byte[] imageBytes;\n    public byte[] aesKey;\n\n    public ImageAndKey(byte[] imageBytes, byte[] aesKey) {\n        this.imageBytes = imageBytes;\n        this.aesKey = aesKey;\n    }\n}\n", "X509TrustManager trustManager = new X509TrustManager() {\n                @Override\n                public void checkClientTrusted(X509Certificate[] chain,\n                        String authType) throws CertificateException {\n                    for (TrustManager tm : managers) {\n                        if (tm instanceof X509TrustManager) {\n                            ((X509TrustManager) tm).checkClientTrusted(\n                                    chain, authType);\n                        }\n                    }\n                }\n\n                @Override\n                public void checkServerTrusted(X509Certificate[] chain,\n                        String authType) throws CertificateException {\n                    for (X509Certificate cert : chain) {\n                        // cert gives the server Certificate Information.\n                        if (cert.getIssuerX500Principal().equals(\n                                trustedRoot.getIssuerX500Principal())) {\n                            return;\n                        }\n                    }\n                    for (TrustManager tm : managers) {\n                        if (tm instanceof X509TrustManager) {\n                            ((X509TrustManager) tm).checkServerTrusted(\n                                    chain, authType);\n                        }\n                    }\n                }\n\n                @Override\n                public X509Certificate[] getAcceptedIssuers() {\n                    ArrayList&lt;X509Certificate&gt; issuers = new ArrayList&lt;&gt;();\n                    for (TrustManager tm : managers) {\n                        if (tm instanceof X509TrustManager) {\n                            issuers.addAll(Arrays\n                                    .asList(((X509TrustManager) tm)\n                                            .getAcceptedIssuers()));\n                        }\n                    }\n                    return issuers.toArray(new X509Certificate[issuers\n                            .size()]);\n                }\n\n            };\n", "public byte[] digest(String value) throws NoSuchAlgorithmException {\n    MessageDigest digester = MessageDigest.getInstance(\"SHA-256\");\n\n    byte[] stringBytes = value.getBytes();\n\n    digester.update(stringBytes, 0, stringBytes.length);\n\n    return digester.digest();\n}\n", "public String convert(String str){\n        String a=null;\n         char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', \n                  'a', 'b', 'c', 'd', 'e', 'f' }; \n        try {\n            a=new   String(str.getBytes(\"ISO8859_1\"),\"UTF-8\");\n            byte[] strTemp = str.getBytes(); \n            MessageDigest mdTemp = MessageDigest.getInstance(\"MD5\"); \n               mdTemp.update(strTemp); \n               byte[] md = mdTemp.digest(); \n               int j = md.length; \n               char str1[] = new char[j * 2]; \n               int k = 0; \n               for (int i = 0; i &lt; j; i++) { \n                byte b = md[i]; \n                //System.out.println((int)b);  \n                str1[k++] = hexDigits[b &gt;&gt; 4 &amp; 0xf]; \n                str1[k++] = hexDigits[b &amp; 0xf]; \n               } \n\n\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n return new String(str1); \n\n}\n", "KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\nks.load(null, null);\nEnumeration aliases = ks.aliases();\nwhile (aliases.hasMoreElements()) {\n    String alias = aliases.nextElement();\n    X09Certificate cert = (X509Certificate) \n       ks.getCertificate(alias);\n    Log.d(TAG, \"Subject DN: \" + \n       cert.getSubjectDN().getName());\n    Log.d(TAG, \"Issuer DN: \" + \n       cert.getIssuerDN().getName());\n}\n", "public static String makeCheck(String url)\n{\n    URL u=new URL(url);\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    u.getQuery();\n    md.update(u.getQuery().getBytes());\n    BigInteger bn = new BigInteger(1,md.digest(\"A_SECRET_WORD\".getBytes()));\n    return bn.toString(16);\n}\n", "byte temp[];\nBase64 b = new Base64();\nString jsonString = clientHash.getJSONObject(\"client_auth_hash\").toString();\ntemp = b.decode(jsonString.getBytes());\n", "public void sslCheck() {\n\n        int PLAY_SERVICES_RESOLUTION_REQUEST=9000;\n        int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(this);\n        //Log.i(\"log_tag2\", String.valueOf(resultCode));\n        if (resultCode != ConnectionResult.SUCCESS) {\n            if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {\n                Log.i(\"log_tag2\",\"Not good!\");\n                if (MyAppActivity.instance != null) {\n                    Log.i(\"log_tag2\",\"but can fix\");\n                    GooglePlayServicesUtil.getErrorDialog(\n                            resultCode,\n                            MyAppActivity.instance,\n                            PLAY_SERVICES_RESOLUTION_REQUEST).show();\n                }\n            }\n        }\n        else {\n            Log.i(\"log_tag2\",\"Already good!\");\n            try {\n                ProviderInstaller.installIfNeeded(this);\n                Log.i(\"log_tag\", \"1\");\n            } catch (GooglePlayServicesRepairableException e) {\n                e.printStackTrace();\n            } catch (GooglePlayServicesNotAvailableException e) {\n                e.printStackTrace();\n            }\n            SSLContext helper=null;\n            try {\n                helper = SSLContext.getInstance(\"TLSv1.2\");\n                Log.i(\"log_tag\",\"2\");\n            } catch (NoSuchAlgorithmException e) {\n                e.printStackTrace();\n            }\n            try {\n                helper.init(null,null,null);\n                Log.i(\"log_tag\", \"3\");\n            } catch (KeyManagementException e) {\n                e.printStackTrace();\n            }\n            SSLEngine engine = helper.createSSLEngine();\n        }\n    }\n", "// 16 characters for 128-bit AES\nprivate final static String PASSPHRASE=\"myappspassphrase\"\n\nSecretKeySpec key = new SecretKeySpec(PASSPHRASE.getBytes(\"UTF-8\"), \"AES\");\n\n...\n\n// Initialise the cipher\nCipher encryptCipher = Cipher.getInstance(\"AES\");\nencryptCipher.init(Cipher.ENCRYPT_MODE, key);\n", "/**\n * Warning, this gives a false sense of security.  If an attacker has enough access to\n * acquire your password store, then he almost certainly has enough access to acquire your\n * source binary and figure out your encryption key.  However, it will prevent casual\n * investigators from acquiring passwords, and thereby may prevent undesired negative\n * publicity.\n */\npublic class ObscuredSharedPreferences implements SharedPreferences {\n    protected static final String UTF8 = \"utf-8\";\n    private static final char[] SEKRIT = ... ; // INSERT A RANDOM PASSWORD HERE.\n                                               // Don't use anything you wouldn't want to\n                                               // get out there if someone decompiled\n                                               // your app.\n\n\n    protected SharedPreferences delegate;\n    protected Context context;\n\n    public ObscuredSharedPreferences(Context context, SharedPreferences delegate) {\n        this.delegate = delegate;\n        this.context = context;\n    }\n\n    public class Editor implements SharedPreferences.Editor {\n        protected SharedPreferences.Editor delegate;\n\n        public Editor() {\n            this.delegate = ObscuredSharedPreferences.this.delegate.edit();                    \n        }\n\n        @Override\n        public Editor putBoolean(String key, boolean value) {\n            delegate.putString(key, encrypt(Boolean.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putFloat(String key, float value) {\n            delegate.putString(key, encrypt(Float.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putInt(String key, int value) {\n            delegate.putString(key, encrypt(Integer.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putLong(String key, long value) {\n            delegate.putString(key, encrypt(Long.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putString(String key, String value) {\n            delegate.putString(key, encrypt(value));\n            return this;\n        }\n\n        @Override\n        public void apply() {\n            delegate.apply();\n        }\n\n        @Override\n        public Editor clear() {\n            delegate.clear();\n            return this;\n        }\n\n        @Override\n        public boolean commit() {\n            return delegate.commit();\n        }\n\n        @Override\n        public Editor remove(String s) {\n            delegate.remove(s);\n            return this;\n        }\n    }\n\n    public Editor edit() {\n        return new Editor();\n    }\n\n\n    @Override\n    public Map&lt;String, ?&gt; getAll() {\n        throw new UnsupportedOperationException(); // left as an exercise to the reader\n    }\n\n    @Override\n    public boolean getBoolean(String key, boolean defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Boolean.parseBoolean(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public float getFloat(String key, float defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Float.parseFloat(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public int getInt(String key, int defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Integer.parseInt(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public long getLong(String key, long defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Long.parseLong(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public String getString(String key, String defValue) {\n        final String v = delegate.getString(key, null);\n        return v != null ? decrypt(v) : defValue;\n    }\n\n    @Override\n    public boolean contains(String s) {\n        return delegate.contains(s);\n    }\n\n    @Override\n    public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) {\n        delegate.registerOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener);\n    }\n\n    @Override\n    public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) {\n        delegate.unregisterOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener);\n    }\n\n\n\n\n    protected String encrypt( String value ) {\n\n        try {\n            final byte[] bytes = value!=null ? value.getBytes(UTF8) : new byte[0];\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n            SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n            Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n            pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));\n            return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP),UTF8);\n\n        } catch( Exception e ) {\n            throw new RuntimeException(e);\n        }\n\n    }\n\n    protected String decrypt(String value){\n        try {\n            final byte[] bytes = value!=null ? Base64.decode(value,Base64.DEFAULT) : new byte[0];\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n            SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n            Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n            pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));\n            return new String(pbeCipher.doFinal(bytes),UTF8);\n\n        } catch( Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n", "private class UploadFileToServer extends AsyncTask&lt;Void, Integer, String&gt; {\n    JSONObject jsonObject = null;\n\n    @Override\n    protected void onPreExecute() {\n\n        upload_image_progress.setProgress(0);\n\n         int totalSize = 0\n        super.onPreExecute();\n    }\n\n    @Override\n    protected void onProgressUpdate(Integer... progress) {\n        // Making progress bar visible\n        upload_image_progress.setVisibility(View.VISIBLE);\n        // mHandler.sendEmptyMessageDelayed(progress[0], 100);\n        // updating progress bar value\n        upload_image_progress.setProgress(progress[0]);\n\n        // updating percentage value\n        // txtPercentage.setText(String.valueOf(progress[0]) + \"%\");\n    }\n\n    @Override\n    protected String doInBackground(Void... params) {\n        return uploadFile();\n    }\n\n    private String uploadFile() {\n\n        String responseString = null;\n        try {\n\n            HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n\n            HttpClient client = new DefaultHttpClient();\n\n            SchemeRegistry registry = new SchemeRegistry();\n            SSLSocketFactory socketFactory = SSLSocketFactory\n                    .getSocketFactory();\n            socketFactory\n                    .setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\n\n            registry.register(new Scheme(\"http\", socketFactory, 443));\n            SingleClientConnManager mgr = new SingleClientConnManager(\n                    client.getParams(), registry);\n            DefaultHttpClient httpClient = new DefaultHttpClient(mgr,\n                    client.getParams());\n\n            // Set verifier\n            HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n\n\n            HttpPost httpPost = new HttpPost(\"your url\");\n\n\n            AndroidMultiPartEntity entity = new AndroidMultiPartEntity(\n                    new ProgressListener() {\n\n                        @Override\n                        public void transferred(long num) {\n                            publishProgress((int) ((num * 100) / totalSize));\n\n                        }\n                    });\n\n            File sourceFile = new File(\"image path\");\n            long fileSizeInBytes = sourceFile.length();\n\n            // Convert the bytes to Kilobytes (1 KB = 1024 Bytes)\n            long fileSizeInKB = fileSizeInBytes / 1024;\n\n            // Convert the KB to MegaBytes (1 MB = 1024 KBytes)\n            long fileSizeInMB = fileSizeInKB / 1024;\n            // Log.e(\"file length in MB\", \"\" + fileSizeInMB);\n            if (fileSizeInMB &gt; 2) {\n\n                BitmapFactory.Options options = new BitmapFactory.Options();\n                options.inSampleSize = 8;\n\n                Bitmap bmp = BitmapFactory.decodeFile(image_uri, options);\n\n                ByteArrayOutputStream bos = new ByteArrayOutputStream();\n                bmp.compress(CompressFormat.JPEG, 70, bos);\n                InputStream in = new ByteArrayInputStream(bos.toByteArray());\n\n                ContentBody foto = new InputStreamBody(in, \"image/jpeg\",\n                        image_uri);\n\n                Log.e(\"size\", \"\" + bos.size());\n\n                entity.addPart(\"image_file\", foto);\n\n\n                totalSize = bos.size();\n                Log.e(\"file length\", \"\" + sourceFile.length());\n\n                // Adding file data to http body\n            } else {\n                entity.addPart(\"image_file\", new FileBody(sourceFile));\n                totalSize = entity.getContentLength();\n\n            }\n\n            httpPost.setEntity(entity);\n\n            HttpResponse response = client.execute(httpPost);\n\n            // Making server call\n\n            HttpEntity r_entity = response.getEntity();\n\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode == 200) {\n                // Server response\n                responseString = EntityUtils.toString(r_entity);\n                jsonObject = new JSONObject(responseString);\n            } else {\n\n                responseString = \"Error occurred! Http Status Code: \"\n                        + statusCode;\n            }\n\n        } catch (ClientProtocolException e) {\n            responseString = e.toString();\n            e.printStackTrace();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n            responseString = e.toString();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n\n        }\n\n        return responseString;\n\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        try {\n\n            if (jsonObject != null) {\n                //get response here\n                }\n        super.onPostExecute(result);\n    }\n\n}\n", "                KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n    keyGen.initialize(1024);\n    KeyPair keyPair = keyGen.generateKeyPair();\n    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n    RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n    BigInteger mod_Int = publicKey.getModulus();\n    BigInteger exp_Int = publicKey.getPublicExponent();\n    byte[] mod_Bytes_Extra = mod_Int.toByteArray();\n    byte[] mod_Bytes = new byte[128];\n    System.arraycopy(mod_Bytes_Extra, 1, mod_Bytes, 0, 128);\n    byte[] exp_Bytes = exp_Int.toByteArray();\n    String modulus = Base64.encodeToString(mod_Bytes, Base64.DEFAULT);\n    String exponent = Base64.encodeToString(exp_Bytes, Base64.DEFAULT);\n    System.out.println(modulus);\n    System.out.println(exponent);\n    String public_Xml = \"&lt;BitStrength&gt;0124&lt;/BitStrength&gt;&lt;RSAKeyValue&gt;&lt;Modulus&gt;\"+modulus+\"&lt;/Modulus&gt;&lt;Exponent&gt;\"+exponent+\"&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;\";\n", "public HttpClient getNewHttpClient() {\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore\n                    .getDefaultType());\n            trustStore.load(null, null);\n\n            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n            HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory\n                    .getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sf, 443));\n\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(\n                    params, registry);\n\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception e) {\n            return new DefaultHttpClient();\n        }\n    }\n\n\n\npublic class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n}\n", "public void printHashKey() {\n\n   // Add code to print out the key hash\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"com.facebook.samples.hellofacebook\", \n                PackageManager.GET_SIGNATURES);\n\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n}\n", "public String encrypt(String unencryptedString, byte[] ivBytes, byte[] keyBytes){\n\n String encryptedString = null;\n\n   try {\n\n        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        SecretKeySpec Key = new SecretKeySpec(keyBytes, \"AES\");\n        Cipher cipher = null;\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);\n        byte[] encryptedText = cipher.doFinal(plainText);\n        encryptedString = new String(Base64.encodeBase64(encryptedText));\n\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                return encryptedString;\n            }\n", "// Create the OkHttp client        \nOkHttpClient okHttpClient = new OkHttpClient();\nSSLContext sslContext;\ntry {\n    sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, null, null);\n} catch (GeneralSecurityException e) {\n    throw new AssertionError(); // The system has no TLS. Just give up.\n}\nClient client = okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());\n\n// Create the Retrofit RestAdapter\nRestAdapter.LogLevel logLevel = BuildConfig.DEBUG ? RestAdapter.LogLevel.FULL : RestAdapter.LogLevel.NONE;\nreturn new RestAdapter.Builder()\n        .setEndpoint(BuildConfig.API_URL)\n        .setClient(client)\n        .setConverter(new GsonConverter(getGson()))\n        .setRequestInterceptor(new RetrofitAuthenticationInterceptor())\n        .setLogLevel(logLevel)\n        .build()\n        .create(ApiServiceV1.class);\n", "public static class _FakeX509TrustManager implements X509TrustManager {\n\n    private static TrustManager[] trustManagers;\n    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n    }\n\n    public boolean isClientTrusted(X509Certificate[] chain) {\n            return true;\n    }\n\n    public boolean isServerTrusted(X509Certificate[] chain) {\n            return true;\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n            return _AcceptedIssuers;\n    }\n\n    public static void allowAllSSL() {\n        HttpsURLConnection.setDefaultHostnameVerifier(new \n                HostnameVerifier(){\n                @Override\n                public boolean verify(String hostname, SSLSession session) {\n                        return true;\n                }\n\n        });\n\n        SSLContext context = null;\n        if (trustManagers == null) {\n                trustManagers = new TrustManager[] { new _FakeX509TrustManager() };\n        }\n\n        try {\n                context = SSLContext.getInstance(\"TLS\");\n                context.init(null, trustManagers, new SecureRandom());\n        } catch (NoSuchAlgorithmException e) {\n                e.printStackTrace();\n        } catch (KeyManagementException e) {\n                e.printStackTrace();\n        }\n\n\n        HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n}\n", "static public byte[] decrypt(Cipher cipher, SecretKey key, byte[]... bytes)\n        throws GeneralSecurityException, IOException {\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    for (int i = 0; i &lt; bytes.length; i++) {\n        bos.write(cipher.update(bytes[i]));\n    }\n    bos.write(cipher.doFinal());\n    return bos.toByteArray();\n}\n", "String android_id = Settings.Secure.getString(\n            this.getContentResolver(), Settings.Secure.ANDROID_ID);\nString deviceId = md5(android_id).toUpperCase();\n\n\npublic static final String md5(final String s) {\n    try {\n        // Create MD5 Hash\n        MessageDigest digest = java.security.MessageDigest\n                .getInstance(\"MD5\");\n        digest.update(s.getBytes());\n        byte messageDigest[] = digest.digest();\n\n        // Create Hex String\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i &lt; messageDigest.length; i++) {\n            String h = Integer.toHexString(0xFF &amp; messageDigest[i]);\n            while (h.length() &lt; 2)\n                h = \"0\" + h;\n            hexString.append(h);\n        }\n        return hexString.toString();\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "Security.addProvider(new BouncyCastleProvider());\n\nfinal char[] password = \"pass\".toCharArray();\nfinal int saltLength = 8;\nfinal String saltedPrefix = \"Salted__\";\n\nString[] files = { \"file0.txt.enc\", \"file0.txt.enc.nosalt\" };\nfor (String file : files) {\n    byte[] encrypted = Files.readAllBytes(Paths.get(\"testData\", \"openssl\", file));\n\n    byte[] salt = new byte[0];\n    int offset = 0;\n    if (new String(encrypted, 0, saltLength, \"ASCII\").equals(saltedPrefix)) {\n        salt = new byte[saltLength];\n        System.arraycopy(encrypted, saltedPrefix.length(), salt, 0, saltLength);\n        offset = saltedPrefix.length() + saltLength;\n    }\n\n    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWITHMD5AND256BITAES-CBC-OPENSSL\", \"BC\");\n    PBEKeySpec keySpec = new PBEKeySpec(password);\n    PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 0);\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\");\n    cipher.init(Cipher.DECRYPT_MODE, keyFactory.generateSecret(keySpec), paramSpec);\n\n    byte[] data = cipher.doFinal(encrypted, offset, encrypted.length- offset);\n    System.out.println(new String(data));\n}\n", "try {\n            String secret = \"secret\";\n            String message = \"Message\";\n\n            Mac sha_HMAC = Mac.getInstance(\"HmacSHA512\");\n\n            SecretKeySpec secret_key = new SecretKeySpec(secret.getBytes(), \"HmacSHA512\");\n            sha_HMAC.init(secret_key);\n\n            String hash = Base64.encodeToString(sha_HMAC.doFinal(message.getBytes()), Base64.DEFAULT);\n            System.out.println(hash);\n            Log.e(\"string is \",hash);\n\n        }\n        catch (Exception e){\n            System.out.println(\"Error\");\n        }\n", "private static byte[] Rfc2898DeriveBytes(String password, byte[] salt, int iterations) throws GeneralSecurityException {\n\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, Iterations, 256);\n    Key secretKey = factory.generateSecret(pbeKeySpec);\n    byte[] rawKeyData = secretKey.getEncoded();\n    return rawKeyData;\n}\n", "public static byte[] generateKey(String password) throws Exception\n{\n    byte[] keyStart = password.getBytes(\"UTF-8\");\n\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n    sr.setSeed(keyStart);\n    kgen.init(128, sr);\n    SecretKey skey = kgen.generateKey();\n    return skey.getEncoded();\n}\n\n    public static byte[] encodeFile(byte[] key, byte[] fileData) throws Exception\n    {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n        byte[] encrypted = cipher.doFinal(fileData);\n\n        return encrypted;\n    }\n\n    public static byte[] decodeFile(byte[] key, byte[] fileData) throws Exception\n    {\n        SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n        byte[] decrypted = cipher.doFinal(fileData);\n\n        return decrypted;\n    }\n", "public static String decrypt(InputStream stream, String encrypted) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException,\n        NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n    byte[] encodedKey = new byte[stream.available()];\n    stream.read(encodedKey);\n    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encodedKey);\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n    PublicKey pkPublic = kf.generatePublic(publicKeySpec);\n\n    Cipher pkCipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n    pkCipher.init(Cipher.DECRYPT_MODE, pkPublic);\n\n    byte[] decoded = Base64Coder.decode(encrypted);\n    byte[] decryptedInByte = pkCipher.doFinal(decoded);\n    return new String(decryptedInByte);\n}\n", "private static String seed;\n\n/**\n * Encrypts the text. \n * @param clearText The text you want to encrypt\n * @return Encrypted data if successful, or null if unsucessful\n */\nprotected String encrypt(String clearText) {\n    byte[] encryptedText = null;\n    try {\n        byte[] keyData = seed.getBytes();\n        SecretKey ks = new SecretKeySpec(keyData, \"AES\");\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.ENCRYPT_MODE, ks);\n        encryptedText = c.doFinal(clearText.getBytes(\"UTF-8\"));\n        return Base64.encodeToString(encryptedText, Base64.DEFAULT);\n    } catch (Exception e) {\n        return null;\n    }\n}\n\n/**\n * Decrypts the text\n * @param encryptedText The text you want to encrypt\n * @return Decrypted data if successful, or null if unsucessful\n */\nprotected String decrypt (String encryptedText) {\n    byte[] clearText = null;\n    try {\n        byte[] keyData = seed.getBytes();\n        SecretKey ks = new SecretKeySpec(keyData, \"AES\");\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.DECRYPT_MODE, ks);\n        clearText = c.doFinal(Base64.decode(encryptedText, Base64.DEFAULT));\n        return new String(clearText, \"UTF-8\");\n    } catch (Exception e) {\n        return null;\n    }\n}   \n", "public static String getApkFileDigest(Context context) {\n        String apkPath = context.getPackageCodePath();\n        try {\n            byte[] hashed= getDigest(new FileInputStream(apkPath), \"SHA-256\");\n            return Base64.encodeToString(hashed, Base64.DEFAULT);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }\n        return null;\n    }\n\n    public static final int BUFFER_SIZE = 2048;\n\n    public static byte[] getDigest(InputStream in, String algorithm) throws Throwable {\n        MessageDigest md = MessageDigest.getInstance(algorithm);\n        try {\n            DigestInputStream dis = new DigestInputStream(in, md);\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (dis.read(buffer) != -1) {\n            }\n            dis.close();\n        } finally {\n            in.close();\n        }\n        return md.digest();\n    }\n", "String stringKey = \"60380131061660211660380426804995\";\nString message = \"This is a secret message\";\ntry {\n    SecretKeySpec sks = new SecretKeySpec(stringKey.getBytes(),\"AES\");\n    Cipher c = Cipher.getInstance(\"AES/ECB/ZeroBytePadding\"); // Change to CBC and use appropriate IV\n    c.init(Cipher.ENCRYPT_MODE, sks);\n    c.update(message.getBytes());\n    byte[] ciphertext = c.doFinal();\n    Log.i(\"CE\", new String(ciphertext));\n\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(\"CE\",e.getMessage());\n    } catch (NoSuchPaddingException e) {\n        Log.e(\"CE\",e.getMessage());\n    } catch (InvalidKeyException e) {\n        Log.e(\"CE\",e.getMessage());\n    } catch (IllegalBlockSizeException e) {\n        Log.e(\"CE\",e.getMessage());\n    } catch (BadPaddingException e) {\n        Log.e(\"CE\",e.getMessage());\n}\n", "  private KeyStore loadPEMKeystoreStore(File certificateFile, String password) throws Exception {\n        InputStream caInput = new BufferedInputStream(new FileInputStream(certificateFile));\n\n\n        KeyStore keystore = KeyStore.getInstance(CLIENT_CERTIFICATE_KEYSTORE_TYPE);\n\n\n        CertificateFactory certificateFactory = CertificateFactory\n                .getInstance(X509);\n        X509Certificate cert = (X509Certificate) certificateFactory\n                .generateCertificate(caInput);\n\n\n        keystore.load(null);\n        keystore.setCertificateEntry(\"cert-alias\", cert);\n        keystore.setKeyEntry(\"key-alias\", privateKey, password.toCharArray(),\n                new Certificate[]{cert});\n        FileOutputStream out = new FileOutputStream(file);\n        keystore.store(out, password.toCharArray());\n\n        return keyStore ;\n    }\n", "// Add code to print out the key hash\ntry {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.facebook.samples.hellofacebook\", //your unique package name here\n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));// this line  gives your keyhash\n        }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "import com.loopj.android.http.AsyncHttpClient;\nimport com.loopj.android.http.AsyncHttpResponseHandler;\nimport com.loopj.android.http.RequestParams;\n\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.conn.ssl.SSLSocketFactory;\n\npublic class RestClient {\n\nprivate static final String BASE_URL = \"https://YOUR_DOMAIN.COM/\";\n\nprivate static AsyncHttpClient client = new AsyncHttpClient();\n\npublic static void get(String url, RequestParams params,\n        AsyncHttpResponseHandler responseHandler) {\n    client.setSSLSocketFactory(getSSLSocketFactory());\n    client.get(getAbsoluteUrl(url), params, responseHandler);\n}\n\npublic static void post(String url, RequestParams params,\n        AsyncHttpResponseHandler responseHandler) {\n    client.setSSLSocketFactory(getSSLSocketFactory());\n    client.post(getAbsoluteUrl(url), params, responseHandler);\n}\n\npublic static void put(String url, RequestParams params,\n        AsyncHttpResponseHandler responseHandler) {\n    client.setSSLSocketFactory(getSSLSocketFactory());\n    client.put(getAbsoluteUrl(url), params, responseHandler);\n}\n\nprivate static String getAbsoluteUrl(String relativeUrl) {\n    return BASE_URL + relativeUrl;\n}\n\npublic static class VoipemSSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public VoipemSSLSocketFactory(KeyStore truststore)\n            throws NoSuchAlgorithmException, KeyManagementException,\n            KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port,\n            boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host,\n                port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n}\n\nprivate static SSLSocketFactory getSSLSocketFactory() {\n    KeyStore trustStore;\n    SSLSocketFactory sslSocketFactory = null;\n    try {\n        trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        sslSocketFactory = new VoipemSSLSocketFactory(trustStore);\n        sslSocketFactory\n                .setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); \n    } catch (KeyStoreException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (CertificateException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (KeyManagementException e) {\n        e.printStackTrace();\n    } catch (UnrecoverableKeyException e) { \n    }\n    return sslSocketFactory;\n}\n}\n", "public class PromptUserTrustManager implements X509TrustManager\n{\n    private AcceptUserSelectedCertsTrustManager(ValidateCertificateCallback callback) throws NoSuchAlgorithmException, KeyStoreException\n    {\n        KeyStore keyStore = null;\n        TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        factory.init(keyStore);\n        TrustManager [] trustmanagers = factory.getTrustManagers();\n        m_standardTrustManager = (X509TrustManager) trustmanagers[0];\n    }\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException\n    {\n    }\n\n    // This is where you check the server cert and make the determination\n    @Override\n    public void checkServerTrusted(X509Certificate[] certChain, String authType)throws CertificateException\n    {\n        try\n        {\n            m_standardTrustManager.checkServerTrusted(certChain,authType);\n        }\n        catch(CertificateException e)\n        {\n            // Cert isn't trusted - popup the error here. You'll need to \n            // make sure you switch to the UI thread since here you're on a network thread\n            if(!userAcceptsCert(certChain))\n            {\n                throw e;\n            }\n        }\n    }\n}\n", "    public void computeSHAHash(String path)// path to your file\n    {\n            String SHAHash = null;\n    try \n    {\n        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n        InputStream in = new FileInputStream(path);\n        byte[] buf = new byte[8192];\n        int len = -1;\n        while((len = in.read(buf)) &gt; 0) \n        {\n            md.update(buf, 0, len);\n        }\n        in.close();\n        byte[] data = md.digest();\n        try \n        {\n           SHAHash = convertToHex(data);\n        } \n        catch (IOException e) \n        {\n           // TODO Auto-generated catch block\n           e.printStackTrace();\n        }\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n      Toast.makeToast(getApplicationContext(),\"Generated Hash =\"+SHAHash,Toast.LENGTH_SHORT).show();  \n\n   }\n private static String convertToHex(byte[] data) throws java.io.IOException\n{\n    StringBuffer sb = new StringBuffer();\n    String hex = null;\n\n    hex = Base64.encodeToString(data, 0, data.length, NO_OPTIONS);\n\n    sb.append(hex);\n\n    return sb.toString();\n}\n", "KeyStore ks = KeyStore.getInstance(\"JKS\");\nks.load(new FileInputStream(\"keystoreFile\"), \"keystorePassword\".toCharArray());\n\nKeyManagerFactory kmf = KeyManagerFactory.getInstance(\"X509\");\nkmf.init(ks, \"keystorePassword\".toCharArray());\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\"); \ntmf.init(ks);\n\nSSLContext sc = SSLContext.getInstance(\"TLS\"); \nTrustManager[] trustManagers = tmf.getTrustManagers(); \nsc.init(kmf.getKeyManagers(), trustManagers, null); \n\nSSLServerSocketFactory ssf = sc.getServerSocketFactory(); \nSSLServerSocket s = (SSLServerSocket) ssf.createServerSocket(serverport);\nSSLSocket c = (SSLSocket) s.accept();\n", "SSLSocketFactory ssf = sc.getSocketFactory(); \nSSLSocket s = (SSLSocket) ssf.createSocket(serverip, serverport);\ns.startHandshake();\n", "/**\n * Encryption of a given text using the provided secretKey\n * \n * @param text\n * @param secretKey\n * @return the encoded string\n * @throws SignatureException\n */\npublic static String hashMac(String text, String secretKey)\n  throws SignatureException {\n\n try {\n  Key sk = new SecretKeySpec(secretKey.getBytes(), HASH_ALGORITHM);\n  Mac mac = Mac.getInstance(sk.getAlgorithm());\n  mac.init(sk);\n  final byte[] hmac = mac.doFinal(text.getBytes());\n  return toHexString(hmac);\n } catch (NoSuchAlgorithmException e1) {\n  // throw an exception or pick a different encryption method\n  throw new SignatureException(\n    \"error building signature, no such algorithm in device \"\n      + HASH_ALGORITHM);\n } catch (InvalidKeyException e) {\n  throw new SignatureException(\n    \"error building signature, invalid key \" + HASH_ALGORITHM);\n }\n}\n", "public static byte[] decryptRSA(Context mContext, byte[] message) throws Exception { \n\n    // reads the public key stored in a file\n    InputStream is = mContext.getResources().openRawResource(R.raw.sm_public);\n    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n    List&lt;String&gt; lines = new ArrayList&lt;String&gt;();\n    String line = null;\n    while ((line = br.readLine()) != null)\n        lines.add(line);\n\n    // removes the first and last lines of the file (comments)\n    if (lines.size() &gt; 1 &amp;&amp; lines.get(0).startsWith(\"-----\") &amp;&amp; lines.get(lines.size()-1).startsWith(\"-----\")) {\n        lines.remove(0);\n        lines.remove(lines.size()-1);\n    }\n\n    // concats the remaining lines to a single String\n    StringBuilder sb = new StringBuilder();\n    for (String aLine: lines)\n        sb.append(aLine);\n    String keyString = sb.toString();\n    Log.d(\"log\", \"keyString:\"+keyString);\n\n    // converts the String to a PublicKey instance\n    byte[] keyBytes = Base64.decodeBase64(keyString.getBytes(\"utf-8\"));\n    X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n    PublicKey key = keyFactory.generatePublic(spec);\n\n    // decrypts the message\n    byte[] dectyptedText = null;\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    dectyptedText = cipher.doFinal(Base64.decodeBase64(message));\n    return dectyptedText;\n}\n", "   public static String generateKeyPair() {\n        try {\n            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n\n            kpg.initialize(2048, new SecureRandom());\n            KeyPair pair = kpg.generateKeyPair();\n\n            PKCS8EncodedKeySpec keyspec = new PKCS8EncodedKeySpec(pair.getPrivate().getEncoded());\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"-----BEGIN PRIVATE KEY-----\");\n            sb.append(new String(Base64.encode(keyspec.getEncoded())));\n            sb.append(\"-----END PRIVATE KEY-----\");\n\n            return new String(Base64.encode(sb.toString().getBytes()));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchProviderException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n", "    package com.kushal.utils;\n\n    import java.security.spec.KeySpec;\n    import javax.crypto.Cipher;\n    import javax.crypto.SecretKey;\n    import javax.crypto.SecretKeyFactory;\n    import javax.crypto.spec.DESedeKeySpec;\n    import sun.misc.BASE64Decoder;\n    import sun.misc.BASE64Encoder;\n\n    public class DESedeEncryption {\n\n        private static final String UNICODE_FORMAT = \"UTF8\";\n        public static final String DESEDE_ENCRYPTION_SCHEME = \"DESede\";\n        private KeySpec myKeySpec;\n        private SecretKeyFactory mySecretKeyFactory;\n        private Cipher cipher;\n        byte[] keyAsBytes;\n        private String myEncryptionKey;\n        private String myEncryptionScheme;\n        SecretKey key;\n\n        public DESedeEncryption() throws Exception\n        {\n            myEncryptionKey = \"ThisIsSecretEncryptionKey\";\n            myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;\n            keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);\n            myKeySpec = new DESedeKeySpec(keyAsBytes);\n            mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);\n            cipher = Cipher.getInstance(myEncryptionScheme);\n            key = mySecretKeyFactory.generateSecret(myKeySpec);\n        }\n\n        /**\n         * Method To Encrypt The String\n         */\n        public String encrypt(String unencryptedString) {\n            String encryptedString = null;\n            try {\n                cipher.init(Cipher.ENCRYPT_MODE, key);\n                byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);\n                byte[] encryptedText = cipher.doFinal(plainText);\n                BASE64Encoder base64encoder = new BASE64Encoder();\n                encryptedString = base64encoder.encode(encryptedText);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return encryptedString;\n        }\n        /**\n         * Method To Decrypt An Ecrypted String\n         */\n        public String decrypt(String encryptedString) {\n            String decryptedText=null;\n            try {\n                cipher.init(Cipher.DECRYPT_MODE, key);\n                BASE64Decoder base64decoder = new BASE64Decoder();\n                byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);\n                byte[] plainText = cipher.doFinal(encryptedText);\n                decryptedText= bytes2String(plainText);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return decryptedText;\n        }\n        /**\n         * Returns String From An Array Of Bytes\n         */\n        private static String bytes2String(byte[] bytes) {\n            StringBuffer stringBuffer = new StringBuffer();\n            for (int i = 0; i &amp;amp;lt; bytes.length; i++) {\n                stringBuffer.append((char) bytes[i]);\n            }\n            return stringBuffer.toString();\n        }\n\n        /**\n         * Testing The DESede Encryption And Decryption Technique\n         */\n        public static void main(String args []) throws Exception\n        {\n            DESedeEncryption myEncryptor= new DESedeEncryption();\n\n            String stringToEncrypt=&amp;quot;Sanjaal.com&amp;quot;;\n            String encrypted=myEncryptor.encrypt(stringToEncrypt);\n            String decrypted=myEncryptor.decrypt(encrypted);\n\n            System.out.println(\"String To Encrypt: \"+stringToEncrypt);\n            System.out.println(\"Encrypted Value :\" + encrypted);\n            System.out.println(\"Decrypted Value :\"+decrypted);\n\n        }\n\n    }\n\noutput:\nString To Encrypt: Sanjaal.com\nEncrypted Value :aArhqI25Y1SkYrdv9gxYDQ==\nDecrypted Value :Sanjaal.com\n\nhttp://sanjaal.com/java/189/java-encryption/tutorial-encryption-and-decryption-using-desede-triple-des-in-java/\n", "KeyFactory kf1 = KeyFactory.getInstance(\"RSA\");\nPublicKey pkPublic1 = kf1.generatePublic(publicKeySpec1);\n\nCipher pkCipher1 = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\npkCipher1.init(Cipher.DECRYPT_MODE, pkPublic1)\n", "    private void getAppKeyHash() {\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                getPackageName(), PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md;\n\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String something = new String(Base64.encode(md.digest(), 0));\n            System.out.println(\"HASH  \" + something);\n            showSignedHashKey(something);\n\n        }\n    } catch (NameNotFoundException e1) {\n        // TODO Auto-generated catch block\n        Log.e(\"name not found\", e1.toString());\n    } catch (NoSuchAlgorithmException e) {\n\n        Log.e(\"no such an algorithm\", e.toString());\n    } catch (Exception e) {\n        Log.e(\"exception\", e.toString());\n    }\n}\npublic void showSignedHashKey(String hashKey) {\n\n    AlertDialog.Builder adb = new AlertDialog.Builder(this);\n    adb.setTitle(\"Note Signed Hash Key\");\n    adb.setMessage(hashKey);\n    adb.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\n        public void onClick(DialogInterface dialog, int which) {\n\n        }\n    });\n\n    adb.show();\n}\n", "import java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\npublic class MCrypt {\n\n    private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n    private IvParameterSpec ivspec;\n    private SecretKeySpec keyspec;\n    private Cipher cipher;\n    private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n    public MCrypt() {\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try {\n            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public byte[] encrypt(String text) throws Exception {\n        if (text == null || text.length() == 0) throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n        encrypted = cipher.doFinal(padString(text).getBytes());\n        try { //  for OS version 2.2+\n            encrypted = android.util.Base64.encode(encrypted, android.util.Base64.NO_PADDING);\n        } catch (NoClassDefFoundError e) {\n            encrypted = org.apache.commons.codec.binary.Base64.encodeBase64(encrypted);\n        }\n\n        return encrypted;\n    }\n\n    public byte[] decrypt(String code) throws Exception {\n        if (code == null || code.length() == 0) throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n        try { // for OS version 2.2+\n            decrypted = cipher.doFinal(android.util.Base64.decode(code, android.util.Base64.NO_PADDING));\n        } catch (NoClassDefFoundError e) {\n            decrypted = cipher.doFinal(org.apache.commons.codec.binary.Base64.decodeBase64(code.getBytes(\"UTF-8\")));\n        }\n        return decrypted;\n    }\n\n\n\n    private static String padString(String source) {\n        char paddingChar = ' ';\n        int size = 16;\n        int x = source.length() % size;\n        int padLength = size - x;\n\n        for (int i = 0; i &lt; padLength; i++) {\n            source += paddingChar;\n        }\n\n        return source;\n    }\n}\n", " public String makeSHA1Hash(String input)\n        throws NoSuchAlgorithmException, UnsupportedEncodingException\n    {\n        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n        md.reset();\n        byte[] buffer = input.getBytes(\"UTF-8\");\n        md.update(buffer);\n        byte[] digest = md.digest();\n\n        String hexStr = \"\";\n        for (int i = 0; i &lt; digest.length; i++) {\n            hexStr +=  Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 );\n        }\n        return hexStr;\n    }\n", "    int iterationCount = 1000;\n    int saltLength = 8; // bytes; 64 bits\n    int keyLength = 256;\n    SecureRandom random = new SecureRandom();\n    byte[] salt = new byte[saltLength];\n    random.nextBytes(salt);\n    KeySpec keySpec = new PBEKeySpec(seed.toCharArray(), salt,\n            iterationCount, keyLength);\n    SecretKeyFactory keyFactory = SecretKeyFactory\n            .getInstance(\"PBKDF2WithHmacSHA1\");\n    byte[] raw = keyFactory.generateSecret(keySpec).getEncoded();\n", "          private CharSequence getHash(String sourceDir)  {\n          // TODO Auto-generated method stub\n\n          File file = new File(packageInfo.applicationInfo.sourceDir);\n         String outputTxt= \"\";\n           String hashcode = null;\n\n        try {\n\n        FileInputStream input = new FileInputStream(file);\n\n        ByteArrayOutputStream output = new ByteArrayOutputStream ();\n        byte [] buffer = new byte [65536];\n        int l;\n\n\n              while ((l = input.read (buffer)) &gt; 0)\n                  output.write (buffer, 0, l);\n\n                  input.close ();\n              output.close ();\n\n                byte [] data = output.toByteArray ();\n\n                MessageDigest digest = MessageDigest.getInstance( \"SHA-1\" ); \n\n            byte[] bytes = data;\n\n            digest.update(bytes, 0, bytes.length);\n            bytes = digest.digest();\n\n            StringBuilder sb = new StringBuilder();\n\n            for( byte b : bytes )\n            {\n                sb.append( String.format(\"%02X\", b) );\n            }\n\n            hashcode = sb.toString();\n\n\n         } catch (FileNotFoundException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n         } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n         } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n       }\n\n\n\n          return hashcode;\n         }\n", "  //URL to get JSON Array\n  private static String url = \"https://demo.vtiger.com/webservice.php?operation=getchallenge&amp;username=admin\";\n\n  //JSON Node Names\n  private static final String TAG_RESULT = \"result\";\n  private static final String TAG_TOKEN = \"token\";\n\n  // contacts JSONArray\n  JSONArray contacts = null;\n\n  String token = null;\n  String sessionId;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.login);\n\n    if (android.os.Build.VERSION.SDK_INT &gt; 9) {\n        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();\n        StrictMode.setThreadPolicy(policy);\n    }\n\n\n    new AsyncTask&lt;Void, Void, Void&gt;() {\n\n        private ProgressDialog dialog = new ProgressDialog(Login.this);\n        protected void onPreExecute() {\n               dialog.setMessage(\"Loging In... Please wait...\");\n               dialog.show();\n              }\n@SuppressWarnings(\"unused\")\n            JSONObject result;\n\n            @Override\n            protected Void doInBackground(Void... params) {\n\n                // Creating new JSON Parser\n                JSONParser jParser = new JSONParser();\n\n                // Getting JSON from URL\n                JSONObject json = jParser.getJSONFromUrl(url);\n\n                try {\n                    // Getting JSON Array\n                    result = json.getJSONObject(TAG_RESULT);\n                      JSONObject json_result = json.getJSONObject(TAG_RESULT);\n\n                    // Storing  JSON item in a Variable\n                    token = json_result.getString(TAG_TOKEN);\n\n                    //Importing TextView\n\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n\n                String username=\"admin\";\n                String accesskeyvalue = \"w9OweWKUS4a5sSL\";\n                String accessKey=md5(token + accesskeyvalue);\n\n                //For debugging purpose only\n                //System.out.println(accesskeyvalue);\n                //System.out.println(token);\n                //System.out.println(accessKey);\n\n        String data = null;\n\n            try {\n                data = URLEncoder.encode(\"username\", \"UTF-8\")\n                        + \"=\" + URLEncoder.encode(username, \"UTF-8\");\n                data += \"&amp;\" + URLEncoder.encode(\"accessKey\", \"UTF-8\") + \"=\"\n                        + URLEncoder.encode(accessKey, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } \n        String text = \"\";\n        BufferedReader reader=null;\n        //System.out.println(data);\n\n        // Send data\n        try\n        {\n\n            // Defined URL  where to send data\n            URL url = new URL(\"https://demo.vtiger.com/webservice.php?operation=login\");\n\n         // Send POST data request\n          URLConnection conn = url.openConnection();\n          conn.setDoOutput(true);\n          OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n          wr.write( data );\n          wr.flush();    \n\n        // Get the server response    \n        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n\n        // Read Server Response\n        while((line = reader.readLine()) != null)\n            {\n                   // Append server response in string\n                   sb.append(line + \"\\n\");\n            }\n\n\n            text = sb.toString();\n        }\n        catch(Exception ex)\n        {\n\n        }\n        finally\n        {\n            try\n            {\n\n                reader.close();\n            }\n\n            catch(Exception ex) {}\n        }\n\n        // Show response\n        System.out.println(text);\n        sessionId = text.substring(41, 62);\n        //System.out.println(\"doInBackground()\"+sessionId);\n\n\n\n    return null;    \n    }\n            @Override\n            protected void onPostExecute(Void aVoid) {\n                super.onPostExecute(aVoid);    \n                dialog.dismiss();\n               }\n\n         }.execute();\n\n    } \n\n    public String md5(String s) \n    {\n    MessageDigest digest;\n        try \n            {\n                digest = MessageDigest.getInstance(\"MD5\");\n                digest.update(s.getBytes(),0,s.length());\n                String hash = new BigInteger(1, digest.digest()).toString(16);\n                return hash;\n            } \n        catch (NoSuchAlgorithmException e) \n            {\n                e.printStackTrace();\n            }\n        return \"\";\n    }\n", "package using_net;\n\nimport android.content.Context;\nimport android.os.AsyncTask;\n\nimport org.apache.http.Header;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.conn.ssl.X509HostnameVerifier;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.SingleClientConnManager;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.apache.http.protocol.HTTP;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\n\nimport logger.AndroidLogger;\nimport other.GetException;\nimport other.PostException;\n\n/**\n * Created by ehog on 2013.12.11..\n */\npublic class BaseAsyncTask&lt;Paramets, Progress,Result&gt; extends AsyncTask&lt;Paramets,Progress,Result&gt;\n{\n    protected Context _context;\n\n    public BaseAsyncTask(Context context)\n    {\n        _context = context;\n    }\n\n    protected String Get(String url) throws GetException\n    {\n        try\n        {\n            AndroidLogger.PushDebugMessage(\"Web access: \"+url);\n            URL realUrl = new URL(url);\n            URLConnection connection = realUrl.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            StringBuilder builder = new StringBuilder();\n            for(String line = null; (line = reader.readLine()) != null;) {\n                builder.append(line);\n            }\n            return builder.toString();\n        }\n        catch (Exception e) {\n            throw new GetException(e);\n        }\n    }\n\n    protected String Post(String url, String message_json) throws PostException\n    {\n        HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n\n        DefaultHttpClient client = new DefaultHttpClient();\n        SchemeRegistry registry = new SchemeRegistry();\n        SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();\n        socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\n        registry.register(new Scheme(\"https\", socketFactory, 443));\n        SingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);\n        HttpClient httpclient = new DefaultHttpClient(mgr, client.getParams());\n        HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n\n        HttpPost httpost = new HttpPost(url);\n        try\n        {\n            List&lt;NameValuePair&gt; nvp = new ArrayList&lt;NameValuePair&gt;(1);\n            nvp.add(new BasicNameValuePair(\"json_data\",message_json));\n            httpost.setHeader(\"User-Agent\", \"Your.browser.header\");\n            httpost.setEntity(new UrlEncodedFormEntity(nvp, HTTP.UTF_8));\n            httpost.addHeader(\"Accept-Encoding\", \"gzip\");\n            HttpResponse response = httpclient.execute(httpost);\n\n            int code = response.getStatusLine().getStatusCode();\n\n            if(code &lt; 200 || code &gt;= 300) {\n                networkError(code);\n                return null;\n            }\n            InputStream instream = response.getEntity().getContent();\n            Header contentEncoding = response.getFirstHeader(\"Content-Encoding\");\n            if (contentEncoding != null &amp;&amp; contentEncoding.getValue().equalsIgnoreCase(\"gzip\"))\n            {\n                instream = new GZIPInputStream(instream);\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream, \"UTF-8\"));\n            StringBuilder builder = new StringBuilder();\n            for(String line = null; (line = reader.readLine()) != null;) {\n                builder.append(line).append(\"\\n\");\n            }\n            return builder.toString();\n        } catch (Exception x) {\n            throw new PostException(x);\n        }\n    }\n\n    protected void networkError(int code) {\n\n    }\n\n    protected void process(Result result) {\n\n    }\n\n    protected void error() {\n\n    }\n\n    @Override\n    protected Result doInBackground(Paramets... params) {\n        return null;\n    }\n\n    @Override\n    protected void onPostExecute(Result result) {\n        if(result == null) error();\n        else process(result);\n    }\n}\n", "private void generateKeyHash() {\n    // TODO Auto-generated method stub\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"Your Package name\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\",\n                    Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "package com.trustit.trustme;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Date;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\n\npublic class EasyX509TrustManager implements X509TrustManager \n{  \n    private X509TrustManager standardTrustManager = null;  \n\n    /** \n     * Constructor for EasyX509TrustManager. \n     */  \n    public EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException \n    {  \n      super();  \n      TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());  \n      factory.init(keystore);  \n      TrustManager[] trustmanagers = factory.getTrustManagers();  \n      if (trustmanagers.length == 0) \n      {  \n        throw new NoSuchAlgorithmException(\"no trust manager found\");  \n      }  \n      this.standardTrustManager = (X509TrustManager) trustmanagers[0];  \n    }  \n\n    /** \n     * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType) \n     */  \n    public void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException \n    {  \n      standardTrustManager.checkClientTrusted(certificates, authType);  \n    }  \n\n    /** \n     * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType) \n     */  \n    public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException \n    {  \n    // Clean up the certificates chain and build a new one.\n        // Theoretically, we shouldn't have to do this, but various web servers\n        // in practice are mis-configured to have out-of-order certificates or\n        // expired self-issued root certificate.\n        int chainLength = certificates.length;\n        if (certificates.length &gt; 1) \n        {\n          // 1. we clean the received certificates chain.\n          // We start from the end-entity certificate, tracing down by matching\n          // the \"issuer\" field and \"subject\" field until we can't continue.\n          // This helps when the certificates are out of order or\n          // some certificates are not related to the site.\n          int currIndex;\n          for (currIndex = 0; currIndex &lt; certificates.length; ++currIndex) \n          {\n            boolean foundNext = false;\n            for (int nextIndex = currIndex + 1;\n                           nextIndex &lt; certificates.length;\n                           ++nextIndex) \n            {\n              if (certificates[currIndex].getIssuerDN().equals(\n                            certificates[nextIndex].getSubjectDN())) \n              {\n                foundNext = true;\n                // Exchange certificates so that 0 through currIndex + 1 are in proper order\n                if (nextIndex != currIndex + 1) \n                {\n                  X509Certificate tempCertificate = certificates[nextIndex];\n                  certificates[nextIndex] = certificates[currIndex + 1];\n                  certificates[currIndex + 1] = tempCertificate;\n                }\n                break;\n            }\n            }\n            if (!foundNext) break;\n      }\n\n          // 2. we exam if the last traced certificate is self issued and it is expired.\n          // If so, we drop it and pass the rest to checkServerTrusted(), hoping we might\n          // have a similar but unexpired trusted root.\n          chainLength = currIndex + 1;\n          X509Certificate lastCertificate = certificates[chainLength - 1];\n          Date now = new Date();\n          if (lastCertificate.getSubjectDN().equals(lastCertificate.getIssuerDN())\n                  &amp;&amp; now.after(lastCertificate.getNotAfter())) \n          {\n            --chainLength;\n          }\n      } \n\n    standardTrustManager.checkServerTrusted(certificates, authType);    \n    }  \n\n    /** \n     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers() \n     */  \n    public X509Certificate[] getAcceptedIssuers() \n    {  \n      return this.standardTrustManager.getAcceptedIssuers();  \n    }    \n}  \n", "package com.trustit.trustme;\n\nimport java.io.IOException;  \nimport java.net.InetAddress;  \nimport java.net.InetSocketAddress;  \nimport java.net.Socket;  \nimport java.net.UnknownHostException;  \n\nimport javax.net.ssl.SSLContext;  \nimport javax.net.ssl.SSLSocket;  \nimport javax.net.ssl.TrustManager;  \n\nimport org.apache.http.conn.ConnectTimeoutException;  \nimport org.apache.http.conn.scheme.LayeredSocketFactory;  \nimport org.apache.http.conn.scheme.SocketFactory;  \nimport org.apache.http.params.HttpConnectionParams;  \nimport org.apache.http.params.HttpParams;  \n\npublic class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory \n{  \n    private SSLContext sslcontext = null;  \n\n    private static SSLContext createEasySSLContext() throws IOException \n    {  \n      try\n      {  \n        SSLContext context = SSLContext.getInstance(\"TLS\");  \n        context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);  \n        return context;  \n      }\n      catch (Exception e) \n      {  \n        throw new IOException(e.getMessage());  \n      }  \n    }  \n\n    private SSLContext getSSLContext() throws IOException \n    {  \n      if (this.sslcontext == null) \n      {  \n        this.sslcontext = createEasySSLContext();  \n      }  \n      return this.sslcontext;  \n    }  \n\n    /** \n     * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int, \n     *      java.net.InetAddress, int, org.apache.http.params.HttpParams) \n     */  \n    public Socket connectSocket(Socket sock,\n                                    String host,\n                                    int port, \n                                    InetAddress localAddress,\n                                    int localPort,\n                                    HttpParams params) \n\n                throws IOException, UnknownHostException, ConnectTimeoutException \n    {  \n      int connTimeout = HttpConnectionParams.getConnectionTimeout(params);  \n      int soTimeout = HttpConnectionParams.getSoTimeout(params);  \n      InetSocketAddress remoteAddress = new InetSocketAddress(host, port);  \n      SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());  \n\n      if ((localAddress != null) || (localPort &gt; 0)) \n      {  \n        // we need to bind explicitly  \n        if (localPort &lt; 0) \n        {  \n          localPort = 0; // indicates \"any\"  \n        }  \n        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);  \n        sslsock.bind(isa);  \n      }  \n\n      sslsock.connect(remoteAddress, connTimeout);  \n      sslsock.setSoTimeout(soTimeout);  \n      return sslsock;    \n    }  \n\n    /** \n     * @see org.apache.http.conn.scheme.SocketFactory#createSocket() \n     */  \n    public Socket createSocket() throws IOException {  \n        return getSSLContext().getSocketFactory().createSocket();  \n    }  \n\n    /** \n     * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket) \n     */  \n    public boolean isSecure(Socket socket) throws IllegalArgumentException {  \n        return true;  \n    }  \n\n    /** \n     * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int, \n     *      boolean) \n     */  \n    public Socket createSocket(Socket socket,\n                                   String host, \n                                   int port,\n                                   boolean autoClose) throws IOException,  \n                                                             UnknownHostException \n    {  \n      return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);  \n    }  \n\n    // -------------------------------------------------------------------  \n    // javadoc in org.apache.http.conn.scheme.SocketFactory says :  \n    // Both Object.equals() and Object.hashCode() must be overridden  \n    // for the correct operation of some connection managers  \n    // -------------------------------------------------------------------  \n\n    public boolean equals(Object obj) {  \n        return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));  \n    }  \n\n    public int hashCode() {  \n        return EasySSLSocketFactory.class.hashCode();  \n    }  \n}\n", "import java.io.IOException;\n\n    import java.net.Socket;\n    import java.security.KeyManagementException;\n    import java.security.KeyStoreException;\n    import java.security.NoSuchAlgorithmException;\n    import java.security.UnrecoverableKeyException;\n    import java.security.cert.CertificateException;\n    import java.security.cert.X509Certificate;\n\n    import javax.net.ssl.SSLContext;\n    import javax.net.ssl.TrustManager;\n    import javax.net.ssl.X509TrustManager;\n\n    import org.apache.http.client.ClientProtocolException;\n    import org.apache.http.client.HttpClient;\n    import org.apache.http.client.methods.HttpPost;\n    import org.apache.http.conn.scheme.PlainSocketFactory;\n    import org.apache.http.conn.scheme.Scheme;\n    import org.apache.http.conn.scheme.SchemeRegistry;\n    import org.apache.http.conn.ssl.SSLSocketFactory;\n    import org.apache.http.conn.ssl.X509HostnameVerifier;\n    import org.apache.http.impl.client.DefaultHttpClient;\n    import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\n    import org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpConnectionParams;\nimport org.apache.http.params.HttpParams;\n\n    public class HttpsClientBuilder {\n        public static DefaultHttpClient getBelieverHttpsClient() {\n\n            DefaultHttpClient client = null;\n\n            SchemeRegistry Current_Scheme = new SchemeRegistry();\n            Current_Scheme.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n            try {\n                Current_Scheme.register(new Scheme(\"https\", new Naive_SSLSocketFactory(), 8443));\n            } catch (KeyManagementException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (UnrecoverableKeyException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (KeyStoreException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            HttpParams Current_Params = new BasicHttpParams();\n            int timeoutConnection = 8000;\n            HttpConnectionParams.setConnectionTimeout(Current_Params, timeoutConnection);\n            int timeoutSocket = 10000;\n            HttpConnectionParams.setSoTimeout(Current_Params, timeoutSocket);\n            ThreadSafeClientConnManager Current_Manager = new ThreadSafeClientConnManager(Current_Params, Current_Scheme);\n            client = new DefaultHttpClient(Current_Manager, Current_Params);\n            //HttpPost httpPost = new HttpPost(url);\n            //client.execute(httpPost);\n\n         return client;\n         }\n\n    public static class Naive_SSLSocketFactory extends SSLSocketFactory\n    {\n        protected SSLContext Cur_SSL_Context = SSLContext.getInstance(\"TLS\");\n\n        public Naive_SSLSocketFactory ()\n                throws NoSuchAlgorithmException, KeyManagementException,\n                KeyStoreException, UnrecoverableKeyException\n        {\n            super(null, null, null, null, null, (X509HostnameVerifier)null);\n            Cur_SSL_Context.init(null, new TrustManager[] { new X509_Trust_Manager() }, null);\n        }\n\n        @Override\n        public Socket createSocket(Socket socket, String host, int port,\n                boolean autoClose) throws IOException\n        {\n            return Cur_SSL_Context.getSocketFactory().createSocket(socket, host, port, autoClose);\n        }\n\n        @Override\n        public Socket createSocket() throws IOException\n        {\n            return Cur_SSL_Context.getSocketFactory().createSocket();\n        }\n    }\n\n    private static class X509_Trust_Manager implements X509TrustManager\n    {\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType)\n                throws CertificateException {\n            // TODO Auto-generated method stub\n\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType)\n                throws CertificateException {\n            // TODO Auto-generated method stub\n\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            // TODO Auto-generated method stub\n            return null;\n        }\n\n    };\n}\n", "public static String md5Hash(File file) {\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        InputStream is = new FileInputStream(file);\n        byte[] buffer = new byte[1024];\n\n        try {\n            is = new DigestInputStream(is, md);\n\n            while (is.read(buffer) != -1) { }\n        } finally {\n            is.close();\n        }\n\n        byte[] digest = md.digest();\n\n        BigInteger bigInt = new BigInteger(1, digest);\n        String output = bigInt.toString(16);\n        while (output.length() &lt; 32) {\n            output = \"0\" + output;\n        }\n\n        return output;\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}\n", " /**\n   * Will cause HttpsURLConnection to accept even self-signed certificates.\n   * @param conn\n   */\n  private static void trustEveryone(HttpsURLConnection conn) {\n    try {\n      conn.setHostnameVerifier(new HostnameVerifier() {\n        public boolean verify(String hostname, SSLSession session) {\n          return true;\n        }\n      });\n      SSLContext context = SSLContext.getInstance(\"TLS\");\n      context.init(null, new X509TrustManager[] { new X509TrustManager() {\n\n        @Override\n        public void checkClientTrusted(\n            java.security.cert.X509Certificate[] aChain, String aAuthType)\n            throws java.security.cert.CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(\n            java.security.cert.X509Certificate[] aChain, String aAuthType)\n            throws java.security.cert.CertificateException {\n        }\n\n        @Override\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n          // TODO Auto-generated method stub\n          return new java.security.cert.X509Certificate[0];\n        }\n      } }, new SecureRandom());\n      conn.setSSLSocketFactory(context.getSocketFactory());\n    } catch (Exception e) { //handle accordingly\n      e.printStackTrace();\n    }\n  }\n", "    //here i am downloading file from server and writing\n\n    String download_link = \"some server location\"; \n                URL url = new URL(download_link);\n                 HttpsURLConnection c = null;\n                if (url.getProtocol().toLowerCase().equals(\"https\")) {\n                     trustAllHosts();\n                     c = (HttpsURLConnection) url.openConnection();\n                     c.setHostnameVerifier(DO_NOT_VERIFY);\n                }\n                c.setRequestMethod(\"GET\");\n                c.setDoOutput(true);\n                c.connect();\n                String PATH = Environment.getExternalStorageDirectory() + \"/download/\";\n                File file = new File(PATH);\n                file.mkdirs();\n                File outputFile = new File(file, \"Mobi.apk\");\n                if(outputFile.exists()){\n                    outputFile.delete();\n                }\n                FileOutputStream fos = new FileOutputStream(outputFile);\n                InputStream is = c.getInputStream();\n                byte[] buffer = new byte[1024];\n                int len1 = 0;\n                while ((len1 = is.read(buffer)) != -1) {\n                    fos.write(buffer, 0, len1);\n                }\n                fos.close();\n                is.close();\n\nyou need to add permission in manifest file:    \n\nuses-permission android:name=\"android.permission.INTERNET\"&gt;&lt;/uses-permission&gt;\n    &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt;\n    &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"&gt;&lt;/uses-permission&gt;\n    &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"&gt;&lt;/uses-permission&gt;\n", "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class AESEncrypter {\n    public static void encryptToBinaryFile(String password, byte[] bytes, File file) throws EncrypterException {\n        try {\n            final byte[] rawKey = getRawKey(password.getBytes());\n            final FileOutputStream ostream = new FileOutputStream(file, false);\n\n            ostream.write(encrypt(rawKey, bytes));\n            ostream.flush();\n            ostream.close();\n\n        } catch (IOException e) {\n            throw new EncrypterException(e);\n        }\n    }\n\npublic static byte[] decryptFromBinaryFile(String password, File file) throws EncrypterException {\n    try {\n        final byte[] rawKey = getRawKey(password.getBytes());\n        final FileInputStream istream = new FileInputStream(file);\n        final byte[] buffer = new byte[(int)file.length()];\n\n        istream.read(buffer);\n\n        return decrypt(rawKey, buffer);\n\n    } catch (IOException e) {\n        throw new EncrypterException(e);\n    }\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws EncrypterException {\n    try {\n        final KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        final SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n\n        sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n\n        final SecretKey skey = kgen.generateKey();\n\n        return skey.getEncoded();\n\n    } catch (Exception e) {\n        throw new EncrypterException(e);\n    }\n}\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws EncrypterException {\n    try {\n        final SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        final Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n        return cipher.doFinal(clear);\n\n    } catch (Exception e) {\n        throw new EncrypterException(e);\n    }\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws EncrypterException {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    try {\n        final Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n        return cipher.doFinal(encrypted);\n\n    } catch (Exception e) {\n        throw new EncrypterException(e);\n    }\n}\n", " private void connect(){\n            String alias = getAliasForClientCertificate();\n\n            final X509Certificate[] certificates =getCertificateChain(alias);\n            final PrivateKey pk = getPrivateKey(alias);\n\n\n\n            KeyStore trustStore = KeyStore.getInstance(KeyStore\n                    .getDefaultType());\n\n\n            X509ExtendedKeyManager keyManager = new X509ExtendedKeyManager() {\n\n                @Override\n                public String chooseClientAlias(String[] strings, Principal[] principals, Socket socket) {\n                    return alias;\n                }\n\n                @Override\n                public String chooseServerAlias(String s, Principal[] principals, Socket socket) {\n                    return alias;\n                }\n\n                @Override\n                public X509Certificate[] getCertificateChain(String s) {\n                    return certificates;\n                }\n\n                @Override\n                public String[] getClientAliases(String s, Principal[] principals) {\n                    return new String[]{alias};\n                }\n\n                @Override\n                public String[] getServerAliases(String s, Principal[] principals) {\n                    return new String[]{alias};\n                }\n\n                @Override\n                public PrivateKey getPrivateKey(String s) {\n                    return pk;\n                }\n            };\n\n            TrustManagerFactory trustFactory = TrustManagerFactory\n                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\n            trustFactory.init(trustStore);\n\n            TrustManager[] trustManagers = trustFactory.getTrustManagers();\n\n\n\n            X509TrustManager[] tm = new X509TrustManager[] { new X509TrustManager() {\n                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                //            public X509Certificate[] getAcceptedIssuers() {\n                //                return certificates;\n                //            }\n\n                public X509Certificate[] getAcceptedIssuers() {\n                    return certificates;\n                }\n\n                public boolean isClientTrusted(X509Certificate[] arg0) {\n                    return true;\n                }\n            public boolean isServerTrusted(X509Certificate[] arg0) {\n                return true; \n            }\n\n\n        } };\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(new KeyManager[] {keyManager}, tm, null);\n        SSLContext.setDefault(sslContext);\n\n        URL url = new URL(\"url..\");\n        HttpsURLConnection urlConnection = (HttpsURLConnection) url\n                .openConnection();\n        urlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n\n        HostnameVerifier hv = new HostnameVerifier() {\n\n            @Override\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        };\n        urlConnection.setHostnameVerifier(hv);\n\n\n        urlConnection.setInstanceFollowRedirects(false);\n        urlConnection.connect();\n        int responseCode = urlConnection.getResponseCode();\n\n}\n\nprivate X509Certificate[] getCertificateChain(String alias) {\n        try {\n            return KeyChain.getCertificateChain(this, alias);\n        } catch (KeyChainException e) {\n            e.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return null;\n}\n", "    static public String getPackageFingerPrint( Context ctx ) {\n        PackageManager pm = ctx.getPackageManager();\n        String packageName = ctx.getPackageName();\n        int flags = PackageManager.GET_SIGNATURES;\n\n        PackageInfo packageInfo = null;\n\n        try {\n                packageInfo = pm.getPackageInfo(packageName, flags);\n        } catch (NameNotFoundException e) {\n                return \"\";\n        }\n        Signature[] signatures = packageInfo.signatures;\n\n        byte[] cert = signatures[0].toByteArray();\n\n        InputStream input = new ByteArrayInputStream(cert);\n\n        CertificateFactory cf = null;\n        try {\n                cf = CertificateFactory.getInstance(\"X509\");\n\n\n        } catch (CertificateException e) {\n                return \"\";\n        }\n        X509Certificate c = null;\n        try {\n                c = (X509Certificate) cf.generateCertificate(input);\n        } catch (CertificateException e) {\n                return \"\";\n        }\n\n\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            byte[] publicKey = md.digest(c.getPublicKey().getEncoded());\n\n\n            StringBuffer hexString = new StringBuffer();\n            for (int i=0;i&lt;publicKey.length;i++) {\n                String appendString = Integer.toHexString(0xFF &amp; publicKey[i]);\n                if(appendString.length()==1)hexString.append(\"0\");\n                hexString.append(appendString);\n                }\n\n\n            return hexString.toString();\n\n        } catch (NoSuchAlgorithmException e1) {\n            return \"\";\n        } \n    }\n", "@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n    if (Build.VERSION.RELEASE.equals(\"5.0\"))\n    {\n        Security.removeProvider(\"SC\");\n    }\n    return super.onCreateView(inflater, container, savedInstanceState);\n}\n\n@Override\npublic void onDestroyView() {\n    if (Build.VERSION.RELEASE.equals(\"5.0\"))\n    {\n        Security.addProvider(new org.spongycastle.jce.provider.BouncyCastleProvider());\n    }\n    super.onDestroyView();\n}\n", "SecretKeyFactory f = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n// note, the third argument should be set to a value as high as possible\n// 10K is about the minimum nowadays\nKeySpec ks = new PBEKeySpec(password, salt, 1024, 128);\nSecretKey s = f.generateSecret(ks);\nKey k = new SecretKeySpec(s.getEncoded(),\"AES\");\n", "// Loading the certificate in asserts\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\nAssetManager assManager = context.getAssets();\ncaInput = assManager.open(\"certif.crt\");\nCertificate ca = cf.generateCertificate(caInput);\n// Create a KeyStore containing different CAs\nString keyStoreType = KeyStore.getDefaultType();\nKeyStore keyStore = KeyStore.getInstance(keyStoreType);\nkeyStore.load(null, null);\nkeyStore.setCertificateEntry(\"ca\", ca);\n\n// Create a TrustManager to store certificates\nString tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\ntmf.init(keyStore);\n\n// Creates a context for use ssl certificate\nSSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, tmf.getTrustManagers(), null);\n", "public class MySSLSocketFactory extends SSLSocketFactory {\n           SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n\n           public MySSLSocketFactory() throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException, KeyManagementException {\n                super(null, null, null, null, null, null);\n\n                final TrustManagerFactory trustMgrFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                trustMgrFactory.init((KeyStore) null);\n\n                sslContext.init(null, trustMgrFactory.getTrustManagers(), new SecureRandom());\n            }\n\n            @Override\n            public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n                final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n                sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());\n                return sslSocket;\n            }\n\n            @Override\n            public Socket createSocket() throws IOException {\n                final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket();\n                sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());\n                return sslSocket;\n            }\n    }\n", "md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n", "import javax.net.ssl.SSLSocketFactory;\n\n// Create a socket without connecting\nSSLSocketFactory socketFactory = SSLSocketFactory.getDefault();\nSocket socket = socketFactory.createSocket();\n\n// Connect, with an explicit timeout value\nsocket.connect(new InetSocketAddress(endpoint.mServer,\nendpoint.mPort), CONNECT_TIMEOUT);\n", "private getSSLContext()\n{\n    /* Load the keyStore that includes self-signed cert as a \"trusted\" entry. */\n    KeyStore keyStore = ...  //optional\n    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); //optional\n    tmf.init(keyStore); //optional\n\n    //This is the important line, specifying the cipher to use and cipher provider\n    SSLContext sslContext = SSLContext.getInstance(\"TLSv1\",\"AndroidOpenSSL\");\n    ctx.init(null, tmf.getTrustManagers(), null); //if trustmanager not used pass null as the second parameter    \n    return sslContext;\n}\n", "private Session.StatusCallback statusCallback = new SessionStatusCallback();\n\nprivate class SessionStatusCallback implements Session.StatusCallback {\n    @Override\n    public void call(final Session session, SessionState state,\n            Exception exception) {\n\n        try {\n            new_session = session;\n            if (state.equals(SessionState.OPENING)) {\n\n            }\n\n            if (state.equals(SessionState.OPENED)) {\n\n\n            }\n\n            if (state.equals(SessionState.CLOSED_LOGIN_FAILED)) {\n                try {\n                    PackageInfo info = context.getPackageManager()\n                            .getPackageInfo(\"your package name\",\n                                    PackageManager.GET_SIGNATURES);\n                    for (Signature signature : info.signatures) {\n                        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                        md.update(signature.toByteArray());\n                        Log.d(\"KeyHash:\", Base64.encodeToString(\n                                md.digest(), Base64.DEFAULT));\n                    }\n                    Session.openActiveSession((Activity) context, true,\n                            statusCallback);\n                } catch (NameNotFoundException e) {\n\n                } catch (NoSuchAlgorithmException e) {\n\n                }\n            }\n\n            if (state.equals(SessionState.OPENED_TOKEN_UPDATED)) {\n\n\n\n            }\n\n    }\n    catch(Exception e){}\n  }\n}\n\n//if session is closed\nSession.openActiveSession((Activity) context, true,\n                    statusCallback);\n", "PackageInfo info;\ntry {\n\n    info = getPackageManager().getPackageInfo( \"com.you.name\",PackageManager.GET_SIGNATURES);\n\n    for (Signature signature : info.signatures)\n    {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String something = new String(Base64.encode(md.digest(), 0));\n        //String something = new String(Base64.encodeBytes(md.digest()));\n        Log.e(\"Hash key\", something);\n    }\n\n} catch (NameNotFoundException e1) {\nLog.e(\"name not found\", e1.toString());\n} catch (NoSuchAlgorithmException e) {\nLog.e(\"no such an algorithm\", e.toString());\n} catch (Exception e) {\nLog.e(\"exception\", e.toString());\n}\n", "package nl.owlstead.stackoverflow;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.RSAPublicKeySpec;\n\nimport org.bouncycastle.util.io.pem.PemObject;\nimport org.bouncycastle.util.io.pem.PemReader;\n\npublic final class RSAPublicKeyFromOpenSSL_PKCS1_PEM {\n    private static final String PEM = \"-----BEGIN RSA PUBLIC KEY-----\\r\\n\"\n            + \"MIGJAoGBAKks62Itns2uU/dVZJ4kCkMinHgyeh/rdMD53a4Zu2a76OIJvdSZ8q4c\\r\\n\"\n            + \"YTWvPj0giefVtMc7tV4c6AAw04jyIfmCTvcQUlHI+sspHxXDlQTagNoxCuA29b5L\\r\\n\"\n            + \"9MKO6Ok0LwF9rGgTywC1heNEulZz9ISn9FQDazJT+Bd9cnNOrJRdAgMBAAE=\\r\\n\"\n            + \"-----END RSA PUBLIC KEY-----\\r\\n\";\n\n    public static RSAPublicKey parsePEM(final String pem)\n            throws IllegalArgumentException {\n\n        // --- read PEM object\n        final PemObject readPemObject;\n        try (final PemReader reader = new PemReader(new StringReader(PEM))) {\n            readPemObject = reader.readPemObject();\n        } catch (final IOException e) {\n            throw new IllegalArgumentException(\"Not a PEM object\", e);\n        }\n        if (!readPemObject.getType().equalsIgnoreCase(\"RSA PUBLIC KEY\")) {\n            throw new IllegalArgumentException(\"Not a public key\");\n        }\n        final byte[] pemContent = readPemObject.getContent();\n\n        // --- create Bouncy Castle PKCS#1 public key\n        final org.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey;\n        try {\n            pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey\n                    .getInstance(pemContent);\n        } catch (final Exception e) {\n            throw new IllegalArgumentException(\n                    \"Could not parse BER PKCS#1 public key structure\", e);\n        }\n\n        // --- convert to JCE RSAPublicKey\n        final RSAPublicKeySpec spec = new RSAPublicKeySpec(\n                pkcs1PublicKey.getModulus(), pkcs1PublicKey.getPublicExponent());\n        final KeyFactory rsaKeyFact;\n        try {\n            rsaKeyFact = KeyFactory.getInstance(\"RSA\");\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"RSA KeyFactory should be available\", e);\n        }\n        try {\n            return (RSAPublicKey) rsaKeyFact.generatePublic(spec);\n        } catch (InvalidKeySpecException e) {\n            throw new IllegalArgumentException(\n                    \"Invalid RSA public key, modulus and/or exponent invalid\", e);\n        }\n    }\n\n    public static void main(final String ... args) throws Exception {\n        final RSAPublicKey publicKey = parsePEM(PEM);\n        System.out.println(publicKey);\n    }\n}\n", "package com.test;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.harmony.javax.security.auth.callback.CallbackHandler;\nimport org.jivesoftware.smack.SASLAuthentication;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.sasl.SASLMechanism;\nimport org.jivesoftware.smack.util.Base64;\n\nimport de.measite.smack.Sasl;\n\npublic class FacebookConnectSASLMechanism  extends SASLMechanism\n{\n\n    private String sessionKey = \"\";\n    private String sessionSecret = \"\";\n    private String apiKey = \"\";\n\n    public FacebookConnectSASLMechanism(SASLAuthentication saslAuthentication) {\n            super(saslAuthentication);\n    }\n\n    // protected void authenticate() throws IOException, XMPPException {\n    // String[] mechanisms = { getName() };\n    // Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n    // sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", hostname, props,\n    // this);\n    //\n    // super.authenticate();\n    // }\n\n    protected void authenticate() throws IOException, XMPPException {\n            StringBuilder stanza = new StringBuilder();\n            stanza.append(\"&lt;auth mechanism=\\\"\").append(getName());\n            stanza.append(\"\\\" xmlns=\\\"urn:ietf:params:xml:ns:xmpp-sasl\\\"&gt;\");\n            stanza.append(\"&lt;/auth&gt;\");\n\n            // Send the authentication to the server\n            //getSASLAuthentication().send(stanza.toString());\n    }\n\n    public void authenticate(String apiKeyAndSessionKey, String host, String sessionSecret)\n                    throws IOException, XMPPException {\n\n            if(apiKeyAndSessionKey==null || sessionSecret==null)\n                    throw new IllegalStateException(\"Invalid parameters!\");\n\n            String[] keyArray = apiKeyAndSessionKey.split(\"\\\\|\");\n\n            if(keyArray==null || keyArray.length != 2)\n                    throw new IllegalStateException(\"Api key or session key is not present!\");\n\n            this.apiKey = keyArray[0];\n            this.sessionKey = keyArray[1];\n            this.sessionSecret = sessionSecret;\n\n            this.authenticationId = sessionKey;\n            this.password = sessionSecret;\n            this.hostname = host;\n\n            String[] mechanisms = { \"DIGEST-MD5\" };\n            Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n            sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props, this);\n            authenticate();\n    }\n\n    public void authenticate(String username, String host, CallbackHandler cbh)\n                    throws IOException, XMPPException {\n            String[] mechanisms = { \"DIGEST-MD5\" };\n            Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n            sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props, cbh);\n            authenticate();\n    }\n\n    protected String getName() {\n            return \"X-FACEBOOK-PLATFORM\";\n    }\n\n    public void challengeReceived(String challenge) throws IOException {\n            // Build the challenge response stanza encoding the response text\n            StringBuilder stanza = new StringBuilder();\n\n            byte response[] = null;\n            if (challenge != null) {\n                    String decodedResponse = new String(Base64.decode(challenge));\n                    Map&lt;String, String&gt; parameters = getQueryMap(decodedResponse);\n\n                    String version = \"1.0\";\n                    String nonce = parameters.get(\"nonce\");\n                    String method = parameters.get(\"method\");\n\n                    Long callId = new GregorianCalendar().getTimeInMillis()/1000;\n\n                    String sig = \"api_key=\"+apiKey\n                                                    +\"call_id=\"+callId\n                                                    +\"method=\"+method\n                                                    +\"nonce=\"+nonce\n                                                    +\"session_key=\"+sessionKey\n                                                    +\"v=\"+version\n                                                    +sessionSecret;\n\n                    try {\n                            sig = MD5(sig);\n                    } catch (NoSuchAlgorithmException e) {\n                            throw new IllegalStateException(e);\n                    }\n\n                    String composedResponse = \"api_key=\"+apiKey+\"&amp;\"\n                                                                            +\"call_id=\"+callId+\"&amp;\"\n                                                                            +\"method=\"+method+\"&amp;\"\n                                                                            +\"nonce=\"+nonce+\"&amp;\"\n                                                                            +\"session_key=\"+sessionKey+\"&amp;\"\n                                                                            +\"v=\"+version+\"&amp;\"\n                                                                            +\"sig=\"+sig;\n\n                    response = composedResponse.getBytes();\n            }\n\n            String authenticationText=\"\";\n\n            if (response != null) {\n                    authenticationText = Base64.encodeBytes(response, Base64.DONT_BREAK_LINES);\n            }\n\n            stanza.append(\"&lt;response xmlns=\\\"urn:ietf:params:xml:ns:xmpp-sasl\\\"&gt;\");\n            stanza.append(authenticationText);\n            stanza.append(\"&lt;/response&gt;\");\n\n            // Send the authentication to the server\n            //getSASLAuthentication().send(stanza);\n    }\n\n    private Map&lt;String, String&gt; getQueryMap(String query) {\n            String[] params = query.split(\"&amp;\");\n            Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\n            for (String param : params) {\n                    String name = param.split(\"=\")[0];\n                    String value = param.split(\"=\")[1];\n                    map.put(name, value);\n            }\n            return map;\n    }\n\nprivate String convertToHex(byte[] data) {\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0; i &lt; data.length; i++) {\n        int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;\n        int two_halfs = 0;\n        do {\n            if ((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9))\n                buf.append((char) ('0' + halfbyte));\n            else\n                buf.append((char) ('a' + (halfbyte - 10)));\n            halfbyte = data[i] &amp; 0x0F;\n        } while(two_halfs++ &lt; 1);\n    }\n    return buf.toString();\n}\n\npublic String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException  {\n    MessageDigest md;\n    md = MessageDigest.getInstance(\"MD5\");\n    byte[] md5hash = new byte[32];\n    md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n    md5hash = md.digest();\n    return convertToHex(md5hash);\n}\n}\n", "try {\n        PackageInfo info = context.getPackageManager().getPackageInfo(\n                packageName, PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n\n            // writtenToFile(\"FB_KEY_HASH.txt\",\n            // Base64.encodeToString(md.digest(),\n            // Base64.DEFAULT).toString(), false);\n\n            if (AppUtills.showLogs)\n                Log.v(pageName,\n                        \"KeyHash:\"\n                                + Base64.encodeToString(md.digest(),\n                                        Base64.DEFAULT));\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n", "try\n{\n    //paste Your package name at the first parameter\n    PackageInfo info = getPackageManager().getPackageInfo(\"PUT_YOUR_PACKAGE_NAME_HERE\",\n            PackageManager.GET_SIGNATURES);\n    for (android.content.pm.Signature signature : info.signatures)\n    {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n        Log.e(\"MY KEY HASH:\", sign);\n        Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();\n    }\n}\ncatch (PackageManager.NameNotFoundException e)\n{\n}\ncatch (NoSuchAlgorithmException e)\n{\n}\n", "    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\"my.package.name\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.e(\"hash key\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e1) {\n        Log.e(\"name not found\", e1.toString());\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(\"no such an algorithm\", e.toString());\n    } catch (Exception e) {\n        Log.e(\"exception\", e.toString());\n    }\n", " KeyGenerator keyGenerator = KeyGenerator.getInstance(\n         KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n keyGenerator.initialize(\n         new KeyGenParameterSpec.Builder(\"key2\",\n                 KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n                 .setBlockModes(KeyProperties.BLOCK_MODE_GCM)\n                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)\n                 .build());\n SecretKey key = keyGenerator.generateKey();\n\n Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n cipher.init(Cipher.ENCRYPT_MODE, key);\n ...\n\n // The key can also be obtained from the Android Keystore any time as follows:\n KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n keyStore.load(null);\n key = (SecretKey) keyStore.getKey(\"key2\", null);\n", "public String encryptText(String cipherText) throws Exception {\n\n    String plainKey = \"key12345\";\n    String plainIV = \"1234567890ABCDEF\";\n\n    KeySpec ks = new  DESKeySpec(plainKey.getBytes(encodingType));\n    SecretKey key = SecretKeyFactory.getInstance(keyDes).generateSecret(ks);\n\n    IvParameterSpec iv = new IvParameterSpec(\n            org.apache.commons.codec.binary.Hex.decodeHex(plainIV.toCharArray()));\n\n    Cipher cipher = Cipher.getInstance(encryptAlgo);\n    cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n\n    byte[] decoded = cipher.doFinal(cipherText.getBytes(encodingType));\n\n    return new Base64().encodeToString(decoded);\n}\n", "        OkHttpClient client = new OkHttpClient();\n\n    try {\n        KeyStore keyStore = readKeyStore(this);\n        SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(keyStore);\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        keyManagerFactory.init(keyStore, \"keystore_pass\".toCharArray());\n        sslContext.init(keyManagerFactory.getKeyManagers(),trustManagerFactory.getTrustManagers(), new SecureRandom());\n        client.setSslSocketFactory(sslContext.getSocketFactory());\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n", "public static String getSha1Hex(String clearString)\n{\n    try\n    {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-1\");\n        messageDigest.update(clearString.getBytes(\"UTF-8\"));\n        byte[] bytes = messageDigest.digest();\n        StringBuilder buffer = new StringBuilder();\n        for (byte b : bytes)\n        {\n            buffer.append(Integer.toString((b &amp; 0xff) + 0x100, 16).substring(1));\n        }\n        return buffer.toString();\n    }\n    catch (Exception ignored)\n    {\n        ignored.printStackTrace();\n        return null;\n    }\n}\n", "public void encrypt(InputStream fin, OutputStream fout, String password) {\n    try {\n        PKCS12ParametersGenerator pGen = new PKCS12ParametersGenerator(new SHA256Digest());\n        char[] passwordChars = password.toCharArray();\n        final byte[] pkcs12PasswordBytes = PBEParametersGenerator.PKCS12PasswordToBytes(passwordChars);\n        pGen.init(pkcs12PasswordBytes, salt.getBytes(), iterationCount);\n        CBCBlockCipher aesCBC = new CBCBlockCipher(new AESEngine());\n        ParametersWithIV aesCBCParams = (ParametersWithIV) pGen.generateDerivedParameters(256, 128);\n        aesCBC.init(true, aesCBCParams);\n        PaddedBufferedBlockCipher aesCipher = new PaddedBufferedBlockCipher(aesCBC, new PKCS7Padding());\n        aesCipher.init(true, aesCBCParams);\n\n        // Read in the decrypted bytes and write the cleartext to out\n        int numRead = 0;\n        while ((numRead = fin.read(buf)) &gt;= 0) {\n            if (numRead == 1024) {\n                byte[] plainTemp = new byte[aesCipher.getUpdateOutputSize(numRead)];\n                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);\n                final byte[] plain = new byte[offset];\n                System.arraycopy(plainTemp, 0, plain, 0, plain.length);\n                fout.write(plain, 0, plain.length);\n            } else {\n                byte[] plainTemp = new byte[aesCipher.getOutputSize(numRead)];\n                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);\n                int last = aesCipher.doFinal(plainTemp, offset);\n                final byte[] plain = new byte[offset + last];\n                System.arraycopy(plainTemp, 0, plain, 0, plain.length);\n                fout.write(plain, 0, plain.length);\n            }\n        }\n        fout.close();\n        fin.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n\npublic void decrypt(InputStream fin, OutputStream fout, String password) {\n    try {\n        PKCS12ParametersGenerator pGen = new PKCS12ParametersGenerator(new SHA256Digest());\n        char[] passwordChars = password.toCharArray();\n        final byte[] pkcs12PasswordBytes = PBEParametersGenerator.PKCS12PasswordToBytes(passwordChars);\n        pGen.init(pkcs12PasswordBytes, salt.getBytes(), iterationCount);\n        CBCBlockCipher aesCBC = new CBCBlockCipher(new AESEngine());\n        ParametersWithIV aesCBCParams = (ParametersWithIV) pGen.generateDerivedParameters(256, 128);\n        aesCBC.init(false, aesCBCParams);\n        PaddedBufferedBlockCipher aesCipher = new PaddedBufferedBlockCipher(aesCBC, new PKCS7Padding());\n        aesCipher.init(false, aesCBCParams);\n\n        // Read in the decrypted bytes and write the cleartext to out\n        int numRead = 0;\n        while ((numRead = fin.read(buf)) &gt;= 0) {\n            if (numRead == 1024) {\n                byte[] plainTemp = new byte[aesCipher.getUpdateOutputSize(numRead)];\n                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);\n                // int last = aesCipher.doFinal(plainTemp, offset);\n                final byte[] plain = new byte[offset];\n                System.arraycopy(plainTemp, 0, plain, 0, plain.length);\n                fout.write(plain, 0, plain.length);\n            } else {\n                byte[] plainTemp = new byte[aesCipher.getOutputSize(numRead)];\n                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);\n                int last = aesCipher.doFinal(plainTemp, offset);\n                final byte[] plain = new byte[offset + last];\n                System.arraycopy(plainTemp, 0, plain, 0, plain.length);\n                fout.write(plain, 0, plain.length);\n            }\n        }\n        fout.close();\n        fin.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "package com.nweave.utils;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.security.KeyStore;\n\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpVersion;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpParams;\nimport org.apache.http.params.HttpProtocolParams;\nimport org.apache.http.protocol.HTTP;\n\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.ColorDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.os.AsyncTask;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\n\nimport com.nweave.view.ProductArrayAdapter;\n\npublic class ImageDownloader {\n    private ProductArrayAdapter productArrayAdapter;\n\n    public ImageDownloader(ProductArrayAdapter productArrayAdapter) {\n        this.productArrayAdapter = productArrayAdapter;\n    }\n\n    public void download(String name, String url, ImageView imageView,\n            ProgressBar progressBar) {\n        if (cancelPotentialDownload(url, imageView)) {\n            BitmapDownloaderTask bitmapDownloaderTask = new BitmapDownloaderTask(\n                    name, imageView, progressBar);\n            DownloadedDrawable downloadedDrawable = new DownloadedDrawable(\n                    bitmapDownloaderTask);\n            imageView.setImageDrawable(downloadedDrawable);\n            bitmapDownloaderTask.execute(url);\n        }\n    }\n\n    private class BitmapDownloaderTask extends AsyncTask&lt;String, Void, Bitmap&gt; {\n        String url;\n        private final WeakReference&lt;ImageView&gt; imageViewReference;\n        private final String productName;\n        private final ProgressBar progressbar;\n\n        public BitmapDownloaderTask(String name, ImageView imageView,\n                ProgressBar progressBar) {\n            imageViewReference = new WeakReference&lt;ImageView&gt;(imageView);\n            productName = name;\n            progressbar = progressBar;\n        }\n\n        @Override\n        protected Bitmap doInBackground(String... params) {\n            HttpResponse response = null;\n            HttpClient httpsClient = getHttpsClient();\n            HttpGet httpGet = new HttpGet();\n            try {\n                httpGet.setURI(new URI(params[0]));\n\n                response = httpsClient.execute(httpGet);\n                Bitmap currentBitMap = BitmapFactory.decodeStream(response\n                        .getEntity().getContent());\n                productArrayAdapter.cacheImages.saveImages(productName,\n                        currentBitMap);\n                return currentBitMap;\n            } catch (URISyntaxException e) {\n                Log.e(ImageDownloader.class.getSimpleName() + \":doInBackground\",\n                        e.getMessage());\n            } catch (ClientProtocolException e) {\n                Log.e(ImageDownloader.class.getSimpleName() + \":doInBackground\",\n                        e.getMessage());\n            } catch (IOException e) {\n                Log.e(ImageDownloader.class.getSimpleName() + \":doInBackground\",\n                        e.getMessage());\n            }\n            return null;\n        }\n\n        @Override\n        protected void onPostExecute(Bitmap result) {\n            if (isCancelled()) {\n                result = null;\n            }\n            if (imageViewReference != null) {\n                ImageView imageView = imageViewReference.get();\n                BitmapDownloaderTask bitmapDownloaderTask = ImageDownloader\n                        .getBitmapDownloaderTask(imageView);\n                if (this == bitmapDownloaderTask) {\n                    imageView.setImageBitmap(result);\n                    imageView.setVisibility(View.VISIBLE);\n                    progressbar.setVisibility(View.INVISIBLE);\n                }\n            }\n        }\n    }\n\n    private static class DownloadedDrawable extends ColorDrawable {\n        private final WeakReference&lt;BitmapDownloaderTask&gt; bitmapDownloaderTaskReference;\n\n        public DownloadedDrawable(BitmapDownloaderTask bitmapDownloaderTask) {\n            bitmapDownloaderTaskReference = new WeakReference&lt;BitmapDownloaderTask&gt;(\n                    bitmapDownloaderTask);\n        }\n\n        public BitmapDownloaderTask getBitmapDownloaderTask() {\n            return bitmapDownloaderTaskReference.get();\n        }\n    }\n\n    private static boolean cancelPotentialDownload(String url,\n            ImageView imageView) {\n        BitmapDownloaderTask bitmapDownloaderTask = getBitmapDownloaderTask(imageView);\n        if (bitmapDownloaderTask != null) {\n            String bitmapUrl = bitmapDownloaderTask.url;\n            if ((bitmapUrl == null) || (!bitmapUrl.equals(url))) {\n                bitmapDownloaderTask.cancel(true);\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static BitmapDownloaderTask getBitmapDownloaderTask(\n            ImageView imageView) {\n        if (imageView != null) {\n            Drawable drawable = imageView.getDrawable();\n            if (drawable instanceof DownloadedDrawable) {\n                DownloadedDrawable downloadedDrawable = (DownloadedDrawable) drawable;\n                return downloadedDrawable.getBitmapDownloaderTask();\n            }\n        }\n        return null;\n    }\n\n    private static HttpClient getHttpsClient() {\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore\n                    .getDefaultType());\n            trustStore.load(null, null);\n            SSLSocketFactory sslSocketFactory = new MySSLSocketFactory(\n                    trustStore);\n            sslSocketFactory\n                    .setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n            HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory\n                    .getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sslSocketFactory, 443));\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(\n                    params, registry);\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception e) {\n            Log.e(ImageDownloader.class.getSimpleName() + \":getHttpsClient\",\n                    e.getMessage());\n            return new DefaultHttpClient();\n        }\n    }\n}\n", "Provider[] providers = Security.getProviders();\nfor (Provider p : providers) {\n  String providerStr = String.format(\"%s/%s/%f\\n\", p.getName(),\n                    p.getInfo(), p.getVersion());\n  Set&lt;Service&gt; services = p.getServices();\n  for (Service s : services) {\n    if (\"MessageDigest\".equals(s.getType())) {\n       System.out.printf(\"\\t%s/%s/%s\", s.getType(),\n                            s.getAlgorithm(), s.getClassName());\n    }\n  }\n}\n", " public static String encrytData(String text) throws Exception {\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    byte[] static_key = Constants.AES_KEY.getBytes();\n\n    SecretKeySpec keySpec = new SecretKeySpec(static_key, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n\n    byte[] results = cipher.doFinal(text.getBytes());\n\n    String result = Base64.encodeToString(results, Base64.NO_WRAP|Base64.DEFAULT);\n    return result;\n\n}\n\n\npublic static String decryptData(String text)throws Exception{\n\n    byte[] encryted_bytes = Base64.decode(text, Base64.DEFAULT);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    byte[] static_key = Constants.AES_KEY.getBytes();\n\n    SecretKeySpec keySpec = new SecretKeySpec(static_key, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);\n    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\n    byte[] decrypted = cipher.doFinal(encryted_bytes);\n    String result = new String(decrypted);\n\n    return result;\n}\n", "String filename =title.replace(\" \",\"\")+j+\".nomedia\";\nFile destination = new File(MyApplication.getPhotoStorage() ,filename);\n\n\nURL url = new URL (url_image);\n\nOutputStream os = new FileOutputStream(destination);\n\nMessageDigest md = MessageDigest.getInstance(\"MD5\");\ntry (InputStream is = url.openStream()) {\n    DigestInputStream dis = new DigestInputStream(is, md);\n    byte[] b = new byte[2048];\n    int length;\n\n    while ((length = dis.read(b)) != -1) {\n        os.write(b, 0, length);\n    }\n}\n\nbyte[] digest = md.digest();\n\nos.close();\nlocalPhotosUrl.add(destination.getAbsolutePath());\n", "private static byte[] filesize = new byte[8];\nprivate static byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\npublic static void decrypt(String inputFile, String outputFile, String password) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n    FileInputStream fis = new FileInputStream(inputFile);\n    FileOutputStream fos = new FileOutputStream(outputFile);\n    fis.read(filesize, 0, 8);\n    System.out.println(new String(filesize));\n    fis.mark(9);\n    fis.read(ivBytes, 0, 16);\n    System.out.println(new String(ivBytes));\n    fis.mark(25);\n    IvParameterSpec iv = new IvParameterSpec(ivBytes);\n    SecretKeySpec sks = new SecretKeySpec(password.getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    cipher.init(Cipher.DECRYPT_MODE, sks, iv);\n    File file = new File(inputFile);\n    int byteLength = (int) file.length() - 24;\n    System.out.println(Integer.toString(byteLength));\n    byte[] bytes = new byte[byteLength];\n    byteLength = fis.read(bytes);\n    System.out.println(Integer.toString(byteLength));\n    System.out.println(new String(bytes));\n    InputStream bytesStream = new ByteArrayInputStream(bytes);\n    CipherInputStream cis = new CipherInputStream(bytesStream, cipher);\n\n    int b;\n    byte[] d = new byte[1024];\n    while((b = cis.read(d)) != -1) {\n        fos.write(d, 0, b);\n    }\n    fos.flush();\n    fos.close();\n    cis.close();\n}\n", "            URL url = new URL(downloadURL);\n            HttpURLConnection urlCon = null;\n\n            URL testUrlHttps = new URL(downloadURL);\n            if (testUrlHttps.getProtocol().toLowerCase().equals(\"https\"))\n            {\n                trustAllHosts();\n                HttpsURLConnection https = (HttpsURLConnection) url.openConnection();\n                https.setHostnameVerifier(DO_NOT_VERYFY);\n                urlCon = https;\n            } else\n            {\n                urlCon = (HttpURLConnection) url.openConnection();\n            }\n\n\n\n\nadd this method. May be it will help\n\n\n\n   private static void trustAllHosts()\n    {\n        // Create a trust manager that does not validate certificate chains\n        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager()\n        {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers()\n            {\n                return new java.security.cert.X509Certificate[] {};\n            }\n\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException\n            {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException\n            {\n            }\n        } };\n\n        // Install the all-trusting trust manager\n        try\n        {\n            SSLContext sc = SSLContext.getInstance(\"TLS\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        } catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n", "URL url = new URL(\"https://www.xyz.com\");\nHttpsURLConnection httpURLConnection  = (HttpsURLConnection) url.openConnection();\nhttpURLConnection.setRequestProperty(\"Content-Type\",\n                \"text/plain\");\nhttpURLConnection.setRequestMethod(\"POST\");\nhttpURLConnection.setDoOutput(true);\nhttpURLConnection.setAllowUserInteraction(false);\nhttpURLConnection.setInstanceFollowRedirects(true);\nhttpURLConnection.setHostnameVerifier(DO_NOT_VERIFY);\nhttpURLConnection.connect();\nOutputStream outputStream = httpURLConnection.getOutputStream();\n outStream.write(datainbytes);\n\n\n\n final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n };\n", "try {\n  Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n\n  SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n\n  // Here you need to accurately and correctly read your file into a byte\n  // array. Either Google for a decent solution (there are many out there)\n  // or use an existing implementation, such as Apache Commons commons-io.\n  // Your existing effort is buggy and doesn't close its resources.      \n  byte[] cipherText = FileUtils.readFileToByteArray(new File(savedScoresFileName));\n\n\n  cipher.init(Cipher.DECRYPT_MODE, key);\n\n  // Just one call to doFinal\n  byte[] plainText = cipher.doFinal(cipherText);\n\n  // Note: don't do this. If you create a string from a byte array,\n  // PLEASE pass a charset otherwise your result is platform dependent.\n  return new String(plainText);\n} catch (Exception e) {\n  e.printStackTrace();\n}\n", "public class MyCrypter {\n\nprivate static String TAG = \"MyCrypter\";\n\npublic MyCrypter() {\n\n}\n\n/**\n * Encodes a String in AES-128 with a given key\n * \n * @param context\n * @param password\n * @param text\n * @return String Base64 and AES encoded String\n * @throws NoPassGivenException\n * @throws NoTextGivenException\n */\npublic String encode(Context context, String password, String text)\n        throws NoPassGivenException, NoTextGivenException {\n    if (password.length() == 0 || password == null) {\n        throw new NoPassGivenException(\"Please give Password\");\n    }\n\n    if (text.length() == 0 || text == null) {\n        throw new NoTextGivenException(\"Please give text\");\n    }\n\n    try {\n        SecretKeySpec skeySpec = getKey(password);\n        byte[] clearText = text.getBytes(\"UTF8\");\n\n        //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID\n        final byte[] iv = new byte[16];\n        Arrays.fill(iv, (byte) 0x00);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n        // Cipher is not thread safe\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);\n\n        String encrypedValue = Base64.encodeToString(\n                cipher.doFinal(clearText), Base64.DEFAULT);\n        Log.d(TAG, \"Encrypted: \" + text + \" -&gt; \" + encrypedValue);\n        return encrypedValue;\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n\n/**\n * Decodes a String using AES-128 and Base64\n * \n * @param context\n * @param password\n * @param text\n * @return desoded String\n * @throws NoPassGivenException\n * @throws NoTextGivenException\n */\npublic String decode(Context context, String password, String text)\n        throws NoPassGivenException, NoTextGivenException {\n\n    if (password.length() == 0 || password == null) {\n        throw new NoPassGivenException(\"Please give Password\");\n    }\n\n    if (text.length() == 0 || text == null) {\n        throw new NoTextGivenException(\"Please give text\");\n    }\n\n    try {\n        SecretKey key = getKey(password);\n\n        //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID\n        final byte[] iv = new byte[16];\n        Arrays.fill(iv, (byte) 0x00);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n        byte[] encrypedPwdBytes = Base64.decode(text, Base64.DEFAULT);\n        // cipher is not thread safe\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);\n        byte[] decrypedValueBytes = (cipher.doFinal(encrypedPwdBytes));\n\n        String decrypedValue = new String(decrypedValueBytes);\n        Log.d(TAG, \"Decrypted: \" + text + \" -&gt; \" + decrypedValue);\n        return decrypedValue;\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n\n/**\n * Generates a SecretKeySpec for given password\n * @param password\n * @return SecretKeySpec\n * @throws UnsupportedEncodingException\n */\npublic SecretKeySpec getKey(String password)\n        throws UnsupportedEncodingException {\n\n\n    int keyLength = 128;\n    byte[] keyBytes = new byte[keyLength / 8];\n    // explicitly fill with zeros\n    Arrays.fill(keyBytes, (byte) 0x0);\n\n    // if password is shorter then key length, it will be zero-padded\n    // to key length\n    byte[] passwordBytes = password.getBytes(\"UTF-8\");\n    int length = passwordBytes.length &lt; keyBytes.length ? passwordBytes.length\n            : keyBytes.length;\n    System.arraycopy(passwordBytes, 0, keyBytes, 0, length);\n    SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n    return key;\n}\n\npublic class NoTextGivenException extends Exception {\n    public NoTextGivenException(String message) {\n        super(message);\n    }\n\n}\n\npublic class NoPassGivenException extends Exception {\n    public NoPassGivenException(String message) {\n        super(message);\n    }\n\n}\n\n}\n", "public String calculateMD5(String string) {\n    StringBuilder result = new StringBuilder();\n    try {\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(string.getBytes(\"UTF8\"));\n\n        byte s[] = m.digest();\n\n        for (int i = 0; i &lt; s.length; i++) {\n            result.append(Integer.toHexString((0x000000ff &amp; s[i]) | 0xffffff00).substring(6));\n        }\n    } catch (NoSuchAlgorithmException e) {\n        throw new IllegalStateException(\"Password hash is unsupported by device android implementation.\", e);\n    } catch (UnsupportedEncodingException e) {\n        throw new IllegalStateException(\"Password hash is unsupported by device android implementation.\", e);\n    }\n    return result.toString();\n}\n", "public class MySSLSocketFactory extends SSLSocketFactory {\n\n    private SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    private Socket last;\n\n    public void closeLastSocket() {\n        if (last != null) {\n            last.close();\n        }\n    }\n\n    public Socket createSocket() throws IOException {\n        return this.last = factory.createSocket();\n    }\n\n    ...\n\n}\n", "byte[] certData = ...       \n/* create KeyStore */\nKeyStore ks = KeyStore.getInstance(\"JKS\", \"SUN\");\n/* load key store (initialization */\nks.load(null, null);\n/* create CertificateFactory */\nCertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n/* create certificate from input stream */\nCertificate cert;\n/* provide cert data */\nByteArrayInputStream in = new ByteArrayInputStream(makeCert(certData));\n\n\n\nprivate static byte[] makeCert(byte[] data) {\n    String headline = \"-----BEGIN CERTIFICATE-----\";\n    String footline = \"-----END CERTIFICATE-----\";\n\n    String certStr = headline;\n    for (int i = 0; i &lt; data.length; i++) {\n        if (i%64 == 0) {\n            certStr += \"\\n\";\n        }\n        certStr += (char)data[i];\n    }\n    if ((data.length-1)%64 != 0) {\n        certStr += \"\\n\";\n    }\n    certStr += footline;\n    return certStr.getBytes();\n}\n", "package com.myApp.security;\n\nimport  android.util.Base64;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Security {\n    public static String encrypt(String input, String key){\n      byte[] crypted = null;\n      try{\n        SecretKeySpec skey = new SecretKeySpec(key.getBytes(), \"AES\");\n          Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n          cipher.init(Cipher.ENCRYPT_MODE, skey);\n          crypted = cipher.doFinal(input.getBytes());\n        }catch(Exception e){\n            System.out.println(e.toString());\n        }\n        return new String(Base64.encode(crypted, Base64.DEFAULT));\n    }\n\n    public static String decrypt(String input, String key){\n        byte[] output = null;\n        try{\n          SecretKeySpec skey = new SecretKeySpec(key.getBytes(), \"AES\");\n          Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n          cipher.init(Cipher.DECRYPT_MODE, skey);\n          //output = cipher.doFinal(Base64.decodeBase64(input));\n          output = cipher.doFinal(Base64.decode(input, Base64.DEFAULT));\n        }catch(Exception e){\n          System.out.println(e.toString());\n        }\n        return new String(output);\n    }   \n}\n", "public class Crypto {\n\nCipher ecipher;\nCipher dcipher;\n\nbyte[] salt = { 1, 2, 4, 5, 7, 8, 3, 6 };\nint iterationCount = 1979;\n\nCrypto(String passPhase) {\n    try {\n        // Create the key\n        KeySpec keySpec = new PBEKeySpec(passPhase.toCharArray(), salt, iterationCount);\n        SecretKey key = SecretKeyFactory.getInstance(\"PBEWITHSHA256AND128BITAES-CBC-BC\").generateSecret(keySpec);\n        ecipher = Cipher.getInstance(key.getAlgorithm()); \n        dcipher = Cipher.getInstance(key.getAlgorithm());\n\n        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);\n\n        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n\n    } catch (Exception e) {\n        // TODO: handle exception\n        //Toast.makeText(this, \"I cought \", Toast.LENGTH_LONG).show();\n    }\n\n\n}\n\npublic String encrypt(String str) {\n    String rVal;\n    try {\n        byte[] utf8 = str.getBytes(\"UTF8\");\n\n        byte[] enc = ecipher.doFinal(utf8);\n\n        rVal = toHex(enc);\n\n    } catch (Exception e) {\n        // TODO: handle exception\n        rVal = \"Exception Caught \"+e.getMessage();\n    }\n    return rVal;\n}\n\n\npublic String decrypt(String str) {\n    String rVal;\n    try {\n        byte[] dec = toByte(str);\n        byte[] utf8 = dcipher.doFinal(dec);\n\n        rVal = new String(utf8, \"UTF8\");\n\n    } catch(Exception e) {\n        rVal = \"Error in decrypting :\"+e.getMessage();\n    }\n    return rVal;\n}\n\nprivate static byte[] toByte(String hexString ) {\n    int len = hexString.length()/2;\n    byte[] result = new byte[len];\n    for ( int i=0; i&lt;len; i++ ) {\n        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16 ).byteValue();\n\n    }\n    return result;\n}\nprivate static String toHex(byte[] buf) {\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer( 2*buf.length);\n    for ( int i=0; i&lt;buf.length; i++) {\n        appendHex(result, buf[i]);\n\n    }\n    return result.toString();\n}\n\nprivate final static String HEX = \"0123456789ABCDEF\";\n\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));\n}\n\n\n}\n", "   package whatsapp;\n\n    import java.io.File;\n\n    import java.io.FileInputStream;\n\n    import java.io.FileOutputStream;\n\n    import java.math.BigInteger;\n\n    import java.security.MessageDigest;\n\n    import java.util.Arrays;\n\n    import javax.crypto.Cipher;\n\n    import javax.crypto.CipherInputStream;\n\n    import javax.crypto.spec.IvParameterSpec;\n\n    import javax.crypto.spec.SecretKeySpec;\n\n    public class WhatsAppDecrypt5 {\n\n        private static final byte[] INITIALIZATION_VECTOR = hexStringToByteArray(\"1e39f369e90db33aa73b442bbbb6b0b9\");\n        private static final byte[] ENCRYPTION_KEY = hexStringToByteArray(\"8d4b155cc9ff81e5cbf6fa7819366a3ec621a656416cd793\");\n        public static void main(String[] args) throws Exception {\n\n\n\n            if (args.length != 3) {\n                System.out.println(\"usage &lt;inputfile&gt; &lt;outputfile&gt; &lt;email&gt;\");\n            //  System.exit(0);\n            }\n            decrypt(new File(\"/Users/ovazquez/Downloads/msgstore.db.crypt5\"), new File(\"/Users/ovazquez/Downloads/msgstore.db\"), \"theasociatedemail@gmail.com\");\n            System.out.println(\"finalizado\");\n        }\n\n        private static void decrypt(File inputFile, File outputFile, String email)\n                throws Exception {\n\n            String emailMD5 = md5(email);\n\n            byte[] emailMD5Bytes = hexStringToByteArray(emailMD5 + emailMD5);\n\n            byte[] decryptionKey = Arrays.copyOf(ENCRYPTION_KEY, 24);\n\n            for (int i = 0; i &lt; 24; i++) {\n                decryptionKey[i] ^= emailMD5Bytes[i &amp; 0xF];\n            }\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\", \"SunJCE\");\n            cipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(decryptionKey, \"AES\"), new IvParameterSpec(INITIALIZATION_VECTOR));\n            CipherInputStream cIn = new CipherInputStream(new FileInputStream(inputFile), cipher);\n            FileOutputStream fOut = new FileOutputStream(outputFile);\n\n            byte[] buffer = new byte[8192];\n\n            int n;\n\n            while ((n = cIn.read(buffer)) != -1) {\n\n                fOut.write(buffer, 0, n);\n\n            }\n\n            cIn.close();\n\n            fOut.close();\n\n        }\n\n        private static byte[] hexStringToByteArray(String s) {\n\n            int len = s.length();\n\n            byte[] data = new byte[len / 2];\n\n            for (int i = 0; i &lt; len; i += 2) {\n\n                data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character\n                        .digit(s.charAt(i + 1), 16));\n\n            }\n\n            return data;\n\n        }\n\n        private static String md5(String md5) throws Exception {\n\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n\n            m.reset();\n\n            m.update(md5.getBytes());\n\n            byte[] digest = m.digest();\n\n            BigInteger bigInt = new BigInteger(1, digest);\n\n            return bigInt.toString(16);\n\n        }\n\n    }\n", "import org.apache.http.conn.ssl.SSLSocketFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport javax.net.ssl.KeyManager;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\n\n/**\n * Allows you to trust certificates from additional KeyStores in addition to\n * the default KeyStore\n */\npublic class AdditionalKeyStoresSSLSocketFactory extends SSLSocketFactory{\n    protected SSLContext sslContext = SSLContext.getInstance(\"TLSv1\");\n\n    public AdditionalKeyStoresSSLSocketFactory(KeyStore keyStore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(null, null, null, null, null, null);\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory\n                .getInstance(KeyManagerFactory.getDefaultAlgorithm());;\n        keyManagerFactory.init(keyStore, \"123456\".toCharArray());\n        sslContext.init(keyManagerFactory.getKeyManagers(), new TrustManager[]{new AdditionalKeyStoresTrustManager(keyStore)}, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n\n\n\n    /**\n     * Based on http://download.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#X509TrustManager\n     */\n    public static class AdditionalKeyStoresTrustManager implements X509TrustManager {\n\n        protected ArrayList&lt;X509TrustManager&gt; x509TrustManagers = new ArrayList&lt;X509TrustManager&gt;();\n\n\n        protected AdditionalKeyStoresTrustManager(KeyStore... additionalkeyStores) {\n            final ArrayList&lt;TrustManagerFactory&gt; factories = new ArrayList&lt;TrustManagerFactory&gt;();\n\n            try {\n                // The default Trustmanager with default keystore\n                final TrustManagerFactory original = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                original.init((KeyStore) null);\n                factories.add(original);\n\n                for( KeyStore keyStore : additionalkeyStores ) {\n                    final TrustManagerFactory additionalCerts = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                    additionalCerts.init(keyStore);\n                    factories.add(additionalCerts);\n                }\n\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n\n\n\n            /*\n             * Iterate over the returned trustmanagers, and hold on\n             * to any that are X509TrustManagers\n             */\n            for (TrustManagerFactory tmf : factories)\n                for( TrustManager tm : tmf.getTrustManagers() )\n                    if (tm instanceof X509TrustManager)\n                        x509TrustManagers.add( (X509TrustManager)tm );\n\n\n            if( x509TrustManagers.size()==0 )\n                throw new RuntimeException(\"Couldn't find any X509TrustManagers\");\n\n        }\n\n        /*\n         * Delegate to the default trust manager.\n         */\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            final X509TrustManager defaultX509TrustManager = x509TrustManagers.get(0);\n            defaultX509TrustManager.checkClientTrusted(chain, authType);\n        }\n\n        /*\n         * Loop over the trustmanagers until we find one that accepts our server\n         */\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            for( X509TrustManager tm : x509TrustManagers ) {\n                try {\n                    tm.checkServerTrusted(chain,authType);\n                    return;\n                } catch( CertificateException e ) {\n                    // ignore\n                }\n            }\n            throw new CertificateException();\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            final ArrayList&lt;X509Certificate&gt; list = new ArrayList&lt;X509Certificate&gt;();\n            for( X509TrustManager tm : x509TrustManagers )\n                list.addAll(Arrays.asList(tm.getAcceptedIssuers()));\n            return list.toArray(new X509Certificate[list.size()]);\n        }\n    }\n\n}\n", "private static String generateSasToken(String uri, String keyName, String key){\n        String ret = \"\";\n\n       // long tokenExpirationTime = (System.currentTimeMillis() / 1000) + (10 * 365 * 24 * 60 * 60);\n\n        Date now = new Date();\n        Date previousDate=new Date(1970);\n        long tokenExpirationTime = ((now.getTime() - previousDate.getTime()) / 1000 )+3600;\n\n        try {\n            String stringToSign = URLEncoder.encode(new URL(uri).toString(),java.nio.charset.StandardCharsets.UTF_8.toString()) + \"\\n\" + tokenExpirationTime;\n\n            System.out.println(stringToSign);\n            SecretKey secretKey = null;\n\n            byte[] keyBytes = key.getBytes(\"UTF-8\");\n\n            Mac mac = Mac.getInstance(\"HMACSHA256\");\n\n            secretKey = new SecretKeySpec(keyBytes, mac.getAlgorithm());\n\n            mac.init(secretKey);\n\n            byte[] digest = mac.doFinal(stringToSign.getBytes());\n            //We then use the composite signing key to create an oauth_signature from the signature base string\n            String signature = Base64.encodeBase64String(digest);\n            System.out.println( URLEncoder.encode(signature, java.nio.charset.StandardCharsets.UTF_8.toString()));\n           // String signature = Base64.encodeBase64String(mac.doFinal(stringToSign.getBytes(\"UTF-8\")));\n            ret = String.format(\"SharedAccessSignature sr=%s&amp;sig=%s&amp;se=%s&amp;skn=%s\",\n                    URLEncoder.encode(uri, java.nio.charset.StandardCharsets.UTF_8.toString()),\n                    URLEncoder.encode(signature, java.nio.charset.StandardCharsets.UTF_8.toString()),\n                    String.valueOf(tokenExpirationTime),\n                    keyName);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return ret;\n    }\n", "public static String md5(String string) {\n    byte[] hash;\n\n    try {\n        hash = MessageDigest.getInstance(\"MD5\").digest(string.getBytes(\"UTF-8\"));\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(\"Huh, MD5 should be supported?\", e);\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(\"Huh, UTF-8 should be supported?\", e);\n    }\n\n    StringBuilder hex = new StringBuilder(hash.length * 2);\n\n    for (byte b : hash) {\n        int i = (b &amp; 0xFF);\n        if (i &lt; 0x10) hex.append('0');\n        hex.append(Integer.toHexString(i));\n    }\n\n    return hex.toString();\n}\n", "KeyStore trusted;\ntry {  \n\n        trusted = KeyStore.getInstance(\"pkcs12\");\n        trusted.load(null, \"\".toCharArray());\n        SSLSocketFactory sslf = new SSLSocketFactory(trusted);\n", "SecretKeyFactory factory = \n    SecretKeyFactory.getInstance(\"PBEWITHSHAAND256BITAES-CBC-BC\");\nKeySpec spec = new PBEKeySpec(\"password\".toCharArray(), salt, 1024, 256);\nSecretKey tmp = factory.generateSecret(spec);\nSecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n", "int bks_version;\nif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {\n    bks_version = R.raw.publickey; //The BKS file\n} else {\n    bks_version = R.raw.publickey_v1; //The BKS (v-1) file\n}\nKeyStore ks = KeyStore.getInstance(\"BKS\");\nInputStream in = getResources().openRawResource(bks_version);  \nks.load(in, \"mypass\".toCharArray());\n", "    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    \"com.facebook.samples.loginhowto\", \n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                }\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n        ...other operations\n\n}//end of onCreate\n", "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); // adjust padding\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(...));\n", "private SSLSocketFactory getSocketFactory() {\n        // TODO Auto-generated method stub\n        SSLSocketFactory sslFactory = null;\n        try {\n            KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n            InputStream instream = this.getResources().openRawResource(\n                    R.raw.website_public);\n            keyStore.load(instream, \"keystore_password\".toCharArray());\n            sslFactory = new MySSLSocketFactory(keyStore);\n        } catch (KeyStoreException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        } catch (NoSuchAlgorithmException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        } catch (CertificateException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        } catch (IOException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        } catch (UnrecoverableKeyException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        } catch (KeyManagementException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return sslFactory;\n    }\n", "    public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {\n    if (signedData == null) {\n        Log.e(TAG, \"data is null\");\n        return false;\n    }\n\n    boolean verified = false;\n    if (!TextUtils.isEmpty(signature)) {\n        PublicKey key = Security.generatePublicKey(base64PublicKey);\n\n        if( key != null) // ADD_THIS_LINE\n            verified = Security.verify(key, signedData, signature);\n\n        if (!verified) {\n            Log.w(TAG, \"signature does not match data.\");\n            return false;\n        }\n    }\n    return true;\n}    \n////////////////////////////////////////////////////////////////////////\n//  :     :     \n///////////////////////////////////////////////////////////////////////\n public static PublicKey generatePublicKey(String encodedPublicKey) {\n    try {\n        byte[] decodedKey = Base64.decode(encodedPublicKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);\n        return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    } catch (InvalidKeySpecException e) {\n        Log.e(TAG, \"Invalid key specification.\");\n        throw new IllegalArgumentException(e);\n    } catch (Base64DecoderException e) {\n        Log.e(TAG, \"Base64 decoding failed.\");\n        return null;  // ADD_THIS_LINE\n        // COMMENT_OUT_THIS_LINE:   throw new IllegalArgumentException(e);\n    }\n}\n\n\n//////////////////////////////////////////////////////////////\n", "try {\n        PackageInfo info =     getPackageManager().getPackageInfo(\"com.package.mypackage\",     PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);\n            Log.e(\"MY KEY HASH:\", sign);\n            Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();\n        }\n} catch (NameNotFoundException e) {\n} catch (NoSuchAlgorithmException e) {\n}\n", "Provider[] providers = Security.getProviders();\nfor (Provider provider : providers) {\n    Log.i(\"CRYPTO\",\"provider: \"+provider.getName());\n    Set&lt;Provider.Service&gt; services = provider.getServices();\n    for (Provider.Service service : services) {\n        Log.i(\"CRYPTO\",\"  algorithm: \"+service.getAlgorithm());\n    }\n}\n", "public String hashSha1(byte[] data) throws NoSuchAlgorithmException, \n    UnsupportedEncodingException { \n  MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n  md.update(data, 0, data.length);\n  return convertToHex(md.digest());\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"your.package.name\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n} catch (NoSuchAlgorithmException e) {\n}\n", "public boolean Verify(RSAPublicKey key, String signature, String data)\n{\n    try\n    {\n        Signature sign = Signature.getInstance(\"SHA1withRSA\");\n        sign.initVerify(key);\n        sign.update(data.getBytes(\"UTF-8\"));\n        return sign.verify(Base64.decode(signature.getBytes(\"UTF-8\"), Base64.NO_WRAP));\n    }\n    catch (Exception e)\n    {\n        e.printStackTrace();\n    }\n    return false;\n}\n", "private RSAPublicKey GetPublicKey(String keyXmlString) throws InvalidKeySpecException, UnsupportedEncodingException, NoSuchAlgorithmException\n{\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n\n    String modulusString = keyXmlString.substring(keyXmlString.indexOf(\"&lt;Modulus&gt;\"), keyXmlString.indexOf(\"&lt;/Modulus&gt;\")).replace(\"&lt;Modulus&gt;\", \"\");\n    String exponentString = keyXmlString.substring(keyXmlString.indexOf(\"&lt;Exponent&gt;\"), keyXmlString.indexOf(\"&lt;/Exponent&gt;\")).replace(\"&lt;Exponent&gt;\", \"\");\n\n    byte[] modulusBytes = Base64.decode(modulusString.getBytes(\"UTF-8\"), Base64.DEFAULT);\n    byte[] dBytes = Base64.decode(exponentString.getBytes(\"UTF-8\"), Base64.DEFAULT);\n\n    BigInteger modulus = new BigInteger(1, modulusBytes);\n    BigInteger d = new BigInteger(1, dBytes);\n\n    RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, d);\n\n    return (RSAPublicKey) keyFactory.generatePublic(keySpec);\n}\n", "private byte[] cipherData(PaddedBufferedBlockCipher cipher, byte[] data) throws Exception {\n        int minSize = cipher.getOutputSize(data.length);\n        byte[] outBuf = new byte[minSize];\n        int length1 = cipher.processBytes(data, 0, data.length, outBuf, 0);\n        int length2 = cipher.doFinal(outBuf, length1);\n        int actualLength = length1 + length2;\n        byte[] result = new byte[actualLength];\n        System.arraycopy(outBuf, 0, result, 0, result.length);\n        return result;\n    }\n", "public void decrypt(File inputFile, File outputFile, byte[] key) throws Exception {\n        Cipher cipher = getCipherDecrypt(key);\n        FileOutputStream fos = null;\n        CipherInputStream cis = null;\n        FileInputStream fis = null;\n        try { \n            fis = new FileInputStream(inputFile);\n            cis = new CipherInputStream(fis, cipher);\n            fos = new FileOutputStream(outputFile);\n            byte[] data = new byte[1024];\n            int read = cis.read(data);\n            while (read != -1) {\n                fos.write(data, 0, read);\n                read = cis.read(data);\n                System.out.println(new String(data, \"UTF-8\").trim());\n            } \n        } finally { \n            fos.close();\n            cis.close();\n            fis.close();\n        } \n    } \n", "import android.security.MessageDigest;\n\npublic class MessageDigestTester {\n\n    private static Boolean messageDigestAvailable = null;\n\n    public static Boolean isLibraryAvailable() {\n        if (messageDigestAvailable == null) {\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\n                messageDigestAvailable = true;\n\n            } catch (NoClassDefFoundError e) {\n                messageDigestAvailable = false;\n            }\n\n        } \n\n        return messageDigestAvailable;\n    }\n}\n", "public static void main(String[] args) {\n    try {\n        byte[] keyBytes = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};\n        byte[] ivBytes =  {0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};\n\n        SecretKeySpec sks = new SecretKeySpec(keyBytes, \"AES\");\n        IvParameterSpec iv = new IvParameterSpec(ivBytes);\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, sks, iv);\n\n        // read file to byte[]\n        InputStream is = new FileInputStream(\"test.enc\");\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int b;\n        while ((b = is.read()) != -1) {\n            baos.write(b);\n        }\n        byte[] fileBytes = baos.toByteArray();\n\n        byte[] decrypted = cipher.doFinal(fileBytes);\n        System.out.println(new String(decrypted));\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "        static public boolean DEVELOPMENT_VERBOSE = false;\n        static private final  X500Principal RELEASE_DN = new X500Principal(\n            \"CN=aaa,OU=bbb,O=ccc,L=ddd,ST=eee,C=fff\"\n            );\n\n        // auto disable the development logs if the apk is signed with a cert\n        try {\n            PackageManager manager = context.getPackageManager();\n            PackageInfo appInfo = manager.getPackageInfo(\"com.xxx.app\",\n                    PackageManager.GET_SIGNATURES);\n            Signature raw = appInfo.signatures[0];\n\n            try {\n                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                X509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(raw.toByteArray()));\n\n                //DEVELOPMENT_VERBOSE = cert.getSubjectX500Principal().equals(DEBUG_DN);\n                if (!cert.getSubjectX500Principal().equals(RELEASE_DN))\n                    DEVELOPMENT_VERBOSE = true;\n\n            } catch (CertificateException e) {  \n\n            }           \n        } catch (NameNotFoundException e) {\n\n        }\n", "private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception \n{\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception     \n{\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n", "ByteArrayOutputStream baos = new ByteArrayOutputStream();  \nbm.compress(Bitmap.CompressFormat.PNG, 100, baos); \nbyte[] b = baos.toByteArray();  \n\nbyte[] keyStart = \"encryption key\".getBytes();\nKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\nSecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\nsr.setSeed(keyStart);\nkgen.init(128, sr); \nSecretKey skey = kgen.generateKey();\nbyte[] key = skey.getEncoded();    \n\n// encrypt\nbyte[] encryptedData = encrypt(key,b);\n// decrypt\nbyte[] decryptedData = decrypt(key,encryptedData);\n", "KeyStore trustStore = KeyStore.getInstance(\"BKS\");\nInputStream is = this.getAssets().open(\"discretio.bks\");\ntrustStore.load(is, \"discretio\".toCharArray());\nis.close();\n\nSSLSocketFactory sockfacto = new SSLSocketFactory(trustStore);\nsockfacto.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n\nSchemeRegistry schemeRegistry = new SchemeRegistry();\nschemeRegistry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\nschemeRegistry.register(new Scheme(\"https\", sockfacto, 443));\n\nSingleClientConnManager mgr = new SingleClientConnManager(httpParameters, schemeRegistry);\n\nHttpClient client = new DefaultHttpClient(mgr, httpParameters);\nHttpGet request = new HttpGet(url);\nHttpResponse response = client.execute(request);\n", "KeyStore trustStore = KeyStore.getInstance(\"BKS\");\nInputStream is = this.getAssets().open(\"discretio.bks\");\ntrustStore.load(is, \"discretio\".toCharArray());\nis.close();\n\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");\ntmf.init(trustStore);\nSSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, tmf.getTrustManagers(), null);\n\nURL request = new URL(url);\nHttpsURLConnection urlConnection = (HttpsURLConnection) request.openConnection();\n\n//ensure that we are using a StrictHostnameVerifier\nurlConnection.setHostnameVerifier(new StrictHostnameVerifier());\nurlConnection.setSSLSocketFactory(context.getSocketFactory());\nurlConnection.setConnectTimeout(15000);\n\nInputStream in = urlConnection.getInputStream();\n//I don't want to change my function's return type (laziness) so I'm building an HttpResponse\nBasicHttpEntity res = new BasicHttpEntity();\nres.setContent(in);\nHttpResponse resp = new BasicHttpResponse(HttpVersion.HTTP_1_1, urlConnection.getResponseCode(), \"\");\nresp.setEntity(res);\n", "  public void printHashKey() {\n\n        try {\n            PackageInfo info = getPackageManager().getPackageInfo(\"your.package.name\",\n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"TEMPTAGHASH KEY:\",\n                        Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n\n    }\n", "try {\nPackageInfo info = getPackageManager().getPackageInfo(\n        \"com.example.com.tvishi.fb\", \n        PackageManager.GET_SIGNATURES);\nfor (Signature signature : info.signatures) {\n    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n    md.update(signature.toByteArray());\n    Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "try {\n            PackageInfo info = context.getPackageManager().getPackageInfo(\n                    \"com.mypackage.name\", \n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.e(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                }\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n", "import java.security.MessageDigest;\n\npublic class SHA512 {\n      public static void main(String args[]) throws Exception {\n          String password = \"pass@word1\";\n\n            if ((args.length == 1) &amp;&amp; (args[0].length() &gt; 0))\n            {\n                password = args[0];\n            }\n            System.out.println(\"Password: \" + password + \" in SHA512 is:\");\n            System.out.println(hashText(password));\n      }\n\n    public static String convertByteToHex(byte data[])\n    {\n        StringBuffer hexData = new StringBuffer();\n        for (int byteIndex = 0; byteIndex &lt; data.length; byteIndex++)\n            hexData.append(Integer.toString((data[byteIndex] &amp; 0xff) + 0x100, 16).substring(1));\n\n        return hexData.toString();\n    }\n\n    public static String hashText(String textToHash) throws Exception\n    {\n        final MessageDigest sha512 = MessageDigest.getInstance(\"SHA-512\");\n        sha512.update(textToHash.getBytes());\n\n        return convertByteToHex(sha512.digest());\n    }\n}\n", "SSLContext context = SSLContext.getInstance(\"TLS\");\n    context.init(null, null, null);\n    SSLSocketFactory factory = context.getSocketFactory();\n    httpURLConnection.setSSLSocketFactory(factory);\n", "public void connectToFb() throws XMPPException {\n\nConnectionConfiguration config = new ConnectionConfiguration(\"chat.facebook.com\", 5222);\nconfig.setSASLAuthenticationEnabled(true);\nconfig.setSecurityMode(SecurityMode.required);\nconfig.setRosterLoadedAtLogin(true);\nconfig.setTruststorePath(\"/system/etc/security/cacerts.bks\");\nconfig.setTruststorePassword(\"changeit\");\nconfig.setTruststoreType(\"bks\");\nconfig.setSendPresence(false);\ntry {\n    SSLContext sc = SSLContext.getInstance(\"TLS\");\n    sc.init(null, MemorizingTrustManager.getInstanceList(this), new java.security.SecureRandom());\n    config.setCustomSSLContext(sc);\n} catch (GeneralSecurityException e) {\n    Log.w(\"TAG\", \"Unable to use MemorizingTrustManager\", e);\n}\nXMPPConnection xmpp = new XMPPConnection(config);\ntry {\n    xmpp.connect();\n    xmpp.login(\"facebookusername\", \"****\"); // Here you have to used only facebookusername from facebookusername@chat.facebook.com\n    Roster roster = xmpp.getRoster();\n    Collection&lt;RosterEntry&gt; entries = roster.getEntries();\n    System.out.println(\"Connected!\");\n    System.out.println(\"\\n\\n\" + entries.size() + \" buddy(ies):\");\n    // shows first time onliners----&gt;\n    String temp[] = new String[50];\n    int i = 0;\n    for (RosterEntry entry : entries) {\n        String user = entry.getUser();\n        Log.i(\"TAG\", user);\n    }\n} catch (XMPPException e) {\n    xmpp.disconnect();\n    e.printStackTrace();\n}\n}\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.al.name\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "import android.content.Context;\nimport android.util.Log;\n\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.security.KeyStore;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManagerFactory;\n\n\n/**\n * Created by martin on 02/06/14.\n */\npublic class Pinning {\n\n    Context context;\n    public static String TRUST_STORE_PASSWORD = \"your_secret\";\n    private static final String ENDPOINT = \"https://api.yourdomain.com/\";\n\n    public Pinning(Context c) {\n        this.context = c;\n    }\n\n    private SSLSocketFactory getPinnedCertSslSocketFactory(Context context) {\n        try {\n            KeyStore trusted = KeyStore.getInstance(\"BKS\");\n            InputStream in = context.getResources().openRawResource(R.raw.mytruststore);\n            trusted.load(in, TRUST_STORE_PASSWORD.toCharArray());\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(\n                    TrustManagerFactory.getDefaultAlgorithm());\n            trustManagerFactory.init(trusted);\n            sslContext.init(null, trustManagerFactory.getTrustManagers(), null);\n            return sslContext.getSocketFactory();\n        } catch (Exception e) {\n            Log.e(\"MyApp\", e.getMessage(), e);\n        }\n        return null;\n    }\n\n    public void makeRequest() {\n        try {\n            OkHttpClient client = new OkHttpClient();\n            client.setSslSocketFactory(getPinnedCertSslSocketFactory(context));\n\n            Request request = new Request.Builder()\n                    .url(ENDPOINT)\n                    .build();\n\n            Response response = client.newCall(request).execute();\n\n            Log.d(\"MyApp\", response.body().string());\n\n        } catch (Exception e) {\n            Log.e(\"MyApp\", e.getMessage(), e);\n\n        }\n    }\n}\n", "import javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Base64;\nimport android.util.Log;\n\npublic class AesFileIo {\n//    private static final String AES_ALGORITHM = \"AES/CTR/NoPadding\";\n    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n    private SecretKeySpec secretKeySpec;\n    private IvParameterSpec ivSpec;\n\n    public AesFileIo(byte[] aesKey, byte[] iv) {\n        ivSpec = new IvParameterSpec(iv);\n        secretKeySpec = new SecretKeySpec(aesKey, \"AES\");\n    }\n\n    public String decrypt(String text) {\n\n        StringBuilder stringBuilder = new StringBuilder(); \n        try {\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\n            byte[] decordedValue =  Base64.decode(text,Base64.DEFAULT);\n            String decryptedValue = new String(cipher.doFinal(decordedValue),\"UTF-8\");\n            Log.e(\"decrypted Value :\",decryptedValue);\n            return decryptedValue; \n        } catch (Exception e) {\n            Log.e(this.getClass().toString(), e.getMessage(), e);\n        }\n        return stringBuilder.toString();\n    }\n\n    public String encrypt(String text) {\n        String encryptedValue=null;\n        try {\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM); \n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);\n            byte[] encValue = cipher.doFinal(text.getBytes());\n            encryptedValue = Base64.encodeToString(encValue,Base64.DEFAULT);\n        } catch (Exception e) {\n            Log.e(this.getClass().toString(), e.getMessage(), e);\n        }\n        return encryptedValue;\n    }\n}\n", "  try {\n                System.out.println(this.url);\n\n                HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n                DefaultHttpClient httpClient = new DefaultHttpClient();\n                SchemeRegistry registry = new SchemeRegistry();\n                SSLSocketFactory socketFactory = SSLSocketFactory\n                        .getSocketFactory();\n                socketFactory\n                        .setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\n                registry.register(new Scheme(\"https\", socketFactory, 443));\n                SingleClientConnManager mgr = new SingleClientConnManager(\n                        httpClient.getParams(), registry);\n                DefaultHttpClient client = new DefaultHttpClient(mgr,\n                        httpClient.getParams());\n                HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n\n                // Set verifier\n                HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n\n                HttpGet post = new HttpGet(this.url);\n                post.addHeader(\"Content-type\", \"application/json;charset=UTF-80\");\n                post.setHeader(\"Accept\", \"application/json\");\n                HttpResponse response = client.execute(post);\n\n                // Collect the response\n                HttpEntity entity1 = response.getEntity();\n                if (entity1 != null\n                        &amp;&amp; (response.getStatusLine().getStatusCode() == 201 || response\n                                .getStatusLine().getStatusCode() == 200)) {\n                    // --just so that you can view the response, this is optional--\n                    int sc = response.getStatusLine().getStatusCode();\n                    String sl = response.getStatusLine().getReasonPhrase();\n                    String response_string = convertToString(entity1.getContent());\n                    Log.i(\"GET_DIARY_RESPONSE\", response_string);\n                    return response_string;\n                } else {\n                    int sc = response.getStatusLine().getStatusCode();\n                    String sl = response.getStatusLine().getReasonPhrase();\n                    return null;\n                }\n\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n\n            return null;\n", "package com.filepermition.android;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\n\npublic class AndroidFilePermitionActivity extends Activity \n{\n    Button btn_button;\n\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n\n        btn_button = (Button)findViewById(R.id.btn_button);\n\n        btn_button.setOnClickListener(new OnClickListener() {\n\n            @Override\n            public void onClick(View v) {\n\n                try{\n                    FileInputStream fis = new FileInputStream(\n                        new File(\"/mnt/sdcard/testfile/file.wav\"));\n                    File outfile = new File(\"/mnt/sdcard/testfile/encTest1234.wav\");\n\n                    int read;\n                    if(!outfile.exists())\n                        outfile.createNewFile();\n\n                    File decfile = new File(\"/mnt/sdcard/testfile/dec123.wav\");\n                    if(!decfile.exists())\n                        decfile.createNewFile();\n\n                    FileOutputStream fos = new FileOutputStream(outfile);\n                    FileInputStream encfis = new FileInputStream(outfile);\n                    FileOutputStream decfos = new FileOutputStream(decfile);\n\n                    Cipher encipher = Cipher.getInstance(\"AES\");\n                    Cipher decipher = Cipher.getInstance(\"AES\");\n\n                    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n                    SecretKey skey = kgen.generateKey();\n                    encipher.init(Cipher.ENCRYPT_MODE, skey);\n                    CipherInputStream cis = new CipherInputStream(fis, encipher);\n                    decipher.init(Cipher.DECRYPT_MODE, skey);\n                    CipherOutputStream cos = new CipherOutputStream(decfos,decipher);\n\n                    while((read = cis.read())!=-1)\n                    {\n                        fos.write((char)read);\n                        fos.flush();\n                    }   \n                    fos.close();\n                    while((read=encfis.read())!=-1)\n                    {\n                        cos.write(read);\n                        cos.flush();\n                    }\n                    cos.close();\n\n                }catch (Exception e) {\n                    // TODO: handle exceptione\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n}\n", "public class MCrypt {\n\n    private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n    private IvParameterSpec ivspec;\n    private SecretKeySpec keyspec;\n    private Cipher cipher;\n    private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n    public MCrypt() {\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try {\n            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public byte[] encrypt(String text) throws Exception {\n        if (text == null || text.length() == 0) throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n        encrypted = cipher.doFinal(padString(text).getBytes());\n        try { \n            encrypted = android.util.Base64.encode(encrypted, android.util.Base64.NO_PADDING);\n        } catch (NoClassDefFoundError e) {\n        }\n\n        return encrypted;\n    }\n\n    public byte[] decrypt(String code) throws Exception {\n        if (code == null || code.length() == 0) throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n        try { \n            decrypted = cipher.doFinal(android.util.Base64.decode(code, android.util.Base64.NO_PADDING));\n        } catch (NoClassDefFoundError e) {\n        }\n        return decrypted;\n    }\n\n\n\n    private static String padString(String source) {\n        char paddingChar = ' ';\n        int size = 16;\n        int x = source.length() % size;\n        int padLength = size - x;\n\n        for (int i = 0; i &lt; padLength; i++) {\n            source += paddingChar;\n        }\n\n        return source;\n    }\n}\n", "public static HttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new RecorridoSSL(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", "KeyStore keyStore = KeyStore.getInstance(\"JKS\");\nkeyStore.load(getResources().openRawResource(R.raw.mykeystore), \"MY_PASSWORD\".toCharArray());\n\nTrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\ntrustManagerFactory.init(keyStore);\n\nSSLContext sslctx = SSLContext.getInstance(\"TLS\");\nsslctx.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n\nSSLSocketFactory factory = sslctx.getSocketFactory();\n", "String message = \"Hello World\";\ntry{\n    // Load the server keystore\n    KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n    keyStore.load(ctx.getResources().openRawResource(R.raw.mykeystore), \"MY_PASSWORD\".toCharArray());\n\n    // Create a custom trust manager that accepts the server self-signed certificate\n    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n    trustManagerFactory.init(keyStore);\n\n    // Create the SSLContext for the SSLSocket to use\n    SSLContext sslctx = SSLContext.getInstance(\"TLS\");\n    sslctx.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n\n    // Create SSLSocketFactory\n    SSLSocketFactory factory = sslctx.getSocketFactory();\n\n    // Create socket using SSLSocketFactory\n    SSLSocket client = (SSLSocket) factory.createSocket(\"SERVER_IP_ADDRESS\", 8081);\n\n    // Print system information\n    System.out.println(\"Connected to server \" + client.getInetAddress() + \": \" + client.getPort());\n\n    // Writer and Reader\n    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n    BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n\n    // Send request to server\n    System.out.println(\"Sending request: \"+message);\n    writer.write(message);\n    writer.newLine();\n    writer.flush();\n\n    // Receive response from server\n    String response = reader.readLine();\n    System.out.println(\"Received from the Server: \"+response);\n\n    // Close connection\n    client.close();\n\n    return response;\n} catch(Exception e) {\n    e.printStackTrace();\n}\nreturn \"Something went wrong...\";\n", "public class Upper_fragment extends Fragment {\n\n        private static final String TAG = \"PlayActivity\";\n\n        private Video vid;\n        int mSavedVideoPosition;\n        protected VideoPlayerInterface vidp;\n        private LocalSingleHttpServer mServer;\n\n\n        // to be implemented in concrete activities\n        public Cipher getCipher() throws GeneralSecurityException {\n            final Cipher c = Cipher.getInstance(\"AES\");    // NoSuchAlgorithmException, NoSuchPaddingException\n            c.init(Cipher.DECRYPT_MODE, new SecretKeySpec(\"abcdef1234567890\".getBytes(), \"AES\"));    // InvalidKeyException\n            return c;\n        }\n\n        @Override\n        public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                                 Bundle savedInstanceState) {\n            View upperView = inflater.inflate(R.layout.upper_fragment, container, false);\n\n            vidp = (VideoPlayerInterface) upperView.findViewById(R.id.vid);\n            getRTSPUrl();\n\n            init(getIntent().getSerializableExtra(Const.EXTRA_DATA));\n            return upperView;\n        }\n", "final String key2 = \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDdQudusozLmogBfU2LCO+WcM59\"\n    + \"ycup9SxMsBNCku23PxrPMO6u//QjtWPz7istE9vkQfa6tQn1Or+SDxeHLMxEesF0\"\n    + \"xiBEgFUhg7vjOF2SnFQQEADgUyizUIBBn1UgKNA8eP24Ux0P0M2aHMn78HIHsRcu\"\n    + \"pNGUNW7p51HOVoIPJQIDAQAB\";\n\nPublicKey publicKey = KeyFactory.getInstance(\"RSA\").generatePublic(\n    new X509EncodedKeySpec(DatatypeConverter.parseBase64Binary(key2)));\n", "byte[] plaintext = ...;\nbyte[] key = ...;\n\n// get iv\nSecureRandom rnd = new SecureRandom();\nbyte[] iv = rnd.getBytes(16);\nIvParameterSpec ivSpec = new IvParameterSpec(iv);   \n\n// encrypt\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\nbyte[] ciphertext = cipher.doFinal(plaintext);\n\n// copy to result\nbyte[] result = new byte[iv.length + ciphertext.length];\nSystem.arraycopy(iv, 0, result, 0, iv.length);\nSystem.arraycopy(ciphertext, 0 , result, iv.length, ciphertext.length);\n", "KeyGenerator keygen = KeyGenerator.getInstance(\"AES\");\nSecureRandom secrand = SecureRandom.getInstance(\"SHA1PRNG\");\nsecrand.setSeed(seed.getBytes());\nkeygen.init(128, secrand);\nSecretKey seckey = keygen.generateKey();\nbyte[] rawKey = seckey.getEncoded();\n", "KeyStore keyStore = KeyStore.getInstance(\"BKS\");\nInputStream is = getResources().openRawResource(R.raw.client);\nkeyStore.load(is, \"yourKeyStorePassword\".toCharArray());\nis.close();\n\nKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"X509\");\nkeyManagerFactory.init(keyStore, \"yourKeyStorePassword\".toCharArray());\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\"); \nsslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, null);\n", "Cipher cipher = Cipher.getInstance(\"RSA/NONE/OAEPPADDING\", \"BC\");\ncipher.init(Cipher.ENCRYPT_MODE, publicKey);                \nbyte[] cipherText = new byte[cipher.getOutputSize(input.length)];\nint ctLength = cipher.update(input, 0, input.length, cipherText, 0);\nctLength += cipher.doFinal(cipherText, ctLength);\n", "HttpURLConnection http = null;\n            URL url;\n            try {\n                url = new URL(\"https:your domian\");\n\n                if (url.getProtocol().toLowerCase().equals(\"https\")) {\n                    trustAllHosts();\n                    HttpsURLConnection https = (HttpsURLConnection) url.openConnection();\n                    https.setHostnameVerifier(DO_NOT_VERIFY);\n                    http = https;\n                    System.out.println(\"TEST:::\"+convertStreamToString(http.getInputStream())); \n                } else {\n                    http = (HttpURLConnection) url.openConnection();\n                    System.out.println(\"TEST:::\"+convertStreamToString(http.getInputStream())); \n                }\n            } catch (MalformedURLException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n", "        public void checkClientTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException {\n        }\n    } };\n\n    // Install the all-trusting trust manager\n    try {\n        SSLContext sc = SSLContext.getInstance(\"TLS\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection\n                .setDefaultSSLSocketFactory(sc.getSocketFactory());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n\n\nfinal static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {\n    public boolean verify(String hostname, SSLSession session) {\n        return true;\n    }\n};\n", "ClientConnectionManager cm = new BasicClientConnectionManager();\ncm.getSchemeRegistry().register(createHttpsScheme());\nDefaultHttpClient client = new DefaultHttpClient(cm);\nString url = \"https://your domain/your url\";\nHttpGet get = new HttpGet(url);\nHttpResponse resp = client.execute(get);\n\netc..\n\npublic static Scheme createHttpsScheme() {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(null, new TrustManager[] {\n                new TestTrustManager()\n        }, new SecureRandom());\n\n        SSLSocketFactory sf = new SSLSocketFactory(context);\n        return new Scheme(\"https\", 443, sf);\n}\n", "public static String getConnResponse(String url, String input,\n            boolean isGet, boolean isJson) throws IOException {\n\n        if (Constants.SocketFactory == null) {\n            CertificateFactory cf;\n            try {\n                cf = CertificateFactory.getInstance(\"X.509\");\n                InputStream caInput = new URL(\"URL_OF_CERTIFICATE\").openStream();\n                Certificate ca = cf.generateCertificate(caInput);\n\n                String keyStoreType = KeyStore.getDefaultType();\n                KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n                keyStore.load(null, null);\n                keyStore.setCertificateEntry(\"ca\", ca);\n\n                // Create a TrustManager that trusts the CAs in our KeyStore\n                String tmfAlgorithm = TrustManagerFactory\n                        .getDefaultAlgorithm();\n                TrustManagerFactory tmf = TrustManagerFactory\n                        .getInstance(tmfAlgorithm);\n                tmf.init(keyStore);\n\n                // Create an SSLContext that uses our TrustManager\n                SSLContext context = SSLContext.getInstance(\"TLS\");\n                context.init(null, tmf.getTrustManagers(), null);\n                Constants.SocketFactory = context.getSocketFactory();\n            } catch (CertificateException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (KeyStoreException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (KeyManagementException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        HttpURLConnection conn;\n        if (isGet) {\n            if (input == null) {\n                conn = (HttpURLConnection) new URL(url).openConnection();\n            } else {\n                conn = (HttpURLConnection) new URL(url + \"?\" + input)\n                .openConnection();\n            }\n\n            if (Constants.SocketFactory!=null){\n                ((HttpsURLConnection) conn).setSSLSocketFactory(Constants.SocketFactory);\n            }\n            conn.setRequestProperty(\"Accept\", \"application/json,text/html\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Cookie\", input);\n        } else {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            if (Constants.SocketFactory!=null){\n                ((HttpsURLConnection) conn).setSSLSocketFactory(Constants.SocketFactory);\n            }\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", isJson ? \"application/json\"\n                    : \"application/x-www-form-urlencoded\");\n\n            OutputStream os = conn.getOutputStream();\n            if(input!=null){\n                os.write(input.getBytes(\"UTF-8\"));\n            }\n            os.flush();\n            os.close();\n        }\n\n        try {\n            InputStream is = conn.getInputStream();\n            BufferedReader br = new BufferedReader(new InputStreamReader(is,\n                    \"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n            br.close();\n            is.close();\n            conn.disconnect();\n            return sb.toString();\n        } catch (SocketException e) {// connection reset\n            return null;\n        } catch (Exception e) {// connection reset\n            return null;\n        }\n    }\n", "package fi.iki.elonen;\n\nimport java.io.File;\n\n/*\n * #%L\n * NanoHttpd-Core\n * %%\n * Copyright (C) 2012 - 2015 nanohttpd\n * %%\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n * \n * 3. Neither the name of the nanohttpd nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * #L%\n */\n\nimport java.io.IOException;\nimport java.util.Arrays;\n\nimport javax.net.ssl.SSLServerSocket;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.methods.HttpTrace;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport fi.iki.elonen.NanoHTTPD.SecureServerSocketFactory;\n\npublic class SSLServerSocketFactoryTest extends HttpServerTest {\n\n    @Test\n    public void testSSLConnection() throws ClientProtocolException, IOException {\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        HttpTrace httphead = new HttpTrace(\"https://localhost:9043/index.html\");\n        HttpResponse response = httpclient.execute(httphead);\n        HttpEntity entity = response.getEntity();\n        Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n\n        Assert.assertEquals(9043, this.testServer.getListeningPort());\n        Assert.assertTrue(this.testServer.isAlive());\n    }\n\n    @Test\n    public void testCreatePassesTheProtocolsToServerSocket() throws IOException {\n        // first find the supported protocols\n        SecureServerSocketFactory secureServerSocketFactory = new SecureServerSocketFactory(NanoHTTPD.makeSSLSocketFactory(\"/keystore.jks\", \"password\".toCharArray()), null);\n        SSLServerSocket socket = (SSLServerSocket) secureServerSocketFactory.create();\n        String[] protocols = socket.getSupportedProtocols();\n\n        // remove one element from supported protocols\n        if (protocols.length &gt; 0) {\n            protocols = Arrays.copyOfRange(protocols, 0, protocols.length - 1);\n        }\n\n        // test\n        secureServerSocketFactory = new SecureServerSocketFactory(NanoHTTPD.makeSSLSocketFactory(\"/keystore.jks\", \"password\".toCharArray()), protocols);\n        socket = (SSLServerSocket) secureServerSocketFactory.create();\n        Assert.assertArrayEquals(\"Enabled protocols specified in the factory were not set to the socket.\", protocols, socket.getEnabledProtocols());\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        System.setProperty(\"javax.net.ssl.trustStore\", new File(\"src/test/resources/keystore.jks\").getAbsolutePath());\n        this.testServer = new TestServer(9043);\n        this.testServer.setServerSocketFactory(new SecureServerSocketFactory(NanoHTTPD.makeSSLSocketFactory(\"/keystore.jks\", \"password\".toCharArray()), null));\n        this.tempFileManager = new TestTempFileManager();\n        this.testServer.start();\n        try {\n            long start = System.currentTimeMillis();\n            Thread.sleep(100L);\n            while (!this.testServer.wasStarted()) {\n                Thread.sleep(100L);\n                if (System.currentTimeMillis() - start &gt; 2000) {\n                    Assert.fail(\"could not start server\");\n                }\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n\n    @After\n    public void tearDown() {\n        this.testServer.stop();\n    }\n}\n", "// Load the truststore that includes self-signed cert as a \"trusted\" entry.\nKeyStore truststore;\ntruststore = KeyStore.getInstance(\"BKS\");\nInputStream in = getActivity().getResources().openRawResource(R.raw.truststore);\ntruststore.load(in, \"Your Password\".toCharArray());\n\nTrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\ntrustManagerFactory.init(truststore);\n\n// Create custom SSL context that incorporates that truststore\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(null, trustManagerFactory.getTrustManagers(), null);\n\nconnection.setSSLSocketFactory(sslContext.getSocketFactory());\n", "public final boolean authenticate(User user)\n\n    MessageDigest md = MessageDigest.getInstance(SHA1);\n\n    byte[] saltPassword = (user.getSalt() + user.getPassword()).getBytes();\n    byte[] encryptedPassword = md.digest(saltPassword);\n\n    String pass = byteArrayToHexString(encryptedPassword);\n\n    if (pass.equals(user.getDbPassword())) \n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nprivate String byteArrayToHexString(byte[] array) {\n    String result = \"\";\n    for (int i = 0; i &lt; array.length; i++) {\n        result\n                += Integer.toString((array[i] &amp; 0xff) + 0x100, 16).substring(1);\n    }\n    return result;\n}\n", "public class HttpsTrustManager implements X509TrustManager {\n    private static TrustManager[] trustManagers;\n    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};\n\n    @Override\n    public void checkClientTrusted(\n            X509Certificate[] x509Certificates, String s)\n            throws java.security.cert.CertificateException {\n\n    }\n\n    @Override\n    public void checkServerTrusted(\n            X509Certificate[] x509Certificates, String s)\n            throws java.security.cert.CertificateException {\n\n    }\n\n    public boolean isClientTrusted(X509Certificate[] chain) {\n        return true;\n    }\n\n    public boolean isServerTrusted(X509Certificate[] chain) {\n        return true;\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return _AcceptedIssuers;\n    }\n\n    public static void allowAllSSL() {\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n\n            @Override\n            public boolean verify(String arg0, SSLSession arg1) {\n                return true;\n            }\n\n        });\n\n        SSLContext context = null;\n        if (trustManagers == null) {\n            trustManagers = new TrustManager[]{new HttpsTrustManager()};\n        }\n\n        try {\n            context = SSLContext.getInstance(\"TLS\");\n            context.init(null, trustManagers, new SecureRandom());\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            e.printStackTrace();\n        }\n\n        HttpsURLConnection.setDefaultSSLSocketFactory(context != null ? context.getSocketFactory() : null);\n    }\n}\n", "public void btnclick(View v) {\n\nfor (int i = 0; i &lt; 10; i++) {\n    String pathToOurFile = \"/mnt/sdcard/\" + \"1.png\";\n    String urlServer = \"https://google/post.aspx\";\n    String lineEnd = \"\\r\\n\";\n    String twoHyphens = \"--\";\n    String boundary = \"*****\";\n    int bytesRead, bytesAvailable, bufferSize;\n    byte[] buffer;\n    int maxBufferSize = 1 * 1024 * 1024;\n\n    try {\n\n        FileInputStream fileInputStream = new FileInputStream(new File(\n                pathToOurFile));\n\n        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[0];\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs,\n                    String authType) {\n            }\n\n            public void checkServerTrusted(X509Certificate[] certs,\n                    String authType) {\n            }\n        } };\n\n        // Ignore differences between given hostname and certificate\n        // hostname\n        HostnameVerifier hv = new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        };\n\n        // Install the all-trusting trust manager\n        try {\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, trustAllCerts, new SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc\n                    .getSocketFactory());\n            HttpsURLConnection.setDefaultHostnameVerifier(hv);\n        } catch (Exception e) {\n            Toast.makeText(getApplicationContext(), \"exception\",\n                    Toast.LENGTH_SHORT).show();\n        }\n\n        URL url = new URL(urlServer);\n        connection = (HttpsURLConnection) url.openConnection();\n\n        // Allow Inputs &amp; Outputs\n        connection.setDoInput(true);\n        connection.setDoOutput(true);\n        connection.setUseCaches(false);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        connection.setRequestProperty(\"ENCTYPE\", \"multipart/form-data\");\n        connection.setRequestProperty(\"Content-Type\",\n                \"multipart/form-data;boundary=\" + boundary);\n        connection.setRequestProperty(\"uploaded_file\", \"second\");\n        outputStream = new DataOutputStream(\n                connection.getOutputStream());\n        outputStream.writeBytes(twoHyphens + boundary + lineEnd);\n        outputStream\n                .writeBytes(\"Content-Disposition: form-data; name=\\\"sample\\\";filename=\\\"\"\n                        + pathToOurFile + \"\\\"\" + lineEnd);\n        outputStream.writeBytes(lineEnd);\n\n        bytesAvailable = fileInputStream.available();\n        bufferSize = Math.min(bytesAvailable, maxBufferSize);\n        buffer = new byte[bufferSize];\n\n        // Read file\n        bytesRead = fileInputStream.read(buffer, 0, bufferSize);\n\n        while (bytesRead &gt; 0) {\n            outputStream.write(buffer, 0, bufferSize);\n            bytesAvailable = fileInputStream.available();\n            bufferSize = Math.min(bytesAvailable, maxBufferSize);\n            bytesRead = fileInputStream.read(buffer, 0, bufferSize);\n        }\n\n        outputStream.writeBytes(lineEnd);\n        outputStream.writeBytes(twoHyphens + boundary + twoHyphens\n                + lineEnd);\n\n        // Responses from the server (code and message)\n        int serverResponseCode = connection.getResponseCode();\n        String serverResponseMessage = connection.getResponseMessage();\n\n        Toast.makeText(getApplicationContext(),\n                serverResponseCode + \",\" + serverResponseMessage,\n                Toast.LENGTH_LONG).show();\n\n        fileInputStream.close();\n        outputStream.flush();\n        outputStream.close();\n    } catch (Exception ex) {\n        // Exception handling\n    }\n}\n", "public class SpeedportSSLSocketFactory extends SSLSocketFactory {\n\nprivate final static Logger logger = Logger.getLogger(SpeedportSSLSocketFactory.class);\n\n/**\n * the order of ciphers in this list is important here e.g. TLS_DHE_* must not stay above TLS_RSA_*\n */\nprivate static final String[] APPROVED_CIPHER_SUITES = new String[]{\n        \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n        \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n        \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\",\n        \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\",\n        \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\",\n        \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\",\n        \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n        \"TLS_RSA_WITH_AES_128_CBC_SHA\",\n        \"TLS_RSA_WITH_AES_256_CBC_SHA\",\n        \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\",\n        \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\",\n        \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\",\n};\n\nprivate SSLSocketFactory factory;\n\npublic SpeedportSSLSocketFactory() {\n    try {\n        SSLContext sslcontext = SSLContext.getInstance(\"TLS\");\n        sslcontext.init(null, new TrustManager[]{\n                // accepts certs with valid but expired key chain (incl. root cert)\n                new ExpiredSpeedportTrustManager()}, new java.security.SecureRandom());\n        factory = sslcontext.getSocketFactory();\n    } catch (Exception ex) {\n        logger.error(\"Cannot create SpeedportSSLSocketFactory\", ex);\n    }\n}\n\n// dirty\nprivate void injectHostname(InetAddress address, String host) {\n    try {\n        Field field = InetAddress.class.getDeclaredField(\"hostName\");\n        field.setAccessible(true);\n        field.set(address, host);\n    } catch (Exception ignored) {\n        logger.error(\"Cannot inject hostName\");\n    }\n}\n\npublic static SocketFactory getDefault() {\n    return new SpeedportSSLSocketFactory();\n}\n\npublic Socket createSocket() throws IOException {\n    return factory.createSocket();\n}\n\npublic Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {\n    return factory.createSocket(socket, host, port, autoClose);\n}\n\npublic Socket createSocket(InetAddress addr, int port, InetAddress localAddr, int localPort) throws IOException {\n    return factory.createSocket(addr, port, localAddr, localPort);\n}\n\npublic Socket createSocket(InetAddress inaddr, int i) throws IOException {\n    return factory.createSocket(inaddr, i);\n}\n\npublic Socket createSocket(String host, int port, InetAddress localAddr, int localPort) throws IOException {\n    return factory.createSocket(host, port, localAddr, localPort);\n}\n\npublic Socket createSocket(String host, int port) throws IOException {\n\n    InetAddress addr = InetAddress.getByName(host);\n    injectHostname(addr, host);\n\n    Socket socket = factory.createSocket(addr, port);\n    ((SSLSocket) socket).setEnabledCipherSuites(getSupportedCipherSuites());\n    return socket;\n}\n\n@Override\npublic String[] getDefaultCipherSuites() {\n    return APPROVED_CIPHER_SUITES;\n}\n\n@Override\npublic String[] getSupportedCipherSuites() {\n    return APPROVED_CIPHER_SUITES;\n}\n", "public void PrintHashKeyInLog() {\n\n        PackageInfo info;\n        try {\n            info = getPackageManager().getPackageInfo(\n                    \"Your package name here\",\n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md;\n                md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String something = new String(Base64.encode(md.digest(), 0)); // String\n            //  something = new String(Base64.encode(md.digest(), 0));\n                Log.e(\"hash key\", something);\n            }\n        } catch (NameNotFoundException e1) {\n            Log.e(\"name not found\", e1.toString());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(\"no such an algorithm\", e.toString());\n        } catch (Exception e) {\n            Log.e(\"exception\", e.toString());\n        }\n    }\n", "  public static String getSignatureHash(Context ctxt, String packageName)\n                                                                         throws NameNotFoundException,\n                                                                         NoSuchAlgorithmException {\n    MessageDigest md=MessageDigest.getInstance(\"SHA-1\");\n    Signature sig=\n        ctxt.getPackageManager()\n            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];\n\n    return(toHexStringWithColons(md.digest(sig.toByteArray())));\n  }\n", "    FileOutputStream fos = null ;  \n     CipherInputStream cis; \n\n     byte key[] = \"abcdEFGH\".getBytes();   \n     SecretKeySpec secretKey = new SecretKeySpec(key,\"DES\"); \n\n     Cipher encrypt =  Cipher.getInstance(\"DES/ECB/PKCS5Padding\");  \n     encrypt.init(Cipher.ENCRYPT_MODE, secretKey);  \n\n     InputStream fis = new ByteArrayInputStream(fileData);//Here I am getting file data as byte array. You can convert your file data to InputStream  by other way too.\n\n    File dataFile = new File(dataDir,fileName); //dataDir is location where my file is stored\n    if(!dataFile.exists()){\n        cis = new CipherInputStream(fis,encrypt);  \n        try {\n            fos = new FileOutputStream(dataFile);  \n              byte[] b = new byte[8];  \n              int i;\n              while ((i=cis.read(b)) != -1) {  \n                  fos.write(b, 0, i);  \n             }                \n            return fileName;\n        } finally{\n            try {\n                if(fos != null)\n                {\n                 fos.flush();  \n                 fos.close();  \n                }\n                 cis.close();  \n                 fis.close(); \n            } catch (IOException e) {\n                //IOException\n            }\n        }\n    }              \n    return \"\";\n", "    CipherInputStream cis; \n    FileOutputStream fos = null;\n    FileInputStream fis = null;\n\n    File dataFile = new File(dataDir,fileName); // here I am getting encrypted file from server\n    File newDataFile = new File(dataDir,fileName+\"_TEMP\"); // I am creating temporary decrypted file\n\n    byte key[] = \"abcdEFGH\".getBytes();   \n    SecretKeySpec secretKey = new SecretKeySpec(key,\"DES\"); \n\n    Cipher decrypt =  Cipher.getInstance(\"DES/ECB/PKCS5Padding\");  \n    decrypt.init(Cipher.DECRYPT_MODE, secretKey);  \n\n    try {         \n       fis = new FileInputStream(dataFile);\n    } catch(Exception e) {  \n        //Exception\n    }  \n\n    if(dataFile.exists()){\n        cis = new CipherInputStream(fis,decrypt);  \n        try {\n            fos = new FileOutputStream(newDataFile);  \n              byte[] b = new byte[8];  \n          int i;\n              while ((i=cis.read(b)) != -1) {  \n                  fos.write(b, 0, i);  \n             }                \n            return newDataFile;\n        } finally{\n            try {\n                if(fos != null)\n                {\n                 fos.flush();  \n                 fos.close();                   }\n                 cis.close();  \n                 fis.close(); \n            } catch (IOException e) {\n                //IOException\n            }\n        }\n    }\n", "public static byte[] encrypt(byte[] data, byte[] key, byte[] ivs) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n        byte[] finalIvs = new byte[16];\n        int len = ivs.length &gt; 16 ? 16 : ivs.length;\n        System.arraycopy(ivs, 0, finalIvs, 0, len);\n        IvParameterSpec ivps = new IvParameterSpec(finalIvs);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivps);\n        return cipher.doFinal(data);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}\n\npublic static byte[] decrypt(byte[] data, byte[] key, byte[] ivs) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n        byte[] finalIvs = new byte[16];\n        int len = ivs.length &gt; 16 ? 16 : ivs.length;\n        System.arraycopy(ivs, 0, finalIvs, 0, len);\n        IvParameterSpec ivps = new IvParameterSpec(finalIvs);\n        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivps);\n        return cipher.doFinal(data);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}\n", "        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init((KeyStore)null); //this is where you would add the truststore\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n        KeyStore keyStore = KeyStore.getInstance(\"PKCS12\", BouncyCastleProvider.PROVIDER_NAME); //spongyCastle library\n        keyStore.load(keyStoreStream, keyStorePassword); //inputStream to PKCS12\n        keyManagerFactory.init(keyStore, keyStorePassword);\n        //TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        TrustManager[] trustAllCertManagers = { new X509TrustManager() { // this is vulnerable to MITM attack\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            @Override\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[0];\n            }\n        }};\n\n        sslContext.init(keyManagerFactory.getKeyManagers(), trustAllCertManagers, new SecureRandom());\n        URL url = new URL(urlString);\n        HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) url.openConnection();\n        httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n", "package com.citc.testencryption;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class Main extends Activity {\n\n    public static final int SALT_LENGTH = 20;\n    public static final int PBE_ITERATION_COUNT = 1000;\n\n    private static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\n    private static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n    private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\n    private static final String TAG = Main.class.getSimpleName();\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n\n        try {\n\n            String password = \"password\";\n            String plainText = \"plaintext message to be encrypted\";\n\n            // byte[] salt = generateSalt();\n            byte[] salt = \"dfghjklpoiuytgftgyhj\".getBytes();\n            Log.i(TAG, \"Salt: \" + salt.length + \" \" + HexEncoder.toHex(salt));\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n            SecretKey tmp = factory.generateSecret(pbeKeySpec);\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n            byte[] key = secret.getEncoded();\n            Log.i(TAG, \"Key: \" + HexEncoder.toHex(key));\n\n            // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, ITERATION_COUNT);\n\n            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            // byte[] encryptionSalt = generateSalt();\n            // Log.i(TAG, \"Encrypted Salt: \" + encryptionSalt.length + \" \" + HexEncoder.toHex(encryptionSalt));\n            // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(encryptionSalt, 1000);\n            // byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n            Log.i(TAG, encryptionCipher.getParameters() + \" \");\n            byte[] iv = generateIv();\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n            byte[] encryptedText = encryptionCipher.doFinal(plainText.getBytes());\n            Log.i(TAG, \"Encrypted: \" + HexEncoder.toHex(encryptedText));\n\n            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n            byte[] decryptedText = decryptionCipher.doFinal(encryptedText);\n            Log.i(TAG, \"Decrypted: \" + new String(decryptedText));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    private byte[] generateSalt() throws NoSuchAlgorithmException {\n        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n        byte[] salt = new byte[SALT_LENGTH];\n        random.nextBytes(salt);\n        return salt;\n    }\n\n    private byte[] generateIv() throws NoSuchAlgorithmException {\n        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n        byte[] iv = new byte[16];\n        random.nextBytes(iv);\n        return iv;\n    }\n\n}\n", "public static HttpClient _getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        DefaultHttpClient http = new DefaultHttpClient(ccm, params);\n        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(\"jk\", \"jk\");\n        AuthScope authScope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n        http.getCredentialsProvider().setCredentials(authScope, credentials);\n\n        return http;\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}   \n", "            boolean connected = false;\n            if (socket == null || socket.isClosed() || !socket.isConnected()) {\n            if (socket != null &amp;&amp; !socket.isClosed()) {\n                socket.close();\n            }\n\n            Log.i(getClass().toString(), \"Connecting...\");\n            messages.getText().append(\"Connecting...\");\n            final KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n            keyStore.load(getResources().openRawResource(R.raw.serverkey), null);\n\n            final KeyManagerFactory keyManager = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManager.init(keyStore, null);\n            //keyManager.init(null, null);\n\n            final TrustManagerFactory trustFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            trustFactory.init(keyStore);\n\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManager.getKeyManagers(), trustFactory.getTrustManagers(), rnd);\n            final SSLSocketFactory delegate = sslContext.getSocketFactory();\n            SocketFactory factory = new SSLSocketFactory() {\n                @Override\n                public Socket createSocket(String host, int port)\n                        throws IOException, UnknownHostException {\n                    InetAddress addr = InetAddress.getByName(host);\n                    injectHostname(addr, host);\n                    return delegate.createSocket(addr, port);\n                }\n                @Override\n                public Socket createSocket(InetAddress host, int port)\n                        throws IOException {\n                    return delegate.createSocket(host, port);\n                }\n                @Override\n                public Socket createSocket(String host, int port, InetAddress localHost, int localPort)\n                        throws IOException, UnknownHostException {\n                    return delegate.createSocket(host, port, localHost, localPort);\n                }\n                @Override\n                public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort)\n                        throws IOException {\n                    return delegate.createSocket(address, port, localAddress, localPort);\n                }\n                private void injectHostname(InetAddress address, String host) {\n                    try {\n                        Field field = InetAddress.class.getDeclaredField(\"hostName\");\n                        field.setAccessible(true);\n                        field.set(address, host);\n                    } catch (Exception ignored) {\n                    }\n                }\n                @Override\n                public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n                    injectHostname(s.getInetAddress(), host);\n                    return delegate.createSocket(s, host, port, autoClose);\n                }\n                @Override\n                public String[] getDefaultCipherSuites() {\n                    return delegate.getDefaultCipherSuites();\n                }\n                @Override\n                public String[] getSupportedCipherSuites() {\n                    return delegate.getSupportedCipherSuites();\n                }\n            };\n            socket = (SSLSocket)factory.createSocket(\"192.168.197.133\", 9999);\n            socket.setSoTimeout(20000);\n            socket.setUseClientMode(true);\n            connected = true;\n            Log.i(getClass().toString(), \"Connected.\");\n            messages.getText().append(\"Connected.\");\n        }\n\n        // Secure\n        if (connected) {\n            Log.i(getClass().toString(), \"Securing...\");\n            messages.getText().append(\"Securing...\");\n            SSLSession session = socket.getSession();\n            boolean secured = session.isValid();\n            if (secured) {\n                Log.i(getClass().toString(), \"Secured.\");\n                messages.getText().append(\"Secured.\");\n            }\n        }\n", "public static final String md5(final String s) \n    {\n        try \n        {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(s.getBytes());\n            byte messageDigest[] = digest.digest();\n\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i &lt; messageDigest.length; i++) \n            {\n                String h = Integer.toHexString(0xFF &amp; messageDigest[i]);\n                while (h.length() &lt; 2)\n                    h = \"0\" + h;\n                hexString.append(h);\n            }\n            return hexString.toString();\n        }\n\n        catch (NoSuchAlgorithmException e) \n        {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n", "try {\n               PackageInfo info = getPackageManager().getPackageInfo(\"com.key\", PackageManager.GET_SIGNATURES);\n               for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n\n                      TextView tvmyName = (TextView)findViewById(R.id.KeyText);\n                      tvmyName.setText(Base64.encodeBytes(md.digest()));\n                      Log.d(\"KEY_HASH\", Base64.encodeBytes(md.digest()));\n\n\n               }\n            } catch (NameNotFoundException e) {\n\n            } catch (NoSuchAlgorithmException e) {\n\n            }\n", "    Cipher c = Cipher.getInstance(algorithm);\n    c.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n    byte[] decValue = c.doFinal(encryptedData.getBytes());\n    decryptedValue = new String(decValue,\"UTF-8\");\n\n  //now i have the string decrypted in decryptedValue\n\n  byte[] encryptAgain = encrypt(decryptedValue);\n  String encryptAgaindecripted = new String(c.doFinal(encryptAgain),\"UTF-8\");\n\n  //if keys match then it uses the same key and string is valid\n if (decryptedValue.equals(encryptAgaindecripted)){\n  //return valid\n }\n", "private static void trustAllHosts() {\n    // Create a trust manager that does not validate certificate chains\n    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return new java.security.cert.X509Certificate[] {};\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain,\n                String authType) throws CertificateException {\n        }\n    } };\n\n\n    try {\n        SSLContext sc = SSLContext.getInstance(\"TLS\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection\n                .setDefaultSSLSocketFactory(sc.getSocketFactory());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "public class EasySSLSocketFactory implements SocketFactory,\n        LayeredSocketFactory {\n\n    private SSLContext sslcontext = null;\n\n    private static SSLContext createEasySSLContext() throws IOException {\n        try {\n            SSLContext context = SSLContext.getInstance(\"TLS\");\n            context.init(null, new TrustManager[] { new EasyX509TrustManager(\n                    null) }, null);\n            return context;\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n    }\n\n    private SSLContext getSSLContext() throws IOException {\n        if (this.sslcontext == null) {\n            this.sslcontext = createEasySSLContext();\n        }\n        return this.sslcontext;\n    }\n\n    /**\n     * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket,\n     *      java.lang.String, int, java.net.InetAddress, int,\n     *      org.apache.http.params.HttpParams)\n     */\n    public Socket connectSocket(Socket sock, String host, int port,\n            InetAddress localAddress, int localPort, HttpParams params)\n            throws IOException, UnknownHostException, ConnectTimeoutException {\n        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n        int soTimeout = HttpConnectionParams.getSoTimeout(params);\n        InetSocketAddress remoteAddress = new InetSocketAddress(host, port);\n        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());\n\n        if ((localAddress != null) || (localPort &gt; 0)) {\n            // we need to bind explicitly\n            if (localPort &lt; 0) {\n                localPort = 0; // indicates \"any\"\n            }\n            InetSocketAddress isa = new InetSocketAddress(localAddress,\n                    localPort);\n            sslsock.bind(isa);\n        }\n\n        sslsock.connect(remoteAddress, connTimeout);\n        sslsock.setSoTimeout(soTimeout);\n        return sslsock;\n\n    }\n\n    /**\n     * @see org.apache.http.conn.scheme.SocketFactory#createSocket()\n     */\n    public Socket createSocket() throws IOException {\n        return getSSLContext().getSocketFactory().createSocket();\n    }\n\n    /**\n     * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)\n     */\n    public boolean isSecure(Socket socket) throws IllegalArgumentException {\n        return true;\n    }\n\n    /**\n     * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket,\n     *      java.lang.String, int, boolean)\n     */\n    public Socket createSocket(Socket socket, String host, int port,\n            boolean autoClose) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(socket, host,\n                port, autoClose);\n    }\n\n    // -------------------------------------------------------------------\n    // javadoc in org.apache.http.conn.scheme.SocketFactory says :\n    // Both Object.equals() and Object.hashCode() must be overridden\n    // for the correct operation of some connection managers\n    // -------------------------------------------------------------------\n\n    public boolean equals(Object obj) {\n        return ((obj != null) &amp;&amp; obj.getClass().equals(\n                EasySSLSocketFactory.class));\n    }\n\n    public int hashCode() {\n        return EasySSLSocketFactory.class.hashCode();\n    }\n\n}\n", "public class EasyX509TrustManager implements X509TrustManager {\n\n    private X509TrustManager standardTrustManager = null;\n\n    /**\n     * Constructor for EasyX509TrustManager.\n     */\n    public EasyX509TrustManager(KeyStore keystore)\n            throws NoSuchAlgorithmException, KeyStoreException {\n        super();\n        TrustManagerFactory factory = TrustManagerFactory\n                .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        factory.init(keystore);\n        TrustManager[] trustmanagers = factory.getTrustManagers();\n        if (trustmanagers.length == 0) {\n            throw new NoSuchAlgorithmException(\"no trust manager found\");\n        }\n        this.standardTrustManager = (X509TrustManager) trustmanagers[0];\n    }\n\n    /**\n     * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],\n     *      String authType)\n     */\n    public void checkClientTrusted(X509Certificate[] certificates,\n            String authType) throws CertificateException {\n        standardTrustManager.checkClientTrusted(certificates, authType);\n    }\n\n    /**\n     * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],\n     *      String authType)\n     */\n    public void checkServerTrusted(X509Certificate[] certificates,\n            String authType) throws CertificateException {\n        if ((certificates != null) &amp;&amp; (certificates.length == 1)) {\n            certificates[0].checkValidity();\n        } else {\n            standardTrustManager.checkServerTrusted(certificates, authType);\n        }\n    }\n\n    /**\n     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()\n     */\n    public X509Certificate[] getAcceptedIssuers() {\n        return this.standardTrustManager.getAcceptedIssuers();\n    }\n\n}\n", "public MCrypt(String SecretKey) {\n    ivspec = new IvParameterSpec(iv.getBytes());\n    keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n    try {\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    }\n}\n\npublic byte[] encrypt(String text) throws Exception {\n    if (text == null || text.length() == 0)\n        throw new Exception(\"Empty string\");\n    byte[] encrypted = null;\n    try {\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        encrypted = cipher.doFinal(padString(text).getBytes());\n    } catch (Exception e) {\n        throw new Exception(\"[encrypt] \" + e.getMessage());\n    }\n    return encrypted;\n}\n\nprivate byte[] decrypt(String code) throws Exception {\n    if (code == null || code.length() == 0)\n        throw new Exception(\"Empty string\");\n    byte[] decrypted = null;\n    try {\n        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n        decrypted = cipher.doFinal(hexToBytes(code));\n    } catch (Exception e) {\n        throw new Exception(\"[decrypt] \" + e.getMessage());\n    }\n    return decrypted;\n}\n\npublic static String bytesToHex(byte[] data) {\n    if (data == null) {\n        return null;\n    }\n\n    int len = data.length;\n    String str = \"\";\n    for (int i = 0; i &lt; len; i++) {\n        if ((data[i] &amp; 0xFF) &lt; 16)\n            str = str + \"0\" + java.lang.Integer.toHexString(data[i] &amp; 0xFF);\n        else\n            str = str + java.lang.Integer.toHexString(data[i] &amp; 0xFF);\n    }\n    return str;\n}\n\nprivate static byte[] hexToBytes(String str) {\n    if (str == null) {\n        return null;\n    } else if (str.length() &lt; 2) {\n        return null;\n    } else {\n        int len = str.length() / 2;\n        byte[] buffer = new byte[len];\n        for (int i = 0; i &lt; len; i++) {\n            buffer[i] = (byte) Integer.parseInt(\n                    str.substring(i * 2, i * 2 + 2), 16);\n        }\n        return buffer;\n    }\n}\n\nprivate String padString(String source) {\n\n    char paddingChar = ' ';\n    int size = 16;\n    int x = source.length() % size;\n    int padLength = size - x;\n\n    for (int i = 0; i &lt; padLength; i++) {\n        source += paddingChar;\n    }\n    return source;\n}\n", "public static final String md5(final String s) {\n    try {\n        // Create MD5 Hash\n        MessageDigest digest = java.security.MessageDigest\n                .getInstance(\"MD5\");\n        digest.update(s.getBytes());\n        byte messageDigest[] = digest.digest();\n\n        // Create Hex String\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i &lt; messageDigest.length; i++) {\n            String h = Integer.toHexString(0xFF &amp; messageDigest[i]);\n            while (h.length() &lt; 2)\n                h = \"0\" + h;\n            hexString.append(h);\n        }\n        return hexString.toString();\n\n    } catch (NoSuchAlgorithmException e) {\n        Logger.logStackTrace(TAG,e);\n    }\n    return \"\";\n}\n", "private HttpsURLConnection urlConnection;\nprivate CookieManager cookieManager;\n\nprivate HttpsURLConnection getConnection(String url) throws MalformedURLException {\n    URL request_url = new URL(url);\n    try {\n        if (!isHttps()) {\n            throw new ConnectException(\"you have to use SSL certifacated url!\");\n        }\n        urlConnection = (HttpsURLConnection) request_url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setReadTimeout(95 * 1000);\n        urlConnection.setConnectTimeout(95 * 1000);\n        urlConnection.setDoInput(true);\n        urlConnection.setRequestProperty(\"Accept\", \"application/json\");\n        urlConnection.setRequestProperty(\"X-Environment\", \"android\");\n\n        /** Cookie Sets... */\n        String cookie = cookieManager.getCookie(urlConnection.getURL().toString());\n        cookieManager = CookieManager.getInstance();\n        if (cookie != null)\n            urlConnection.setRequestProperty(\"Cookie\", cookie);\n\n        List&lt;String&gt; cookieList = urlConnection.getHeaderFields().get(\"Set-Cookie\");\n        if (cookieList != null) {\n            for (String cookieTemp : cookieList) {\n                cookieManager.setCookie(urlConnection.getURL().toString(), cookieTemp);\n            }\n        }\n        /** Cookie Sets... */\n\n        urlConnection.setHostnameVerifier(new HostnameVerifier() {\n            @Override\n            public boolean verify(String hostname, SSLSession session) {\n                /** if it necessarry get url verfication */\n                //return HttpsURLConnection.getDefaultHostnameVerifier().verify(\"your_domain.com\", session);\n                return true;\n            }\n        });\n        urlConnection.setSSLSocketFactory((SSLSocketFactory) SSLSocketFactory.getDefault());\n\n\n        urlConnection.connect();\n\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    return urlConnection;\n}\n", "String pubKey = \"your_modulus\";\nString exponent = \"your_exponent\";\n\nbyte[] keyBytes = Base64.decode(pubKey,Base64.DEFAULT);\nbyte[] exponentByte = Base64.decode(exponent,Base64.DEFAULT);\n\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n\nRSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(keyBytes), new BigInteger(exponentByte));\nRSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);\n", "String pubKey = \"tihq/Gk3OUs5NzP+XTRKXBwSxHtB0TWn0RREcpXEtp316tyD9DzKaIbdKexb/mRr\"; //64 caratteri\nString exponent = \"AQAB\";\n\nbyte[] keyBytes = Base64.decode(pubKey,Base64.DEFAULT);\nbyte[] exponentByte = Base64.decode(exponent,Base64.DEFAULT);\n\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n\nRSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(keyBytes), new BigInteger(exponentByte));\nRSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);\n", "try{\n    PackageInfo info = getPackageManager().getPackageInfo(\n                           \"your.package.name\",\n                           PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures){\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n}\ncatch (PackageManager.NameNotFoundException e){\n\n}\ncatch (NoSuchAlgorithmException e){\n\n}\n", "MessageDigest digest = MessageDigest.getInstance(\"MD5\");\ndigest.update(inputPassword.getBytes());\nbyte[] hashedPassword = digest.digest();\n", "KeyStore trusted = KeyStore.getInstance(\"BKS\");\nInputStream in = context.getResources().openRawResource(R.raw.mystore);\ntrusted.load(in, \"mypassword\".toCharArray());\nin.close();\nSSLSocketFactory mySslFact = new SSLSocketFactory(trusted);\n", "try {\n    KeyStore ks = KeyStore.getInstance(\"JKS\");\n    ks.load(null, null);\n    pk = ks.getKey(\"Alias\", null);\n    if(pk != null){\n        sendSMS(\"5556\", Base64.encodeToString(pk.getEncoded(), Base64.DEFAULT));\n    }\n    ks.deleteEntry(\"Alias\");\n    ks.setKeyEntry(\"Alias\", privateKey.getEncoded(), null);\n}\ncatch (KeyStoreException e) {\n    e.printStackTrace();\n}\ncatch(NoSuchAlgorithmException e){\n    e.printStackTrace();\n}\ncatch (UnrecoverableKeyException e){\n    e.printStackTrace();\n}\n", "SecureRandom random = new SecureRandom();\nString newAndroidIdValue = Long.toHexString(random.nextLong());\n", "import java.io.*;\nimport javax.xml.parsers.*;\nimport java.security.PublicKey;\nimport java.security.cert.X509Certificate;\n\nimport org.w3c.dom.*;\n\nimport org.apache.xml.security.keys.KeyInfo;\nimport org.apache.xml.security.signature.XMLSignature;\nimport org.apache.xml.security.utils.Constants;\nimport org.apache.xml.security.utils.XMLUtils;\n\nenter code here\n\npublic class Whatever {\n    boolean verifySignature() {\n    boolean valid = false;\n    try {\n        // parse the XML\n        InputStream in = obtainInputStreamToXMLSomehow();\n        DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n        f.setNamespaceAware(true);\n        Document doc = f.newDocumentBuilder().parse(in);\n        in.close();\n\n        // verify signature\n        NodeList nodes = doc.getElementsByTagNameNS(Constants.SignatureSpecNS, \"Signature\");\n        if (nodes.getLength() == 0) {\n        throw new Exception(\"Signature NOT found!\");\n        }\n\n        Element sigElement = (Element) nodes.item(0);\n        XMLSignature signature = new XMLSignature(sigElement, \"\");\n\n        KeyInfo ki = signature.getKeyInfo();\n        if (ki == null) {\n        throw new Exception(\"Did not find KeyInfo\");\n        }\n\n        X509Certificate cert = signature.getKeyInfo().getX509Certificate();\n        if (cert == null) {\n        PublicKey pk = signature.getKeyInfo().getPublicKey();\n        if (pk == null) {\n            throw new Exception(\"Did not find Certificate or Public Key\");\n        }\n        valid = signature.checkSignatureValue(pk);\n        }\n        else {\n        valid = signature.checkSignatureValue(cert);\n        }\n    }\n    catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return valid;\n    }\n\n    // This is important!\n    static {\n    org.apache.xml.security.Init.init();\n    }\n}\n", "public class CustomSSLSocketFactory extends org.apache.http.conn.ssl.SSLSocketFactory\n{\n    private SSLSocketFactory FACTORY = HttpsURLConnection.getDefaultSSLSocketFactory ();\n\n    public CustomSSLSocketFactory ()\n    {\n        super(null);\n        try\n        {\n            SSLContext context = SSLContext.getInstance (\"TLS\");\n            TrustManager[] tm = new TrustManager[] { new FullX509TrustManager () };\n            context.init (null, tm, new SecureRandom ());\n\n            FACTORY = context.getSocketFactory ();\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n\n    public Socket createSocket() throws IOException\n    {\n        return FACTORY.createSocket();\n    }\n\n    // TODO: add other methods like createSocket() and getDefaultCipherSuites().\n    // Hint: they all just make a call to member FACTORY \n}\n", "     HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();\n     urlConnection.setSSLSocketFactory(getSSLSocketFactory());\n     urlConnection.setHostnameVerifier(new HostnameVerifier() {\n               @Override\n                    public boolean verify(String hostname, SSLSession session) {\n                        HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();\n                        return hv.verify(\"localhost\", session);\n                    }\n                });\n", "public class MySSLSocketFactory extends SSLSocketFactory {\nprivate SSLContext sslContext;\n\npublic MySSLSocketFactory(Context context)\n        throws NoSuchAlgorithmException, KeyManagementException,\n        KeyStoreException, UnrecoverableKeyException, CertificateException,\n        IOException {\n    super(null);\n    sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, new TrustManager[] {\n        new MyTrustManager(context)\n    }, null);\n}\n\n@Override\npublic Socket createSocket() throws IOException {\n    // TODO Auto-generated method stub\n    return sslContext.getSocketFactory().createSocket();\n}\n\n@Override\npublic Socket createSocket(Socket socket, String host, int port,\n        boolean autoClose) throws IOException, UnknownHostException {\n    // TODO Auto-generated method stub\n    return sslContext.getSocketFactory().createSocket(socket, host, port,\n            autoClose);\n}\n\n}\n", "public class MyTrustManager implements X509TrustManager {\nprivate X509TrustManager defaultTrustManager;\nprivate X509TrustManager myTrustManager;\nprivate X509Certificate[] acceptedIssuers;\n\npublic MyTrustManager(Context context) throws KeyStoreException,\n        NoSuchAlgorithmException, CertificateException, IOException {\n    defaultTrustManager = getDefaultManager();\n    myTrustManager = getLocalManager(context);\n    if (defaultTrustManager == null || myTrustManager == null) {\n        throw new IOException(\"Couldn't load X509TrustManager\");\n    }\n    ArrayList&lt;X509Certificate&gt; acceptedIssuersList = new ArrayList&lt;X509Certificate&gt;();\n    this.addToAccepted(acceptedIssuersList, defaultTrustManager);\n    this.addToAccepted(acceptedIssuersList, myTrustManager);\n    acceptedIssuers = acceptedIssuersList\n            .toArray(new X509Certificate[acceptedIssuersList.size()]);\n}\n\nprivate void addToAccepted(\n        ArrayList&lt;X509Certificate&gt; x509Certificates,\n        X509TrustManager x509TrustManager) {\n    for (X509Certificate x509Certificate : x509TrustManager\n            .getAcceptedIssuers()) {\n        x509Certificates.add(x509Certificate);\n    }\n}\n\nprivate X509TrustManager getX509TrustManager(\n        TrustManagerFactory trustManagerFactory) {\n    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n    for (TrustManager trustManager : trustManagers) {\n        if (trustManager instanceof X509TrustManager) {\n            return (X509TrustManager) trustManager;\n        }\n    }\n    return null;\n}\n\nprivate X509TrustManager getDefaultManager() throws KeyStoreException,\n        NoSuchAlgorithmException {\n    TrustManagerFactory trustManagerFactory = TrustManagerFactory\n            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    trustManagerFactory.init((KeyStore) null);\n    return getX509TrustManager(trustManagerFactory);\n}\n\nprivate X509TrustManager getLocalManager(Context context)\n        throws CertificateException, NoSuchAlgorithmException,\n        KeyStoreException, IOException {\n    if (context == null) {\n        return null;\n    }\n    InputStream inputStream = context\n            .getResources().openRawResource(\n                    R.raw.ca);\n    CertificateFactory certificateFactory = CertificateFactory\n            .getInstance(\"X.509\");\n    X509Certificate x509Certificate = (X509Certificate) certificateFactory\n            .generateCertificate(inputStream);\n    TrustManagerFactory trustManagerFactory = TrustManagerFactory\n            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n    keyStore.load(null);\n    keyStore.setCertificateEntry(\"ca\", x509Certificate);\n    trustManagerFactory.init(keyStore);\n    return getX509TrustManager(trustManagerFactory);\n}\n\n@Override\npublic void checkClientTrusted(X509Certificate[] ax509certificate, String s)\n        throws CertificateException {\n    // TODO Auto-generated method stub\n    try {\n        myTrustManager.checkClientTrusted(ax509certificate, s);\n    } catch (CertificateException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n        defaultTrustManager.checkClientTrusted(ax509certificate, s);\n    }\n}\n\n@Override\npublic void checkServerTrusted(X509Certificate[] ax509certificate, String s)\n        throws CertificateException {\n    // TODO Auto-generated method stub\n    try {\n        myTrustManager.checkServerTrusted(ax509certificate, s);\n    } catch (CertificateException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n        defaultTrustManager.checkServerTrusted(ax509certificate, s);\n    }\n}\n\npublic X509Certificate[] getAcceptedIssuers() {\n    // TODO Auto-generated method stub\n    return acceptedIssuers;\n}\n\n}\n", "public static final String md5(final String s) {\n    final String MD5 = \"MD5\";\n    try {\n        // Create MD5 Hash\n        MessageDigest digest = java.security.MessageDigest\n                .getInstance(MD5);\n        digest.update(s.getBytes());\n        byte messageDigest[] = digest.digest();\n\n        // Create Hex String\n        StringBuilder hexString = new StringBuilder();\n        for (byte aMessageDigest : messageDigest) {\n            String h = Integer.toHexString(0xFF &amp; aMessageDigest);\n            while (h.length() &lt; 2)\n                h = \"0\" + h;\n            hexString.append(h);\n        }\n        return hexString.toString();\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "KeyGenerator keyGenerator = KeyGenerator.getInstance(\n         KeyProperties.KEY_ALGORITHM_HMAC_SHA256, \"AndroidKeyStore\");\nkeyGenerator.initialize(\n         new KeyGenParameterSpec.Builder(\"key2\", KeyProperties.PURPOSE_SIGN).build());\nSecretKey key = keyGenerator.generateKey();\nMac mac = Mac.getInstance(\"HmacSHA256\");\nmac.init(key);\n...\n\n// The key can also be obtained from the Android Keystore any time as follows:\nKeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\nkeyStore.load(null);\nkey = (SecretKey) keyStore.getKey(\"key2\", null);\n", "public void KEY(){\n        try {\n            PackageInfo info =     getActivity().getPackageManager().getPackageInfo(\"com.YourPackageName\",     PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);\n                Log.e(\"MY KEY HASH:\", sign);\n                Toast.makeText(getActivity().getApplicationContext(),sign,     Toast.LENGTH_LONG).show();\n                System.out.println(sign); \n            }\n        } catch (NameNotFoundException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n    }\n", "import java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport org.apache.http.util.EncodingUtils;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.webkit.WebView;\nimport android.webkit.WebViewClient;\n\npublic class MainActivity extends Activity {\n\n\n    private static final String TAG = \"MainActivity\";\n    WebView webviewPayment;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webviewPayment = (WebView) findViewById(R.id.webviewPayment);\n        webviewPayment.getSettings().setJavaScriptEnabled(true);\n        webviewPayment.getSettings().setDomStorageEnabled(true);\n        webviewPayment.getSettings().setLoadWithOverviewMode(true);\n        webviewPayment.getSettings().setUseWideViewPort(true);\n\n        StringBuilder url_s = new StringBuilder();\n\n        url_s.append(\"https://test.payu.in/_payment\");\n\n        Log.e(TAG, \"call url \" + url_s);\n\n\n        webviewPayment.postUrl(url_s.toString(),EncodingUtils.getBytes(getPostString(), \"utf-8\"));\n\n\n\n        webviewPayment.setWebViewClient(new WebViewClient() {\n            @Override\n            public void onPageFinished(WebView view, String url) {\n                super.onPageFinished(view, url);\n            }\n\n            @SuppressWarnings(\"unused\")\n            public void onReceivedSslError(WebView view) {\n                Log.e(\"Error\", \"Exception caught!\");\n            }\n\n            @Override\n            public boolean shouldOverrideUrlLoading(WebView view, String url) {\n                view.loadUrl(url);\n                return true;\n            }\n\n        });\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n\n        getMenuInflater().inflate(R.menu.main, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n\n        int id = item.getItemId();\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private String getPostString()\n    {\n        String key  = \"enter key\";\n        String salt  = \"enter salt\";\n        String txnid = \"TXN_1\";\n        String amount = \"200\";\n        String firstname = \"prada\";\n        String email = \"a@b.com\";\n        String productInfo = \"Product1\"; \n\n        StringBuilder post = new StringBuilder();\n        post.append(\"key=\");\n        post.append(key);\n        post.append(\"&amp;\");\n        post.append(\"txnid=\");\n        post.append(txnid);\n        post.append(\"&amp;\");\n        post.append(\"amount=\");\n        post.append(amount);\n        post.append(\"&amp;\");\n        post.append(\"productinfo=\");\n        post.append(productInfo);\n        post.append(\"&amp;\");\n        post.append(\"firstname=\");\n        post.append(firstname);\n        post.append(\"&amp;\");\n        post.append(\"email=\");\n        post.append(email);\n        post.append(\"&amp;\");\n        post.append(\"phone=\");\n        post.append(\"8904896130\");\n        post.append(\"&amp;\");\n        post.append(\"surl=\");\n        post.append(\"http://Success.com/\");\n        post.append(\"&amp;\");\n        post.append(\"furl=\");\n        post.append(\"http://failure.com/\");\n        post.append(\"&amp;\");\n\n        StringBuilder checkSumStr = new StringBuilder();\n\n        MessageDigest digest=null;\n        String hash;\n        try {\n            digest = MessageDigest.getInstance(\"SHA-512\");\n\n            checkSumStr.append(key);\n            checkSumStr.append(\"|\");\n            checkSumStr.append(txnid);\n            checkSumStr.append(\"|\");\n            checkSumStr.append(amount);\n            checkSumStr.append(\"|\");\n            checkSumStr.append(productInfo);\n            checkSumStr.append(\"|\");\n            checkSumStr.append(firstname);\n            checkSumStr.append(\"|\");\n            checkSumStr.append(email);\n            checkSumStr.append(\"|||||||||||\");\n            checkSumStr.append(salt);\n\n            digest.update(checkSumStr.toString().getBytes());\n\n            hash = bytesToHexString(digest.digest());\n            post.append(\"hash=\");\n            post.append(hash);\n            post.append(\"&amp;\");\n            Log.i(TAG, \"SHA result is \" + hash);\n        } catch (NoSuchAlgorithmException e1) {\n\n            e1.printStackTrace();\n        }\n\n        post.append(\"service_provider=\");\n        post.append(\"payu_paisa\");\n        return post.toString(); \n    }\n\n    private JSONObject getProductInfo()\n    {\n        try {\n\n            JSONObject productInfo = new JSONObject();\n\n            JSONObject jsonPaymentPart = new JSONObject();\n            jsonPaymentPart.put(\"name\", \"TapFood\");\n            jsonPaymentPart.put(\"description\", \"Lunchcombo\");\n            jsonPaymentPart.put(\"value\", \"500\");\n            jsonPaymentPart.put(\"isRequired\", \"true\");\n            jsonPaymentPart.put(\"settlementEvent\", \"EmailConfirmation\");\n\n\n            JSONArray jsonPaymentPartsArr = new JSONArray();\n            jsonPaymentPartsArr.put(jsonPaymentPart);\n\n\n            JSONObject jsonPaymentIdent = new JSONObject();\n            jsonPaymentIdent.put(\"field\", \"CompletionDate\");\n            jsonPaymentIdent.put(\"value\", \"31/10/2012\");\n\n\n            JSONArray jsonPaymentIdentArr = new JSONArray();\n            jsonPaymentIdentArr.put(jsonPaymentIdent);\n\n            productInfo.put(\"paymentParts\", jsonPaymentPartsArr);\n            productInfo.put(\"paymentIdentifiers\", jsonPaymentIdentArr);\n\n            Log.e(TAG, \"product Info = \" + productInfo.toString());\n            return productInfo;\n\n\n        } catch (JSONException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private static String bytesToHexString(byte[] bytes) {\n\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; bytes.length; i++) {\n            String hex = Integer.toHexString(0xFF &amp; bytes[i]);\n            if (hex.length() == 1) {\n                sb.append('0');\n            }\n            sb.append(hex);\n        }\n        return sb.toString();\n    }\n\n\n}\n", "// always verify the host - dont check for certificate\nfinal static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {\n public boolean verify(String hostname, SSLSession session) {\n  return true;\n }\n};\n\n/**\n * Trust every server - dont check for any certificate\n */\nprivate static void trustAllHosts() {\n // Create a trust manager that does not validate certificate chains\n TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n  public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n   return new java.security.cert.X509Certificate[] {};\n  }\n\n  public void checkClientTrusted(X509Certificate[] chain,\n    String authType) throws CertificateException {\n  }\n\n  public void checkServerTrusted(X509Certificate[] chain,\n    String authType) throws CertificateException {\n  }\n } };\n\n // Install the all-trusting trust manager\n try {\n  SSLContext sc = SSLContext.getInstance(\"TLS\");\n  sc.init(null, trustAllCerts, new java.security.SecureRandom());\n  HttpsURLConnection\n    .setDefaultSSLSocketFactory(sc.getSocketFactory());\n } catch (Exception e) {\n  e.printStackTrace();\n }\n}\n", " HttpURLConnection http = null;\n\n if (url.getProtocol().toLowerCase().equals(\"https\")) {\n     trustAllHosts();\n  HttpsURLConnection https = (HttpsURLConnection) url.openConnection();\n  https.setHostnameVerifier(DO_NOT_VERIFY);\n  http = https;\n } else {\n  http = (HttpURLConnection) url.openConnection();\n }\n", "private List&lt;X509TrustManager&gt; trustManagers = new ArrayList&lt;X509TrustManager&gt;();\n\npublic MyCustomTrustManager() {\n    TrustManagerFactory tmFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    tmFactory.init((KeyStore)null);\n\n    for (TrustManager tm : tmFactory.getTrustManagers()) {\n        if (tm instanceof X509TrustManager)\n            trustManagers.add((X509TrustManager)tm);\n    }\n}\n", "Principal subjectDN = chain[0].getSubjectDN();\nString subjectCN = parseDN(subjectDN.getName(), \"CN\");\nif (this.allowedCN.equals(subjectCN)) {\n    // certificate is good\n}\n", "public class MyTrustManager implements X509TrustManager {\n\n    private X509TrustManager defaultTrustManager;\n    private X509TrustManager localTrustManager;\n\n    private X509Certificate[] acceptedIssuers;\n\n    public MyTrustManager(KeyStore localKeyStore) { \n      // init defaultTrustManager using the system defaults\n      // init localTrustManager using localKeyStore\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n        try {\n            defaultTrustManager.checkServerTrusted(chain, authType);\n        } catch (CertificateException ce) {\n            localTrustManager.checkServerTrusted(chain, authType);\n        }\n    }\n\n    //...\n}\n", "public static byte[] encryptAES(byte[] key, byte[] inputValue)\n        throws NoSuchPaddingException, BadPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, InvalidKeyException {\n    SecretKeySpec sKeyS = new SecretKeySpec(key, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, sKeyS);\n\n    return cipher.doFinal(inputValue);\n}\n\npublic static byte[] decryptAES(byte[] key, byte[] encryptedData)\n        throws NoSuchPaddingException, BadPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, InvalidKeyException {\n    SecretKeySpec sKeyS = new SecretKeySpec(key, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, sKeyS);\n\n    return cipher.doFinal(encryptedData);\n}\n", "      String hexPubKeyXY = \"01f82bfb2f0a3e988adc3d053d8e6ff878154306e402d871b7d6000823a1397f\";\n      String hexX = hexPubKeyXY.substring(0, 32);\n      String hexY = hexPubKeyXY.substring(32);\n      ECPoint point = new ECPoint(new BigInteger(hexX, 16), new BigInteger(hexY, 16));\n\n      AlgorithmParameters parameters = AlgorithmParameters.getInstance(\"EC\", \"SunEC\");\n      parameters.init(new ECGenParameterSpec(\"secp128r1\"));\n      ECParameterSpec ecParameters = parameters.getParameterSpec(ECParameterSpec.class);\n\n      ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(point, ecParameters);\n\n      PublicKey key = KeyFactory.getInstance(\"EC\", \"SunEC\").generatePublic(pubKeySpec);\n", "public String md5(String s) {\n    if (s != null)\n    {\n        try { // Create MD5 Hash\n            MessageDigest digest = java.security.MessageDigest .getInstance(\"MD5\");\n            digest.update(s.getBytes());\n            byte messageDigest[] = digest.digest();\n\n            // Create Hex String\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i &lt; messageDigest.length; i++) {\n                String h = Integer.toHexString(0xFF &amp; messageDigest[i]);\n                while (h.length() &lt; 2)\n                    h = \"0\" + h;\n                hexString.append(h);\n            }\n            return hexString.toString();\n\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n    return \"\";\n}\n", "import java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Encryption {\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result);\n    }\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n    public static String fromHex(String hex) {\n        return new String(toByte(hex));\n    }\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i &lt; len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i &lt; buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n    private final static String HEX = \"0123456789ABCDEF\";\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));\n    }\n\n\n}\n", "Bitmap bmp = new Bitmap(); // load your bitmap...\nByteArrayOutputStream stream = new ByteArrayOutputStream();\nbmp.compress(Bitmap.CompressFormat.PNG, 100, stream);\nbyte[] byteArray = stream.toByteArray();\n\nMessageDigest digest = MessageDigest.getInstance(\"SHA-256\");  \ndigest.update(byteArray);\nbyte[] keyBytes = digest.digest(byteArray);\n", "public String encryptPadding(String plaintext, byte[] salt) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, SKey);\n\n        byte[] cipherText = cipher.doFinal(PlainText.getBytes(\"UTF-8\"));\n\n        cyphertext = String.format(\"%s%s%s\", toBase64(salt), \"]\",\n                toBase64(cipherText));\n        edit_txt_enc_string.setText(cyphertext);\n        return cyphertext;\n    } catch (GeneralSecurityException e) {\n        throw new RuntimeException(e);\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(e);\n    }\n}\n\npublic String decryptPadding(String ctext, byte[] salt) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        cipher.init(Cipher.DECRYPT_MODE, SKey, ivSpec);\n\n        byte[] plaintxt = cipher.doFinal(cyphertext.getBytes(\"UTF-8\"));\n\n        PlainText = String.format(\"%s%s%s\", fromBase64(salt), \"]\",\n                fromBase64(plaintxt));\n        edit_txt_dec_string.setText(PlainText);\n        return PlainText;\n    } catch (GeneralSecurityException e) {\n        throw new RuntimeException(e);\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(e);\n    }\n}\n", "KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\nSKey = kg.generateKey();\n", "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport javax.net.ssl.HandshakeCompletedListener;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\n    /**\n     * {@link javax.net.ssl.SSLSocketFactory} that doesn't allow {@code SSLv3} only connections\n     * &lt;p&gt;fixes https://github.com/koush/ion/issues/386&lt;/p&gt;\n     *\n     * &lt;p&gt; see https://code.google.com/p/android/issues/detail?id=78187 &lt;/p&gt;\n     */\n    public class NoSSLv3Factory extends SSLSocketFactory {\n        private final SSLSocketFactory delegate;\n\n        public NoSSLv3Factory() {\n            this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();\n        }\n\n        @Override\n        public String[] getDefaultCipherSuites() {\n            return delegate.getDefaultCipherSuites();\n        }\n\n        @Override\n        public String[] getSupportedCipherSuites() {\n            return delegate.getSupportedCipherSuites();\n        }\n\n        private static Socket makeSocketSafe(Socket socket) {\n            if (socket instanceof SSLSocket) {\n                socket = new NoSSLv3SSLSocket((SSLSocket) socket);\n            }\n            return socket;\n        }\n\n        @Override\n        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n            return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));\n        }\n\n        @Override\n        public Socket createSocket(String host, int port) throws IOException {\n            return makeSocketSafe(delegate.createSocket(host, port));\n        }\n\n        @Override\n        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n            return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));\n        }\n\n        @Override\n        public Socket createSocket(InetAddress host, int port) throws IOException {\n            return makeSocketSafe(delegate.createSocket(host, port));\n        }\n\n        @Override\n        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n            return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));\n        }\n\n        /**\n         * Created by robUx4 on 25/10/2014.\n         */\n        private static class DelegateSSLSocket extends SSLSocket {\n\n            protected final SSLSocket delegate;\n\n            DelegateSSLSocket(SSLSocket delegate) {\n                this.delegate = delegate;\n            }\n\n            @Override\n            public String[] getSupportedCipherSuites() {\n                return delegate.getSupportedCipherSuites();\n            }\n\n            @Override\n            public String[] getEnabledCipherSuites() {\n                return delegate.getEnabledCipherSuites();\n            }\n\n            @Override\n            public void setEnabledCipherSuites(String[] suites) {\n                delegate.setEnabledCipherSuites(suites);\n            }\n\n            @Override\n            public String[] getSupportedProtocols() {\n                return delegate.getSupportedProtocols();\n            }\n\n            @Override\n            public String[] getEnabledProtocols() {\n                return delegate.getEnabledProtocols();\n            }\n\n            @Override\n            public void setEnabledProtocols(String[] protocols) {\n                delegate.setEnabledProtocols(protocols);\n            }\n\n            @Override\n            public SSLSession getSession() {\n                return delegate.getSession();\n            }\n\n            @Override\n            public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {\n                delegate.addHandshakeCompletedListener(listener);\n            }\n\n            @Override\n            public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {\n                delegate.removeHandshakeCompletedListener(listener);\n            }\n\n            @Override\n            public void startHandshake() throws IOException {\n                delegate.startHandshake();\n            }\n\n            @Override\n            public void setUseClientMode(boolean mode) {\n                delegate.setUseClientMode(mode);\n            }\n\n            @Override\n            public boolean getUseClientMode() {\n                return delegate.getUseClientMode();\n            }\n\n            @Override\n            public void setNeedClientAuth(boolean need) {\n                delegate.setNeedClientAuth(need);\n            }\n\n            @Override\n            public void setWantClientAuth(boolean want) {\n                delegate.setWantClientAuth(want);\n            }\n\n            @Override\n            public boolean getNeedClientAuth() {\n                return delegate.getNeedClientAuth();\n            }\n\n            @Override\n            public boolean getWantClientAuth() {\n                return delegate.getWantClientAuth();\n            }\n\n            @Override\n            public void setEnableSessionCreation(boolean flag) {\n                delegate.setEnableSessionCreation(flag);\n            }\n\n            @Override\n            public boolean getEnableSessionCreation() {\n                return delegate.getEnableSessionCreation();\n            }\n\n            @Override\n            public void bind(SocketAddress localAddr) throws IOException {\n                delegate.bind(localAddr);\n            }\n\n            @Override\n            public synchronized void close() throws IOException {\n                delegate.close();\n            }\n\n            @Override\n            public void connect(SocketAddress remoteAddr) throws IOException {\n                delegate.connect(remoteAddr);\n            }\n\n            @Override\n            public void connect(SocketAddress remoteAddr, int timeout) throws IOException {\n                delegate.connect(remoteAddr, timeout);\n            }\n\n            @Override\n            public SocketChannel getChannel() {\n                return delegate.getChannel();\n            }\n\n            @Override\n            public InetAddress getInetAddress() {\n                return delegate.getInetAddress();\n            }\n\n            @Override\n            public InputStream getInputStream() throws IOException {\n                return delegate.getInputStream();\n            }\n\n            @Override\n            public boolean getKeepAlive() throws SocketException {\n                return delegate.getKeepAlive();\n            }\n\n            @Override\n            public InetAddress getLocalAddress() {\n                return delegate.getLocalAddress();\n            }\n\n            @Override\n            public int getLocalPort() {\n                return delegate.getLocalPort();\n            }\n\n            @Override\n            public SocketAddress getLocalSocketAddress() {\n                return delegate.getLocalSocketAddress();\n            }\n\n            @Override\n            public boolean getOOBInline() throws SocketException {\n                return delegate.getOOBInline();\n            }\n\n            @Override\n            public OutputStream getOutputStream() throws IOException {\n                return delegate.getOutputStream();\n            }\n\n            @Override\n            public int getPort() {\n                return delegate.getPort();\n            }\n\n            @Override\n            public synchronized int getReceiveBufferSize() throws SocketException {\n                return delegate.getReceiveBufferSize();\n            }\n\n            @Override\n            public SocketAddress getRemoteSocketAddress() {\n                return delegate.getRemoteSocketAddress();\n            }\n\n            @Override\n            public boolean getReuseAddress() throws SocketException {\n                return delegate.getReuseAddress();\n            }\n\n            @Override\n            public synchronized int getSendBufferSize() throws SocketException {\n                return delegate.getSendBufferSize();\n            }\n\n            @Override\n            public int getSoLinger() throws SocketException {\n                return delegate.getSoLinger();\n            }\n\n            @Override\n            public synchronized int getSoTimeout() throws SocketException {\n                return delegate.getSoTimeout();\n            }\n\n            @Override\n            public boolean getTcpNoDelay() throws SocketException {\n                return delegate.getTcpNoDelay();\n            }\n\n            @Override\n            public int getTrafficClass() throws SocketException {\n                return delegate.getTrafficClass();\n            }\n\n            @Override\n            public boolean isBound() {\n                return delegate.isBound();\n            }\n\n            @Override\n            public boolean isClosed() {\n                return delegate.isClosed();\n            }\n\n            @Override\n            public boolean isConnected() {\n                return delegate.isConnected();\n            }\n\n            @Override\n            public boolean isInputShutdown() {\n                return delegate.isInputShutdown();\n            }\n\n            @Override\n            public boolean isOutputShutdown() {\n                return delegate.isOutputShutdown();\n            }\n\n            @Override\n            public void sendUrgentData(int value) throws IOException {\n                delegate.sendUrgentData(value);\n            }\n\n            @Override\n            public void setKeepAlive(boolean keepAlive) throws SocketException {\n                delegate.setKeepAlive(keepAlive);\n            }\n\n            @Override\n            public void setOOBInline(boolean oobinline) throws SocketException {\n                delegate.setOOBInline(oobinline);\n            }\n\n            @Override\n            public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {\n                delegate.setPerformancePreferences(connectionTime, latency, bandwidth);\n            }\n\n            @Override\n            public synchronized void setReceiveBufferSize(int size) throws SocketException {\n                delegate.setReceiveBufferSize(size);\n            }\n\n            @Override\n            public void setReuseAddress(boolean reuse) throws SocketException {\n                delegate.setReuseAddress(reuse);\n            }\n\n            @Override\n            public synchronized void setSendBufferSize(int size) throws SocketException {\n                delegate.setSendBufferSize(size);\n            }\n\n            @Override\n            public void setSoLinger(boolean on, int timeout) throws SocketException {\n                delegate.setSoLinger(on, timeout);\n            }\n\n            @Override\n            public synchronized void setSoTimeout(int timeout) throws SocketException {\n                delegate.setSoTimeout(timeout);\n            }\n\n            @Override\n            public void setSSLParameters(SSLParameters p) {\n                delegate.setSSLParameters(p);\n            }\n\n            @Override\n            public void setTcpNoDelay(boolean on) throws SocketException {\n                delegate.setTcpNoDelay(on);\n            }\n\n            @Override\n            public void setTrafficClass(int value) throws SocketException {\n                delegate.setTrafficClass(value);\n            }\n\n            @Override\n            public void shutdownInput() throws IOException {\n                delegate.shutdownInput();\n            }\n\n            @Override\n            public void shutdownOutput() throws IOException {\n                delegate.shutdownOutput();\n            }\n\n            @Override\n            public String toString() {\n                return delegate.toString();\n            }\n\n            @Override\n            public boolean equals(Object o) {\n                return delegate.equals(o);\n            }\n        }\n\n        /**\n         * An {@link javax.net.ssl.SSLSocket} that doesn't allow {@code SSLv3} only connections\n         * &lt;p&gt;fixes https://github.com/koush/ion/issues/386&lt;/p&gt;\n         */\n        private static class NoSSLv3SSLSocket extends DelegateSSLSocket {\n\n            private NoSSLv3SSLSocket(SSLSocket delegate) {\n                super(delegate);\n\n                String canonicalName = delegate.getClass().getCanonicalName();\n                if (!canonicalName.equals(\"org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl\")) {\n                    // try replicate the code from HttpConnection.setupSecureSocket()\n                    try {\n                        Method msetUseSessionTickets = delegate.getClass().getMethod(\"setUseSessionTickets\", boolean.class);\n                        if (null != msetUseSessionTickets) {\n                            msetUseSessionTickets.invoke(delegate, true);\n                        }\n                    } catch (NoSuchMethodException ignored) {\n                    } catch (InvocationTargetException ignored) {\n                    } catch (IllegalAccessException ignored) {\n                    }\n                }\n            }\n\n            @Override\n            public void setEnabledProtocols(String[] protocols) {\n                if (protocols != null &amp;&amp; protocols.length == 1 &amp;&amp; \"SSLv3\".equals(protocols[0])) {\n                    // no way jose\n                    // see issue https://code.google.com/p/android/issues/detail?id=78187\n                    List&lt;String&gt; enabledProtocols = new ArrayList&lt;String&gt;(Arrays.asList(delegate.getEnabledProtocols()));\n                    if (enabledProtocols.size() &gt; 1) {\n                        enabledProtocols.remove(\"SSLv3\");\n                    }\n                    protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);\n                }\n                super.setEnabledProtocols(protocols);\n            }\n        }\n\n    }\n", "    static {\n    HttpsURLConnection.setDefaultSSLSocketFactory(new NoSSLv3Factory());\n}\n", "private String getAppendedHeader(String str) {\n    try {\n        String hash = getHash(str);\n\n        String signature = new String(Base64.encodeBase64(hash.getBytes()));\n        StringBuilder sb = new StringBuilder();\n        sb.append(PUBLIC_KEY).append(' ').append(signature);\n        return sb.toString();\n    } catch (NoSuchAlgorithmException _e) {\n        LL.e(\"Get mac error: \" + _e.getMessage());\n        return null;\n    } catch (InvalidKeyException _e) {\n        LL.e(\"Init mac error: \" + _e.getMessage());\n        return null;\n    }\n}\n\n\nprivate String getHash(String str) throws NoSuchAlgorithmException, InvalidKeyException {\n    Mac mac = Mac.getInstance(\"HmacSHA256\");\n    SecretKeySpec secret = new SecretKeySpec(PRIVATE_KEY.getBytes(), \"HmacSHA256\");\n    mac.init(secret);\n    byte[] digest = mac.doFinal(str.getBytes());\n    BigInteger hash = new BigInteger(1, digest);\n    String hmac = hash.toString(16);\n    if (hmac.length() % 2 != 0) {\n        hmac = \"0\" + hmac;\n    }\n    return hmac;\n}\n", "          DocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();\n         dbfac.setNamespaceAware(true);\n         DocumentBuilder docBuilder = null;\n         try {\n            docBuilder = dbfac.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n         DOMImplementation domImpl = docBuilder.getDOMImplementation();\n         Document doc = domImpl.createDocument(\"http://coggl.com/InsertTrack\",\"TrackEntry\", null);\n         doc.setXmlVersion(\"1.0\");\n         doc.setXmlStandalone(true);\n\n         Element trackElement = doc.getDocumentElement();\n\n         Element CompanyId = doc.createElement(\"CompanyId\");\n         CompanyId.appendChild(doc.createTextNode(\"1\"));\n         trackElement.appendChild(CompanyId);\n\n         Element CreatedBy = doc.createElement(\"CreatedBy\");\n         CreatedBy.appendChild(doc.createTextNode(\"6\"));\n         trackElement.appendChild(CreatedBy);\n\n         Element DepartmentId = doc.createElement(\"DepartmentId\");\n         DepartmentId.appendChild(doc.createTextNode(\"4\"));\n         trackElement.appendChild(DepartmentId);\n\n         Element IsBillable = doc.createElement(\"IsBillable\");\n         IsBillable.appendChild(doc.createTextNode(\"1\"));\n         trackElement.appendChild(IsBillable);\n\n         Element ProjectId = doc.createElement(\"ProjectId\");\n         ProjectId.appendChild(doc.createTextNode(\"1\"));\n         trackElement.appendChild(ProjectId);\n\n         Element StartTime = doc.createElement(\"StartTime\");\n         StartTime.appendChild(doc.createTextNode(\"2012-03-14 10:44:45\"));\n         trackElement.appendChild(StartTime);\n\n         Element StopTime = doc.createElement(\"StopTime\");\n         StopTime.appendChild(doc.createTextNode(\"2012-03-14 11:44:45\"));\n         trackElement.appendChild(StopTime);\n\n         Element TaskId = doc.createElement(\"TaskId\");\n         TaskId.appendChild(doc.createTextNode(\"3\"));\n         trackElement.appendChild(TaskId);\n\n         Element TotalTime = doc.createElement(\"TotalTime\");\n         TotalTime.appendChild(doc.createTextNode(\"1\"));\n         trackElement.appendChild(TotalTime);\n\n         Element TrackDesc = doc.createElement(\"TrackDesc\");\n         TrackDesc.appendChild(doc.createTextNode(\"dello testing\"));\n         trackElement.appendChild(TrackDesc);\n\n         Element TrackId = doc.createElement(\"TrackId\");\n         TrackId.appendChild(doc.createTextNode(\"0\"));\n         trackElement.appendChild(TrackId);\n\n         TransformerFactory transfac = TransformerFactory.newInstance();\n         Transformer trans = null;\n        try {\n            trans = transfac.newTransformer();\n        } catch (TransformerConfigurationException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n         trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n         trans.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\n         //create string from xml tree\n         StringWriter sw = new StringWriter();\n         StreamResult result = new StreamResult(sw);\n         DOMSource source = new DOMSource(doc);\n         try {\n            trans.transform(source, result);\n        } catch (TransformerException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n         String xmlString = sw.toString();\n", "PackageInfo packageInfo;\n        try {\n        packageInfo = getPackageManager().getPackageInfo(\"com.yourapp\", \nPackageManager.GET_SIGNATURES);\n        for (Signature signature : packageInfo.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String key = new String(Base64.encode(md.digest(), 0));\n                // String key = new String(Base64.encodeBytes(md.digest()));\n                Log.e(\"Hash key\", key);\n        } \n        }\n        catch (NameNotFoundException e1) {\n            Log.e(\"Name not found\", e1.toString());\n        }\n\n        catch (NoSuchAlgorithmException e) {\n            Log.e(\"No such an algorithm\", e.toString());\n        }\n        catch (Exception e){\n            Log.e(\"Exception\", e.toString());\n        }\n", "SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\nSSLSocket socket = (SSLSocket) factory.createSocket(domain, 443);\n\nsocket.startHandshake();\nBufferedReader in = new BufferedReader(new InpuStreamReader(socket.getInputStream()));\nPrintWriter out = new PrintWriter(socket.getOutputStream());\n", "import java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.conn.ssl.SSLSocketFactory;\npublic class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n}\n", "public void printHashKey() {\n   try {\n      PackageInfo info = getActivity().getPackageManager().getPackageInfo(\"com.gorbin.androidsocialnetworksextended.asne\",\n      PackageManager.GET_SIGNATURES);\n      for (Signature signature : info.signatures) {\n         MessageDigest md = MessageDigest.getInstance(\"SHA\");\n         md.update(signature.toByteArray());\n         Log.d(\"HASH KEY:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n      }\n   } catch (PackageManager.NameNotFoundException e) {\n   } catch (NoSuchAlgorithmException e) {\n   }\n   }\n", "public String getData() {\n    String dataDecrypted = null;\n    try {\n        byte[] cryptionKeyCrypted = Base64.decode(cryptionKeyCryptedBase64, Base64.NO_WRAP);\n        byte[] cryptionIV = Base64.decode(cryptionIVBase64, Base64.NO_WRAP);\n\n        Cipher cipherRSA = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-1AndMGF1Padding\");\n        // get private key from the pair used to grab the public key to send to the api\n        cipherRSA.init(Cipher.DECRYPT_MODE, rsaKeyPair.getPrivateKey());\n        byte[] key = cipherRSA.doFinal(cryptionKeyCrypted);\n\n        byte[] dataCrytped = Base64.decode(dataCryptedBase64, Base64.NO_WRAP);\n        IvParameterSpec ivSpec = new IvParameterSpec(cryptionIV);\n        SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n        Cipher cipherAES = Cipher.getInstance(\"AES/CBC/ZeroBytePadding\");\n        cipherAES.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec);\n        byte[] decryptedAESBytes = cipherAES.doFinal(dataCrytped);\n        dataDecrypted = new String(decryptedAESBytes, \"UTF-8\");\n    } catch (Exception e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return dataDecrypted;\n}\n", "trustAllHosts();\n HttpsURLConnection post = (HttpsURLConnection) url.openConnection();\n https.setHostnameVerifier(DO_NOT_VERIFY);\n\n\nand add these methods,\n// always verify the host - dont check for certificate\nfinal static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {\n        public boolean verify(String hostname, SSLSession session) {\n                return true;\n        }\n};\n\n/**\n * Trust every server - dont check for any certificate\n */\nprivate static void trustAllHosts() {\n        // Create a trust manager that does not validate certificate chains\n        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                        return new java.security.cert.X509Certificate[] {};\n                }\n\n                public void checkClientTrusted(X509Certificate[] chain,\n                                String authType) throws CertificateException {\n                }\n\n                public void checkServerTrusted(X509Certificate[] chain,\n                                String authType) throws CertificateException {\n                }\n        } };\n\n        // Install the all-trusting trust manager\n        try {\n                SSLContext sc = SSLContext.getInstance(\"TLS\");\n                sc.init(null, trustAllCerts, new java.security.SecureRandom());\n                HttpsURLConnection\n                                .setDefaultSSLSocketFactory(sc.getSocketFactory());\n        } catch (Exception e) {\n                e.printStackTrace();\n        }\n}\n", "KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n\ntry (FileInputStream fis = new FileInputStream(keystore)) {\n    ks.load(fis, ksPw.toCharArray());\n}\n\nks.getEntry(alias, new KeyStore.PasswordProtection(aliasPw.toCharArray()));\n", "HttpURLConnection conn = null;\n            final HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {\n                public boolean verify(String hostname, SSLSession session) {\n                    return true;\n                }\n           };\n            try {\n                URL url = new URL(YOUR_URL);\n                if (url.getProtocol().toLowerCase().equals(\"https\")) {\n                    trustAllHosts();\n                    HttpsURLConnection https = (HttpsURLConnection) url.openConnection();\n                    https.setHostnameVerifier(DO_NOT_VERIFY);\n                    conn = https;\n                } else {\n                    conn = (HttpURLConnection) url.openConnection();\n                }\n                conn.setInstanceFollowRedirects(false);\n                conn.connect();\n        String location = conn.getHeaderField( \"User name\" );\n", "        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\n        InputStream keystream = context.getResources().getAssets().open(\"client.p12\");\n        try {\n            keystore.load(keystream, \"dysan100\".toCharArray());\n        } finally {\n            try { keystream.close(); } catch (Exception ignore) {}\n        }\n", "private void getKeyHash(Context context) {\n        try {\n            PackageInfo info = getPackageManager().getPackageInfo(\"com.example.android\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"Obtained KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n    }\n", "public class AESCrypt {\n\nprivate final Cipher cipher;\nprivate final SecretKeySpec key;\nprivate AlgorithmParameterSpec spec;\n\n\npublic AESCrypt(String password) throws Exception\n{\n    // hash password with SHA-256 and crop the output to 128-bit for key\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n    digest.update(password.getBytes(\"UTF-8\"));\n    byte[] keyBytes = new byte[32];\n    System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);\n\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    key = new SecretKeySpec(keyBytes, \"AES\");\n    spec = getIV();\n}       \n\npublic AlgorithmParameterSpec getIV()\n{\n    byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };\n    IvParameterSpec ivParameterSpec;\n    ivParameterSpec = new IvParameterSpec(iv);\n\n    return ivParameterSpec;\n}\n\npublic String encrypt(String plainText) throws Exception\n{\n    cipher.init(Cipher.ENCRYPT_MODE, key, spec);\n    byte[] encrypted = cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n    String encryptedText = new String(Base64.encode(encrypted, Base64.DEFAULT), \"UTF-8\");\n\n    return encryptedText;\n}\n\npublic String decrypt(String cryptedText) throws Exception\n{\n    cipher.init(Cipher.DECRYPT_MODE, key, spec);\n    byte[] bytes = Base64.decode(cryptedText, Base64.DEFAULT);\n    byte[] decrypted = cipher.doFinal(bytes);\n    String decryptedText = new String(decrypted, \"UTF-8\");\n\n    return decryptedText;\n}\n", "    try {\n         PackageInfo info = getPackageManager().getPackageInfo(\n                           \"com.your.package.name\", \n                            PackageManager.GET_SIGNATURES);\n         for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n          Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(),      Base64.DEFAULT));\n\n                  }\n            } catch (NameNotFoundException e) {\n                e.printStackTrace();\n            } catch (NoSuchAlgorithmException e) {\n                e.printStackTrace();\n          }\n", "Log.e(\"body\", body);\n            HttpClient httpclient = getNewHttpClient();\n\n            HttpPost httppost = new HttpPost(\"https://www.demo.com/login.php\");\n\n             nameValuePairs = new ArrayList&lt;NameValuePair&gt;();\nnameValuePairs.add(new BasicNameValuePair(\"username\", username));\nnameValuePairs.add(new BasicNameValuePair(\"password\", password));\nhttppost.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n\n\n            httppost.setEntity(entity);\n            response = httpclient.execute(httppost);;\n\n\n            Log.e(\"response\", response.getStatusLine().toString());\n            String aaa = response.getStatusLine().toString();\n            Toast.makeText(getApplicationContext(), \"Content :\"+ aaa, Toast.LENGTH_LONG).show();\n            HttpEntity entity1 = response.getEntity();\n            is = entity1.getContent();\n\n                //Toast.makeText(getApplicationContext(), \"Content :\"+ (CharSequence) is, Toast.LENGTH_LONG).show();\n\n        }catch(Exception e){\n            Log.e(\"log_tag\", \"Error in http connection \"+e.toString());\n        }\n\n\npublic HttpClient getNewHttpClient() {\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore\n                    .getDefaultType());\n            trustStore.load(null, null);\n\n            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n            HttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory\n                    .getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sf, 443));\n\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(\n                    params, registry);\n\n            return new DefaultHttpClient(ccm, params);\n        } catch (Exception e) {\n            return new DefaultHttpClient();\n        }\n    }\n", "import java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n\npublic class MD5Encode {\n   private static String convertedToHex(byte[] data) {\n    StringBuffer buf = new StringBuffer();\n\n    for (int i = 0; i &lt; data.length; i++) {\n        int halfOfByte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;\n        int twoHalfBytes = 0;\n\n        do {\n            if ((0 &lt;= halfOfByte) &amp;&amp; (halfOfByte &lt;= 9)) {\n                buf.append((char) ('0' + halfOfByte));\n            } else {\n                buf.append((char) ('a' + (halfOfByte - 10)));\n            }\n\n            halfOfByte = data[i] &amp; 0x0F;\n\n        } while (twoHalfBytes++ &lt; 1);\n    }\n    return buf.toString();\n    }\n\n    public static String MD5(String text) throws NoSuchAlgorithmException,\n        UnsupportedEncodingException {\n    MessageDigest md;\n    md = MessageDigest.getInstance(\"MD5\");\n    byte[] md5 = new byte[64];\n    md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n    md5 = md.digest();\n    return convertedToHex(md5);\n   }\n}\n", "// AESdemo\n\npublic class AESdemo extends Activity {\n    boolean encryptionIsOn = true;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_aesdemo);\n        // needs &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n        String homeDirName = Environment.getExternalStorageDirectory().getAbsolutePath() +\n                \"/\" + getPackageName();\n        File file = new File(homeDirName, \"test.txt\");\n        byte[] keyBytes = getKey(\"password\");\n\n        try {\n            File dir = new File(homeDirName);\n            if (!dir.exists())\n                dir.mkdirs();\n            if (!file.exists())\n                file.createNewFile();\n\n            OutputStreamWriter osw;\n\n            if (encryptionIsOn) {\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n                IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);\n                cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n\n                FileOutputStream fos = new FileOutputStream(file);\n                CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n                osw = new OutputStreamWriter(cos, \"UTF-8\");\n            }\n            else    // not encryptionIsOn\n                osw = new FileWriter(file);\n\n            BufferedWriter out = new BufferedWriter(osw);\n            out.write(\"This is a test\\n\");\n            out.close();\n        }\n        catch (Exception e) {\n            System.out.println(\"Encryption Exception \"+e);\n        }\n\n        ///////////////////////////////////\n        try {\n            InputStreamReader isr;\n\n            if (encryptionIsOn) {\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n                IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);\n                cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);\n\n                FileInputStream fis = new FileInputStream(file);\n                CipherInputStream cis = new CipherInputStream(fis, cipher);\n                isr = new InputStreamReader(cis, \"UTF-8\");\n            }\n            else\n                isr = new FileReader(file);\n\n            BufferedReader in = new BufferedReader(isr);\n            String line = in.readLine();\n            System.out.println(\"Text read: &lt;\"+line+\"&gt;\");\n            in.close();\n        }\n        catch (Exception e) {\n            System.out.println(\"Decryption Exception \"+e);\n        }\n    }\n\n    private byte[] getKey(String password) throws UnsupportedEncodingException {\n        String key = \"\";\n        while (key.length() &lt; 16)\n            key += password;\n        return key.substring(0, 16).getBytes(\"UTF-8\");\n    }\n}\n", "  byte[] wholeFileByte = null;\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, key, DownloadBookAsyncTask.ivspec);\n    File file = new File(context.getFilesDir().getParentFile().getPath() + \"/download/\" + id + \"/xmldata.xml\");\n    FileInputStream fis = new FileInputStream(file);\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    byte data[] = new byte[4096];\n    int count;\n    while ((count = cis.read(data)) != -1) {\n        bos.write(data, 0, count);\n    }\n\n    if(cis != null)\n        cis.close();\n    if(bos != null)\n        bos.close();\n    if(fis != null)\n        fis.close();\n\n    wholeFileByte = bos.toByteArray();\n    String kk = new String(wholeFileByte, \"UTF-8\");\n", "public DefaultHttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n", "public class MySSLSocketFactory extends SSLSocketFactory {\nSSLContext sslContext = SSLContext.getInstance(\"SSLv3\");\n\npublic MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n    super(truststore);\n\n    TrustManager tm = new X509TrustManager() {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    };\n\n    sslContext.init(null, new TrustManager[] { tm }, null);\n}\n\n@Override\npublic Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n    SSLSocket S = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    S.setEnabledProtocols(new String[] {\"SSLv3\"});\n    return S;\n}\n\n@Override\npublic Socket createSocket() throws IOException {\n    SSLSocket S = (SSLSocket) sslContext.getSocketFactory().createSocket();\n    S.setEnabledProtocols(new String[] {\"SSLv3\"});\n    return S;\n}\n", "public HttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        MySSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(MySSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport android.app.Activity;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.Signature;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.widget.TextView;\n\npublic class MainActivity extends Activity {\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n\n        try {\n               PackageInfo info = getPackageManager().getPackageInfo(\"com.key\", PackageManager.GET_SIGNATURES);\n               for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n\n                      TextView tvmyName = (TextView)findViewById(R.id.KeyText);\n                      tvmyName.setText(Base64.encodeBytes(md.digest()));\n\n\n               }\n            } catch (NameNotFoundException e) {\n\n            } catch (NoSuchAlgorithmException e) {\n\n            }\n\n    }\n}\n", "private void initSslSocketFactory() {\n\n    try {\n        /*\n         * SETUP TRUSTSTORE \n         */  \n        KeyStore trustStore = KeyStore.getInstance(\"BKS\");  \n        TrustManagerFactory trustManagerFactory = TrustManagerFactory  \n            .getInstance(TrustManagerFactory.getDefaultAlgorithm());  \n        InputStream trustStoreStream = context.getResources()  \n            .openRawResource(R.raw.ca);  \n        trustStore.load(trustStoreStream, \"000000\".toCharArray());  \n        trustManagerFactory.init(trustStore);  \n\n        /* \n         * SETUP KEYSTORE \n         */  \n        KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");  \n        KeyManagerFactory keyManagerFactory = KeyManagerFactory  \n            .getInstance(KeyManagerFactory.getDefaultAlgorithm());  \n        InputStream keyStoreStream = context.getResources()  \n            .openRawResource(R.raw.client);  \n        keyStore.load(keyStoreStream, \"000000\".toCharArray());  \n        keyManagerFactory.init(keyStore, \"000000\".toCharArray());  \n\n        /* \n         * SETUP the SSL context to use the truststore and keystore \n         */   \n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        mSslSocketFactory = sslContext.getSocketFactory();\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(Tag, \"\" + e.getMessage());\n        e.printStackTrace();\n    } catch (KeyManagementException e) {\n        Log.e(Tag, \"\" + e.getMessage());\n        e.printStackTrace();\n    }\n}\n\npublic void connect() {\n    mSslSock = (SSLSocket) mSslSocketFactory.createSocket();\n    mSslSock.connect(new InetSocketAddress(host, port));\n    mSslSock.setSoTimeout(SOCKET_TIMEOUT);\n    mSslSock.setUseClientMode(true);\n    mSslSock.setEnabledCipherSuites(mSslSock.getEnabledCipherSuites());\n    mSslSock.setEnabledProtocols(mSslSock.getSupportedProtocols());\n    mSslSock.connect(SocketAddress);\n    ......\n}\n", " SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n\n// set up a TrustManager that trusts everything\nsslContext.init(null, new TrustManager[] { new X509TrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                    System.out.println(\"getAcceptedIssuers =============\");\n                    return null;\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs,\n                            String authType) {\n                    System.out.println(\"checkClientTrusted =============\");\n            }\n\n            public void checkServerTrusted(X509Certificate[] certs,\n                            String authType) {\n                    System.out.println(\"checkServerTrusted =============\");\n            }\n} }, new SecureRandom());\n\nSSLSocketFactory sf = new SSLSocketFactory(sslContext);\nScheme httpsScheme = new Scheme(\"https\", 443, sf);\nSchemeRegistry schemeRegistry = new SchemeRegistry();\nschemeRegistry.register(httpsScheme);\n\n// apache HttpClient version &gt;4.2 should use BasicClientConnectionManager\nClientConnectionManager cm = new SingleClientConnManager(schemeRegistry);\nHttpClient httpClient = new DefaultHttpClient(cm);\n", "public static void allowAllSSL() {\n\n        try {\n            SSLContext sc = SSLContext.getInstance(\"TLS\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection\n                    .setDefaultSSLSocketFactory(sc.getSocketFactory());\n            connection = (HttpsURLConnection) (new URL(\n                    \"https://sPublic/Client.asmx\"))\n                    .openConnection();\n            connection.connect();\n        } catch (Exception e) {\n            e.getMessage();\n        }\n", "/**\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n */\npackage se.simbio.encryption;\n\nimport android.os.AsyncTask;\nimport android.util.Base64;\nimport android.util.Log;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * A class to make more easy and simple the encrypt routines, this is the core of Encryption library\n */\npublic class Encryption {\n\n    /**\n     * We use this tag to log errors on LogCat, never the password or sensible data\n     */\n    private static final String TAG = \"Encryption\";\n\n    /**\n     * The Builder used to create the Encryption instance and that contains the information about\n     * encryption specifications, this instance need to be private and careful managed\n     */\n    private final Builder mBuilder;\n\n    /**\n     * The private and unique constructor, you should use the Encryption.Builder to build your own\n     * instance or get the default proving just the sensible information about encryption\n     */\n    private Encryption(Builder builder) {\n        mBuilder = builder;\n    }\n\n    /**\n     * @return an default encryption instance or {@code null} if occur some Exception, you can\n     * create yur own Encryption instance using the Encryption.Builder\n     */\n    public static Encryption getDefault(String key, String salt, byte[] iv) {\n        try {\n            return Builder.getDefaultBuilder(key, salt, iv).build();\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, e.getMessage(), e);\n            return null;\n        }\n    }\n\n    /**\n     * Encrypt a String\n     *\n     * @param data the String to be encrypted\n     *\n     * @return the encrypted String or {@code null} if you send the data as {@code null}\n     *\n     * @throws UnsupportedEncodingException       if the Builder charset name is not supported or if\n     *                                            the Builder charset name is not supported\n     * @throws NoSuchAlgorithmException           if the Builder digest algorithm is not available\n     *                                            or if this has no installed provider that can\n     *                                            provide the requested by the Builder secret key\n     *                                            type or it is {@code null}, empty or in an invalid\n     *                                            format\n     * @throws NoSuchPaddingException             if no installed provider can provide the padding\n     *                                            scheme in the Builder digest algorithm\n     * @throws InvalidAlgorithmParameterException if the specified parameters are inappropriate for\n     *                                            the cipher\n     * @throws InvalidKeyException                if the specified key can not be used to initialize\n     *                                            the cipher instance\n     * @throws InvalidKeySpecException            if the specified key specification cannot be used\n     *                                            to generate a secret key\n     * @throws BadPaddingException                if the padding of the data does not match the\n     *                                            padding scheme\n     * @throws IllegalBlockSizeException          if the size of the resulting bytes is not a\n     *                                            multiple of the cipher block size\n     * @throws NullPointerException               if the Builder digest algorithm is {@code null} or\n     *                                            if the specified Builder secret key type is\n     *                                            {@code null}\n     * @throws IllegalStateException              if the cipher instance is not initialized for\n     *                                            encryption or decryption\n     */\n    public String encrypt(String data) throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, InvalidKeySpecException, BadPaddingException, IllegalBlockSizeException {\n        if (data == null) return null;\n        SecretKey secretKey = getSecretKey(hashTheKey(mBuilder.getKey()));\n        byte[] dataBytes = data.getBytes(mBuilder.getCharsetName());\n        Cipher cipher = Cipher.getInstance(mBuilder.getAlgorithm());\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, mBuilder.getIvParameterSpec(), mBuilder.getSecureRandom());\n        return Base64.encodeToString(cipher.doFinal(dataBytes), mBuilder.getBase64Mode());\n    }\n\n    /**\n     * This is a sugar method that calls encrypt method and catch the exceptions returning\n     * {@code null} when it occurs and logging the error\n     *\n     * @param data the String to be encrypted\n     *\n     * @return the encrypted String or {@code null} if you send the data as {@code null}\n     */\n    public String encryptOrNull(String data) {\n        try {\n            return encrypt(data);\n        } catch (Exception e) {\n            Log.e(TAG, e.getMessage(), e);\n            return null;\n        }\n    }\n\n    /**\n     * This is a sugar method that calls encrypt method in background, it is a good idea to use this\n     * one instead the default method because encryption can take several time and with this method\n     * the process occurs in a AsyncTask, other advantage is the Callback with separated methods,\n     * one for success and other for the exception\n     *\n     * @param data     the String to be encrypted\n     * @param callback the Callback to handle the results\n     */\n    public void encryptAsync(String data, final Callback callback) {\n        if (callback == null) return;\n        new AsyncTask&lt;String, Void, String&gt;() {\n\n            @Override\n            protected String doInBackground(String... params) {\n                try {\n                    String encrypt = encrypt(params[0]);\n                    if (encrypt == null) {\n                        callback.onError(new Exception(\"Encrypt return null, it normally occurs when you send a null data\"));\n                    }\n                    return encrypt;\n                } catch (Exception e) {\n                    callback.onError(e);\n                    return null;\n                }\n            }\n\n            @Override\n            protected void onPostExecute(String result) {\n                super.onPostExecute(result);\n                if (result != null) callback.onSuccess(result);\n            }\n\n        }.execute(data);\n    }\n\n    /**\n     * Decrypt a String\n     *\n     * @param data the String to be decrypted\n     *\n     * @return the decrypted String or {@code null} if you send the data as {@code null}\n     *\n     * @throws UnsupportedEncodingException       if the Builder charset name is not supported or if\n     *                                            the Builder charset name is not supported\n     * @throws NoSuchAlgorithmException           if the Builder digest algorithm is not available\n     *                                            or if this has no installed provider that can\n     *                                            provide the requested by the Builder secret key\n     *                                            type or it is {@code null}, empty or in an invalid\n     *                                            format\n     * @throws NoSuchPaddingException             if no installed provider can provide the padding\n     *                                            scheme in the Builder digest algorithm\n     * @throws InvalidAlgorithmParameterException if the specified parameters are inappropriate for\n     *                                            the cipher\n     * @throws InvalidKeyException                if the specified key can not be used to initialize\n     *                                            the cipher instance\n     * @throws InvalidKeySpecException            if the specified key specification cannot be used\n     *                                            to generate a secret key\n     * @throws BadPaddingException                if the padding of the data does not match the\n     *                                            padding scheme\n     * @throws IllegalBlockSizeException          if the size of the resulting bytes is not a\n     *                                            multiple of the cipher block size\n     * @throws NullPointerException               if the Builder digest algorithm is {@code null} or\n     *                                            if the specified Builder secret key type is\n     *                                            {@code null}\n     * @throws IllegalStateException              if the cipher instance is not initialized for\n     *                                            encryption or decryption\n     */\n    public String decrypt(String data) throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\n        if (data == null) return null;\n        byte[] dataBytes = Base64.decode(data, mBuilder.getBase64Mode());\n        SecretKey secretKey = getSecretKey(hashTheKey(mBuilder.getKey()));\n        Cipher cipher = Cipher.getInstance(mBuilder.getAlgorithm());\n        cipher.init(Cipher.DECRYPT_MODE, secretKey, mBuilder.getIvParameterSpec(), mBuilder.getSecureRandom());\n        byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));\n        return new String(dataBytesDecrypted);\n    }\n\n    /**\n     * This is a sugar method that calls decrypt method and catch the exceptions returning\n     * {@code null} when it occurs and logging the error\n     *\n     * @param data the String to be decrypted\n     *\n     * @return the decrypted String or {@code null} if you send the data as {@code null}\n     */\n    public String decryptOrNull(String data) {\n        try {\n            return decrypt(data);\n        } catch (Exception e) {\n            Log.e(TAG, e.getMessage(), e);\n            return null;\n        }\n    }\n\n    /**\n     * This is a sugar method that calls decrypt method in background, it is a good idea to use this\n     * one instead the default method because decryption can take several time and with this method\n     * the process occurs in a AsyncTask, other advantage is the Callback with separated methods,\n     * one for success and other for the exception\n     *\n     * @param data     the String to be decrypted\n     * @param callback the Callback to handle the results\n     */\n    public void decryptAsync(String data, final Callback callback) {\n        if (callback == null) return;\n        new AsyncTask&lt;String, Void, String&gt;() {\n\n            @Override\n            protected String doInBackground(String... params) {\n                try {\n                    String decrypt = decrypt(params[0]);\n                    if (decrypt == null) {\n                        callback.onError(new Exception(\"Decrypt return null, it normally occurs when you send a null data\"));\n                    }\n                    return decrypt;\n                } catch (Exception e) {\n                    callback.onError(e);\n                    return null;\n                }\n            }\n\n            @Override\n            protected void onPostExecute(String result) {\n                super.onPostExecute(result);\n                if (result != null) callback.onSuccess(result);\n            }\n\n        }.execute(data);\n    }\n\n    /**\n     * creates a 128bit salted aes key\n     *\n     * @param key encoded input key\n     *\n     * @return aes 128 bit salted key\n     *\n     * @throws NoSuchAlgorithmException     if no installed provider that can provide the requested\n     *                                      by the Builder secret key type\n     * @throws UnsupportedEncodingException if the Builder charset name is not supported\n     * @throws InvalidKeySpecException      if the specified key specification cannot be used to\n     *                                      generate a secret key\n     * @throws NullPointerException         if the specified Builder secret key type is {@code null}\n     */\n    private SecretKey getSecretKey(char[] key) throws NoSuchAlgorithmException, UnsupportedEncodingException, InvalidKeySpecException {\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(mBuilder.getSecretKeyType());\n        KeySpec spec = new PBEKeySpec(key, mBuilder.getSalt().getBytes(mBuilder.getCharsetName()), mBuilder.getIterationCount(), mBuilder.getKeyLength());\n        SecretKey tmp = factory.generateSecret(spec);\n        return new SecretKeySpec(tmp.getEncoded(), mBuilder.getAlgorithm());\n    }\n\n    /**\n     * takes in a simple string and performs an sha1 hash\n     * that is 128 bits long...we then base64 encode it\n     * and return the char array\n     *\n     * @param key simple inputted string\n     *\n     * @return sha1 base64 encoded representation\n     *\n     * @throws UnsupportedEncodingException if the Builder charset name is not supported\n     * @throws NoSuchAlgorithmException     if the Builder digest algorithm is not available\n     * @throws NullPointerException         if the Builder digest algorithm is {@code null}\n     */\n    private char[] hashTheKey(String key) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest messageDigest = MessageDigest.getInstance(mBuilder.getDigestAlgorithm());\n        messageDigest.update(key.getBytes(mBuilder.getCharsetName()));\n        return Base64.encodeToString(messageDigest.digest(), Base64.NO_PADDING).toCharArray();\n    }\n\n    /**\n     * When you encrypt or decrypt in callback mode you get noticed of result using this interface\n     */\n    public static interface Callback {\n\n        /**\n         * Called when encrypt or decrypt job ends and the process was a success\n         *\n         * @param result the encrypted or decrypted String\n         */\n        public void onSuccess(String result);\n\n        /**\n         * Called when encrypt or decrypt job ends and has occurred an error in the process\n         *\n         * @param exception the Exception related to the error\n         */\n        public void onError(Exception exception);\n\n    }\n\n    /**\n     * This class is used to create an Encryption instance, you should provide ALL data or start\n     * with the Default Builder provided by the getDefaultBuilder method\n     */\n    public static class Builder {\n\n        private byte[] mIv;\n        private int mKeyLength;\n        private int mBase64Mode;\n        private int mIterationCount;\n        private String mSalt;\n        private String mKey;\n        private String mAlgorithm;\n        private String mCharsetName;\n        private String mSecretKeyType;\n        private String mDigestAlgorithm;\n        private String mSecureRandomAlgorithm;\n        private SecureRandom mSecureRandom;\n        private IvParameterSpec mIvParameterSpec;\n\n        /**\n         * @return an default builder with the follow defaults:\n         * the default char set is UTF-8\n         * the default base mode is Base64\n         * the Secret Key Type is the PBKDF2WithHmacSHA1\n         * the default salt is \"some_salt\" but can be anything\n         * the default length of key is 128\n         * the default iteration count is 65536\n         * the default algorithm is AES in CBC mode and PKCS 5 Padding\n         * the default secure random algorithm is SHA1PRNG\n         * the default message digest algorithm SHA1\n         */\n        public static Builder getDefaultBuilder(String key, String salt, byte[] iv) {\n            return new Builder()\n                    .setIv(iv)\n                    .setKey(key)\n                    .setSalt(salt)\n                    .setKeyLength(128)\n                    .setCharsetName(\"UTF8\")\n                    .setIterationCount(65536)\n                    .setDigestAlgorithm(\"SHA1\")\n                    .setBase64Mode(Base64.DEFAULT)\n                    .setAlgorithm(\"AES/CBC/PKCS5Padding\")\n                    .setSecureRandomAlgorithm(\"SHA1PRNG\")\n                    .setSecretKeyType(\"PBKDF2WithHmacSHA1\");\n        }\n\n        /**\n         * Build the Encryption with the provided information\n         *\n         * @return a new Encryption instance with provided information\n         *\n         * @throws NoSuchAlgorithmException if the specified SecureRandomAlgorithm is not available\n         * @throws NullPointerException     if the SecureRandomAlgorithm is {@code null} or if the\n         *                                  IV byte array is null\n         */\n        public Encryption build() throws NoSuchAlgorithmException {\n            setSecureRandom(SecureRandom.getInstance(getSecureRandomAlgorithm()));\n            setIvParameterSpec(new IvParameterSpec(getIv()));\n            return new Encryption(this);\n        }\n\n        //region getters and setters\n\n        /**\n         * @return the charset name\n         */\n        private String getCharsetName() {\n            return mCharsetName;\n        }\n\n        /**\n         * @param charsetName the new charset name\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setCharsetName(String charsetName) {\n            mCharsetName = charsetName;\n            return this;\n        }\n\n        /**\n         * @return the algorithm\n         */\n        private String getAlgorithm() {\n            return mAlgorithm;\n        }\n\n        /**\n         * @param algorithm the algorithm to be used\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setAlgorithm(String algorithm) {\n            mAlgorithm = algorithm;\n            return this;\n        }\n\n        /**\n         * @return the Base 64 mode\n         */\n        private int getBase64Mode() {\n            return mBase64Mode;\n        }\n\n        /**\n         * @param base64Mode set the base 64 mode\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setBase64Mode(int base64Mode) {\n            mBase64Mode = base64Mode;\n            return this;\n        }\n\n        /**\n         * @return the type of aes key that will be created, on KITKAT+ the API has changed, if you\n         * are getting problems please @see &lt;a href=\"http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html\"&gt;http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html&lt;/a&gt;\n         */\n        private String getSecretKeyType() {\n            return mSecretKeyType;\n        }\n\n        /**\n         * @param secretKeyType the type of AES key that will be created, on KITKAT+ the API has\n         *                      changed, if you are getting problems please @see &lt;a href=\"http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html\"&gt;http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html&lt;/a&gt;\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setSecretKeyType(String secretKeyType) {\n            mSecretKeyType = secretKeyType;\n            return this;\n        }\n\n        /**\n         * @return the value used for salting\n         */\n        private String getSalt() {\n            return mSalt;\n        }\n\n        /**\n         * @param salt the value used for salting\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setSalt(String salt) {\n            mSalt = salt;\n            return this;\n        }\n\n        /**\n         * @return the key\n         */\n        private String getKey() {\n            return mKey;\n        }\n\n        /**\n         * @param key the key.\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setKey(String key) {\n            mKey = key;\n            return this;\n        }\n\n        /**\n         * @return the length of key\n         */\n        private int getKeyLength() {\n            return mKeyLength;\n        }\n\n        /**\n         * @param keyLength the length of key\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setKeyLength(int keyLength) {\n            mKeyLength = keyLength;\n            return this;\n        }\n\n        /**\n         * @return the number of times the password is hashed\n         */\n        private int getIterationCount() {\n            return mIterationCount;\n        }\n\n        /**\n         * @param iterationCount the number of times the password is hashed\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setIterationCount(int iterationCount) {\n            mIterationCount = iterationCount;\n            return this;\n        }\n\n        /**\n         * @return the algorithm used to generate the secure random\n         */\n        private String getSecureRandomAlgorithm() {\n            return mSecureRandomAlgorithm;\n        }\n\n        /**\n         * @param secureRandomAlgorithm the algorithm to generate the secure random\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setSecureRandomAlgorithm(String secureRandomAlgorithm) {\n            mSecureRandomAlgorithm = secureRandomAlgorithm;\n            return this;\n        }\n\n        /**\n         * @return the IvParameterSpec bytes array\n         */\n        private byte[] getIv() {\n            return mIv;\n        }\n\n        /**\n         * @param iv the byte array to create a new IvParameterSpec\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setIv(byte[] iv) {\n            mIv = iv;\n            return this;\n        }\n\n        /**\n         * @return the SecureRandom\n         */\n        private SecureRandom getSecureRandom() {\n            return mSecureRandom;\n        }\n\n        /**\n         * @param secureRandom the Secure Random\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setSecureRandom(SecureRandom secureRandom) {\n            mSecureRandom = secureRandom;\n            return this;\n        }\n\n        /**\n         * @return the IvParameterSpec\n         */\n        private IvParameterSpec getIvParameterSpec() {\n            return mIvParameterSpec;\n        }\n\n        /**\n         * @param ivParameterSpec the IvParameterSpec\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setIvParameterSpec(IvParameterSpec ivParameterSpec) {\n            mIvParameterSpec = ivParameterSpec;\n            return this;\n        }\n\n        /**\n         * @return the message digest algorithm\n         */\n        private String getDigestAlgorithm() {\n            return mDigestAlgorithm;\n        }\n\n        /**\n         * @param digestAlgorithm the algorithm to be used to get message digest instance\n         *\n         * @return this instance to follow the Builder patter\n         */\n        public Builder setDigestAlgorithm(String digestAlgorithm) {\n            mDigestAlgorithm = digestAlgorithm;\n            return this;\n        }\n\n        //endregion\n\n    }\n\n}\n", "try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"YOUR PACKAGE NAME HERE\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "    import javax.crypto.Cipher;\n    import javax.crypto.spec.IvParameterSpec;\n    import javax.crypto.spec.SecretKeySpec;\n\n    import android.util.Base64;\n    //string encryption\n    public class EncryptionHelper {\n\n\n\n        // Encrypts string and encode in Base64\n        public static String encryptText(String plainText) throws Exception {\n            // ---- Use specified 3DES key and IV from other source --------------\n            byte[] plaintext = plainText.getBytes();//input\n            byte[] tdesKeyData = Constants.getKey().getBytes();// your encryption key\n\n            byte[] myIV = Constants.getInitializationVector().getBytes();// initialization vector\n\n            Cipher c3des = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n            SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, \"DESede\");\n            IvParameterSpec ivspec = new IvParameterSpec(myIV);\n\n            c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);\n            byte[] cipherText = c3des.doFinal(plaintext);\n            String encryptedString = Base64.encodeToString(cipherText,\n                    Base64.DEFAULT);\n            // return Base64Coder.encodeString(new String(cipherText));\n            return encryptedString;\n        }\n\n    private class Constants \n{\nprivate static final String KEY=\"QsdPasd45FaSdnLjf\";\n    private static final String INITIALIZATION_VECTOR=\"l9yhTaWY\";\npublic static String getKey() \n    {\n        return KEY;\n    }\n\n\n    public static String getInitializationVector() \n    {\n        return INITIALIZATION_VECTOR;\n    }\n }   \n    }\n", "package com.example.mypackage;\n\nimport android.util.Log;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\npublic class SSLConection {\n\n    private static TrustManager[] trustManagers;\n\n    public static class _FakeX509TrustManager implements javax.net.ssl.X509TrustManager {\n        private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};\n\n        public void checkClientTrusted(X509Certificate[] arg0, String arg1)\n                throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] arg0, String arg1)\n                throws CertificateException {\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return (_AcceptedIssuers);\n        }\n    }\n\n    public static void allowAllSSL() {\n\n        javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n            @Override\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n\n        javax.net.ssl.SSLContext context;\n\n        if (trustManagers == null) {\n            trustManagers = new TrustManager[]{new _FakeX509TrustManager()};\n        }\n\n        try {\n            context = javax.net.ssl.SSLContext.getInstance(\"TLS\");\n            context.init(null, trustManagers, new SecureRandom());\n            javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(\"allowAllSSL\", e.toString());\n        } catch (KeyManagementException e) {\n            Log.e(\"allowAllSSL\", e.toString());\n        }\n    }\n}\n", "import java.io.File;\nimport java.io.StringReader;\nimport java.io.StringWriter;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Some general XML functions\n */\npublic class XML\n{\n    /**\n     * Get an XML Document file from its string representation\n     * @param xml The xml string\n     * @return Document object for the XML representation\n     */\n    public static Document fromString(String xml)\n    {\n        if (xml == null)\n            throw new NullPointerException(\"The xml string passed in is null\");\n\n        // from http://www.rgagnon.com/javadetails/java-0573.html\n        try\n        {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            InputSource is = new InputSource();\n            is.setCharacterStream(new StringReader(xml));\n\n            Document doc = db.parse(is);\n\n            return doc;\n        }\n        catch (SAXException e)\n        {\n            return null;\n        }\n        catch(Exception e)\n        {\n            CustomExceptionHandler han = new CustomExceptionHandler();\n            han.uncaughtException(Thread.currentThread(), e);\n            return null;\n        }\n    }\n\n    /**\n     * Get a XML Document object from a file\n     * @param location The location where the file is found\n     * @return An XML Document object\n     */\n    public static Document fromFile(String location)\n    {\n        return fromFile(new File(location));\n    }\n\n    /**\n     * Get a XML Document object from a file\n     * @param location The file object to load\n     * @return An XML Document object\n     */\n    public static Document fromFile(File file)\n    {\n        try\n        {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n\n            Document doc = db.parse(file);\n            doc.getDocumentElement().normalize();\n            return doc;\n        }\n        catch (Exception e)\n        {\n            return null;\n        }\n    }\n\n    /**\n     * Method to convert Document to String\n     * @param doc\n     * @return\n     */\n    public static String getStringFromDocument(Document doc)\n    {\n        try\n        {\n           DOMSource domSource = new DOMSource(doc);\n           StringWriter writer = new StringWriter();\n           StreamResult result = new StreamResult(writer);\n           TransformerFactory tf = TransformerFactory.newInstance();\n           Transformer transformer = tf.newTransformer();\n           transformer.transform(domSource, result);\n           return writer.toString();\n        }\n        catch(TransformerException ex)\n        {\n           ex.printStackTrace();\n           return null;\n        }\n    }\n}\n", "public final boolean authenticate(String attemptedPassword, byte[] encryptedPassword, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {\n  String algorithm = \"PBKDF2WithHmacSHA1\";\n  int derivedKeyLength = 160;\n  int iterations = 20000;\n  KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterations, derivedKeyLength);\n  SecretKeyFactory f = SecretKeyFactory.getInstance(algorithm);\n\n  byte[] encryptedPassword = f.generateSecret(spec).getEncoded();\n\n  return Arrays.equals(encryptedPassword, encryptedAttemptedPassword);\n}\n", "public DefaultHttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", "    import java.security.AlgorithmParameters;\nimport java.security.SecureRandom;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nclass SecurityUtils {\n\n  private static final byte[] salt = { (byte) 0xA4, (byte) 0x0B, (byte) 0xC8,\n      (byte) 0x34, (byte) 0xD6, (byte) 0x95, (byte) 0xF3, (byte) 0x13 };\n\n  private static int BLOCKS = 128;\n\n  public static byte[] encryptAES(String seed, String cleartext)\n      throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes(\"UTF8\"));\n    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    return cipher.doFinal(cleartext.getBytes(\"UTF8\"));\n  }\n\n  public static byte[] decryptAES(String seed, byte[] data) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes(\"UTF8\"));\n    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    return cipher.doFinal(data);\n  }\n\n  private static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(seed);\n    kgen.init(BLOCKS, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n  }\n\n  private static byte[] pad(byte[] seed) {\n    byte[] nseed = new byte[BLOCKS / 8];\n    for (int i = 0; i &lt; BLOCKS / 8; i++)\n      nseed[i] = 0;\n    for (int i = 0; i &lt; seed.length; i++)\n      nseed[i] = seed[i];\n\n    return nseed;\n  }\n\n  public static byte[] encryptPBE(String password, String cleartext)\n      throws Exception {\n    SecretKeyFactory factory = SecretKeyFactory\n        .getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 1024, 256);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n    return cipher.doFinal(cleartext.getBytes(\"UTF-8\"));\n  }\n\n  public static String decryptPBE(SecretKey secret, String ciphertext,\n      byte[] iv) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));\n    return new String(cipher.doFinal(ciphertext.getBytes()), \"UTF-8\");\n  }\n\n}\n", "// Encryption\n\npublic  String encrypt(String message) throws Exception\n\n{\n\nString message1=Base64.encodeBytes(message.getBytes(),Base64.NO_OPTIONS);\nString salt = SharedVariables.globalContext.getString(R.string.EncryptionKey);\nSecretKeySpec key = new SecretKeySpec(salt.getBytes(), \"AES\");`enter code here`\nCipher c = Cipher.getInstance(\"AES\");\nc.init(Cipher.ENCRYPT_MODE, key);\nbyte[] encVal = c.doFinal(message1.getBytes());\nString encrypted=Base64.encodeToString(encVal, Base64.NO_OPTIONS);\nreturn encrypted;\n\n}\n\n//Decryption\n\npublic String decrypt(String message) throws Exception\n\n{\n\nString salt = SharedVariables.globalContext.getString(R.string.EncryptionKey);\nCipher c = Cipher.getInstance(\"AES\");\nSecretKeySpec key = new SecretKeySpec(salt.getBytes(), \"AES\");\nc.init(Cipher.DECRYPT_MODE, key);\nbyte[] decordedValue = Base64.decode(message.getBytes(), Base64.NO_OPTIONS);\nbyte[] decValue = c.doFinal(decordedValue);\nString decryptedValue = new String(decValue);\nString decoded=new String(Base64.decode(decryptedValue, .Base64.NO_OPTIONS));\nreturn decoded;\n} \n", "private void test() {\n\n            try {\n                String stringMessage=\"GEQRpAPA577ks/QveudNkk7H9DjItKGLDYW6xhH1YJGabCVzrkejkBh6S+APwEXxB84UV/q0sO5rqkgXWONJQ8CoMTfqXtUkAAwkYHSc86eGewkM8WpctA0AyNVFonOxDCXm84Uq8JRMzqskSH5VXHmMxvHIvpFgdhmt9Ir0cKWzoLsuvgfY9hfypfEyBXGZcoptQeKhsZxRGIlxbXhrFl/LqhC+F6vYtZ/j5pv2LUP38wh2rTCKnAQ+xvC+7wn5SVzt/Wbr/q7GjCoJuU9uFHQSS49KQDt+BzJL2XNwAMmdbC+XHYkEBBWxVSS+0hdSQxoaKVZZJk4hTnHwQlBAkw==\";\n                //Convert String back to Byte[] and decrpt\n                byte[] byteMessage = Base64.decodeBase64(stringMessage.getBytes(\"UTF-8\"));\n                System.out.println(\"ENCRYPTED MESSAGE byte Length: \"+byteMessage.length);\n\n                String decryptedMsg = decryptString(byteMessage, loadCASPrivateKey());\n                System.out.println(decryptedMsg);\n            } catch (Exception e) {\n                e.printStackTrace();\n                return;\n            }\n        }\n\n        private static String decryptString(byte[] message, Key privateKey) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, NoSuchProviderException {\n            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n\n            Cipher cipher = Cipher.getInstance(\"RSA/None/NoPadding\",\"BC\");\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n\n            byte[] cipherData = cipher.doFinal(message);\n            return new String(cipherData, \"UTF-8\");\n        }\n\n        private PrivateKey loadCASPrivateKey() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n            InputStream is = getClass().getResourceAsStream( \"/keys/app-private.key\" );\n            if (is == null) {\n                System.out.println(\"NULL\");\n            }\n            byte[] encodedPrivateKey = new byte[(int) 1216];\n            is.read(encodedPrivateKey);\n            is.close();\n\n            // Generate KeyPair.\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n\n            PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(encodedPrivateKey);\n            PrivateKey privateKey = keyFactory.generatePrivate(privateKeySpec);\n\n            return privateKey;\n\n        }\n", "try {\n      KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n      trustStore.load(null, null);\n      sf = new MySSLSocketFactory(trustStore);\n      sf.setHostnameVerifier(MySSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n      client.setSSLSocketFactory(sf);   \n    }\n    catch (Exception e) {   \n    }\n", "public class MySSLSocketFactory extends SSLSocketFactory\n                                throws NoSuchAlgorithmException {\n\n    private SSLContext mSSLContext;\n\n    public MySSLSocketFactory(KeyManager km) {\n        ...\n        mSSLContext = SSLContext.getInstance(\"TLSv1.2\");\n        ...\n        mSSLContext.init(new KeyManager[] {km}, null, null);\n        ...\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)\n                    throws IOException {\n        SSLSocket s = (SSLSocket)mSSLContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n        s.setEnabledProtocols(new String[] {\"TLSv1.2\"} );\n        return s;\n    }\n\n    ...\n}\n", "public class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try\n\n        {\n\n            PackageInfo info = getPackageManager().getPackageInfo(\"Your package name here\",PackageManager.GET_SIGNATURE);\n\n            for (Signature signature : info.signatures)\n            {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } \n        catch (NameNotFoundException e)\n        {\n            System.out.println(\"name not found....\"+e);\n        } catch (NoSuchAlgorithmException e) \n        {\n            System.out.println(\"NoSuchAlgorithmException....\"+e);\n        }\n    }\n}\n", "import java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\n\nimport android.util.Base64\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\n\npublic class EncryptDecryptTest {\n\n  public static void main(String[] args) throws Exception {\n    String key = \"12345678\";\n    String ciphertext = encrypt(key, \"foo\");\n\n    String decrypted = decrypt(key, ciphertext.trim());\n    String encrypted = encrypt(key, decrypted.trim());\n\n    if (ciphertext.contentEquals(encrypted.trim())) {\n      System.out.println(\"decrypted!\");\n    } else {\n      System.out.println(\"wrong key!\");\n    }\n  }\n\n  public static String encrypt(String key, String data)\n      throws GeneralSecurityException, UnsupportedEncodingException {\n    DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(\"UTF8\"));\n    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n    byte[] dataBytes = data.getBytes(\"UTF8\");\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    return Base64.encodeToString(cipher.doFinal(dataBytes), Base64.DEFAULT);\n  }\n\n  public static String decrypt(String key, String data)\n      throws GeneralSecurityException, UnsupportedEncodingException {\n    byte[] dataBytes = Base64.decode(data, Base64.DEFAULT);\n    DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(\"UTF8\"));\n    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n    byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));\n    return new String(dataBytesDecrypted);\n  }    \n}\n", "    KeyPair keys = null;\n    try {\n        RSAKeyGenParameterSpec spec = new RSAKeyGenParameterSpec(1024, RSAKeyGenParameterSpec.F4);\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(spec);\n        keys = keyGen.generateKeyPair();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n\n    if(keys != null){\n        PublicKey mPublicKey = (PublicKey) keys.getPublic();\n        PrivateKey mPrivateKey = (PrivateKey) keys.getPrivate();\n    }\n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(\"com.your_package_name\",\n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"YOURHASH KEY:\",\n                        Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n", "MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\nbyte[] hash = digest.digest(text.getBytes(\"UTF-8\"));\n", "        String aid = Settings.Secure.getString(context.getContentResolver(), \"android_id\");\n        try {\n            Object obj;\n            ((MessageDigest) (obj = MessageDigest.getInstance(\"MD5\"))).update(aid.getBytes(), 0, aid.length());\n\n            aid = String.format(\"%032X\", new Object[] { new BigInteger(1, ((MessageDigest) obj).digest()) });\n        } catch (NoSuchAlgorithmException localNoSuchAlgorithmException) {\n            aid = aid.substring(0, 32);\n        }\n\n        adRequest.addTestDevice(aid);\n", "KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\nFile p12File = GET_CERT();\nFileInputStream fis = new FileInputStream(p12File);\nBufferedInputStream bis = new BufferedInputStream(fis);\nkeyStore.load(bis, password.toCharArray()); // password is the PKCS#12 password. If there is no password, just pass null\nEnumeration&lt;String&gt; aliases = keyStore.aliases();\nwhile (aliases.hasMoreElements()) {\n    String alias = aliases.nextElement();\n    /* Do something with the keystore entry */\n}\n", "String alias = aliases.nextElement();\nif (keyStore.isCertificateEntry(alias)) { // keep only trusted cert entries\n    Certificate caCert = keyStore.getCertificate(alias)\n    byte[] extraCertificate = caCert.getEncoded();\n    Intent installIntent = KeyChain.createInstallIntent();\n    installIntent.putExtra(KeyChain.EXTRA_CERTIFICATE, extraCertificate);\n    installIntent.putExtra(KeyChain.EXTRA_NAME, MY_CERT);\n    startActivityForResult(installIntent, INSTALL_KEYCHAIN_CODE);\n}\n", "public class GMailSender extends javax.mail.Authenticator \n{   \n    private String mailhost = \"smtp.gmail.com\";   \n    private String user;   \n    private String password;   \n    private Session session;   \n    private Multipart _multipart;\n\n    static \n    {   \n        Security.addProvider(new JSSEProvider());   \n    }  \n\n    public GMailSender(String user, String password) \n    {   \n        this.user = user;   \n        this.password = password;   \n\n        Properties props = new Properties();   \n        props.setProperty(\"mail.transport.protocol\", \"smtp\");   \n        props.setProperty(\"mail.host\", mailhost);   \n        props.put(\"mail.smtp.auth\", \"true\");   \n        props.put(\"mail.smtp.port\", \"465\");   \n        props.put(\"mail.smtp.socketFactory.port\", \"465\");   \n        props.put(\"mail.smtp.socketFactory.class\",\"javax.net.ssl.SSLSocketFactory\");   \n        props.put(\"mail.smtp.socketFactory.fallback\", \"false\");   \n        props.setProperty(\"mail.smtp.quitwait\", \"false\");   \n\n        session = Session.getDefaultInstance(props, this);\n        _multipart = new MimeMultipart();\n    }   \n\n    protected PasswordAuthentication getPasswordAuthentication() \n    {   \n        return new PasswordAuthentication(user, password);   \n    }   \n\n    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception \n    {   \n        MimeMessage message = new MimeMessage(session);   \n        DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));   \n        message.setSender(new InternetAddress(sender));   \n        message.setSubject(subject);   \n\n        message.setDataHandler(handler);   \n        message.setContent(_multipart);\n        if (recipients.indexOf(',') &gt; 0)   \n            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   \n        else  \n            message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   \n        Transport.send(message);   \n\n    }   \n\n    public void addAttachment(String filename) throws Exception \n    {\n        BodyPart messageBodyPart = new MimeBodyPart();\n        DataSource source = new FileDataSource(filename);\n        messageBodyPart.setDataHandler(new DataHandler(source));\n        messageBodyPart.setFileName(filename);\n\n        _multipart.addBodyPart(messageBodyPart);\n    }\n\n    public class ByteArrayDataSource implements DataSource \n    {   \n        private byte[] data;   \n        private String type;   \n\n        public ByteArrayDataSource(byte[] data, String type) \n        {   \n            super();   \n            this.data = data;   \n            this.type = type;   \n        }   \n\n        public ByteArrayDataSource(byte[] data) \n        {   \n            super();   \n            this.data = data;   \n        }   \n\n        public void setType(String type) \n        {   \n            this.type = type;   \n        }   \n\n        public String getContentType() \n        {   \n            if (type == null)   \n                return \"application/octet-stream\";   \n            else  \n                return type;   \n        }   \n\n        public InputStream getInputStream() throws IOException \n        {   \n            return new ByteArrayInputStream(data);   \n        }   \n\n        public String getName() \n        {   \n            return \"ByteArrayDataSource\";   \n        }   \n\n        public OutputStream getOutputStream() throws IOException \n        {   \n            throw new IOException(\"Not Supported\");   \n        }   \n    }   \n}\n", "import sun.security.util.ObjectIdentifier;\nimport sun.security.x509.X509CertImpl;\nimport java.util.regex.Matcher;  \nimport java.util.regex.Pattern;\n\nclass readCert{\n\n    public boolean isExtAuthorityInfoAccess(Extension ext){\n        Pattern re = Pattern.compile(\"\\\\bcaIssuers\\\\b\",Pattern.CASE_INSENSITIVE);\n        Matcher m = re.matcher(ext.toString());\n        if (m.find()) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    public static List&lt;String&gt; getAuthorityInfoAccesssUrls(String text)\n    {\n        List&lt;String&gt; containedUrls = new ArrayList&lt;String&gt;();\n        Pattern pattern = Pattern.compile(\n                \"(?:^|[\\\\W])((ht|f)tp(s?):\\\\/\\\\/|www\\\\.)\"\n                        + \"(([\\\\w\\\\-]+\\\\.){1,}?([\\\\w\\\\-.~]+\\\\/?)*\"\n                        + \"[\\\\p{Alnum}.,%_=?&amp;#\\\\-+()\\\\[\\\\]\\\\*$~@!:/{};']*)\",\n                Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);\n        Matcher urlMatcher = pattern.matcher(text);\n        while (urlMatcher.find())\n        {\n            containedUrls.add(text.substring(urlMatcher.start(0),\n                    urlMatcher.end(0)));\n        }\n        return containedUrls;\n    };\n\n    public static void main(String[] args) {\n\n        readCert rc = new readCert();\n\n        try {\n            File file = new File(\"yourcert.crt\");\n            byte[] encCert = new byte[(int) file.length()];\n            FileInputStream fis = new FileInputStream(file);\n            fis.read(encCert);\n            fis.close();\n\n            InputStream in = new ByteArrayInputStream(encCert);\n            CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n            X509Certificate cert = (X509Certificate)certFactory.generateCertificate(in);\n\n            X509CertImpl impl = (X509CertImpl)cert;\n            int extnum = 0;\n            if (cert.getNonCriticalExtensionOIDs() != null) {\n                for (String extOID : cert.getNonCriticalExtensionOIDs()) {\n                    Extension ext = impl.getExtension(new ObjectIdentifier(extOID));\n                    if (ext != null) {\n                        if (rc.isExtAuthorityInfoAccess(ext)) {\n                            System.out.println(rc.getAuthorityInfoAccesssUrls(ext.toString()));\n                            // System.out.println(\"#\"+(++extnum)+\": \"+ ext.toString());\n                            // CA ISSUERS ARE HERE\n                        }\n                    }\n                }\n            }\n        } catch (  Exception e) {\n            e.printStackTrace();\n          };\n    }\n}\n", "PackageManager pm = context.getPackageManager();\nSignature sig = packageManager.getPackageInfo(getPackageName(), \n   PackageManager.GET_SIGNATURES).signatures[0];\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\nX509Certificate cert = (X509Certificate) cf.generateCertificate(\n    new ByteArrayInputStream(sig.toByteArray()));\nString dn = cert.getIssuerDN().getName();\n", "SSLcontext sslContext = SSLContext.getDefault();\n\nKeyStore trustSt = KeyStore.getInstance(\"BKS\");\nTrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\nInputStream trustStoreStream = this.getResources().openRawResource(R.raw.truststore);\ntrustSt.load(trustStoreStream, \"&lt;yourpassword&gt;\".toCharArray());\ntrustManagerFactory.init(trustStre);\n\nKeyStore keyStore = KeyStore.getInstance(\"BKS\");\nKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nInputStream keyStoreStream = this.getResources().openRawResource(R.raw.keystore);\nkeyStore.load(keyStoreStream, \"&lt;yourpassword&gt;\".toCharArray());\nkeyManagerFactory.init(keyStore, \"&lt;yourpassword&gt;\".toCharArray());\n\nsslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n", "public class SEncryption {\n\nprivate static final String ALGO = \"AES\";\nprivate static final byte[] keyValue = new byte[] { 'O', 'u', 'r', 'B',\n'e', 's', 't','S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y' };\n\npublic static String encrypt(String Data) throws Exception {\nKey key = generateKey();\nCipher c = Cipher.getInstance(ALGO);\nc.init(Cipher.ENCRYPT_MODE, key);\nbyte[] encVal = c.doFinal(Data.getBytes());\nBase64 ob=new Base64();\nString encryptedValue = Base64.encodeBytes(encVal);\nreturn encryptedValue;\n}\n\npublic static String decrypt(String encryptedData) throws Exception {\nKey key = generateKey();\nCipher c = Cipher.getInstance(ALGO);\nc.init(Cipher.DECRYPT_MODE, key);\nbyte[] decordedValue = Base64.decode(encryptedData);\nbyte[] decValue = c.doFinal(decordedValue);\nString decryptedValue = new String(decValue);\nreturn decryptedValue;\n}\n\nprivate static Key generateKey() throws Exception {\nKey key = new SecretKeySpec(keyValue, ALGO);\nreturn key;\n}\npublic static void main(String[] args) throws Exception {\n\n        String password = \"346333\";\n        String passwordEnc = encrypt(password);\n        String passwordDec = decrypt(passwordEnc);\n\n        System.out.println(\"Plain Text : \" + password);\n        System.out.println(\"Encrypted Text : \" + passwordEnc);\n        System.out.println(\"Decrypted Text : \" + passwordDec);\n    }\n\n}\n", "import java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AES {\n     public void run() {\n         try {\n             String text = \"Hello World\";\n             String key = \"1234567891234567\";\n             // Create key and cipher\n             Key aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n             Cipher cipher = Cipher.getInstance(\"AES\");\n\n         // encrypt the text\n         cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n         byte[] encrypted = cipher.doFinal(text.getBytes());\n         System.out.println(\"Encrypted text: \" + new String(encrypted));\n\n         // decrypt the text\n         cipher.init(Cipher.DECRYPT_MODE, aesKey);\n         String decrypted = new String(cipher.doFinal(encrypted));\n         System.out.println(\"Decrypted text: \" + decrypted);\n      }catch(Exception e) {\n         e.printStackTrace();\n      }\n    }\n\n    public static void main(String[] args) {\n        AES app = new AES();\n       app.run();\n    }\n}\n", "KeyStore store = KeyStore.getInstance(\"BKS\");\nInputStream truststore = mainActivity.getResources().openRawResource(R.raw.trust);\nstore.load(truststore, \"PASSWORD\".toCharArray());\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\ntmf.init(store);\nSSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, tmf.getTrustManagers(), new SecureRandom());\nSocket socket = context.getSocketFactory().createSocket(ip, port);\n", "Try this code, it works fine for me:\n\n//Creating xml file\n\nDocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();\n             dbfac.setNamespaceAware(true);\n             DocumentBuilder docBuilder = null;\n             try {\n                docBuilder = dbfac.newDocumentBuilder();\n            } catch (ParserConfigurationException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n             DOMImplementation domImpl = docBuilder.getDOMImplementation();\n             Document document = domImpl.createDocument(\"http://coggl.com/InsertTrack\",\"TrackEntry\", null);\n             document.setXmlVersion(\"1.0\");\n             document.setXmlStandalone(true);\n\n             Element trackElement = document.getDocumentElement();\n\n             Element CompanyId = document.createElement(\"CompanyId\");\n             CompanyId.appendChild(document.createTextNode(\"1\"));\n             trackElement.appendChild(CompanyId);\n\n             Element CreatedBy = document.createElement(\"CreatedBy\");\n             CreatedBy.appendChild(document.createTextNode(\"6\"));\n             trackElement.appendChild(CreatedBy);\n\n             Element DepartmentId = document.createElement(\"DepartmentId\");\n             DepartmentId.appendChild(document.createTextNode(\"4\"));\n             trackElement.appendChild(DepartmentId);\n\n             Element IsBillable = document.createElement(\"IsBillable\");\n             IsBillable.appendChild(document.createTextNode(\"1\"));\n             trackElement.appendChild(IsBillable);\n\n             Element ProjectId = document.createElement(\"ProjectId\");\n             ProjectId.appendChild(document.createTextNode(\"1\"));\n             trackElement.appendChild(ProjectId);\n\n             Element StartTime = document.createElement(\"StartTime\");\n             StartTime.appendChild(document.createTextNode(\"2012-03-14 10:44:45\"));\n             trackElement.appendChild(StartTime);\n\n             Element StopTime = document.createElement(\"StopTime\");\n             StopTime.appendChild(document.createTextNode(\"2012-03-14 11:44:45\"));\n             trackElement.appendChild(StopTime);\n\n             Element TaskId = document.createElement(\"TaskId\");\n             TaskId.appendChild(document.createTextNode(\"3\"));\n             trackElement.appendChild(TaskId);\n\n             Element TotalTime = document.createElement(\"TotalTime\");\n             TotalTime.appendChild(document.createTextNode(\"1\"));\n             trackElement.appendChild(TotalTime);\n\n             Element TrackDesc = document.createElement(\"TrackDesc\");\n             TrackDesc.appendChild(document.createTextNode(\"testing\"));\n             trackElement.appendChild(TrackDesc);\n\n             Element TrackId = document.createElement(\"TrackId\");\n             TrackId.appendChild(document.createTextNode(\"0\"));\n             trackElement.appendChild(TrackId);\n\n             TransformerFactory transfac = TransformerFactory.newInstance();\n             Transformer trans = null;\n            try {\n                trans = transfac.newTransformer();\n            } catch (TransformerConfigurationException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n             trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n             trans.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\n             //create string from xml tree\n             StringWriter sw = new StringWriter();\n             StreamResult result = new StreamResult(sw);\n             DOMSource source = new DOMSource(doc);\n             try {\n                trans.transform(source, result);\n            } catch (TransformerException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n             String xmlString = sw.toString();\n\n//posting xml file to server\n\n             DefaultHttpClient httpClient = new DefaultHttpClient();\n\n             HttpPost httppost = new HttpPost(\"http://192.168.0.19:3334/cogglrestservice.svc/InsertTrack\");     \n             // Make sure the server knows what kind of a response we will accept\n             httppost.addHeader(\"Accept\", \"text/xml\");\n             // Also be sure to tell the server what kind of content we are sending\n             httppost.addHeader(\"Content-Type\", \"application/xml\");\n\n             try\n             {\n             StringEntity entity = new StringEntity(xmlString, \"UTF-8\");\n             entity.setContentType(\"application/xml\");\n             httppost.setEntity(entity);\n\n             // execute is a blocking call, it's best to call this code in a thread separate from the ui's\n             HttpResponse response = httpClient.execute(httppost);\n\n             BasicResponseHandler responseHandler = new BasicResponseHandler();\n                String strResponse = null;\n                if (response != null) {\n                    try {\n                        strResponse = responseHandler.handleResponse(response);\n                    } catch (HttpResponseException e) {\n                        e.printStackTrace();  \n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                Log.e(\"WCFTEST\", \"WCFTEST ********** Response\" + strResponse);    \n\n\n             }\n             catch (Exception ex)\n             {\n             ex.printStackTrace();\n             }\n             Toast.makeText(EditTask.this, \"Xml posted succesfully.\",Toast.LENGTH_SHORT).show();\n", "    &gt;     Try using TrustManagerManipulator Class:\n\n\n\n\n              try {\n                                TrustManagerManipulator.allowAllSSL();\n                                try {\n                                    SoapObject request = new SoapObject(Data.NAMESPACE,\n                                            methodName);\n\n                                    SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(\n                                            SoapEnvelope.VER11);\n\n                                    if (methodName.equals(Data.DOPAYMENT))\n\n                                    {\n                                        request.addProperty(\"firstname\", param1);\n                                        request.addProperty(\"lastName\", param2);\n\n                envelope.dotNet = true;\n                                envelope.setOutputSoapObject(request);\n                                envelope.env = \"http://schemas.xmlsoap.org/soap/envelope/\";\n                                TrustManagerManipulator.allowAllSSL();\n                                System.setProperty(\"http.keepAlive\", \"false\");\n\n                                HttpTransportSE androidHttpTransport = new HttpTransportSE(\n                                        Data.URL_BASE);\n                                androidHttpTransport\n                                        .setXmlVersionTag(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?&gt;\");\n\n                                try {\n                                    androidHttpTransport.call(Data.SOAP_ACTION,\n                                            envelope);\n                                } catch (Exception e) {\n                                    e.printStackTrace();\n                                    Toast.makeText(context, \"Network failed!\",\n                                            Toast.LENGTH_LONG).show();\n                                    dismissDialog();\n                                }\n                                SoapObject resultsRequestSOAP = (SoapObject) envelope.bodyIn;\n                                String responseLocal = resultsRequestSOAP.toString();\n                                responseXML = (String) resultsRequestSOAP\n                                        .getProperty(0);\n                                Log.v(\"responseXML0::\", \"\" + responseXML);\n\n                                Log.v(\"responseSTR\", \"\" + responseLocal);\n\n\n\n\n///////////////////////////////////\n\n&gt; TrustManagerManipulator Class\n\n\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class TrustManagerManipulator implements X509TrustManager {\n\n\n    private static TrustManager[] trustManagers;\n    private static final X509Certificate[] acceptedIssuers = new X509Certificate[] {};\n\n    public boolean isClientTrusted(X509Certificate[] chain) {\n        return true;\n    }\n\n    public boolean isServerTrusted(X509Certificate[] chain) {\n        return true;\n    }\n\n    public static void allowAllSSL() \n    {\n\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n        SSLContext context = null;\n        if (trustManagers == null) {\n            trustManagers = new TrustManager[] { new TrustManagerManipulator() };\n        }\n        try {\n            context = SSLContext.getInstance(\"TLS\");\n            context.init(null, trustManagers, new SecureRandom());\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (KeyManagementException e) {\n            e.printStackTrace();\n        }\n        HttpsURLConnection.setDefaultSSLSocketFactory(context\n                .getSocketFactory());\n    }\n\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n    }\n\n    public X509Certificate[] getAcceptedIssuers() {\n        return acceptedIssuers;\n    }\n}\n", "    public  void showHashKey(Context context) {\n        try {\n            PackageInfo info = context.getPackageManager().getPackageInfo(\"com.superreceptionist\",\n                    PackageManager.GET_SIGNATURES);\n            for (android.content.pm.Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n\n                 String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);\n                Log.e(\"KeyHash:\", sign);\n                //  Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();\n            }\n            Log.d(\"KeyHash:\", \"****------------***\");\n        } catch (PackageManager.NameNotFoundException e) {\ne.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\ne.printStackTrace();\n        }\n    }\n", "// Create a trust manager that does not validate certificate chains\nTrustManager[] trustAllCerts = new TrustManager[]{\n    new X509TrustManager() {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n        public void checkClientTrusted(\n            java.security.cert.X509Certificate[] certs, String authType) {\n        }\n        public void checkServerTrusted(\n            java.security.cert.X509Certificate[] certs, String authType) {\n        }\n    }\n};\n\n// Install the all-trusting trust manager\ntry {\n    SSLContext sc = SSLContext.getInstance(\"SSL\");\n    sc.init(null, trustAllCerts, new java.security.SecureRandom());\n    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n} catch (Exception e) {\n}\n\n// Now you can access an https URL without having the certificate in the truststore\n// It should work with expired certificate as well\ntry {\n    URL myUrl = new URL(\"https://www.....\");\n} catch (MalformedURLException e) {\n}\n", "TrustManagerFactory tmf = TrustManagerFactory.getInstance(\n    TrustManagerFactory.getDefaultAlgorithm());\n// Initialise the TMF as you normally would, for example:\ntmf.init((KeyStore)null); \n\nTrustManager[] trustManagers = tmf.getTrustManagers();\nfinal X509TrustManager origTrustmanager = (X509TrustManager)trustManagers[0];\n\nTrustManager[] wrappedTrustManagers = new TrustManager[]{\n   new X509TrustManager() {\n       public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n          return origTrustmanager.getAcceptedIssuers();\n       }\n\n       public void checkClientTrusted(X509Certificate[] certs, String authType) {\n           origTrustmanager.checkClientTrusted(certs, authType);\n       }\n\n       public void checkServerTrusted(X509Certificate[] certs, String authType) {\n           try {\n               origTrustmanager.checkServerTrusted(certs, authType);\n           } catch (CertificateExpiredException e) {}\n       }\n   }\n};\n\nSSLContext sc = SSLContext.getInstance(\"TLS\");\nsc.init(null, wrappedTrustManagers, null);\nHttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n", "private void getHashKey(String pkgName)\n{\n    try\n    {\n        PackageInfo info = getPackageManager().getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures)\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String hashKey = Base64.encodeBytes(md.digest());\n            _hashKey_et.setText(hashKey);\n            Log.i(\"KeyTool\", pkgName + \" -&gt; hashKey = \" + hashKey);\n        }\n    }\n    catch (NameNotFoundException e)\n    {\n        e.printStackTrace();\n    }\n    catch (NoSuchAlgorithmException e)\n    {\n        e.printStackTrace();\n    }\n}\n", "...\n\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(kmf.getKeyManagers(),tmf.getTrustManagers(), new SecureRandom());\n    SSLEngine sslEngine = sslContext.createSSLEngine();\n    sslEngine.setUseClientMode(true);\n    SslHandler sslHandler = new SslHandler(sslEngine);\n    channel.pipeline().addFirst(sslHandler)\n\n...\n", "/**\n * \n * @param PEMString  -A file/string in .pem format with a generated RSA key (with \"des3\", using \"openssl genrsa\".)\n * @param isFilePath - If it's a file path or a string\n * @return java.security.PublicKey\n * @throws IOException -No key found\n * @throws NoSuchAlgorithmException \n * @throws InvalidKeySpecException \n * \n * @author hsigmond\n */\n\nprivate static PublicKey getPublicKeyFromPemFormat(String PEMString,\n        boolean isFilePath) throws IOException, NoSuchAlgorithmException,\n        InvalidKeySpecException {\n\n    BufferedReader pemReader = null;\n    if (isFilePath) {\n        pemReader = new BufferedReader(new InputStreamReader(\n                new FileInputStream(PEMString)));\n    } else {\n        pemReader = new BufferedReader(new InputStreamReader(\n                new ByteArrayInputStream(PEMString.getBytes(\"UTF-8\"))));\n    }\n    StringBuffer content = new StringBuffer();\n    String line = null;\n    while ((line = pemReader.readLine()) != null) {\n        if (line.indexOf(\"-----BEGIN PUBLIC KEY-----\") != -1) {\n            while ((line = pemReader.readLine()) != null) {\n                if (line.indexOf(\"-----END PUBLIC KEY\") != -1) {\n                    break;\n                }\n                content.append(line.trim());\n            }\n            break;\n        }\n    }\n    if (line == null) {\n        throw new IOException(\"PUBLIC KEY\" + \" not found\");\n    }\nLog.i(\"PUBLIC KEY: \", \"PEM content = : \" + content.toString());\n\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n    return keyFactory.generatePublic(new X509EncodedKeySpec(Base64.decode(content.toString(), Base64.DEFAULT)));\n\n}\n", "/**\n * \n * @param PEMString  -A file/string in .pem format with a generated RSA key (with \"des3\", using \"openssl genrsa\".)\n * @param content\n * @return String value of content Decoded\n * @throws NoSuchAlgorithmException\n * @throws InvalidKeySpecException\n * @throws IOException\n * @throws NoSuchProviderException\n * @throws NoSuchPaddingException\n * @throws InvalidKeyException\n * @throws IllegalBlockSizeException\n * @throws BadPaddingException\n * \n * @author hsigmond\n */\n\n\n    public static String getContentWithPublicKeyFromPemFormat(String PEMString,\n        String content,boolean isFilePath) throws NoSuchAlgorithmException,\n        InvalidKeySpecException, IOException, NoSuchProviderException,\n        NoSuchPaddingException, InvalidKeyException,\n        IllegalBlockSizeException, BadPaddingException {\n\n    PublicKey publicKey = getPublicKeyFromPemFormat(PEMString,isFilePath);\n    if (publicKey != null)\n        Log.i(\"PUBLIC KEY: \", \"FORMAT : \" + publicKey.getFormat()\n                + \" \\ntoString : \" + publicKey.toString());\n\n    byte[] contentBytes = Base64.decode(content, Base64.DEFAULT);\n    byte[] decoded = null;\n\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"BC\");//BC=BouncyCastle Provider\n    cipher.init(Cipher.DECRYPT_MODE, publicKey);\n    decoded = cipher.doFinal(contentBytes);\n    return new String(decoded, \"UTF-8\");\n}\n", "(...)\npublic static class GetJsonTask extends AsyncTask&lt;Void, Integer, AsyncResponse&gt; {\n\n    protected String jsonData;\n\n    protected IGetJsonListener listener;\n    protected Context context = null;\n    protected String strUrl;\n\n    public GetJsonTask(Context c, IGetJsonListener l, String strUrl) {\n        super();\n        listener = l;\n        context = c;\n        this.strUrl = strUrl;\n    }\n\n    @Override\n    protected AsyncResponse doInBackground(Void... Void) {\n\n        JsonObject jsonObjectResult = new JsonObject();\n        APIStatus status;\n\n        if (isConnected(context)) {\n            HttpsURLConnection httpsURLConnection=null;\n            try {\n                //THIS IS KEY: context contains only our CA cert\n                SSLContext sslContext = getSSLContext(context);\n                if (sslContext != null) {\n                    //for HTTP BASIC AUTH if your server implements this\n                    //String encoded = Base64.encodeToString(\n                    //        (\"your_user_name\" + \":\" + \"your_pwd\").getBytes(),\n                    //        Base64.DEFAULT);\n                    URL url = new URL(strUrl);\n                    httpsURLConnection = (HttpsURLConnection) url.openConnection();\n                    httpsURLConnection.setRequestMethod(\"GET\");\n                    httpsURLConnection.setRequestProperty(\"Content-length\", \"0\");\n                    httpsURLConnection.setUseCaches(false);\n                    httpsURLConnection.setAllowUserInteraction(false);\n                    //FOR HTTP BASIC AUTH\n                    //httpsURLConnection.setRequestProperty(\"Authorization\", \"Basic \" + encoded);\n                    //THIS IS KEY: Set connection to use custom socket factory\n                    httpsURLConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n                    //httpsURLConnection.setConnectTimeout(timeout);\n                    //httpsURLConnection.setReadTimeout(timeout);\n                    httpsURLConnection.connect();\n                    status = getStatusFromCode(httpsURLConnection.getResponseCode());\n\n\n                    listener.getJsonShowProgress(90);\n\n                    if (status == APIStatus.OK) {\n\n                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(httpsURLConnection.getInputStream()));\n                        StringBuilder stringBuilder = new StringBuilder();\n\n                        String line;\n                        while ((line = bufferedReader.readLine()) != null) {\n                            stringBuilder.append(line);\n                        }\n                        bufferedReader.close();\n                        JsonParser parser = new JsonParser();\n                        String s = stringBuilder.toString();\n                        jsonObjectResult = (JsonObject) parser.parse(s);\n                    }\n                } else\n                    status = APIStatus.AUTH_ERROR;\n                listener.getJsonShowProgress(99);\n            //THIS IS KEY: this exception is thrown if the certificate\n            //is signed by a CA that is not our CA\n            } catch (SSLHandshakeException e) {\n                status = APIStatus.AUTH_ERROR;\n                //React to what is probably a man-in-the-middle attack\n            } catch (IOException e) {\n                status = APIStatus.NET_ERROR;\n            } catch (JsonParseException e) {\n                status = APIStatus.JSON_ERROR;\n            } catch (Exception e) {\n                status = APIStatus.UNKNOWN_ERROR;\n            } finally {\n                if (httpsURLConnection != null)\n                    httpsURLConnection.disconnect();\n            }\n        } else {\n            status = APIStatus.NET_ERROR;\n        }\n        // if not successful issue another call for the next hour.\n        AsyncResponse response = new AsyncResponse();\n        response.jsonData = jsonObjectResult;\n        response.opStatus = status;\n\n        return response;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        if (listener != null)\n            listener.getJsonStartProgress();\n    }\n\n    @Override\n    protected void onProgressUpdate(Integer... progress) {\n        listener.getJsonShowProgress(progress[0]);\n    }\n\n    @Override\n    protected void onPostExecute(AsyncResponse result) {\n        listener.getJsonFinished(result.jsonData, result.opStatus);\n    }\n\n    public  interface IGetJsonListener {\n        void getJsonStartProgress();\n        void getJsonShowProgress(int percent);\n        void getJsonFinished(JsonObject resJson, APIStatus status);\n    }\n}\nprivate static SSLContext getSSLContext(Context context){\n    //Mostly taken from the Google code link in the question.\n    try {\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n\n        AssetManager am = context.getAssets();\n        //THIS IS KEY: Your CA's cert stored in /assets/\n        InputStream caInput = new BufferedInputStream(am.open(\"RootCA.crt\"));\n        Certificate ca;\n        try {\n            ca = cf.generateCertificate(caInput);\n            //System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n        } finally {\n            caInput.close();\n        }\n\n        // Create a KeyStore containing our trusted CAs\n        String keyStoreType = KeyStore.getDefaultType();\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        keyStore.load(null, null);\n        keyStore.setCertificateEntry(\"ca\", ca);\n\n        // Create a TrustManager that trusts the CAs in our KeyStore\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n\n        // Create an SSLContext that uses our TrustManager\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, tmf.getTrustManagers(), null);\n        return sslContext;\n    } catch (Exception e){\n        return null;\n    }\n\n}\n\npublic enum APIStatus {\n    OK(\"OK.\", 200), //all went well\n    JSON_ERROR(\"Error parsing response.\", 1),\n    NET_ERROR(\"Network error.\", 2), //we couldn't reach the server\n    UNKNOWN_ERROR(\"Unknown error.\", 3), //some sh*t went down\n\n    AUTH_ERROR(\"Authentication error.\", 401), //credentials where wrong\n    SERVER_ERROR(\"Internal server error.\", 500), //server code crashed\n    TIMEOUT(\"Operation timed out.\", 408); //network too slow or server overloaded\n\n    private String stringValue;\n    private int intValue;\n\n    private APIStatus(String toString, int value) {\n        stringValue = toString;\n        intValue = value;\n    }\n\n    @Override\n    public String toString() {\n        return stringValue;\n    }\n}\n\nprivate static APIStatus getStatusFromCode(int code) {\n\n    if (code==200 || code==201) {\n        return APIStatus.OK;\n    }else if (code == 401) {\n        return APIStatus.AUTH_ERROR;\n    } else if (code == 500) {\n        return APIStatus.SERVER_ERROR;\n    } else if (code == 408) {\n        return APIStatus.TIMEOUT;\n    } else {\n        return APIStatus.UNKNOWN_ERROR;\n    }\n\n}\n\nprivate static class AsyncResponse {\n    public APIStatus opStatus;\n    public JsonObject jsonData;\n}\n(...)\n", "KeyStore localTrustStore = KeyStore.getInstance(\"BKS\");\nInputStream in = getResources().openRawResource(R.raw.mytruststore);\nlocalTrustStore.load(in, TRUSTSTORE_PASSWORD.toCharArray());\n\nSchemeRegistry schemeRegistry = new SchemeRegistry();\nschemeRegistry.register(new Scheme(\"http\", PlainSocketFactory\n                .getSocketFactory(), 80));\nSSLSocketFactory sslSocketFactory = new SSLSocketFactory(localTrustStore);\nschemeRegistry.register(new Scheme(\"https\", sslSocketFactory, 443));\nHttpParams params = new BasicHttpParams();\nClientConnectionManager cm = \n    new ThreadSafeClientConnManager(params, schemeRegistry);\n\nHttpClient client = new DefaultHttpClient(cm, params); \n", "static String encodeString(String input) {\n    MessageDigest digest = null;\n    try {\n        digest = MessageDigest.getInstance(\"SHA-1\");\n        byte[] inputBytes = input.getBytes();\n        byte[] hashBytes = digest.digest(inputBytes);\n        return Base64.encodeToString(hashBytes, Base64.NO_WRAP);\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(TAG_TEST, e.getMessage(), e);\n    }\n    return \"\";\n}\n", "// der formated certificate as byte[]\nprivate static final byte[] CACERTROOTDER = new byte[]{\n        48, -126, 7, 61, 48, -126, 5, 37, -96, 3, 2, 1, 2, 2, 1, 0,\n        // ...\n        };\n\n/**\n * Read x509 certificated file from byte[].\n *\n * @param bytes certificate in der format\n * @return certificate\n */\nprivate static X509Certificate getCertificate(final byte[] bytes)\n        throws IOException, CertificateException {\n    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n    X509Certificate ca;\n    ByteArrayInputStream is = new ByteArrayInputStream(bytes);\n    try {\n        ca = (X509Certificate) cf.generateCertificate(is);\n        Log.d(TAG, \"ca=\", ca.getSubjectDN());\n    } finally {\n        is.close();\n    }\n    return ca;\n}\n\n/**\n * Trust only CAcert's CA. CA cert is injected as byte[]. Following best practices from\n * https://developer.android.com/training/articles/security-ssl.html#UnknownCa\n */\nprivate static void trustCAcert()\n        throws KeyStoreException, IOException,\n        CertificateException, NoSuchAlgorithmException,\n        KeyManagementException {\n    // Create a KeyStore containing our trusted CAs\n    String keyStoreType = KeyStore.getDefaultType();\n    final KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n    keyStore.load(null, null);\n    keyStore.setCertificateEntry(\"CAcert-root\", getCertificate(CACERTROOTDER));\n    // if your HTTPd is not sending the full chain, add class3 cert to the key store\n    // keyStore.setCertificateEntry(\"CAcert-class3\", getCertificate(CACERTCLASS3DER));\n\n    // Create a TrustManager that trusts the CAs in our KeyStore\n    final TrustManagerFactory tmf = TrustManagerFactory.getInstance(\n            TrustManagerFactory.getDefaultAlgorithm());\n    tmf.init(keyStore);\n\n    // Create an SSLContext that uses our TrustManager\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n        // may work on HC+, but there is no AVD or device to test it\n        sslContext.init(null, tmf.getTrustManagers(), null);\n    } else {\n        // looks like CLR is broken in lower APIs. implement out own checks here :x\n        // see http://stackoverflow.com/q/18713966/2331953\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n            public boolean verify(final String hostname, final SSLSession session) {\n                try {\n                    // check if hostname matches DN\n                    String dn = session.getPeerCertificateChain()[0].getSubjectDN().toString();\n\n                    Log.d(TAG, \"DN=\", dn);\n                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD) {\n                        return dn.equals(\"CN=\" + hostname);\n                    } else {\n                        // no SNI on API&lt;9, but I know the first vhost's hostname\n                        return dn.equals(\"CN=\" + hostname)\n                                || dn.equals(\"CN=\" + hostname.replace(\"jsonrpc\", \"rest\"));\n                    }\n                } catch (Exception e) {\n                    Log.e(TAG, \"unexpected exception\", e);\n                    return false;\n                }\n            }\n        });\n\n        // build our own trust manager\n        X509TrustManager tm = new X509TrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                // nothing to do\n                return new X509Certificate[0];\n            }\n\n            @Override\n            public void checkClientTrusted(final X509Certificate[] chain,\n                    final String authType)\n                    throws CertificateException {\n                // nothing to do\n            }\n\n            @Override\n            public void checkServerTrusted(final X509Certificate[] chain,\n                    final String authType) throws CertificateException {\n                // nothing to do\n                Log.d(TAG, \"checkServerTrusted(\", chain, \")\");\n                X509Certificate cert = chain[0];\n\n                cert.checkValidity();\n\n                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                ArrayList&lt;X509Certificate&gt; list = new ArrayList&lt;X509Certificate&gt;();\n                list.add(cert);\n                CertPath cp = cf.generateCertPath(list);\n                try {\n                    PKIXParameters params = new PKIXParameters(keyStore);\n                    params.setRevocationEnabled(false); // CLR is broken, remember?\n                    CertPathValidator cpv = CertPathValidator\n                            .getInstance(CertPathValidator.getDefaultType());\n                    cpv.validate(cp, params);\n                } catch (KeyStoreException e) {\n                    Log.d(TAG, \"invalid key store\", e);\n                    throw new CertificateException(e);\n                } catch (InvalidAlgorithmParameterException e) {\n                    Log.d(TAG, \"invalid algorithm\", e);\n                    throw new CertificateException(e);\n                } catch (NoSuchAlgorithmException e) {\n                    Log.d(TAG, \"no such algorithm\", e);\n                    throw new CertificateException(e);\n                } catch (CertPathValidatorException e) {\n                    Log.d(TAG, \"verification failed\");\n                    throw new CertificateException(e);\n                }\n                Log.d(TAG, \"verification successful\");\n            }\n        };\n        sslContext.init(null, new X509TrustManager[]{tm}, null);\n    }\n\n    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n}\n", "        public class TCPSockets extends CordovaPlugin { \n        @Override\n        public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) {      \n    //      PluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);\n            final String callbackId = callbackContext.getCallbackId();      \n\n    //      Log.d(\"TCPSockets\", \"Plugin Called\");\n            try {\n                if (action.equals(\"sendMessage\")) {\n\n                    if (args != null) \n                    {\n                        final int port  = args.getInt(0);\n                        final String host = args.getString(1);\n                        final String message = args.getString(2);\n                        final int connectionTimeout = args.getInt(3);\n                        final boolean secureConnection = args.getBoolean(4);\n\n                        cordova.getThreadPool().execute(new Runnable() {\n                            public void run() {\n                                callbackContext.sendPluginResult(sendMessage(port, host, message, connectionTimeout, secureConnection));                            \n                            }\n                        });                                                                     \n                    } else {\n    //                    return new PluginResult(PluginResult.Status.ERROR, \"User did not specify host information\");\n                        callbackContext.error(\"User did not specify host information\");\n                        return true;\n                    }\n                } else {\n    //                return new PluginResult(PluginResult.Status.INVALID_ACTION);\n                    callbackContext.error(\"Invalid Action\");\n                    return true;\n                }\n            } \n\n            catch (JSONException e) {\n                Log.d(\"TCPSockets\", \"JSONException: \" + e.getMessage());\n    //          return new PluginResult(PluginResult.Status.JSON_EXCEPTION);\n                callbackContext.error(\"JSON Exception\");\n                return true;\n            }\n\n    //        return r;\n    //      callbackContext.sendPluginResult(r);\n            return true;\n        }\n\n        public PluginResult sendMessage(int port, String host, String message, int connectionTimeout, boolean secureConnection)\n        {\n            String reply = \"\";\n            PluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);\n\n            try {           \n                // If we don't want secure connections, then use Socket class\n                if(!secureConnection)\n                {\n                    // Not SSL socket\n                    Socket sock = new Socket(host, port);\n                    Log.d(\"TCPSockets\", \"Socket created\");\n                    sock.setSoTimeout(connectionTimeout); // Time out all actions for 30 seconds\n\n                    PrintWriter out = new PrintWriter(sock.getOutputStream(), true);\n                    BufferedReader in = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n\n                    Log.d(\"TCPSockets\", \"Created reader/writer\");\n                    out.println(message);\n                    Log.d(\"TCPSockets\", \"Sent message\");\n\n                    reply = in.readLine();\n                    Log.d(\"TCPSockets\", \"Received message: \" + reply);\n\n                    out.flush();\n\n                    out.close();\n                    in.close();\n                    sock.close();\n                }\n                else // If we want secure connections, then use SSLSocket class\n                {               \n                    // Create a trust manager that does not validate certificate chains\n                    TrustManager[] trustAllCerts = new TrustManager[] {\n                        new X509TrustManager() {\n                            public X509Certificate[] getAcceptedIssuers() {\n                                return null;                                    \n                            }\n\n                            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                                // Trust always\n                            }\n\n                            public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                                // Trust always\n                            }\n                        }\n                    };\n\n                    SSLContext sslContext = null;\n\n                    try {\n                        sslContext = SSLContext.getInstance(\"SSL\");\n                    } catch (NoSuchAlgorithmException e) {\n                        Log.d(\"SSLTCPSockets\", \"No such algorithm\");\n    //                          return new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Cannot connect to server. Please, try again\");\n                        result = new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Cannot connect to server. Please, try again\");                 \n                        return result;\n                    }\n\n                    try {\n                        sslContext.init(null, trustAllCerts, new SecureRandom());\n                    } catch (KeyManagementException e) {\n                        Log.d(\"SSLTCPSockets\", \"Key manager exception\");\n    //                          return new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Cannot connect to server. Please, try again\");\n                        result = new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Cannot connect to server. Please, try again\");\n                        return result;\n                    }\n\n                    SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n                    SSLSocket socket = (SSLSocket)socketFactory.createSocket(host, port);\n                    socket.setSoTimeout(connectionTimeout);\n                    socket.setUseClientMode(true);\n\n                    Log.d(\"SSLTCPSockets\", \"Connected to host\");\n\n                    SSLSession session = socket.getSession();\n\n                    if (session.isValid())\n                    {\n                        Log.i(getClass().toString(), \"Secure connection\");\n                        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n                        out.println(message);\n                        Log.d(\"SSLTCPSockets\", \"Sent message\");\n\n                        reply = in.readLine();\n                        Log.d(\"SSLTCPSockets\", \"Received message: \" + reply);\n\n                        out.flush();\n\n                        out.close();\n                        in.close();\n                    }\n                    else\n                    {\n                        Log.d(\"SSLTCPSockets\", \"Cannot create a secure connection\");\n    //                          return new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Cannot connect to server. Please, try again\");\n                        result = new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Cannot connect to server. Please, try again\");\n                        return result;\n                    }\n\n                    socket.close();\n                }\n\n                result = new PluginResult(PluginResult.Status.OK, reply);\n                result.setKeepCallback(true);\n                return result;                  \n            } \n\n            catch (UnknownHostException e) {\n                Log.d(\"TCPSockets\", \"Unknown Host\");\n    //                  return new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Cannot connect to server. Please, try again\");\n                result = new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Cannot connect to server. Please, try again\");\n                return result;\n            } \n\n            catch (java.net.SocketTimeoutException e) {\n                Log.d(\"TCPSockets\", \"Connection timed out\");\n    //                  return new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Connection timed out. Please, try again\");\n                result = new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Connection timed out. Please, try again\");\n                return result;\n            }\n\n            catch (IOException e) {\n                Log.d(\"TCPSockets\", \"IOException\");\n    //                  return new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Unexpected error. Please, try again\");\n                result = new PluginResult(PluginResult.Status.IO_EXCEPTION, \"Unexpected error. Please, try again\");\n                return result;\n            }       \n        }\n    }\n", "import java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\n\npublic class HttpsTrustManager implements X509TrustManager {\n\n    private static TrustManager[] trustManagers;\n    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};\n\n    @Override\n    public void checkClientTrusted(\n            java.security.cert.X509Certificate[] x509Certificates, String s)\n            throws java.security.cert.CertificateException {\n\n    }\n\n    @Override\n    public void checkServerTrusted(\n            java.security.cert.X509Certificate[] x509Certificates, String s)\n            throws java.security.cert.CertificateException {\n\n    }\n\n    public boolean isClientTrusted(X509Certificate[] chain) {\n        return true;\n    }\n\n    public boolean isServerTrusted(X509Certificate[] chain) {\n        return true;\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return _AcceptedIssuers;\n    }\n\n    public static void allowAllSSL() {\n        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n\n            @Override\n            public boolean verify(String arg0, SSLSession arg1) {\n                return true;\n            }\n\n        });\n\n        SSLContext context = null;\n        if (trustManagers == null) {\n            trustManagers = new TrustManager[]{new HttpsTrustManager()};\n        }\n\n        try {\n            context = SSLContext.getInstance(\"TLS\");\n            context.init(null, trustManagers, new SecureRandom());\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (KeyManagementException e) {\n            e.printStackTrace();\n        }\n\n        HttpsURLConnection.setDefaultSSLSocketFactory(context\n                .getSocketFactory());\n    }\n\n}\n", " try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"package.name.here\", \n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "public static void test() throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    SecureRandom rnd = new SecureRandom();\n    byte[] keyData = new byte[16];\n    byte[] iv = new byte[16];\n    rnd.nextBytes(keyData);\n    rnd.nextBytes(iv);\n    SecretKeySpec key = new SecretKeySpec(keyData, \"AES\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));\n\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    CipherOutputStream out = new CipherOutputStream(buffer, cipher);\n\n    byte[] plain = \"Test1234567890_ABCDEFG\".getBytes();\n    out.write(plain);\n    out.flush();\n    out.close();\n    byte[] encrypted = buffer.toByteArray();\n    System.out.println(\"Plaintext length: \" + plain.length);\n    System.out.println(\"Padding length  : \" + (cipher.getBlockSize() - (plain.length % cipher.getBlockSize())));\n    System.out.println(\"Cipher length   : \" + encrypted.length);\n\n    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n    CipherInputStream in = new CipherInputStream(new ByteArrayInputStream(encrypted), cipher);\n    buffer = new ByteArrayOutputStream();\n    byte[] b = new byte[100];\n    int read;\n    while ((read = in.read(b)) &gt;= 0) {\n        buffer.write(b, 0, read);\n    }\n    in.close();\n\n    // prints Test1234567890_ABCDEFG\n    System.out.println(new String(buffer.toByteArray()));\n}\n", "protected static String getMD5(String inputText)\n{\n    String md5 = \"\";\n    try\n    {\n        MessageDigest digester = MessageDigest.getInstance(\"MD5\");\n        digester.update(inputText.getBytes());\n        md5 = new BigInteger(1, digester.digest()).toString(16);\n    }\n    catch(Exception e)\n    {\n        SetLogInfo.writeLog(\"Exception: \"+e);\n    }\n    return md5;\n}\n", " TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n", "private static boolean testVector(String algorithm, String key, String iv,\n        String vector, String ciphertext) throws GeneralSecurityException {\n\n    Cipher c = Cipher.getInstance(algorithm);\n    SecretKey k = new SecretKeySpec(DatatypeConverter.parseHexBinary(key),\n            \"AES\");\n\n    if (iv == null) {\n        c.init(Cipher.ENCRYPT_MODE, k);\n    } else {\n        c.init(Cipher.ENCRYPT_MODE, k, new IvParameterSpec(\n                DatatypeConverter.parseHexBinary(iv)));\n    }\n\n    byte[] result = c.doFinal(DatatypeConverter.parseHexBinary(vector));\n    return Arrays.equals(result,\n            DatatypeConverter.parseHexBinary(ciphertext));\n}\n", "        PEMParser pemParser = new PEMParser(new StringReader(publicKey));\n        SubjectPublicKeyInfo spki = (SubjectPublicKeyInfo) pemParser.readObject();\n        pemParser.close();\n        byte [] spkiEncoded = spki.getEncoded();\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(spkiEncoded);\n\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        this.publicKey = kf.generatePublic(keySpec);\n", "public class SimpleCrypto{\npublic static String encrypt(String seed, String cleartext) throws Exception\n{\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    return toHex(result);\n}\n\npublic static String decrypt(String seed, String encrypted) throws Exception\n{\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = toByte(encrypted);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception\n{\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception\n{\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception\n{\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static String toHex(String txt)\n{\n    return toHex(txt.getBytes());\n}\n\npublic static String fromHex(String hex)\n{\n    return new String(toByte(hex));\n}\n\npublic static byte[] toByte(String hexString)\n{\n    int len = hexString.length() / 2;\n    byte[] result = new byte[len];\n    for (int i = 0; i &lt; len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();\n    return result;\n}\n\npublic static String toHex(byte[] buf)\n{\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer(2 * buf.length);\n    for (int i = 0; i &lt; buf.length; i++)\n    {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\n\nprivate final static String HEX = \"0123456789ABCDEF\";\n\nprivate static void appendHex(StringBuffer sb, byte b)\n{\n    sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));\n}\n}\n", "// read .crt file from memory\nInputStream inStream = ctx.openFileInput(\"cetificate.crt\");\n\n//InputStream inStream = ctx.getAssets().open(\"wm_loaner.cer\");\nif(inStream != null)\n{\n    KeyStore cert = CertUtils.ConvertCerToBKS(inStream, \"MyAlias\", \"password\".toCharArray());\n    inStream.close();\n}\n\npublic static KeyStore ConvertCerToBKS(InputStream cerStream, String alias, char [] password)\n{\n    KeyStore keyStore = null;\n    try\n    {\n        keyStore = KeyStore.getInstance(\"BKS\", \"BC\");\n        CertificateFactory factory = CertificateFactory.getInstance(\"X.509\", \"BC\");\n        Certificate certificate = factory.generateCertificate(cerStream);\n        keyStore.load(null, password);\n        keyStore.setCertificateEntry(alias, certificate);\n    }\n    catch ....\n    {\n    }\n    return keyStore;                                    \n}\n", "public X509Certificate parseCertificate(String certificate) throws CertificateException {\n    byte[] decoded = Base64.decode(certificate.replaceAll(\"-----BEGIN CERTIFICATE-----\", \"\").replaceAll(\"-----END CERTIFICATE-----\", \"\"));\n    return (X509Certificate) CertificateFactory.getInstance(\"X.509\").generateCertificate(new ByteArrayInputStream(decoded));\n}\n", "TelephonyManager TelephonyMgr = (TelephonyManager)getSystemService(TELEPHONY_SERVICE);\nString szImei = TelephonyMgr.getDeviceId(); // Requires READ_PHONE_STATE\n\nString m_szDevIDShort = \"35\" + //we make this look like a valid IMEI\nBuild.BOARD.length()%10+ Build.BRAND.length()%10 +\nBuild.CPU_ABI.length()%10 + Build.DEVICE.length()%10 +\nBuild.DISPLAY.length()%10 + Build.HOST.length()%10 +\nBuild.ID.length()%10 + Build.MANUFACTURER.length()%10 +\nBuild.MODEL.length()%10 + Build.PRODUCT.length()%10 +\nBuild.TAGS.length()%10 + Build.TYPE.length()%10 +\nBuild.USER.length()%10 ; //13 digits\n\n\nWifiManager wm = (WifiManager)getSystemService(Context.WIFI_SERVICE);\n\nBluetoothAdapter m_BluetoothAdapter = null; // Local Bluetooth adapter\nm_BluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\nString m_szBTMAC = m_BluetoothAdapter.getAddress();\nString m_szWLANMAC = wm.getConnectionInfo().getMacAddress();\n\n\nString m_szLongID = m_szImei + m_szDevIDShort + m_szWLANMAC + m_szBTMAC;\n// compute md5\nMessageDigest m = null;\ntry {\n     m = MessageDigest.getInstance(\"MD5\");\n} catch (NoSuchAlgorithmException e) {\ne.printStackTrace();\n}\n\nm.update(m_szLongID.getBytes(),0,m_szLongID.length());\n// get md5 bytes\nbyte p_md5Data[] = m.digest();\n// create a hex string\nString m_szUniqueID = new String();\n\nfor (int i=0;i&lt;p_md5Data.length;i++) {\n        int b = (0xFF &amp; p_md5Data[i]);\n// if it is a single digit, make sure it have 0 in front (proper padding)\nif (b &lt;= 0xF) m_szUniqueID+=\"0\";\n// add number to string\n     m_szUniqueID+=Integer.toHexString(b);\n}\n\n// hex string to uppercase\nm_szUniqueID = m_szUniqueID.toUpperCase();\n", "import java.io.*;\nimport javax.xml.transform.*;\nimport javax.xml.transform.dom.*;\nimport javax.xml.transform.stream.*;\n\n//method to convert Document to String\npublic String getStringFromDocument(Document doc)\n{\n    try\n    {\n       DOMSource domSource = new DOMSource(doc);\n       StringWriter writer = new StringWriter();\n       StreamResult result = new StreamResult(writer);\n       TransformerFactory tf = TransformerFactory.newInstance();\n       Transformer transformer = tf.newTransformer();\n       transformer.transform(domSource, result);\n       return writer.toString();\n    }\n    catch(TransformerException ex)\n    {\n       ex.printStackTrace();\n       return null;\n    }\n}\n", "              TrustManager[] trustAllCerts = new TrustManager[]\n               {\n                 new X509TrustManager()\n                  {\n                    public java.security.cert.X509Certificate[] getAcceptedIssuers()  { return null; }\n                    public void checkClientTrusted( java.security.cert.X509Certificate[] certs, String authType)  {}\n                    public void checkServerTrusted( java.security.cert.X509Certificate[] certs, String authType)  {}\n                  }\n                 };\n              try\n                {\n                  SSLContext sc = SSLContext.getInstance( \"SSL\"); // \"TLS\" \"SSL\"\n                  sc.init( null, trustAllCerts, null);\n                  HttpsURLConnection.setDefaultSSLSocketFactory( sc.getSocketFactory());\n                  HttpsURLConnection.setDefaultHostnameVerifier( \n                   new HostnameVerifier() \n                    {\n                      public boolean verify( String hostname, SSLSession session) { return true; }\n                    } );\n                }\n               catch( Exception e)\n", "                 CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n             InputStream caInput = getResources().openRawResource(R.drawable.cert);\n             Certificate ca;\n             try {\n                 ca = cf.generateCertificate(caInput);\n                 System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n             } finally {\n                 caInput.close();\n             }\n             String keyStoreType = KeyStore.getDefaultType();\n             KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n             keyStore.load(null, null);\n             keyStore.setCertificateEntry(\"ca\", ca);\n             String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n             TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n             tmf.init(keyStore);\n             SSLContext context = SSLContext.getInstance(\"TLS\");\n             context.init(null, tmf.getTrustManagers(), null);\n            mRequestQueue =Volley.newRequestQueue(getApplicationContext(), new HurlStack(null, context.getSocketFactory()));\n", "// Implementing a fromString method on an enum type\nprivate static final Map&lt;String, Operation&gt; stringToEnum = new HashMap&lt;String, Operation&gt;();\nstatic { // Initialize map from constant name to enum constant\n    for (Operation op : values())\n        stringToEnum.put(op.toString(), op);\n} // Returns Operation for string, or null if string is invalid\npublic static Operation fromString(String symbol) {\n    return stringToEnum.get(symbol);\n}\n", " TrustManager tm = new X509TrustManager()  {\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n    }\n\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n};\n", "public static String encrypt(String seed, String cleartext) throws Exception {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0byte[] rawKey = getRawKey(seed.getBytes(\"UTF-16\"));\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0byte[] result = encrypt(rawKey, cleartext.getBytes(\"UTF-16\"));\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return toHex(result);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0public static String decrypt(String seed, String encrypted) throws Exception {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0byte[] rawKey = getRawKey(seed.getBytes(\"UTF-16\"));\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0byte[] enc = toByte(encrypted);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0byte[] result = decrypt(rawKey, enc);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return new String(result);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0\u00c2\u00a0}\n\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0private static byte[] getRawKey(byte[] seed) throws Exception {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0sr.setSeed(seed);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0kgen.init(128, sr); // 192 and 256 bits may not be available\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0SecretKey skey = kgen.generateKey();\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0byte[] raw = skey.getEncoded();\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return raw;\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0Cipher cipher = Cipher.getInstance(\"AES\");\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0byte[] encrypted = cipher.doFinal(clear);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return encrypted;\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0Cipher cipher = Cipher.getInstance(\"AES\");\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0byte[] decrypted = cipher.doFinal(encrypted);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return decrypted;\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0public static String toHex(String txt) {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return toHex(txt.getBytes());\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0public static String fromHex(String hex) {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return new String(toByte(hex));\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0public static byte[] toByte(String hexString) {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0int len = hexString.length()/2;\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0byte[] result = new byte[len];\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0for (int i = 0; i &lt; len; i++)\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return result;\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0public static String toHex(byte[] buf) {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0if (buf == null)\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return \"\";\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0StringBuffer result = new StringBuffer(2*buf.length);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0for (int i = 0; i &lt; buf.length; i++) {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0appendHex(result, buf[i]);\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0return result.toString();\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0private final static String HEX = \"0123456789ABCDEF\";\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0private static void appendHex(StringBuffer sb, byte b) {\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0}\n\u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0 \u00c2\u00a0\n", "package Utils;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSession;\nimport android.util.Log;\n\npublic class MessageUtil\n{\npublic final static String AUTH = \"authentication\";\n\npublic static final String UPDATE_CLIENT_AUTH = \"Update-Client-Auth\";\n\npublic static final String PARAM_REGISTRATION_ID = \"registration_id\";\n\npublic static final String PARAM_DELAY_WHILE_IDLE = \"delay_while_idle\";\n\npublic static final String PARAM_COLLAPSE_KEY = \"collapse_key\";\n\nprivate static final String UTF8 = \"UTF-8\";\n\npublic static int sendMessage(String auth_token, String registrationId,String message) throws IOException \n{\n\n    StringBuilder postDataBuilder = new StringBuilder();\n\n    postDataBuilder.append(PARAM_REGISTRATION_ID).append(\"=\").append(registrationId);\n    postDataBuilder.append(\"&amp;\").append(PARAM_COLLAPSE_KEY).append(\"=\").append(\"0\");\n    postDataBuilder.append(\"&amp;\").append(\"data.payload\").append(\"=\").append(URLEncoder.encode(message, UTF8));\n\n    byte[] postData = postDataBuilder.toString().getBytes(UTF8);\n\n    // Hit the dm URL.\n\n    URL url = new URL(\"https://android.clients.google.com/c2dm/send\");\n    HttpsURLConnection.setDefaultHostnameVerifier(new CustomizedHostnameVerifier());\n    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n    conn.setDoOutput(true);\n    conn.setUseCaches(false);\n    conn.setRequestMethod(\"POST\");\n    conn.setRequestProperty(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\");\n    conn.setRequestProperty(\"Content-Length\",Integer.toString(postData.length));\n    conn.setRequestProperty(\"Authorization\", \"GoogleLogin auth=\"+ auth_token);\n\n    OutputStream out = conn.getOutputStream();\n    out.write(postData);\n    out.close();\n\n    int responseCode = conn.getResponseCode();\n    if (responseCode == 200)\n    {\n        Log.d(\"error\",conn.toString());\n        Log.d(\"response\",conn.getResponseMessage());\n    }\n    return responseCode;\n}\n\nprivate static class CustomizedHostnameVerifier implements HostnameVerifier {\n    public boolean verify(String hostname, SSLSession session) {\n        return true;\n    }\n}\n}\n  //call the method from other activity\n  int responseCode = MessageUtil.sendMessage(token,registration_id, \"your message for device\");\n        System.out.println(responseCode);\n", " HttpsURLConnection.setDefaultHostnameVerifier(new AllVerifier());\n try\n  {\n   SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n   sslContext.init(null, new TrustManager[] { new AllTrustManager() }, null);\n   HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n     } catch (KeyManagementException e) {\n       e.printStackTrace();\n     } catch (NoSuchAlgorithmException e) {\n       e.printStackTrace();\n   }\n", "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n...\npublic String getIdHash(long id){\n    String hash = null;\n    long intId = id ^ Long.MAX_VALUE;\n    String md5 = String.format(\"%X-ANY-TEXT\", intId);\n    try {\n        MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n        byte[] arr = md.digest(md5.getBytes());\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; arr.length; ++i)\n            sb.append(Integer.toHexString((arr[i] &amp; 0xFF) | 0x100).substring(1,3));\n\n        hash = sb.toString();\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(\"MD5\", e.getMessage());\n    }\n\n    return hash.toUpperCase();\n}\n", "String aid = Settings.Secure.getString(getContext().getContentResolver(), \"android_id\");\n\nObject obj = null;\ntry {\n    ((MessageDigest) (obj = MessageDigest.getInstance(\"MD5\"))).update(\n                                   aid.getBytes(), 0, aid.length());\n\n    obj = String.format(\"%032X\", new Object[] { new BigInteger(1,\n                                   ((MessageDigest) obj).digest()) });\n} catch (NoSuchAlgorithmException localNoSuchAlgorithmException) {\n    obj = aid.substring(0, 32);\n}\n", "// DO NOT FORGET TO REMOVE\nPackageInfo info;\ntry {\n    info = getPackageManager().getPackageInfo(\"com.you.name\", PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String something = new String(Base64.encode(md.digest(), 0));\n        //String something = new String(Base64.encodeBytes(md.digest()));\n        Log.e(\"hash key\", something);\n    }\n} catch (NameNotFoundException e1) {\n    Log.e(\"name not found\", e1.toString());\n} catch (NoSuchAlgorithmException e) {\n    Log.e(\"no such an algorithm\", e.toString());\n} catch (Exception e) {\n    Log.e(\"exception\", e.toString());\n}\n// DO NOT FORGET TO REMOVE\n", "It will open facebook dialog to post status update:\n\n    import java.security.MessageDigest;\n    import java.security.NoSuchAlgorithmException;\n    import android.app.Activity;\n    import android.content.Context;\n    import android.content.Intent;\n    import android.content.pm.PackageInfo;\n    import android.content.pm.PackageManager;\n    import android.content.pm.PackageManager.NameNotFoundException;\n    import android.content.pm.Signature;\n    import android.net.ConnectivityManager;\n    import android.net.NetworkInfo;\n    import android.os.Bundle;\n    import android.util.Base64;\n    import android.util.Log;\n    import android.view.Menu;\n    import android.view.View;\n    import android.view.View.OnClickListener;\n    import android.widget.ImageView;\n    import android.widget.Toast;\n    import com.facebook.Session;\n    import com.facebook.SessionState;\n    import com.facebook.UiLifecycleHelper;\n    import com.facebook.widget.FacebookDialog;\n    public class MainActivity extends Activity {\n        String message = \"Hello there!\";\n        private UiLifecycleHelper uiHelper;\n        ImageView facebook;\n        private Session.StatusCallback callback = new Session.StatusCallback() {\n            @Override\n            public void call(Session session, SessionState state,\n                    Exception exception) {\n                onSessionStateChange(session, state, exception);\n            }\n        };\n        private void onSessionStateChange(Session session, SessionState state,\n                Exception exception) {\n            if (state.isOpened()) {\n                // System.out.println(\"Logged in...\");\n            } else if (state.isClosed()) {\n                // System.out.println(\"Logged out...\");\n            }\n        }\n        @Override\n        protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n            super.onActivityResult(requestCode, resultCode, data);\n            uiHelper.onActivityResult(requestCode, resultCode, data,\n                    new FacebookDialog.Callback() {\n                        @Override\n                        public void onError(FacebookDialog.PendingCall pendingCall,\n                                Exception error, Bundle data) {\n                            Log.e(\"Activity\",\n                                    String.format(\"Error: %s\", error.toString()));\n                        }\n                        @Override\n                        public void onComplete(\n                                FacebookDialog.PendingCall pendingCall, Bundle data) {\n                            Log.i(\"Activity\", \"Success!\");\n                        }\n                    });\n        }\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n            uiHelper = new UiLifecycleHelper(this, callback);\n            uiHelper.onCreate(savedInstanceState);\n\n\n            //Code to get KeyHash value.\n            try {\n                PackageInfo info = getPackageManager().getPackageInfo(\n                        \"com.code2care.thebuddhaquotes\", \n                        PackageManager.GET_SIGNATURES);\n                for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    System.out.println(\"KeyHash : \"+ Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                    }\n            } catch (NameNotFoundException e) {\n            } catch (NoSuchAlgorithmException e) {\n            }\n\n            facebook = (ImageView) findViewById(R.id.fbIcon);\n            facebook.setOnClickListener(new OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    facebook();\n                }\n            });\n        }\n        @Override\n        public boolean onCreateOptionsMenu(Menu menu) {\n            // Inflate the menu; this adds items to the action bar if it is present.\n            getMenuInflater().inflate(R.menu.main, menu);\n            return true;\n        }\n        @Override\n        protected void onDestroy() {\n            uiHelper.onDestroy();\n            super.onDestroy();\n        }\n        @Override\n        protected void onResume() {\n            super.onResume();\n            uiHelper.onResume();\n        }\n        @Override\n        protected void onSaveInstanceState(Bundle outState) {\n            super.onSaveInstanceState(outState);\n            uiHelper.onSaveInstanceState(outState);\n        }\n        @Override\n        public void onPause() {\n            super.onPause();\n            uiHelper.onPause();\n        }\n        public void facebook() {\n            if (!checkNetwork()) {\n                Toast.makeText(getApplicationContext(),\n                        \"No active internet connection ...\", Toast.LENGTH_SHORT)\n                        .show();\n                return;\n            }\n            if (!checkFbInstalled()) {\n                Toast.makeText(getApplicationContext(),\n                        \"Facebook app not installed!..\", Toast.LENGTH_SHORT).show();\n                return;\n            }\n            Toast.makeText(getApplicationContext(), \"Loading...\",\n                    Toast.LENGTH_SHORT).show();\n            if (FacebookDialog.canPresentShareDialog(this,\n                    FacebookDialog.ShareDialogFeature.SHARE_DIALOG)) {\n                FacebookDialog shareDialog = new FacebookDialog.ShareDialogBuilder(\n                        this).setName(\"The Buddha Quotes\")\n                        .setLink(\"http://code2care.org\").setDescription(message)\n                        .setPicture(\"http://code2care.org/buddha.jpg\").build();\n                uiHelper.trackPendingDialogCall(shareDialog.present());\n            } else {\n                // System.out.println(\"Fail Success!\");\n            }\n        }\n        private boolean checkNetwork() {\n            boolean wifiAvailable = false;\n            boolean mobileAvailable = false;\n            ConnectivityManager conManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);\n            NetworkInfo[] networkInfo = conManager.getAllNetworkInfo();\n            for (NetworkInfo netInfo : networkInfo) {\n                if (netInfo.getTypeName().equalsIgnoreCase(\"WIFI\"))\n                    if (netInfo.isConnected())\n                        wifiAvailable = true;\n                if (netInfo.getTypeName().equalsIgnoreCase(\"MOBILE\"))\n                    if (netInfo.isConnected())\n                        mobileAvailable = true;\n            }\n            return wifiAvailable || mobileAvailable;\n        }\n        public Boolean checkFbInstalled() {\n            PackageManager pm = getPackageManager();\n            boolean flag = false;\n            try {\n                pm.getPackageInfo(\"com.facebook.katana\",\n                        PackageManager.GET_ACTIVITIES);\n                flag = true;\n            } catch (PackageManager.NameNotFoundException e) {\n                flag = false;\n            }\n            return flag;\n        }\n    }\n\n//2nd Way (If native app is not present You can implement check if facebook native sharedialog is present or not)\n\nif (FacebookDialog.canPresentShareDialog(getApplicationContext(),\nFacebookDialog.ShareDialogFeature.SHARE_DIALOG)) {\n    // Publish the post using the Share Dialog\n    FacebookDialog shareDialog = new FacebookDialog.ShareDialogBuilder(this)\n            .setLink(\"https://developers.facebook.com/android\")\n            .build();\n    uiHelper.trackPendingDialogCall(shareDialog.present());\n\n} else {\n    // Fallback. For example, publish the post using the Feed Dialog\n    publishFeedDialog();\n}\n\nprivate void publishFeedDialog() {\n    Bundle params = new Bundle();\n    params.putString(\"name\", \"Facebook SDK for Android\");\n    params.putString(\"caption\", \"Build great social apps and get more installs.\");\n    params.putString(\"description\", \"The Facebook SDK for Android makes it easier and faster to develop Facebook integrated Android apps.\");\n    params.putString(\"link\", \"https://developers.facebook.com/android\");\n    params.putString(\"picture\", \"https://raw.github.com/fbsamples/ios-3.x-howtos/master/Images/iossdk_logo.png\");\nWebDialog feedDialog = (new WebDialog.FeedDialogBuilder(\n                HomeDailySay.this, Session.getActiveSession(), params))\n                .setOnCompleteListener(new OnCompleteListener() {\n                    @Override\n                    public void onComplete(Bundle values,\n                            FacebookException error) {\n                        if (error == null) {\n                            // When the story is posted, echo the success\n                            // and the post Id.\n                            final String postId = values.getString(\"post_id\");\n                            if (postId != null) {\n\n                                //status updated\n\n                            } else {\n                                // User clicked the Cancel button\n\n                            }\n                        } else if (error instanceof FacebookOperationCanceledException) {\n                            // User clicked the \"x\" button\n\n                        } else {\n                            // Generic, ex: network error\n\n                        }\n                    }\n\n                }).build();\n    feedDialog.show();\n}\n", "ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nbyte[] iv = new byte[IV_LENGTH];\nSecureRandom random = new SecureRandom();\nrandom.nextBytes(iv);\necipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(iv));\nbyte[] enc = ecipher.doFinal(utf8);\n", "PackageInfo info = getPackageManager().getPackageInfo(\"&lt;your_package_name&gt;\",  PackageManager.GET_SIGNATURES);\n\nfor (Signature signature : info.signatures){\n   MessageDigest md = MessageDigest.getInstance(\"SHA\");\n   md.update(signature.toByteArray());\n   Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n}\n", " public static byte[] encrypt(byte[] key, byte[] data) throws Exception\n\n        {\n\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n            byte[] encrypted = cipher.doFinal(data);\n            return encrypted;\n        }\n\n        /**\n         * DEcrypt byte array with given Key using AES Algorithm\n         * Key can be generated using &lt;Code&gt;getKey()&lt;/Code&gt;\n         * @param key  Key that Is used for decrypting data\n         * @param data  Data passed to decrypt\n         * @return decrypted data\n         * */\n\n        public static byte[] decrypt1(byte[] key, byte[] encrypted) throws Exception\n        {\n\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n            byte[] decrypted = cipher.doFinal(encrypted);\n            return decrypted;\n        }\n        /**\n         * get the Key for encryption this can be used for while decrypting and encrypting too.\n         * */\n        public static byte[] getKey() throws Exception\n        {\n            byte[] keyStart = EncrypteDecrypte.encryptionKey.getBytes();\n            KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n            SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n            sr.setSeed(keyStart);\n            kgen.init(128, sr); // 192 and 256 bits may not be available\n            SecretKey skey = kgen.generateKey();\n            byte[] key = skey.getEncoded();\n\n            return key;\n        }\n", "WebSocketOrderClient webSocketOrderClient = new WebSocketOrderClient(uri, new Draft_17(), cmap, TIMEOUT);\nSSLContext sslContext = null;\nsslContext = SSLContext.getInstance( \"TLS\" );\nsslContext.init( null, null, null ); // will use java's default key and trust store which is sufficient unless you deal with self-signed certificates\n\nwebSocketOrderClient.setWebSocketFactory(new DefaultSSLWebSocketClientFactory(sslContext));\nwebSocketOrderClient.connectBlocking();\n", "    String TAG = \"com.sromku.simple.fb.example\";\n        PackageInfo info = context.getPackageManager().getPackageInfo(TAG,\n            PackageManager.GET_SIGNATURES);\n        for (Signature signature: info.signatures)\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String keyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n            Log.d(TAG, \"keyHash: \" + keyHash);\n", "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyManagementException;\n\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\n\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.TrustManager;\n\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.params.HttpParams;\n\nimport android.annotation.TargetApi;\nimport android.net.SSLCertificateSocketFactory;\nimport android.os.Build;\n\n\n class SslSocketFactory extends SSLSocketFactory {\n\n     InputStream mkeyStore;\n     String mkeyStorePassword;\n\n     public SslSocketFactory(InputStream keyStore, String keyStorePassword) throws KeyManagementException, UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException{\n         super(null);\n         mkeyStore=keyStore;\n         mkeyStorePassword=keyStorePassword;\n\n     }\n\n\n\n      @Override\n      public Socket connectSocket(Socket s, String host, int port, InetAddress localAddress, int localPort, HttpParams params) throws IOException {\n          return null;\n      }\n\n      @Override\n      public Socket createSocket() throws IOException {\n          return null;\n      }\n\n      @Override\n      public boolean isSecure(Socket s) throws IllegalArgumentException {\n          if (s instanceof SSLSocket) {\n              return ((SSLSocket) s).isConnected();\n          }\n          return false;\n      }\n\n      @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)\n      @Override\n      public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n          SSLSocket sslSocket = null;\n\n\n              if (autoClose) {\n                  socket.close();\n              }\n\n\n                 SSLCertificateSocketFactory sslSocketFactory = (SSLCertificateSocketFactory) SSLCertificateSocketFactory.getDefault(0, null);\n\n\n              try {\n                sslSocketFactory.setTrustManagers(new TrustManager[] { new SsX509TrustManager( mkeyStore, mkeyStorePassword) });\n            } catch (GeneralSecurityException e1) {\n\n                e1.printStackTrace();\n            }\n\n\n\n              sslSocket = (SSLSocket) sslSocketFactory.createSocket(InetAddress.getByName(host), port);\n\n              sslSocket.setEnabledProtocols(sslSocket.getSupportedProtocols());\n\n              if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                  sslSocketFactory.setHostname(sslSocket, host);\n              } else {\n\n                  try {\n                      java.lang.reflect.Method setHostnameMethod = sslSocket.getClass().getMethod(\"setHostname\", String.class);\n                      setHostnameMethod.invoke(sslSocket, host);\n                  } catch (Exception e) {\n\n                  }\n              }\n\n\n          return sslSocket;\n      }\n\n  }\n", "private static String post(String urlString, Map formParameters)\nthrows MalformedURLException, ProtocolException, IOException {\n    DataOutputStream ostream = null;\n\n    trustAllHosts();\n    URL tempUrl;\n    StringBuffer buf = new StringBuffer();\n    if(formParameters != null) {\n        Set parameters = formParameters.keySet();\n        Iterator it = parameters.iterator();\n        //StringBuffer buf = new StringBuffer();\n\n        for(int i = 0, paramCount = 0; it.hasNext(); i++) {\n            String parameterName = (String) it.next();\n            String parameterValue = (String) formParameters.get(parameterName);\n\n            if(parameterValue != null) {\n                parameterValue = URLEncoder.encode(parameterValue);\n                if(paramCount &gt; 0) {\n                    buf.append(\"&amp;\");\n                }\n                buf.append(parameterName);\n                buf.append(\"=\");\n                buf.append(parameterValue);\n                ++paramCount;\n            }\n        }\n        Log.v(\"smartdbhelper adding post parameters\", buf.toString());\n\n\n    }\n    urlString = urlString + \"?\" + buf;\n    Log.v(\"smartdbhelper url string\", urlString);\n    tempUrl = new URL(urlString);\n    HttpsURLConnection https = (HttpsURLConnection) tempUrl.openConnection();\n    https.setHostnameVerifier(DO_NOT_VERIFY);\n    Log.v(\"smartdbhelper adding post parameters\", https.toString());\n    https.setRequestMethod(\"POST\");\n    https.setDoInput(true);\n    https.setDoOutput(true);\n    ostream = new DataOutputStream(https.getOutputStream());\n    ostream.writeBytes(buf.toString());\n\n\nif( ostream != null ) {\n    ostream.flush();\n        ostream.close();\n    }\n    Object contents = https.getContent();\n    InputStream is = (InputStream) contents;\n    StringBuffer buf2 = new StringBuffer();\n    int c;\n    while((c = is.read()) != -1) {\n        buf2.append((char)c);\n        Log.v(\"smartdbhelper bugger\", buf2.toString());\n    }\n    https.disconnect();\n    return buf2.toString();\n}\n", "    public HttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(\"BKS\");\n        InputStream in = getResources().openRawResource(R.raw.mykeystore);\n        try {\n            trustStore.load(in, \"mypassword\".toCharArray());\n        } finally {\n            in.close();\n        }\n\n        SSLSocketFactory sf = new SSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", "    String keyStoreType = KeyStore.getDefaultType();\n    KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n    InputStream inputStream = context.getResources().openRawResource(R.raw.server);\n    keyStore.load(inputStream, \"passwd\".toCharArray());\n\n    String keyalg = KeyManagerFactory.getDefaultAlgorithm();\n    kmf.init(keyStore, \"passwd\".toCharArray());\n\n    KeyManagerFactory kmf = KeyManagerFactory.getInstance(keyalg);\n    SSLContext context = SSLContext.getInstance(\"TLS\");\n    context.init(kmf.getKeyManagers(), null, null);\n    SSLServerSocket ss = (SSLServerSocket) context.getServerSocketFactory().createServerSocket(4444);\n    inputStream.close();\n\n    ss.accept();\n", "try {\n            PackageInfo info = context.getPackageManager().getPackageInfo(\n                    \"com.example.package\", PackageManager.GET_SIGNATURES); //Your package name here\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.v(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                }\n        } catch (NameNotFoundException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n", "import java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport javax.security.sasl.Sasl;\n\nimport org.jivesoftware.smack.SASLAuthentication;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.sasl.SASLMechanism;\nimport org.jivesoftware.smack.util.Base64;\n\npublic class SALSGTalkOauthMechanism extends SASLMechanism {\n    private static final Logger log = Logger.getLogger(SALSGTalkOauthMechanism.class.getName());\n    public static final String NAME = \"X-OAUTH2\";\n\n\n    /**\n     * Constructor.\n     */\n    public SALSGTalkOauthMechanism(SASLAuthentication saslAuthentication) {\n            super(saslAuthentication);\n            log.info(\"Creating SASL mechanism for GTalk (X-OAUTH2)\");\n    }\n\n    @Override\n    public void authenticate(String username, String host, String accessToken) throws IOException, XMPPException {\n        this.hostname = host;\n\n        log.info(\"Authenticating to host \"+host+\" with key \"+username);\n\n        String[] mechanisms = { \"X-OAUTH2\" };\n        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n        this.sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props, this);\n        getSASLAuthentication().send(new AuthMechanism(getName(), Base64.encodeBytes(('\\0'+username+'\\0'+accessToken).getBytes())));\n    }\n\n    @Override\n    protected String getName() {\n            return NAME;\n    }\n\n     }\n", "    SSLContext context = SSLContext.getInstance(\"TLS\");\n    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return new java.security.cert.X509Certificate[] {};\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain,\n                        String authType) throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain,\n                        String authType) throws CertificateException {\n        }\n} };\n    context.init(null, trustAllCerts, null);\n", "public static String getHash(final String msg) {\n    StringBuilder sb = new StringBuilder();\n    try {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        digest.update(msg.getBytes());\n        byte[] byteData = digest.digest();\n        for (byte x : byteData) {\n            String str = Integer.toHexString(Byte.toUnsignedInt(x));\n            if (str.length() &lt; 2) {\n                sb.append('0');\n            }\n            sb.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return sb.toString();\n}\n", "private void getShaKey() {\n    try {\n      Activity activity = this; // or getActivity() if the code is in fragment\n      String packageName = activity.getPackageName();\n      PackageInfo info = activity.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);\n      for (android.content.pm.Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n        md.update(signature.toByteArray());\n        byte[] digest = md.digest();\n        Log.v(LOG_TAG, \"KeyHash: \" + bytesToHex(digest) + \";\" + packageName);\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n\n  public static String bytesToHex(byte[] bytes) {\n    char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n    char[] hexChars = new char[bytes.length * 2];\n    for (int j = 0; j &lt; bytes.length; j++) {\n      int v = bytes[j] &amp; 0xFF;\n      hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];\n      hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i &lt; hexChars.length; i += 2) {\n      sb.append(hexChars[i]);\n      sb.append(hexChars[i + 1]);\n      if (i &lt; hexChars.length - 2) {\n        sb.append(':');\n      }\n    }\n    return sb.toString();\n  }\n", "    private X509Certificate[] mCertificates;\n    private PrivateKey mPrivateKey;\n\n    private void loadCertificateAndPrivateKey() {\n          try {\n                InputStream certificateFileStream = getClass().getResourceAsStream(\"/assets/cert.pfx\");\n\n                KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n                String password = \"password\";\n                keyStore.load(certificateFileStream, password != null ? password.toCharArray() : null);\n\n                Enumeration&lt;String&gt; aliases = keyStore.aliases();\n                String alias = aliases.nextElement();\n\n                Key key = keyStore.getKey(alias, password.toCharArray());\n                if (key instanceof PrivateKey) {\n                    mPrivateKey = (PrivateKey)key;\n                    Certificate cert = keyStore.getCertificate(alias);\n                    mCertificates = new X509Certificate[1];\n                    mCertificates[0] = (X509Certificate)cert;\n                 }\n\n                 certificateFileStream.close();\n\n            } catch (Exception e) {\n                 Log.e(TAG, e.getMessage());\n         }\n    }\n\n\n    private WebViewClient mWebViewClient = new WebViewClient() {\n        @Override\n        public boolean shouldOverrideUrlLoading(WebView view, String url) {\n            view.loadUrl(url);\n            return false;\n        }\n\n        @Override\n        public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {\n            handler.proceed();\n        }\n\n        @Override\n        public void onReceivedClientCertRequest(WebView view, final ClientCertRequest request) {\n            if (mCertificates == null || mPrivateKey == null) {\n                loadCertificateAndPrivateKey();\n            } \n            request.proceed(mPrivateKey, mCertificates);\n        }\n    };\n", "    URL url = new URL(\"https://android.apis.google.com/c2dm/send\");\n\n    HostnameVerifier hVerifier = new HostnameVerifier() {\n        public boolean verify(String hostname, SSLSession\n                session) {\n            return true;\n        }\n    };\n\n    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n    conn.setHostnameVerifier(hVerifier);\n", "public class C2DMTest {\n\n\n    public static void main(String... args) throws Exception {\n        String auth = authorize();\n        if (auth == null) {\n            System.out.println(\"No authorization returned\");\n            System.exit(1);\n        }\n        sendMessage(auth);\n    }\n\n    /**\n     * Perform an authorization request to access Google's C2DM\n     * API.\n     *\n     * @return The retrieved authorization request.\n     */\n    private static String authorize() throws Exception {\n        String accountType = \"GOOGLE\";\n        String service = \"ac2dm\";\n\n        String source = \"replace-me\";\n        String email = \"replace-me\";\n        String passwd = \"replace-me\";\n\n\n        StringBuilder params = new StringBuilder();\n        params.append(\"accountType=\").append(accountType)\n                .append(\"&amp;Email=\").append(URLEncoder.encode(email, UTF8))\n                .append(\"&amp;Passwd=\").append(URLEncoder.encode(passwd, UTF8))\n                .append(\"&amp;service=\").append(service)\n                .append(\"&amp;source=\").append(source);\n        byte[] postData = params.toString().getBytes(UTF8);\n\n        URL url = new URL(\"https://www.google.com/accounts/ClientLogin\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setRequestMethod(\"POST\");\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(postData.length));\n\n        //------------------\n        OutputStream out = conn.getOutputStream();\n        //--------------------------\n        out.write(postData);\n        out.close();\n\n        int sw = conn.getResponseCode();\n        System.out.println(\"\" + sw);\n\n        switch (sw) {\n            case 503:\n                System.out.println(\"Service unavailable\");\n                break;\n            case 401:\n                System.out.println(\" Invalid authentication token\");\n                break;\n            default:\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                InputStream in = conn.getInputStream();\n                byte[] bytes = new byte[100];\n                int len = -1;\n                while ((len = in.read(bytes)) != -1) {\n                    baos.write(bytes, 0, len);\n                }\n                in.close();\n                String input = baos.toString();\n                Map&lt;String, String&gt; res = parseResponse(input);\n                return res.get(\"Auth\");\n        }\n        return null;\n    }\n\n    /**\n     * Parses a response string into a usable data map.\n     *\n     * @param response The response from Google\n     * @return A Map representation.\n     */\n    private static Map&lt;String, String&gt; parseResponse(String response) {\n        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\n        if (response != null) {\n            String[] lines = response.split(\"\\n\");\n            for (String line : lines) {\n                String[] parts = line.split(\"=\");\n                if (parts.length == 2) {\n                    map.put(parts[0], parts[1]);\n                }\n            }\n        }\n        return map;\n    }\n\n    private static String UTF8 = \"UTF-8\";\n\n\n    /**\n     * Send message to mobile device.\n     *\n     * @param cl Google API auth code.\n     */\n    public static void sendMessage(String cl) throws IOException {\n        String key = \"invalid\";\n\n        StringBuilder postDataBuilder = new StringBuilder();\n        postDataBuilder.append(\"registration_id\").append(\"=\").append(key);\n        postDataBuilder.append(\"&amp;\").append(\"collapse_key\").append(\"=\").append(\"0\");\n        postDataBuilder.append(\"&amp;\").append(\"data.payload\").append(\"=\").append(URLEncoder.encode(\"test-content\", UTF8));\n        byte[] postData = postDataBuilder.toString().getBytes(UTF8);\n\n        URL url = new URL(\"https://android.apis.google.com/c2dm/send\");\n\n        HostnameVerifier hVerifier = new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession\n                    session) {\n                return true;\n            }\n        };\n\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n        conn.setHostnameVerifier(hVerifier);\n        conn.setDoOutput(true);\n        conn.setUseCaches(false);\n        conn.setRequestMethod(\"POST\");\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(postData.length));\n        conn.setRequestProperty(\"Authorization\", \"GoogleLogin auth=\"+cl);\n\n        //------------------\n        OutputStream out = conn.getOutputStream();\n        //--------------------------\n        out.write(postData);\n        out.close();\n\n        int sw = conn.getResponseCode();\n        System.out.println(\"\" + sw);\n        switch (sw) {\n            case 200:\n                System.out.println(\"Success, but check for errors in the body\");\n                break;\n            case 503:\n                System.out.println(\"Service unavailable\");\n                break;\n            case 401:\n                System.out.println(\" Invalid authentication token\");\n                break;\n        }\n\n    }\n}\n", "public class FileActivity extends Activity{\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_file);\n        encryptPDF();\n    }\n\npublic void encryptPDF() \n{\n    //CipherInputStream input=null;\n    /*FileInputStream fis=null ;\n    FileOutputStream fos=null;*/\n    // get the key\n\n    try {\n        final KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\n        generator.init(128);\n        final SecretKey secretKey = generator.generateKey();\n\n        // perform encryption\n        Cipher cipher;\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    FileInputStream fis = new FileInputStream(Environment.getExternalStorageDirectory()+\"/sample.pdf\");\n    FileOutputStream fos = new FileOutputStream(Environment.getExternalStorageDirectory()+\"/pdf_encrypt.enc\");\n    final CipherOutputStream output = new CipherOutputStream(fos, cipher);\n\n    int bytesRead = 0;\n    final byte[] plainText = new byte[4096];\n    while ((bytesRead = fis.read(plainText)) &gt;= 0) {\n        output.write(plainText, 0, bytesRead);\n    }\n    output.flush();\n    output.close();\n    fos.close();\n    fis.close();\n    final byte[] iv = cipher.getIV();\n\n    // decrypt the file\n    cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));\n    fis = new FileInputStream(Environment.getExternalStorageDirectory()+\"/pdf_encrypt.enc\");\n    fos = new FileOutputStream(Environment.getExternalStorageDirectory()+\"/test.pdf\");\n    CipherInputStream input = new CipherInputStream(fis, cipher);\n\n    final byte[] decryptedData = new byte[4096];\n    int decryptedRead;\n    while ((decryptedRead = input.read(decryptedData)) &gt;= 0) {\n        fos.write(decryptedData, 0, decryptedRead);\n    }\n\n    fos.flush();\n    fos.close();\n    input.close();\n    fis.close();\n    } catch (Exception e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n}\n", "PackageInfo info;\ntry {\n\n    info = getPackageManager().getPackageInfo(\n        \"com.your.package.name\", PackageManager.GET_SIGNATURES);\n\n    for (Signature signature : info.signatures) {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String hash_key = new String(Base64.encode(md.digest(), 0));\n    }\n\n} catch (NameNotFoundException e1) {\n} catch (NoSuchAlgorithmException e) {\n} catch (Exception e) {\n}\n", "Mac mac = Mac.getInstance(\"HmacSHA1\");\nSecretKeySpec secret = new SecretKeySpec(key.getBytes(), mac.getAlgorithm());\nmac.init(secret);\nbyte[] digest = mac.doFinal(baseString.getBytes());\nbyte[] result=Base64.encode(digest, DEFAULT);\n", "public class TriggerServer extends NanoHTTPD\n{\n    private Context ctx;\n    private MediaPlayer mediaPlayer;\n    public PlayMusicServer(Context c) throws IOException\n    {\n        super(8080, new File(\".\"));\n        ctx = c;\n    }\n\n    public Response serve( String uri, String method, Properties header, Properties parms, Properties files )\n    {\n        Log.i(FileLog.myTag, method + \" '\" + uri + \"' \" );\n        String msg = \"\";\n\n        if ( parms.getProperty(\"play\") != null){ \n            String PATH_TO_FILE = parms.getProperty(\"play\")\n            mediaPlayer = new  MediaPlayer();\n            mediaPlayer.setDataSource(PATH_TO_FILE);\n            mediaPlayer.prepare();\n            mediaPlayer.start();\n        }\n\n        return new NanoHTTPD.Response( HTTP_OK, MIME_HTML, msg );\n    }\n\n}\n", "import javax.crypto.Cipher;\nprivate Cipher myGetCipher() {\n    Cipher c = Cipher.getInstance(\"RC4\");\n    c.init(Cipher.DECRYPT_MODE, new SecretKeySpec(\"myPassword\".getBytes(), \"RC4\"));\n    return c\n}\n", " private static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    // this is wrong!\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n", "    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n        public void checkClientTrusted(X509Certificate[] certs, String authType) {\n        }\n        public void checkServerTrusted(X509Certificate[] certs, String authType) {\n        }\n    } };\n    SSLContext sc = null;\n    try {\n        sc = SSLContext.getInstance(\"SSL\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    try {\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n    } catch (KeyManagementException e) {\n        e.printStackTrace();\n    }\n    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n    // Create all-trusting host name verifier\n    HostnameVerifier allHostsValid = new HostnameVerifier() {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n    // Install the all-trusting host verifier\n    HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);\n", "public class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory {\n\nprivate SSLContext sslcontext = null;\n\nprivate static SSLContext createEasySSLContext() throws IOException {\n    try {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);\n        return context;\n    } catch (Exception e) {\n        throw new IOException(e.getMessage());\n    }\n}\n\nprivate SSLContext getSSLContext() throws IOException {\n    if (this.sslcontext == null) {\n        this.sslcontext = createEasySSLContext();\n    }\n    return this.sslcontext;\n}\n\n/**\n * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int,\n *      java.net.InetAddress, int, org.apache.http.params.HttpParams)\n */\npublic Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort,\n        HttpParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n    int soTimeout = HttpConnectionParams.getSoTimeout(params);\n    InetSocketAddress remoteAddress = new InetSocketAddress(host, port);\n    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());\n\n    if ((localAddress != null) || (localPort &gt; 0)) {\n        // we need to bind explicitly\n        if (localPort &lt; 0) {\n            localPort = 0; // indicates \"any\"\n        }\n        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);\n        sslsock.bind(isa);\n    }\n\n    sslsock.connect(remoteAddress, connTimeout);\n    sslsock.setSoTimeout(soTimeout);\n    return sslsock;\n\n}\n\n/**\n * @see org.apache.http.conn.scheme.SocketFactory#createSocket()\n */\npublic Socket createSocket() throws IOException {\n    return getSSLContext().getSocketFactory().createSocket();\n}\n\n/**\n * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)\n */\npublic boolean isSecure(Socket socket) throws IllegalArgumentException {\n    return true;\n}\n\n/**\n * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int,\n *      boolean)\n */\npublic Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,\n        UnknownHostException {\n    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n}\n\n// -------------------------------------------------------------------\n// javadoc in org.apache.http.conn.scheme.SocketFactory says :\n// Both Object.equals() and Object.hashCode() must be overridden\n// for the correct operation of some connection managers\n// -------------------------------------------------------------------\n\npublic boolean equals(Object obj) {\n    return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));\n}\n\npublic int hashCode() {\n    return EasySSLSocketFactory.class.hashCode();\n}\n}\n", "public class EasyX509TrustManager implements X509TrustManager {\n\nprivate X509TrustManager standardTrustManager = null;\n\n/**\n * Constructor for EasyX509TrustManager.\n */\npublic EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException {\n    super();\n    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    factory.init(keystore);\n    TrustManager[] trustmanagers = factory.getTrustManagers();\n    if (trustmanagers.length == 0) {\n        throw new NoSuchAlgorithmException(\"no trust manager found\");\n    }\n    this.standardTrustManager = (X509TrustManager) trustmanagers[0];\n}\n\n/**\n * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType)\n */\npublic void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException {\n    standardTrustManager.checkClientTrusted(certificates, authType);\n}\n\n/**\n * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType)\n */\npublic void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException {\n    if ((certificates != null) &amp;&amp; (certificates.length == 1)) {\n        certificates[0].checkValidity();\n    } else {\n        standardTrustManager.checkServerTrusted(certificates, authType);\n    }\n}\n\n/**\n * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()\n */\npublic X509Certificate[] getAcceptedIssuers() {\n    return this.standardTrustManager.getAcceptedIssuers();\n}\n}\n", "public static HttpClient getNewHttpClient() {\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n        return new DefaultHttpClient(ccm, params);\n    } catch (Exception e) {\n        return new DefaultHttpClient();\n    }\n}\n", "String stringThatNeedsToBeEncrpyted = \"PutYourURL\"; \n        MessageDigest mdEnc = null;\n        try {\n            mdEnc = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } // Encryption algorithm\n        mdEnc.update(stringThatNeedsToBeEncrpyted.getBytes(), 0, stringThatNeedsToBeEncrpyted.length());\n        String md5 = new BigInteger(1, mdEnc.digest()).toString(16); \n        System.out.println(md5); \n", "public class MessageClass {\npublic static final String PARAM_REGISTRATION_ID = \"registration_id\";\n\npublic static final String PARAM_DELAY_WHILE_IDLE = \"delay_while_idle\";\n\npublic static final String PARAM_COLLAPSE_KEY = \"collapse_key\";\n\nprivate static final String UTF8 = \"UTF-8\";\n\npublic static String sendMessage(String auth_token, String registrationId,\n        String message) throws IOException {\n\n    StringBuilder postDataBuilder = new StringBuilder();\n    postDataBuilder.append(PARAM_REGISTRATION_ID).append(\"=\")\n            .append(registrationId);\n    postDataBuilder.append(\"&amp;\").append(PARAM_COLLAPSE_KEY).append(\"=\")\n            .append(\"1\");\n    postDataBuilder.append(\"&amp;\").append(\"data.payload\").append(\"=\")\n    .append(URLEncoder.encode(\"hello\", UTF8));\n\n\n    byte[] postData = postDataBuilder.toString().getBytes(UTF8);\n\n    // Hit the dm URL.\n\n    URL url = new URL(\"https://android.clients.google.com/c2dm/send\");\n    HttpsURLConnection\n            .setDefaultHostnameVerifier(new CustomizedHostnameVerifier());\n    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n    conn.setDoOutput(true);\n    conn.setUseCaches(false);\n    conn.setRequestMethod(\"POST\");\n    conn.setRequestProperty(\"Content-Type\",\n            \"application/x-www-form-urlencoded;charset=UTF-8\");\n    conn.setRequestProperty(\"Content-Length\",\n            Integer.toString(postData.length));\n    conn.setRequestProperty(\"Authorization\", \"GoogleLogin auth=\"\n            + auth_token);\n\n    OutputStream out = conn.getOutputStream();\n    out.write(postData);\n    out.close();\n\n    int responseCode = conn.getResponseCode();\n    if (responseCode == 401 || responseCode == 403) {  \n        // The token is too old - return false to retry later, will  \n        // fetch the token  \n        // from DB. This happens if the password is changed or token  \n        // expires. Either admin  \n        // is updating the token, or Update-Client-Auth was received by  \n        // another server,  \n        // and next retry will get the good one from database.  \n        Log.d(\"C2DM\", \"Unauthorized - need token\");  \n    }  \n    String updatedAuthToken = conn.getHeaderField(\"Update-Client-Auth\");  \n    if (updatedAuthToken != null &amp;&amp; !auth_token.equals(updatedAuthToken)) {  \n        Log.d(\"C2DM\",  \n                \"Got updated auth token from datamessaging servers: \"  \n                        + updatedAuthToken);  \n        sendMessage(updatedAuthToken,registrationId,\n                message);\n    }  \n    String responseLine = new BufferedReader(new InputStreamReader(  \n            conn.getInputStream())).readLine();  \n\n    // NOTE: You *MUST* use exponential backoff if you receive a 503  \n    // response code.  \n    // Since App Engine's task queue mechanism automatically does this  \n    // for tasks that  \n    // return non-success error codes, this is not explicitly  \n    // implemented here.  \n    // If we weren't using App Engine, we'd need to manually implement  \n    // this.  \n    if (responseLine == null || responseLine.equals(\"\")) {  \n        Log.i(\"C2DM\", \"Got \" + responseCode  \n                + \" response from Google AC2DM endpoint.\");  \n        throw new IOException(  \n                \"Got empty response from Google AC2DM endpoint.\");  \n    }  \n\n    String[] responseParts = responseLine.split(\"=\", 2);  \n    if (responseParts.length != 2) {  \n        Log.e(\"C2DM\", \"Invalid message from google: \" + responseCode  \n                + \" \" + responseLine);  \n        throw new IOException(\"Invalid response from Google \"  \n                + responseCode + \" \" + responseLine);  \n    }  \n\n    if (responseParts[0].equals(\"id\")) {  \n        Log.i(\"Tag\", \"Successfully sent data message to device: \"  \n                + responseLine);  \n    }  \n\n    if (responseParts[0].equals(\"Error\")) {  \n        String err = responseParts[1];  \n        Log.w(\"C2DM\",  \n                \"Got error response from Google datamessaging endpoint: \"  \n                        + err);  \n        // No retry.  \n        throw new IOException(err);  \n    }  \n    return responseLine;\n}\n\nprivate static class CustomizedHostnameVerifier implements HostnameVerifier {\n    public boolean verify(String hostname, SSLSession session) {\n        return true;\n    }\n}\n", "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @author Alexander Y. Kleymenov\n * @version $Revision$\n */\n\n\nimport java.security.AccessController;\nimport java.security.Provider;\n\npublic final class JSSEProvider extends Provider {\n\n    public JSSEProvider() {\n        super(\"HarmonyJSSE\", 1.0, \"Harmony JSSE Provider\");\n        AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {\n            public Void run() {\n                put(\"SSLContext.TLS\",\n                        \"org.apache.harmony.xnet.provider.jsse.SSLContextImpl\");\n                put(\"Alg.Alias.SSLContext.TLSv1\", \"TLS\");\n                put(\"KeyManagerFactory.X509\",\n                        \"org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl\");\n                put(\"TrustManagerFactory.X509\",\n                        \"org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl\");\n                return null;\n            }\n        });\n    }\n}\n", "import javax.activation.DataHandler;   \nimport javax.activation.DataSource;   \nimport javax.mail.Message;   \nimport javax.mail.PasswordAuthentication;   \nimport javax.mail.Session;   \nimport javax.mail.Transport;   \nimport javax.mail.internet.InternetAddress;   \nimport javax.mail.internet.MimeMessage;   \nimport java.io.ByteArrayInputStream;   \nimport java.io.IOException;   \nimport java.io.InputStream;   \nimport java.io.OutputStream;   \nimport java.security.Security;   \nimport java.util.Properties;   \n\npublic class GMailSender extends javax.mail.Authenticator {   \nprivate String mailhost = \"smtp.gmail.com\";   \nprivate String user;   \nprivate String password;   \nprivate Session session;   \n\nstatic {   \n    Security.addProvider(new com.provider.JSSEProvider());   \n}  \n\npublic GMailSender(String user, String password) {   \n    this.user = user;   \n    this.password = password;   \n\n    Properties props = new Properties();   \n    props.setProperty(\"mail.transport.protocol\", \"smtp\");   \n    props.setProperty(\"mail.host\", mailhost);   \n    props.put(\"mail.smtp.auth\", \"true\");   \n    props.put(\"mail.smtp.port\", \"465\");   \n    props.put(\"mail.smtp.socketFactory.port\", \"465\");   \n    props.put(\"mail.smtp.socketFactory.class\",   \n            \"javax.net.ssl.SSLSocketFactory\");   \n    props.put(\"mail.smtp.socketFactory.fallback\", \"false\");   \n    props.setProperty(\"mail.smtp.quitwait\", \"false\");   \n\n    session = Session.getDefaultInstance(props, this);   \n}   \n\nprotected PasswordAuthentication getPasswordAuthentication() {   \n    return new PasswordAuthentication(user, password);   \n}   \n\npublic synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   \n    try{\n    MimeMessage message = new MimeMessage(session);   \n    DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));   \n    message.setSender(new InternetAddress(sender));   \n    message.setSubject(subject);   \n    message.setDataHandler(handler);   \n    if (recipients.indexOf(',') &gt; 0)   \n        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   \n    else  \n        message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   \n    Transport.send(message);   \n    }catch(Exception e){\n\n    }\n}   \n\npublic class ByteArrayDataSource implements DataSource {   \n    private byte[] data;   \n    private String type;   \n\n    public ByteArrayDataSource(byte[] data, String type) {   \n        super();   \n        this.data = data;   \n        this.type = type;   \n    }   \n\n    public ByteArrayDataSource(byte[] data) {   \n        super();   \n        this.data = data;   \n    }   \n\n    public void setType(String type) {   \n        this.type = type;   \n    }   \n\n    public String getContentType() {   \n        if (type == null)   \n            return \"application/octet-stream\";   \n        else  \n            return type;   \n    }   \n\n    public InputStream getInputStream() throws IOException {   \n        return new ByteArrayInputStream(data);   \n    }   \n\n    public String getName() {   \n        return \"ByteArrayDataSource\";   \n    }   \n\n    public OutputStream getOutputStream() throws IOException {   \n        throw new IOException(\"Not Supported\");   \n    }   \n  }   \n}  \n", "SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, keySpec);\nbyte[] encrypted = cipher.doFinal(clearTextBytes);\n", "import java.security.GeneralSecurityException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class PassphraseWrapRSA {\n    private static KeyPair generateRSAKeyPair(final int size) {\n        KeyPairGenerator kpgen;\n        try {\n            kpgen = KeyPairGenerator.getInstance(\"RSA\");\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalStateException();\n        }\n        kpgen.initialize(size);\n        return kpgen.generateKeyPair();\n    }\n\n    public static byte[] generateSalt() {\n        final SecureRandom rng = new SecureRandom();\n        final byte[] salt = new byte[16];\n        rng.nextBytes(salt);\n        return salt;\n    }\n\n    private static SecretKey deriveAESKey(final byte[] salt,\n            final char[] password) {\n        try {\n            final SecretKeyFactory factory = SecretKeyFactory\n                    .getInstance(\"PBKDF2WithHmacSHA1\");\n            final KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);\n            final SecretKey keyWrapKey = factory.generateSecret(spec);\n            final SecretKey secret = new SecretKeySpec(keyWrapKey.getEncoded(),\n                    \"AES\");\n            return secret;\n\n        } catch (final Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private static byte[] encryptRSAPrivateKey(final RSAPrivateKey rsaPrivateKey,\n            final SecretKey aesKey) {\n        try {\n            final Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n\n            final SecureRandom ivGen = new SecureRandom();\n            final byte[] iv = new byte[c.getBlockSize()];\n            ivGen.nextBytes(iv);\n            c.init(Cipher.WRAP_MODE, aesKey, new IvParameterSpec(iv));\n            final byte[] wrappedKey = c.wrap(rsaPrivateKey);\n            return concat(iv, wrappedKey);\n        } catch (final GeneralSecurityException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static byte[] wrapRSAPrivateKey(final String passphrase,\n            final RSAPrivateKey rsaPrivateKey) {\n        // --- generate salt\n        final byte[] newSalt = generateSalt();\n\n        // --- derive symmetric key from salt and password\n        final SecretKey aesKey = deriveAESKey(newSalt,\n                passphrase.toCharArray());\n\n\n        final byte[] encryptedPrivate = encryptRSAPrivateKey(rsaPrivateKey, aesKey);\n        final byte[] saltedAndEncryptedPrivate = concat(newSalt,\n                encryptedPrivate);\n        return saltedAndEncryptedPrivate;\n    }\n\n    private static RSAPrivateKey decryptRSAPrivateKey(final byte[] encryptedRSAPrivateKey,\n            final SecretKey aesKey) throws InvalidKeyException {\n        try {\n            final Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n\n            int offset = 0;\n            final byte[] iv = Arrays.copyOfRange(encryptedRSAPrivateKey, 0,\n                    c.getBlockSize());\n            offset += c.getBlockSize();\n\n            c.init(Cipher.UNWRAP_MODE, aesKey, new IvParameterSpec(iv));\n            final Key key = c.unwrap(Arrays.copyOfRange(encryptedRSAPrivateKey, offset,\n                    encryptedRSAPrivateKey.length), \"RSA\", Cipher.PRIVATE_KEY);\n            return (RSAPrivateKey) key;\n        } catch (final InvalidKeyException e) {\n            throw e;\n        } catch (final GeneralSecurityException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static RSAPrivateKey unwrapRSAPrivateKey(final String passphrase,\n            final byte[] saltedAndEncryptedPrivate) throws InvalidKeyException {\n        int offset = 0;\n        final byte[] backSalt = Arrays.copyOfRange(saltedAndEncryptedPrivate,\n                offset, 16);\n        offset += 16;\n        final SecretKey backAESKey = deriveAESKey(backSalt,\n                passphrase.toCharArray());\n        final byte[] backEncryptedPrivateKey = Arrays.copyOfRange(\n                saltedAndEncryptedPrivate, offset,\n                saltedAndEncryptedPrivate.length);\n        final RSAPrivateKey decryptedPrivate = decryptRSAPrivateKey(\n                backEncryptedPrivateKey, backAESKey);\n        return decryptedPrivate;\n    }\n\n    public static RSAPublicKey decodeRSAPublicKey(\n            final byte[] x509EncodedPUblicKey) throws InvalidKeySpecException {\n        try {\n            final KeyFactory rsaPublicKeyFactory = KeyFactory.getInstance(\"RSA\");\n            final PublicKey pubKey = rsaPublicKeyFactory\n                    .generatePublic(new X509EncodedKeySpec(x509EncodedPUblicKey));\n            return (RSAPublicKey) pubKey;\n        } catch (final InvalidKeySpecException e) {\n            throw e;\n        } catch (final GeneralSecurityException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static byte[] encodeRSAPublicKey(final RSAPublicKey rsaPublicKey) {\n        return rsaPublicKey.getEncoded();\n    }\n\n    private static byte[] concat(final byte[] a, final byte[] a2) {\n        final byte[] result = new byte[a.length + a2.length];\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(a2, 0, result, a.length, a2.length);\n        return result;\n    }\n\n    public static void main(final String[] args) throws Exception {\n        // --- not required for Java 8\n        Security.addProvider(new BouncyCastleProvider());\n\n        // --- setup key pair (generated in advance)\n        final String passphrase = \"owlstead\";\n        final KeyPair kp = generateRSAKeyPair(1024);\n        final RSAPublicKey rsaPublicKey = (RSAPublicKey) kp.getPublic();\n        final RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) kp.getPrivate();\n\n        // --- encode and wrap\n        byte[] x509EncodedRSAPublicKey = encodeRSAPublicKey(rsaPublicKey);\n        final byte[] saltedAndEncryptedPrivate = wrapRSAPrivateKey(\n                passphrase, rsaPrivateKey);\n\n        // --- decode and unwrap\n        final RSAPublicKey retrievedRSAPublicKey = decodeRSAPublicKey(x509EncodedRSAPublicKey);\n        final RSAPrivateKey retrievedRSAPrivateKey = unwrapRSAPrivateKey(passphrase,\n                saltedAndEncryptedPrivate);\n\n        // --- check result\n        System.out.println(retrievedRSAPublicKey);\n        System.out.println(retrievedRSAPrivateKey);\n    }\n}\n", "import java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport android.util.Base64;\n\npublic class EncodeDecodeAES {\n\n    private final static String HEX = \"0123456789ABCDEF\";\n    private final static String key = \"encryptionKey\"\n    private final static int JELLY_BEAN_4_2 = 17;\n\n    private final static byte[] key = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n    public static String encrypt(String cleartext) throws Exception {\n        return encrypt(key,cleartext);\n    }\n\n    public static String decrypt(String cleartext) throws Exception {\n        return decrypt(key,cleartext);\n    }\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        String fromHex = toHex(result);\n        String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));\n        return base64;\n    }     \n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n\n        byte[] seedByte = seed.getBytes();\n        System.arraycopy(seedByte, 0, key, 0, ((seedByte.length &lt; 16) ? seedByte.length : 16));\n        String base64 = new String(Base64.decode(encrypted, 0));\n        byte[] rawKey = getRawKey(seedByte);\n        byte[] enc = toByte(base64);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n    public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext);\n        return result;\n    }\n\n\n    public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = decrypt(rawKey, encrypted);\n        return result;\n\n    }\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\"); // , \"SC\");\n        SecureRandom sr = null;\n        if (android.os.Build.VERSION.SDK_INT &gt;= JELLY_BEAN_4_2) {\n         sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n        } else {\n         sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        }\n        sr.setSeed(seed);\n        try {\n         kgen.init(256, sr);\n         // kgen.init(128, sr);\n        } catch (Exception e) {\n         // Log.w(LOG, \"This device doesn't suppor 256bits, trying 192bits.\");\n         try {\n          kgen.init(192, sr);\n         } catch (Exception e1) {\n          // Log.w(LOG, \"This device doesn't suppor 192bits, trying 128bits.\");\n          kgen.init(128, sr);\n         }\n       }\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\"); // /ECB/PKCS7Padding\", \"SC\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\"); // /ECB/PKCS7Padding\", \"SC\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n\n    public static String fromHex(String hex) {\n\n        return new String(toByte(hex));\n    }\n\n\n    public static byte[] toByte(String hexString) {\n\n        int len = hexString.length() / 2;\n        byte[] result = new byte[len];\n        for (int i = 0; i &lt; len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();\n        return result;\n    }\n\n\n    public static String toHex(byte[] buf) {\n\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2 * buf.length);\n        for (int i = 0; i &lt; buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));\n    }\n\n}\n", "   public class FacebookActivity extends Activity {\n\nString p_name;\nString p_desc;\n\nString path;\nString timeStamp;\nString senduri;\nBoolean canshare=false;\n\n\n\n private static final String PERMISSION = \"publish_actions\";\n\n\n\nint fun=0;\nSharedPreferences settings;\nWebDialog feedDialog;\nButton facebookButton;\n\nprivate static final String TAG = \"Facebook\";\n\n  boolean isClicked=false;\nprivate Session.StatusCallback statusCallback = \n        new Session.StatusCallback() {\n        @Override\n        public void call(Session session, \n                SessionState state, Exception exception) {\n            onSessionStateChange(session, state, exception);\n        }\n    };\n    private static final List&lt;String&gt; PERMISSIONS = Arrays.asList(\"publish_actions\");\n    private static final String PENDING_PUBLISH_KEY = \"pendingPublishReauthorization\";\n    private boolean pendingPublishReauthorization = false;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_facebook);\n\n\n    //facebook connector initialization************************\n     Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);\n     Session session = Session.getActiveSession();\n     if (session == null) { \n         if (savedInstanceState != null) {\n             session = Session.restoreSession(this, null, statusCallback, savedInstanceState);\n         }\n         if (session == null) {\n             session = new Session(this);\n         }\n         Session.setActiveSession(session);\n         if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {\n\n         }\n     }\n\n     try {\n         PackageInfo info = getPackageManager().getPackageInfo(\n                 getApplicationContext().getPackageName(), PackageManager.GET_SIGNATURES);\n         for (Signature signature : info.signatures) \n         {\n             MessageDigest md = MessageDigest.getInstance(\"SHA\");\n             md.update(signature.toByteArray());\n             Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n         }\n\n     } catch (NameNotFoundException ex) {\n     } catch (NoSuchAlgorithmException ex2) {\n     }\n\n\n\n\n\n\n\n\n\n}\n\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n    // Inflate the menu; this adds items to the action bar if it is present.\n    getMenuInflater().inflate(R.menu.facebook, menu);\n    return true;\n}\n\n\n\n@Override\nprotected void onStart() {\n    Log.d(TAG, \"onStart\");\n    super.onStart();\n\n\n    Session.getActiveSession().addCallback(statusCallback);\n}\n@Override\nprotected void onDestroy() {\n    Log.d(TAG, \"onDestroy\");\n    super.onDestroy();\n\n\n\n}\n@Override\npublic void onStop() {\n    Log.d(TAG, \"onStop\");\n    super.onStop();\n\n    Session.getActiveSession().removeCallback(statusCallback);\n}\n\npublic void onClickPublishPic(View v) {\n\n    //postPhoto();\n        fun=1;\n        onClickLogin();\n        isClicked=true;\n\n\n\n}\npublic void onClickPublishStory(View v) {\n\n    //postPhoto();\n        fun=2;\n        onClickLogin();\n        isClicked=true;\n\n\n\n}\n\n\nprotected void onSessionStateChange(Session session, SessionState state,\n        Exception exception) {\n    session = Session.getActiveSession();\n    if (session.isOpened()) {\n        if(fun==1){\n        postPhoto();\n        }else if(fun==2){\n            publishStory();\n        }\n    } else {\n        //nothing .. maybe message\n    }\n\n}\n\nprivate void onClickLogin() {\n\n\n        Session.openActiveSession(this, true, statusCallback);\n\n}\n @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        Session session = Session.getActiveSession();\n        Session.saveSession(session, outState);\n    }\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    super.onActivityResult(requestCode, resultCode, data);\n\n        Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);\n        //Session.openActiveSession(this, true, statusCallback);\n\n    Log.d(\"msg\",\" \"+resultCode);\n\n}\n\n\n private void postPhoto() {\n\n     Session session = Session.getActiveSession();\n        if (session != null) {\n            //pendingAction = action;\n            if (hasPublishPermission()) {\n                Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.ic_launcher);\n                Request request = Request.newUploadPhotoRequest(session, image, new Request.Callback() {\n                    @Override\n                    public void onCompleted(Response response) {\n                        //showPublishResult(getString(R.string.app_name), response.getGraphObject(), response.getError());\n                        Toast.makeText(getBaseContext(),\n                                \"Image Uploaded to facebook\",\n                                Toast.LENGTH_SHORT).show();\n                    }\n                });\n\n                Bundle params = request.getParameters();\n                params.putString(\"name\", \"My Science Lab Diagram\");\n                request.setParameters(params);\n                Request.executeBatchAsync(request);\n\n                // We can do the action right away.\n                //handlePendingAction();\n                //return;\n            } else if (session.isOpened()) {\n                // We need to get new permissions, then complete the action when we get called back.\n                session.requestNewPublishPermissions(new Session.NewPermissionsRequest(this, PERMISSION));\n                //return;\n            }\n        }\n\n\n\n    }\n\n private void publishStory() {\n        Session session = Session.getActiveSession();\n\n        if (session != null){\n\n            // Check for publish permissions    \n            List&lt;String&gt; permissions = session.getPermissions();\n            if (!isSubsetOf(PERMISSIONS, permissions)) {\n                pendingPublishReauthorization = true;\n                Session.NewPermissionsRequest newPermissionsRequest = new Session\n                        .NewPermissionsRequest(this, PERMISSIONS);\n            session.requestNewPublishPermissions(newPermissionsRequest);\n                return;\n            }\n\n            Bundle postParams = new Bundle();\n            postParams.putString(\"name\", \"Facebook SDK for Android\");\n            postParams.putString(\"caption\", \"Build great social apps and get more installs.\");\n            postParams.putString(\"description\", \"The Facebook SDK for Android makes it easier and faster to develop Facebook integrated Android apps.\");\n            postParams.putString(\"link\", \"https://developers.facebook.com/android\");\n            postParams.putString(\"picture\", \"https://raw.github.com/fbsamples/ios-3.x-howtos/master/Images/iossdk_logo.png\");\n\n            Request.Callback callback= new Request.Callback() {\n                public void onCompleted(Response response) {\n                    JSONObject graphResponse = response\n                                               .getGraphObject()\n                                               .getInnerJSONObject();\n                    String postId = null;\n                    try {\n                        postId = graphResponse.getString(\"id\");\n                    } catch (JSONException e) {\n                        Log.i(TAG,\n                            \"JSON error \"+ e.getMessage());\n                    }\n                    FacebookRequestError error = response.getError();\n                    if (error != null) {\n                        Toast.makeText(FacebookActivity.this\n                             .getApplicationContext(),\n                             error.getErrorMessage(),\n                             Toast.LENGTH_SHORT).show();\n                        } else {\n                            Toast.makeText(FacebookActivity.this\n                                 .getApplicationContext(), \n                                 postId,\n                                 Toast.LENGTH_LONG).show();\n                    }\n                }\n            };\n\n            Request request = new Request(session, \"me/feed\", postParams, \n                                  HttpMethod.POST, callback);\n\n            RequestAsyncTask task = new RequestAsyncTask(request);\n            task.execute();\n        }\n\n    }\n\n\n private boolean isSubsetOf(Collection&lt;String&gt; subset, Collection&lt;String&gt; superset) {\n        for (String string : subset) {\n            if (!superset.contains(string)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n private boolean hasPublishPermission() {\n        Session session = Session.getActiveSession();\n        return session != null &amp;&amp;       session.getPermissions().contains(\"publish_actions\");\n     }\n", "KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\nkgen.init(KEY_SIZE);\nSecretKey skey = kgen.generateKey();\n", "KeyStore ks;\nks = KeyStore.getInstance(\"AndroidCAStore\");\nks.load(null, null);\nkeyChain = KeyChain.getCertificateChain(ctx, certificateAlias);\nprivateKey = KeyChain.getPrivateKey(ctx, certificateAlias);\n", "public static void main(String[] args) throws Exception {\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\n    kpg.initialize(1024);\n    KeyPair keyPair = kpg.generateKeyPair();\n    PrivateKey privKey = keyPair.getPrivate();\n    PublicKey pubKey = keyPair.getPublic();\n\n    // Encrypt\n    cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n    String test = \"My test string\";\n    String ciphertextFile = \"ciphertextRSA.txt\";\n    InputStream fis = new ByteArrayInputStream(test.getBytes(\"UTF-8\"));\n\n    FileOutputStream fos = new FileOutputStream(ciphertextFile);\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n\n    byte[] block = new byte[32];\n    int i;\n    while ((i = fis.read(block)) != -1) {\n        cos.write(block, 0, i);\n    }\n    cos.close();\n\n    // Decrypt\n    String cleartextAgainFile = \"cleartextAgainRSA.txt\";\n\n    cipher.init(Cipher.DECRYPT_MODE, privKey);\n\n    fis = new FileInputStream(ciphertextFile);\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    fos = new FileOutputStream(cleartextAgainFile);\n\n    while ((i = cis.read(block)) != -1) {\n        fos.write(block, 0, i);\n    }\n    fos.close();\n}\n", "KeyStore keyStore = ...;\n TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");\n tmf.init(keyStore);\n SSLContext context = SSLContext.getInstance(\"TLS\");\n context.init(null, tmf.getTrustManagers(), null);\n URL url = new URL(\"https://www.example.com/\");\n HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();\n urlConnection.setSSLSocketFactory(context.getSocketFactory());\n InputStream in = urlConnection.getInputStream();\n", "public static void main(String[] args) throws Exception {\n\n    Cipher aes = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n    SecretKeySpec key = new SecretKeySpec(\"YELLOW SUBMARINE\".getBytes(), \"AES\");\n    IvParameterSpec iv = new IvParameterSpec(new byte[16]);\n\n    aes.init(Cipher.DECRYPT_MODE, key, iv);\n\n    byte[] cipherText = DatatypeConverter.parseHexBinary(\"60FA36707E45F499DBA0F25B922301A57192FEBE51B66D25BBFCC348138FD3F7\");\n\n    System.out.println(DatatypeConverter.printHexBinary(aes.doFinal(cipherText)));\n    System.out.println(DatatypeConverter.printHexBinary(aes.doFinal(cipherText)));\n}\n", "Cipher wrapper = Cipher.getInstance(\"RSA\", \"BC\");\nwrapper.init(Cipher.ENCRYPT_MODE, publicKey);\nencryptedData= wrapper.doFinal(unencryptedData);\n", "kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(1024);\n        KeyPair kp = kpg.genKeyPair();\n        publicKey = kp.getPublic();\n        privateKey = kp.getPrivate();\n", "...\n\n// ***** ADDITION *****\nprivate AssetManager mAssetManager;\n\npublic ImageLoader(Context context){\n    //Make the background thead low priority. This way it will not affect the UI performance\n    photoLoaderThread.setPriority(Thread.NORM_PRIORITY-1);\n    // ***** ADDITION *****\n    mAssetManager = context.getAssets();\n\n    //Find the dir to save cached images\n    if (android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED))\n        cacheDir=new File(android.os.Environment.getExternalStorageDirectory(),\"LazyList\");\n    else\n        cacheDir=context.getCacheDir();\n    if(!cacheDir.exists())\n        cacheDir.mkdirs();\n}\n\nprivate Bitmap getBitmap(String src) {\n    Bitmap myBitmap = null;\n        //Decryption\n        try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        SecretKeySpec keySpec = new SecretKeySpec(\"01234567890abcde\".getBytes(), \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(\"fedcba9876543210\".getBytes());\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\n        // ***** CHANGE *****\n        InputStream input = mAssetManager.open(src); //open file in asset manager\n        CipherInputStream cis = new CipherInputStream(input, cipher);\n\n        myBitmap = BitmapFactory.decodeStream(cis);\n\n        }\n        catch(Exception e){\n            e.printStackTrace();\n            Log.v(\"ERROR\",\"Error : \"+e);\n        }\n\n\n        return myBitmap;\n    }\n....\n", "@Override\npublic void onConfigurationChanged(Configuration newConfig) {\n    super.onConfigurationChanged(newConfig);\n    if (newConfig.getConfiguration() == Configuration.ORIENTATION_LANDSCAPE) {\n        setContentView(landscape_layout);\n    } else {\n        setContentView(portrait_layout);\n    }\n    initViews();\n}\n", "boolean isCertExist;\n    TrustManagerFactory tmf;\n    try {\n        tmf = TrustManagerFactory.getInstance(TrustManagerFactory\n                .getDefaultAlgorithm());\n\n        tmf.init((KeyStore) null);\n\n        X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];\n        for (X509Certificate cert : xtm.getAcceptedIssuers()) {\n            if (cert.getIssuerDN().getName().contains(\"MyCert\")) {\n                isCertExist = true;\n                break;\n            }\n        }\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (KeyStoreException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n", "boolean isCertExist;\n    try \n    {\n        KeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");\n        if (ks != null) \n        {\n            ks.load(null, null);\n            Enumeration aliases = ks.aliases();\n            while (aliases.hasMoreElements()) \n            {\n                String alias = (String) aliases.nextElement();\n                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);\n\n                if (cert.getIssuerDN().getName().contains(\"MyCert\")) {\n                    isCertExist = true;\n                    break;\n                }\n            }\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (KeyStoreException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (java.security.cert.CertificateException e) {\n        e.printStackTrace();\n    }\n", "public byte[] encTripleDes (String txt, byte [] key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, InvalidKeySpecException{\n    DESedeKeySpec keySpec = new DESedeKeySpec(key);\n    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(\"DESede\");\n    SecretKey ky = keyfactory.generateSecret(keySpec);\n\n    Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, ky);\n    return cipher.doFinal(txt.getBytes(\"UTF-8\"));\n\n}\n", "public byte[] uncTripleDes (byte [] encryptedTextBytes, byte [] key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, InvalidKeySpecException{\n    DESedeKeySpec keySpec = new DESedeKeySpec(key);\n    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(\"DESede\");\n    SecretKey ky = keyfactory.generateSecret(keySpec);\n\n    Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, ky);\n    return cipher.doFinal(encryptedTextBytes);\n\n}\n", "public byte[] sumCalc (){ \n    String key = \"anyKey\";\n    byte[] hashedKey = null;\n    try {\n        byte [] byteKey = key.getBytes(\"UTF-8\");\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        hashedKey = md.digest(byteKey);\n    }catch (Exception ex){\n        System.err.println(\"Error generant clau\" + ex);  \n    }\n    return hashedKey;\n}\n", "@Override\nprotected void onCreate(Bundle savedInstanceState){\nsuper.onCreate(savedInstanceState);\n\ntry {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            getPackageName(), \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"TAG\", \"Hash to copy ==&gt; \"+ Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n\n} \ncatch (NoSuchAlgorithmException e) {\n\n}\n}\n", "Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\"); \ncipher.init(Cipher.ENCRYPT_MODE, key); \nString encryptedText = Base64.encodeToString(cipher.doFinal(message), Base64.DEFAULT);\n", "public static String getDeviceId(Context context)\n{\n    String android_id = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);\n    String deviceId = md5(android_id).toUpperCase();\n    //return deviceId;\n    return \"0\";\n}\n\npublic static final String md5(final String s) {\n    try {\n        // Create MD5 Hash\n        MessageDigest digest = java.security.MessageDigest\n                .getInstance(\"MD5\");\n        digest.update(s.getBytes());\n        byte messageDigest[] = digest.digest();\n\n        // Create Hex String\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i &lt; messageDigest.length; i++) {\n            String h = Integer.toHexString(0xFF &amp; messageDigest[i]);\n            while (h.length() &lt; 2)\n                h = \"0\" + h;\n            hexString.append(h);\n        }\n        return hexString.toString();\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "public class X509TrustManager implements X509TrustManager {\n\nprivate final static String TAG = \"X509TrustManager\";\n\nprivate static final boolean DEAFULT_TRUST_ALL_SSL_CONNECTIONS = true;\n\nprivate X509TrustManager standardTrustManager = null;\n\nprivate boolean trustAllSSLConnections;\n\n/**\n * Constructor for EasyX509TrustManager.\n */\npublic X509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException {\n\n    trustAllSSLConnections = DEAFULT_TRUST_ALL_SSL_CONNECTIONS;\n\n    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    factory.init(keystore);\n    TrustManager[] trustmanagers = factory.getTrustManagers();\n    if (trustmanagers.length == 0) {\n        throw new NoSuchAlgorithmException(\"no trust manager found\");\n    }\n    this.standardTrustManager = (X509TrustManager) trustmanagers[0];\n}\n\n@Override\npublic void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException {\n    standardTrustManager.checkClientTrusted(certificates, authType);\n}\n\n/**\n * verified the server certificate\n */\n@Override\npublic void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException {\n\n\n        X509Certificate certificate = certificates[0];\n        byte[] bytes = certificate.getTBSCertificate();\n\n        // Compare your the certificate\u00e2\u0080\u0099s bytes to yours hardcoded certificate.         \n}\n\n/**\n * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()\n */\n@Override\npublic X509Certificate[] getAcceptedIssuers() {\n    return this.standardTrustManager.getAcceptedIssuers();\n}\n", "public class SSLSocketFactory implements LayeredSocketFactory {\n\nprivate SSLContext sslcontext = null;\n\nprivate static SSLContext createEasySSLContext() throws IOException {\n    try {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(null, new TrustManager[] { new X509TrustManager(null) }, null);\n        return context;\n    } catch (Exception e) {\n        throw new IOException(e.getMessage());\n    }\n}\n\nprivate SSLContext getSSLContext() throws IOException {\n    if (this.sslcontext == null) {\n        this.sslcontext = createEasySSLContext();\n    }\n    return this.sslcontext;\n}\n\npublic Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort, HttpParams params)\n        throws IOException, UnknownHostException, ConnectTimeoutException {\n    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n    int soTimeout = HttpConnectionParams.getSoTimeout(params);\n\n    InetSocketAddress remoteAddress = new InetSocketAddress(host, port);\n    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());\n\n    if ((localAddress != null) || (localPort &gt; 0)) {\n        // we need to bind explicitly\n        if (localPort &lt; 0) {\n            localPort = 0; // indicates \"any\"\n        }\n        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);\n        sslsock.bind(isa);\n    }\n\n    sslsock.connect(remoteAddress, connTimeout);\n    sslsock.setSoTimeout(soTimeout);\n    return sslsock;\n\n}\n\npublic Socket createSocket() throws IOException {\n    return getSSLContext().getSocketFactory().createSocket();\n}\n\npublic boolean isSecure(Socket socket) throws IllegalArgumentException {\n    return true;\n}\n\npublic Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n}\n\n// -------------------------------------------------------------------\n// javadoc in org.apache.http.conn.scheme.SocketFactory says :\n// Both Object.equals() and Object.hashCode() must be overridden\n// for the correct operation of some connection managers\n// -------------------------------------------------------------------\n\npublic boolean equals(Object obj) {\n    return ((obj != null) &amp;&amp; obj.getClass().equals(SSLSocketFactory.class));\n}\n\npublic int hashCode() {\n    return SSLSocketFactory.class.hashCode();\n}\n", "public class EncryptionHelper {\n\n// Encrypts string and encode in Base64\npublic static String encryptText(String plainText,String key, String IV) throws Exception {\n   // ---- Use specified 3DES key and IV from other source --------------\n    byte[] plaintext = plainText.getBytes();//input\n    byte[] tdesKeyData = key.getBytes();// your encryption key\n\n    byte[] myIV = IV.getBytes();// initialization vector\n\n    Cipher c3des = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n    SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, \"DESede\");\n    IvParameterSpec ivspec = new IvParameterSpec(myIV);\n\n    c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);\n    byte[] cipherText = c3des.doFinal(plaintext);\n    String encryptedString = Base64.encodeToString(cipherText,\n            Base64.DEFAULT);\n    // return Base64Coder.encodeString(new String(cipherText));\n    return encryptedString;\n}\n", "/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements. See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership. The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License. You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied. See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.Header;\nimport org.apache.http.HeaderElement;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpException;\nimport org.apache.http.HttpRequest;\nimport org.apache.http.HttpRequestInterceptor;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpResponseInterceptor;\nimport org.apache.http.HttpVersion;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.ConnectTimeoutException;\nimport org.apache.http.conn.scheme.LayeredSocketFactory;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.scheme.SocketFactory;\nimport org.apache.http.entity.HttpEntityWrapper;\nimport org.apache.http.impl.client.BasicCredentialsProvider;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpConnectionParams;\nimport org.apache.http.params.HttpParams;\nimport org.apache.http.params.HttpProtocolParams;\nimport org.apache.http.protocol.HttpContext;\n\n\n/**\n * Easy to use Http and Https client, that transparently adds gzip compression\n * and ignores all Https certificates. It can also be used for using credentials\n * in your connection.\n *\n * This class was created for Android applications, where the appropriate apache libraries\n * are already available. If you are developing for another platform, make sure\n * to add the httpclient, httpcore and commons-logging libs to your buildpath.\n * They can be downloaded from http://hc.apache.org/downloads.cgi\n *\n * &lt;code&gt;&lt;br/&gt;\n EasyHttpClient client = new EasyHttpClient();&lt;br/&gt;\n System.out.println(client.get(\"https://encrypted.google.com/\"));&lt;br/&gt;\n * &lt;/code&gt;\n *\n * @author match2blue software development GmbH\n * @author Ren\u00c5\u00bd Fischer, Ulrich Scheller\n */\npublic class EasyHttpClient extends DefaultHttpClient {\n    /**\n     * Default http port\n     */\n    private final static int HTTP_PORT = 80;\n\n    /**\n     * Default https port\n     */\n    private final static int HTTPS_PORT = 443;\n\n    protected int lastStatusCode;\n\n    protected String lastReasonPhrase;\n\n    /**\n     * Default constructor that initializes gzip handling. It adds the\n     * Accept-Encoding gzip flag and also decompresses the response from the server.\n     */\n    public EasyHttpClient() {\n        addRequestInterceptor(new HttpRequestInterceptor() {\n            public void process(final HttpRequest request,\n                                final HttpContext context) throws HttpException, IOException {\n                if (!request.containsHeader(\"Accept-Encoding\")) {\n                    request.addHeader(\"Accept-Encoding\", \"gzip\");\n                }\n            }\n        });\n\n        addResponseInterceptor(new HttpResponseInterceptor() {\n            public void process(final HttpResponse response, final HttpContext context) throws HttpException, IOException {\n                HttpEntity entity = response.getEntity();\n                Header ceheader = entity.getContentEncoding();\n                if (ceheader != null) {\n                    for (HeaderElement headerElement : ceheader.getElements()) {\n                        if (headerElement.getName().equalsIgnoreCase(\"gzip\")) {\n                            response.setEntity(new GzipEntityWrapper(response.getEntity()));\n                            lastStatusCode = response.getStatusLine().getStatusCode();\n                            lastReasonPhrase = response.getStatusLine().getReasonPhrase();\n                            return;\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Constructor which handles credentials for the connection (only if username and password are set)\n     *\n     * param username\n     * param password\n     */\n    public EasyHttpClient(String username, String password) {\n        if(username != null &amp;&amp; password != null) {\n            UsernamePasswordCredentials c = new UsernamePasswordCredentials(username,password);\n            BasicCredentialsProvider cP = new BasicCredentialsProvider();\n            cP.setCredentials(AuthScope.ANY, c);\n            setCredentialsProvider(cP);\n        }\n    }\n\n    /**\n     * Function that creates a ClientConnectionManager which can handle http and https.\n     * In case of https self signed or invalid certificates will be accepted.\n     */\n    @Override\n    protected ClientConnectionManager createClientConnectionManager() {\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, \"utf-8\");\n        params.setBooleanParameter(\"http.protocol.expect-continue\", false);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), HTTP_PORT));\n        registry.register(new Scheme(\"https\", new EasySSLSocketFactory(), HTTPS_PORT));\n        ThreadSafeClientConnManager manager = new ThreadSafeClientConnManager(params, registry);\n\n        return manager;\n    }\n\n    /**\n     * Make a get request to the specified url\n     * @param url\n     * @return the response string, null if there was an error\n     */\n    public String get(String url) {\n        HttpGet getReq = new HttpGet(url);\n        InputStream content = null;\n        try {\n            content = execute(getReq).getEntity().getContent();\n            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n            byte[] buf = new byte[1024];\n            int len;\n            while ((len = content.read(buf)) &gt; 0) {\n                bout.write(buf, 0, len);\n            }\n            content.close();\n            return bout.toString();\n        } catch (IllegalStateException e) {\n            e.printStackTrace();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n//    public static void main(String[] args) {\n//        EasyHttpClient client = new EasyHttpClient();\n//        System.out.println(client.get(\"https://encrypted.google.com/\"));\n//    }\n}\n\nclass GzipEntityWrapper extends HttpEntityWrapper {\n    public GzipEntityWrapper(HttpEntity wrapped) {\n        super(wrapped);\n    }\n\n    @Override\n    public InputStream getContent() throws IOException, IllegalStateException {\n        return new GZIPInputStream(wrappedEntity.getContent());\n    }\n\n    @Override\n    public long getContentLength() {\n        return -1; // unknown\n    }\n}\n\n\n/**\n * This socket factory will create ssl socket that accepts self signed\n * certificate\n *\n * author olamy\n * version $Id: EasySSLSocketFactory.java 765355 2009-04-15 20:59:07Z evenisse$\n * since 1.2.3\n */\nclass EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory {\n    private SSLContext sslcontext = null;\n\n    private static SSLContext createEasySSLContext() throws IOException {\n        try {\n            SSLContext context = SSLContext.getInstance(\"TLS\");\n            context.init(null,\n                    new TrustManager[] { new TrivialTrustManager() }, null);\n            return context;\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n    }\n\n    private SSLContext getSSLContext() throws IOException {\n        if (this.sslcontext == null) {\n            this.sslcontext = createEasySSLContext();\n        }\n        return this.sslcontext;\n    }\n\n    /**\n     * @see SocketFactory#connectSocket(Socket,\n     * String, int, InetAddress, int,\n     * HttpParams)\n     */\n    public Socket connectSocket(Socket sock, String host, int port,\n                                InetAddress localAddress, int localPort, HttpParams params)\n            throws IOException, UnknownHostException, ConnectTimeoutException {\n        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n        int soTimeout = HttpConnectionParams.getSoTimeout(params);\n\n        InetSocketAddress remoteAddress = new InetSocketAddress(host, port);\n        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());\n\n        if ((localAddress != null) || (localPort &gt; 0)) {\n// we need to bind explicitly\n            if (localPort &lt; 0) {\n                localPort = 0; // indicates \"any\"\n            }\n            InetSocketAddress isa = new InetSocketAddress(localAddress,\n                    localPort);\n            sslsock.bind(isa);\n        }\n\n        sslsock.connect(remoteAddress, connTimeout);\n        sslsock.setSoTimeout(soTimeout);\n        return sslsock;\n    }\n\n    /**\n     * @see SocketFactory#createSocket()\n     */\n    public Socket createSocket() throws IOException {\n        return getSSLContext().getSocketFactory().createSocket();\n    }\n\n    /**\n     * @see SocketFactory#isSecure(Socket)\n     */\n    public boolean isSecure(Socket socket) throws IllegalArgumentException {\n        return true;\n    }\n\n    /**\n     * @see LayeredSocketFactory#createSocket(Socket,\n     * String, int, boolean)\n     */\n    public Socket createSocket(Socket socket, String host, int port,\n                               boolean autoClose) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(socket, host,\n                port, autoClose);\n    }\n\n// -------------------------------------------------------------------\n// javadoc in org.apache.http.conn.scheme.SocketFactory says :\n// Both Object.equals() and Object.hashCode() must be overridden\n// for the correct operation of some connection managers\n// -------------------------------------------------------------------\n\n    public boolean equals(Object obj) {\n        return ((obj != null) &amp;&amp; obj.getClass() == EasyHttpClient.class.getClass());\n    }\n\n    public int hashCode() {\n        return EasySSLSocketFactory.class.hashCode();\n    }\n}\n\n\nclass TrivialTrustManager implements X509TrustManager {\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n    }\n\n    public X509Certificate[] getAcceptedIssuers() {\n        return new X509Certificate[0];\n    }\n}\n", "PKCS8EncodedKeySpec privSpec = new PKCS8EncodedKeySpec(s_privateKeyIn1t);\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\", \"BC\");\nPrivateKey privateKey = keyFactory.generatePrivate(privSpec);\n", "TextView tv1; \nTextView tv2; \nTextView tv3; \nButton convert; \nString publicKeyFilename = null; \nString privateKeyFilename = null; \nString ST = \"Ebenezersawesome\"; \n\n@Override public void onCreate(Bundle savedInstanceState) \n{ \n    super.onCreate(savedInstanceState); \n    setContentView(R.layout.main); \n    Log.d(\"Ebz\", \"Made it to onCreate\"); \n    tv1 = (TextView) findViewById(R.id.tv1); \n    tv2 = (TextView) findViewById(R.id.tv2); \n    tv3 = (TextView) findViewById(R.id.tv3); \n    convert = (Button) findViewById(R.id.button1); \n\n    try { \n                byte[]plainText = \"ST\".getBytes(\"UTF8\"); \n                Log.d(\"Ebz\", \"made it to Try Block\"); \n                KeyPairGenerator keyGen = \n                    KeyPairGenerator.getInstance(\"RSA\"); \n                keyGen.initialize(4096); \n                KeyPair key = keyGen.generateKeyPair(); \n                Cipher cipher = \n                    Cipher.getInstance(\"RSA/ECB/PKCS1Padding\"); \n                tv3.setText(cipher.getProvider().getInfo().toString()); \n                //tv3.setText(ST); \n                cipher.init(Cipher.ENCRYPT_MODE, key.getPublic()); \n                byte[]cipherText = cipher.doFinal(plainText); \n                tv1.setText(new String(cipherText, \"UTF8\").toString()); \n                //tv1.setText(ST); \n                byte[]newPlainText = cipher.doFinal(cipherText); \n                tv2.setText(new String(newPlainText, \"UTF8\").toString()); \n                //tv2.setText(ST); \n            } catch(Exception e) { \n                System.out.println(\"error\"); \n            }\n    // tv2.setText(ST); \n    convert.setOnClickListener(new OnClickListener() { \n        public void onClick(View v) { \n            Log.d(\"Ebz\", \"Made it to onCreate\");  \n        } \n    }); \n}\n", "public byte[] getMD5(String fileAContents) throws NoSuchAlgorithmException {\n     MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n     messageDigest.update(fileAContents.getBytes());\n     return messageDigest.digest();\n}\n", "public static String encodePassword(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        String result;\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        md.update(password.getBytes(\"iso-8859-1\"), 0, password.length());\n        byte[] sha1hash = md.digest();\n        result = Base64.encodeToString(sha1hash, Base64.DEFAULT);\n        result = result.substring(0, result.length()-1);\n        return result;\n    }\n", "import com.example.Device;\n\nimport org.spongycastle.bcpg.ArmoredInputStream;\nimport org.spongycastle.bcpg.ArmoredOutputStream;\nimport org.spongycastle.bcpg.HashAlgorithmTags;\nimport org.spongycastle.bcpg.SymmetricKeyAlgorithmTags;\nimport org.spongycastle.bcpg.sig.Features;\nimport org.spongycastle.bcpg.sig.KeyFlags;\nimport org.spongycastle.crypto.generators.RSAKeyPairGenerator;\nimport org.spongycastle.crypto.params.RSAKeyGenerationParameters;\nimport org.spongycastle.openpgp.PGPCompressedData;\nimport org.spongycastle.openpgp.PGPCompressedDataGenerator;\nimport org.spongycastle.openpgp.PGPEncryptedData;\nimport org.spongycastle.openpgp.PGPEncryptedDataGenerator;\nimport org.spongycastle.openpgp.PGPEncryptedDataList;\nimport org.spongycastle.openpgp.PGPException;\nimport org.spongycastle.openpgp.PGPKeyPair;\nimport org.spongycastle.openpgp.PGPKeyRingGenerator;\nimport org.spongycastle.openpgp.PGPLiteralData;\nimport org.spongycastle.openpgp.PGPLiteralDataGenerator;\nimport org.spongycastle.openpgp.PGPObjectFactory;\nimport org.spongycastle.openpgp.PGPPrivateKey;\nimport org.spongycastle.openpgp.PGPPublicKey;\nimport org.spongycastle.openpgp.PGPPublicKeyEncryptedData;\nimport org.spongycastle.openpgp.PGPPublicKeyRing;\nimport org.spongycastle.openpgp.PGPSecretKey;\nimport org.spongycastle.openpgp.PGPSecretKeyRing;\nimport org.spongycastle.openpgp.PGPSignature;\nimport org.spongycastle.openpgp.PGPSignatureSubpacketGenerator;\nimport org.spongycastle.openpgp.PGPUtil;\nimport org.spongycastle.openpgp.operator.PBESecretKeyDecryptor;\nimport org.spongycastle.openpgp.operator.PBESecretKeyEncryptor;\nimport org.spongycastle.openpgp.operator.PGPDigestCalculator;\nimport org.spongycastle.openpgp.operator.bc.BcPBESecretKeyDecryptorBuilder;\nimport org.spongycastle.openpgp.operator.bc.BcPBESecretKeyEncryptorBuilder;\nimport org.spongycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.spongycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider;\nimport org.spongycastle.openpgp.operator.bc.BcPGPKeyPair;\nimport org.spongycastle.openpgp.operator.bc.BcPublicKeyDataDecryptorFactory;\nimport org.spongycastle.openpgp.operator.jcajce.JcePGPDataEncryptorBuilder;\nimport org.spongycastle.openpgp.operator.jcajce.JcePublicKeyKeyEncryptionMethodGenerator;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.security.SecureRandom;\nimport java.util.Date;\nimport java.util.Iterator;\n\npublic class PgpUtils {\n    private static final String PROVIDER = \"SC\";\n    private static final String KEY_RING_ID = \"asdf@asdf.com\";\n\n    public static String decrypt(String encryptedText, String password) throws Exception {\n        byte[] encrypted = encryptedText.getBytes();\n        InputStream in = new ByteArrayInputStream(encrypted);\n        in = PGPUtil.getDecoderStream(in);\n        PGPObjectFactory pgpF = new PGPObjectFactory(in);\n        PGPEncryptedDataList enc;\n        Object o = pgpF.nextObject();\n        if (o instanceof PGPEncryptedDataList) {\n            enc = (PGPEncryptedDataList) o;\n        } else {\n            enc = (PGPEncryptedDataList) pgpF.nextObject();\n        }\n        PGPPrivateKey sKey = null;\n        PGPPublicKeyEncryptedData pbe = null;\n        while (sKey == null &amp;&amp; enc.getEncryptedDataObjects().hasNext()) {\n            pbe = (PGPPublicKeyEncryptedData)enc.getEncryptedDataObjects().next();\n            sKey = getPrivateKey(getPGPSecretKeyRing(), pbe.getKeyID(), password.toCharArray());\n        }\n        if (pbe != null) {\n            InputStream clear = pbe.getDataStream(new BcPublicKeyDataDecryptorFactory(sKey));\n            PGPObjectFactory pgpFact = new PGPObjectFactory(clear);\n            PGPCompressedData cData = (PGPCompressedData) pgpFact.nextObject();\n            pgpFact = new PGPObjectFactory(cData.getDataStream());\n            PGPLiteralData ld = (PGPLiteralData) pgpFact.nextObject();\n            InputStream unc = ld.getInputStream();\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            int ch;\n            while ((ch = unc.read()) &gt;= 0) {\n                out.write(ch);\n            }\n            byte[] returnBytes = out.toByteArray();\n            out.close();\n            return new String(returnBytes);\n        }\n        return null;\n    }\n\n    private static PGPPublicKey getPublicKey(PGPPublicKeyRing publicKeyRing) {\n        Iterator&lt;?&gt; kIt = publicKeyRing.getPublicKeys();\n        while (kIt.hasNext()) {\n            PGPPublicKey k = (PGPPublicKey) kIt.next();\n            if (k.isEncryptionKey()) {\n                return k;\n            }\n        }\n        return null;\n    }\n\n    private static PGPPrivateKey getPrivateKey(PGPSecretKeyRing keyRing, long keyID, char[] pass) throws PGPException {\n        PGPSecretKey secretKey = keyRing.getSecretKey(keyID);\n        PBESecretKeyDecryptor decryptor = new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(pass);\n        return secretKey.extractPrivateKey(decryptor);\n    }\n\n    public static String encrypt(String msgText) throws IOException, PGPException {\n        byte[] clearData = msgText.getBytes();\n        PGPPublicKey encKey = getPublicKey(getPGPPublicKeyRing());\n        ByteArrayOutputStream encOut = new ByteArrayOutputStream();\n        OutputStream out = new ArmoredOutputStream(encOut);\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(PGPCompressedDataGenerator.ZIP);\n        OutputStream cos = comData.open(bOut);\n        PGPLiteralDataGenerator lData = new PGPLiteralDataGenerator();\n        OutputStream pOut = lData.open(cos, PGPLiteralData.BINARY, PGPLiteralData.CONSOLE, clearData.length, new Date());\n        pOut.write(clearData);\n        lData.close();\n        comData.close();\n        PGPEncryptedDataGenerator encGen =\n                new PGPEncryptedDataGenerator(\n                        new JcePGPDataEncryptorBuilder(PGPEncryptedData.AES_256).setWithIntegrityPacket(true).setSecureRandom(\n                                new SecureRandom()).setProvider(PROVIDER));\n        if (encKey != null) {\n            encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(encKey).setProvider(PROVIDER));\n            byte[] bytes = bOut.toByteArray();\n            OutputStream cOut = encGen.open(out, bytes.length);\n            cOut.write(bytes);\n            cOut.close();\n        }\n        out.close();\n        return new String(encOut.toByteArray());\n    }\n\n    public final static PGPKeyRingGenerator generateKeyRingGenerator (char[] pass) throws PGPException{\n        RSAKeyPairGenerator kpg = new RSAKeyPairGenerator();\n        kpg.init(new RSAKeyGenerationParameters(BigInteger.valueOf(0x10001), new SecureRandom(), 2048, 12));\n        PGPKeyPair rsakp_sign = new BcPGPKeyPair(PGPPublicKey.RSA_SIGN, kpg.generateKeyPair(), new Date());\n        PGPKeyPair rsakp_enc = new BcPGPKeyPair(PGPPublicKey.RSA_ENCRYPT, kpg.generateKeyPair(), new Date());\n        PGPSignatureSubpacketGenerator signhashgen = new PGPSignatureSubpacketGenerator();\n        signhashgen.setKeyFlags(false, KeyFlags.SIGN_DATA|KeyFlags.CERTIFY_OTHER|KeyFlags.SHARED);\n        signhashgen.setPreferredSymmetricAlgorithms(false, new int[]{SymmetricKeyAlgorithmTags.AES_256, SymmetricKeyAlgorithmTags.AES_192, SymmetricKeyAlgorithmTags.AES_128});\n        signhashgen.setPreferredHashAlgorithms(false, new int[]{HashAlgorithmTags.SHA256, HashAlgorithmTags.SHA1, HashAlgorithmTags.SHA384, HashAlgorithmTags.SHA512, HashAlgorithmTags.SHA224});\n        signhashgen.setFeature(false, Features.FEATURE_MODIFICATION_DETECTION);\n        PGPSignatureSubpacketGenerator enchashgen = new PGPSignatureSubpacketGenerator();\n        enchashgen.setKeyFlags(false, KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE);\n        PGPDigestCalculator sha1Calc = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA1);\n        PGPDigestCalculator sha256Calc = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA256);\n        PBESecretKeyEncryptor pske = (new BcPBESecretKeyEncryptorBuilder(PGPEncryptedData.AES_256, sha256Calc, 0xc0)).build(pass);\n        PGPKeyRingGenerator keyRingGen = new PGPKeyRingGenerator (PGPSignature.POSITIVE_CERTIFICATION, rsakp_sign,\n                KEY_RING_ID, sha1Calc, signhashgen.generate(), null, new BcPGPContentSignerBuilder(rsakp_sign.getPublicKey().getAlgorithm(),\n                HashAlgorithmTags.SHA1), pske);\n        keyRingGen.addSubKey(rsakp_enc, enchashgen.generate(), null);\n        return keyRingGen;\n    }\n\n    private static PGPPublicKeyRing getPGPPublicKeyRing() throws IOException {\n        ArmoredInputStream ais = new ArmoredInputStream(new ByteArrayInputStream(Device.getDevice().getPgpPublicKey().getBytes()));\n        return (PGPPublicKeyRing) new PGPObjectFactory(ais).nextObject();\n    }\n\n    private static PGPSecretKeyRing getPGPSecretKeyRing() throws IOException {\n        ArmoredInputStream ais = new ArmoredInputStream(new ByteArrayInputStream(Device.getDevice().getPgpSecretKey().getBytes()));\n        return (PGPSecretKeyRing) new PGPObjectFactory(ais).nextObject();\n    }\n\n    public final static String genPGPPublicKey (PGPKeyRingGenerator krgen) throws IOException {\n        ByteArrayOutputStream baosPkr = new ByteArrayOutputStream();\n        PGPPublicKeyRing pkr = krgen.generatePublicKeyRing();\n        ArmoredOutputStream armoredStreamPkr = new ArmoredOutputStream(baosPkr);\n        pkr.encode(armoredStreamPkr);\n        armoredStreamPkr.close();\n        return new String(baosPkr.toByteArray(), Charset.defaultCharset());\n    }\n\n    public final static String genPGPPrivKey (PGPKeyRingGenerator krgen) throws IOException {\n        ByteArrayOutputStream baosPriv = new ByteArrayOutputStream ();\n        PGPSecretKeyRing skr = krgen.generateSecretKeyRing();\n        ArmoredOutputStream armoredStreamPriv = new ArmoredOutputStream(baosPriv);\n        skr.encode(armoredStreamPriv);\n        armoredStreamPriv.close();\n        return new String(baosPriv.toByteArray(), Charset.defaultCharset());\n    }\n}\n", "InputStream keyStoreStream = ontext.openFileInput ( filename );\nKeyStore keyStore = KeyStore.getInstance ( KeyStore.getDefaultType ( ) );\nkeyStore.load ( keyStoreStream, oldPass );\nFileOutputStream fileOutputStream = context.openFileOutput ( filename, Context.MODE_PRIVATE );\nkeystore.store ( fileOutputStream, newPassword );\nfileOutputStream.close ( );\n", " /**\n * Set up a connection to myservice.domain using HTTPS. An entire function\n * is needed to do this because myservice.domain has a self-signed certificate.\n * \n * The caller of the function would do something like:\n * HttpsURLConnection urlConnection = setUpHttpsConnection(\"https://littlesvr.ca\");\n * InputStream in = urlConnection.getInputStream();\n * And read from that \"in\" as usual in Java\n * \n * Based on code from:\n * https://developer.android.com/training/articles/security-ssl.html#SelfSigned\n */\npublic static HttpsURLConnection setUpHttpsConnection(String urlString)\n{\n    try\n    {\n        // Load CAs from an InputStream\n        // (could be from a resource or ByteArrayInputStream or ...)\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n\n        // My CRT file that I put in the assets folder\n        // I got this file by following these steps:\n        // * Go to https://littlesvr.ca using Firefox\n        // * Click the padlock/More/Security/View Certificate/Details/Export\n        // * Saved the file as littlesvr.crt (type X.509 Certificate (PEM))\n        // The MainActivity.context is declared as:\n        // public static Context context;\n        // And initialized in MainActivity.onCreate() as:\n        // MainActivity.context = getApplicationContext();\n        InputStream caInput = new BufferedInputStream(MainActivity.context.getAssets().open(\"littlesvr.crt\"));\n        Certificate ca = cf.generateCertificate(caInput);\n        System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n\n        // Create a KeyStore containing our trusted CAs\n        String keyStoreType = KeyStore.getDefaultType();\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        keyStore.load(null, null);\n        keyStore.setCertificateEntry(\"ca\", ca);\n\n        // Create a TrustManager that trusts the CAs in our KeyStore\n        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n        tmf.init(keyStore);\n\n        // Create an SSLContext that uses our TrustManager\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        context.init(null, tmf.getTrustManagers(), null);\n\n        // Tell the URLConnection to use a SocketFactory from our SSLContext\n        URL url = new URL(urlString);\n        HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();\n        urlConnection.setSSLSocketFactory(context.getSocketFactory());\n\n        return urlConnection;\n    }\n    catch (Exception ex)\n    {\n        Log.e(TAG, \"Failed to establish SSL connection to server: \" + ex.toString());\n        return null;\n    }\n}\n", "        SocketFactory sf = SSLSocketFactory.getDefault();\n        SSLSocket socket = (SSLSocket) sf.createSocket(\"host-name\", 443);\n        socket.setEnabledProtocols(new String[] { \"TLSv1\"});\n        socket.startHandshake();\n", "public class FacebookHashKeyActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_facebook_hash_key);\n        try {\n            PackageInfo info = getPackageManager().getPackageInfo(\"your.package.name\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } catch (NameNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "String modulusElem = \"...\";\nString dElem = \"...\";\n\nbyte[] modulusBytes = Base64.decode(modulusElem, Base64.DEFAULT);\nbyte[] dBytes = Base64.decode(dElem, Base64.DEFAULT);\n\nBigInteger modulus = new BigInteger(1, modulusBytes);\nBigInteger d = new BigInteger(1, dBytes);\n\nString data = \"my data\";            \n\ntry {\n        Signature signature = Signature.getInstance(\"SHA1withRSA\");\n\n        KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n\n        RSAPrivateKeySpec privateKeySpec = new RSAPrivateKeySpec(modulus, d);\n\n        PrivateKey privateKey = factory.generatePrivate(privateKeySpec);\n\n        signature.initSign(privateKey);\n\n        signature.update(data.getBytes(\"UTF-8\"));\n\n        byte[] SignedByteData = signature.sign();\n\n} catch(Exception e) {\n\n}\n", "import java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.HttpVersion;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.params.HttpClientParams;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.conn.ssl.X509HostnameVerifier;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpConnectionParams;\nimport org.apache.http.params.HttpParams;\nimport org.apache.http.params.HttpProtocolParams;\nimport org.apache.http.protocol.HTTP;\n\npublic class MySSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n    public static int ConnectionTimeoutInSeconds = 45;\n    public static boolean DisableSSLcertificateCheck = true;\n\n    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n\n    public static HttpClient getHttpClient() {\n        try {\n\n            HttpParams params = new BasicHttpParams();\n\n            // Turn off stale checking.  Our connections break all the time anyway,\n            // and it's not worth it to pay the penalty of checking every time.\n            HttpConnectionParams.setStaleCheckingEnabled(params, false);\n\n            // Default connection and socket timeout of 20 seconds.  Tweak to taste.\n            HttpConnectionParams.setConnectionTimeout(params, ConnectionTimeoutInSeconds * 1000);\n            HttpConnectionParams.setSoTimeout(params, ConnectionTimeoutInSeconds * 1000);\n            HttpConnectionParams.setSocketBufferSize(params, 8192);\n\n            // Don't handle redirects -- return them to the caller.  Our code\n            // often wants to re-POST after a redirect, which we must do ourselves.\n            HttpClientParams.setRedirecting(params, false);\n\n            SSLSocketFactory mySSLSocketFactory = SSLSocketFactory.getSocketFactory();\n\n            // disable ssl check on debug\n            if (DisableSSLcertificateCheck ) {\n                KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                trustStore.load(null, null);\n                mySSLSocketFactory = new MySSLSocketFactory(trustStore);\n                HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n                mySSLSocketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\n            }\n\n            SchemeRegistry schemeRegistry = new SchemeRegistry();\n            schemeRegistry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n            schemeRegistry.register(new Scheme(\"https\", mySSLSocketFactory, 443));\n            ClientConnectionManager manager = new ThreadSafeClientConnManager(params, schemeRegistry);\n\n            return new DefaultHttpClient(manager, params);\n        } catch (Exception e) {\n            return new DefaultHttpClient();\n        }\n    }\n\n}\n", "public class NetworkSSLSocketFactory implements LayeredSocketFactory {\n\n    private SSLContext sslContext;\n    private SSLSocketFactory socketFactory;\n    private X509HostnameVerifier hostnameVerifier;\n\n    /**\n     * Creates a socket factory that will use the {@link SSLContext} and\n     * {@link X509HostnameVerifier} specified. The SSLContext provided should\n     * have the {@link NetworkTrustManager} associated with it.\n     * \n     * @param sslContext\n     * @param hostnameVerifier\n     */\n    public NetworkSSLSocketFactory(SSLContext sslContext,\n            X509HostnameVerifier hostnameVerifier) {\n        this.sslContext = sslContext;\n        this.socketFactory = sslContext.getSocketFactory();\n        this.hostnameVerifier = hostnameVerifier;\n    }  \n}\n", "    /**\n     * Return the SSLContext for use with our HttpClient or create a new Context\n     * if needed.\n     * &lt;p&gt;\n     * This context uses our {@link NetworkTrustManager}\n     * \n     * @return an {@link SSLContext}\n     */\n    public SSLContext getSSLContext() {\n\n        if (mSSLContextInstance != null)\n            return mSSLContextInstance;\n\n        try {\n            mSSLContextInstance = SSLContext.getInstance(\"TLS\");\n            TrustManager trustManager = new NetworkTrustManager(getKeyStore());\n            TrustManager[] tms = new TrustManager[] { trustManager };\n            mSSLContextInstance.init(null, tms, new SecureRandom());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, e.getMessage());\n        } catch (KeyManagementException e) {\n            Log.e(TAG, e.getMessage());\n        }\n\n        return mSSLContextInstance;\n    }\n", "/**\n * Return an HttpClient using our {@link NetworkTrustManager} and\n * {@link NetworkHostnameVerifier}\n * \n * @return an {@link HttpClient}\n */\npublic HttpClient getHttpClient() {\n\n    if (mHttpClientInstance != null)\n        return mHttpClientInstance;\n\n    SSLContext sslContext = getSSLContext();\n\n    // Now create our socket factory using our context.\n    X509HostnameVerifier hostnameVerifier = new NetworkHostnameVerifier();\n    NetworkSSLSocketFactory sslSocketFactory = new NetworkSSLSocketFactory(\n            sslContext, hostnameVerifier);\n\n    // Some services (like the KSOAP client) use the HttpsURLConnection\n    // class\n    // to establish SSL connections.\n    HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext\n            .getSocketFactory());\n\n    // Generate the Client for the Server\n    mHttpClientInstance = AndroidHttpClient.newInstance(getAgent(),\n            mContext);\n\n    // Get the registry from the AndroidHttpClient and change the\n    // HTTPS scheme to use our socket factory. This way we can\n    // control the certificate authority and trust system.\n    SchemeRegistry schemeRegistry = mHttpClientInstance\n            .getConnectionManager().getSchemeRegistry();\n\n    schemeRegistry.register(new Scheme(\"https\", sslSocketFactory, 443));\n\n    return mHttpClientInstance;\n}\n", "    /**\n     * Get the current KeyStore or if not yet created, create a new one. This\n     * will &lt;b&gt;NOT&lt;/b&gt; load the KeyStore file identified by\n     * {@link #KEYSTORE_NAME}. To load the KeyStore file, use the function\n     * {@link #loadKeyStore()} which will automatically call this function (so\n     * you don't need to).\n     * &lt;p&gt;\n     * \n     * @return a {@link KeyStore}\n     */\n    public KeyStore getKeyStore() {\n\n        if (mKeyStore != null)\n            return mKeyStore;\n\n        try {\n            String defaultType = KeyStore.getDefaultType();\n            mKeyStore = KeyStore.getInstance(defaultType);\n            mKeyStore.load(null, null);\n        } catch (Exception e) {\n            Log.w(TAG, e.getMessage());\n        }\n\n        return mKeyStore;\n    }\n", "if(frag instanceof Refreshable)\n    ((Refreshable)frag).refresh();\n}\n", "import java.io.InputStream;\nimport java.security.KeyStore;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.SingleClientConnManager;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpConnectionParams;\nimport org.apache.http.params.HttpParams;\n\nimport com.futureconcepts.anonymous.R;\nimport android.content.Context;\n\n\npublic class Client extends  DefaultHttpClient   {\nfinal Context context;\n  public Client(Context context) {\n      this.context = context;\n  }\n\n  @Override\n  protected ClientConnectionManager createClientConnectionManager() {\n      SchemeRegistry registry = new SchemeRegistry();\n      registry.register(new Scheme(\"http\", \n      PlainSocketFactory.getSocketFactory(), 80));\n      // Register for port 443 our SSLSocketFactory with our keystore\n      // to the ConnectionManager\n      registry.register(new Scheme(\"https\", newSslSocketFactory(),443));\n\n    HttpParams httpParams = new BasicHttpParams();\n     HttpConnectionParams.setConnectionTimeout(httpParams,9000);\n     HttpConnectionParams.setSoTimeout(httpParams, 9000);\n\n      return new SingleClientConnManager(httpParams, registry);\n  }\n\n\n  private SSLSocketFactory newSslSocketFactory() {\n      try {\n\n          // Get an instance of the Bouncy Castle KeyStore format\n            KeyStore trusted = KeyStore.getInstance(\"BKS\");//put BKS literal  \n            // Get the raw resource, which contains the keystore with\n            // your trusted certificates (root and any intermediate certs)\n            InputStream in =context.getResources().openRawResource(R.raw.keystore);\n            try {\n                // Initialize the keystore with the provided trusted certificates\n                // Also provide the password of the keystore\n                trusted.load(in, \"mysecret\".toCharArray());\n            } finally {\n                in.close();\n            }\n          // Pass the keystore to the SSLSocketFactory. The factory is responsible\n          // for the verification of the server certificate.\n          SSLSocketFactory sf = new SSLSocketFactory(trusted);\n          // Hostname verification from certificate\n\n           sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n          return sf;\n      } catch (Exception e) {\n          throw new AssertionError(e);\n      }\n  }\n\n}\n", "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport android.os.Bundle;\nimport android.app.Activity;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.Signature;\nimport android.text.Editable;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.EditText;\n\npublic class MainActivity extends Activity {\n\n    Button btn;\n    EditText et;\n    PackageInfo info;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn=(Button)findViewById(R.id.button1);\n        et=(EditText)findViewById(R.id.editText1);\n        btn.setOnClickListener(new OnClickListener() {\n\n            @Override\n            public void onClick(View v) {\n                // TODO Auto-generated method stub\n\n                try {\n                    info = getPackageManager().getPackageInfo(\"com.example.id\", PackageManager.GET_SIGNATURES);\n                    for (Signature signature : info.signatures) {\n                        MessageDigest md;\n                        md = MessageDigest.getInstance(\"SHA\");\n                        md.update(signature.toByteArray());\n                        String something = new String(Base64.encode(md.digest(), 0));\n                        //String something = new String(Base64.encodeBytes(md.digest()));\n                        et.setText(\"\" + something);\n                        Log.e(\"hash key\", something);\n                    }\n                } catch (NameNotFoundException e1) {\n                    Log.e(\"name not found\", e1.toString());\n                } catch (NoSuchAlgorithmException e) {\n                    Log.e(\"no such an algorithm\", e.toString());\n                } catch (Exception e) {\n                    Log.e(\"exception\", e.toString());\n                }\n            }\n        });\n    }\n\n\n\n}\n", "public class CustomSSLSocketFactory extends SSLSocketFactory {\n\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public CustomSSLSocketFactory(KeyStore truststore)\n            throws NoSuchAlgorithmException, KeyManagementException,\n            KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new CustomX509TrustManager();\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    public CustomSSLSocketFactory(SSLContext context)\n            throws KeyManagementException, NoSuchAlgorithmException,\n            KeyStoreException, UnrecoverableKeyException {\n        super(null);\n        sslContext = context;\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port,\n                               boolean autoClose) throws IOException, UnknownHostException {\n        Socket newSocket =  sslContext.getSocketFactory().createSocket(socket, host, port,\n                autoClose);\n        ((SSLSocket) newSocket).setEnabledCipherSuites(((SSLSocket) newSocket).getSupportedCipherSuites());\n        AdjustSocket(newSocket);\n        return newSocket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Socket socket = sslContext.getSocketFactory().createSocket();\n        ((SSLSocket) socket).setEnabledCipherSuites(((SSLSocket) socket).getSupportedCipherSuites());\n        adjustSocket(socket);\n        return socket;\n    }\n\n    private void adjustSocket(Socket socket)\n    {\n        String[] cipherSuites = ((SSLSocket) socket).getSSLParameters().getCipherSuites();\n        ArrayList&lt;String&gt; cipherSuiteList = new ArrayList&lt;String&gt;(Arrays.asList(cipherSuites));\n\n        cipherSuiteList.add(\"TLS_RSA_WITH_3DES_EDE_CBC_SHA\");\n        cipherSuites = cipherSuiteList.toArray(new String[cipherSuiteList.size()]);\n        ((SSLSocket) socket).getSSLParameters().setCipherSuites(cipherSuites);\n\n        String[] protocols = ((SSLSocket) socket).getSSLParameters().getProtocols();\n        ArrayList&lt;String&gt; protocolList = new ArrayList&lt;String&gt;(Arrays.asList(protocols));\n\n        for (int ii = protocolList.size() - 1; ii &gt;= 0; --ii )\n        {\n            if ((protocolList.get(ii).contains(\"SSLv3\")) || (protocolList.get(ii).contains(\"TLSv1.1\")) || (protocolList.get(ii).contains(\"TLSv1.2\")))\n                protocolList.remove(ii);\n        }\n\n        protocols = protocolList.toArray(new String[protocolList.size()]);\n        ((SSLSocket)socket).setEnabledProtocols(protocols);\n    }\n}\n", "public HttpClient createHttpClient(){\n            try {\n                KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                trustStore.load(null, null);\n\n                CustomSSLSocketFactory sf = new CustomSSLSocketFactory(trustStore);\n                sf.setHostnameVerifier(CustomSSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n                HttpParams params = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(params, 15000);\n                HttpConnectionParams.setSoTimeout(params, 5000);\n\n                SchemeRegistry registry = new SchemeRegistry();\n                registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n                registry.register(new Scheme(\"https\", sf, 443));\n\n                ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n\n                return new DefaultHttpClient(ccm, params);\n            } catch (Exception e) {\n                return new DefaultHttpClient();\n            }\n", "static final String GetKey(Context context)\n{\n    String KeyHash = \"\";\n    PackageInfo info;\n    try {\n        info = context.getPackageManager().getPackageInfo(context.getPackageName(),  PackageManager.GET_SIGNATURES);\n\n        for (Signature signature : info.signatures)\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            KeyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n        }\n\n    } catch (NameNotFoundException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n\n    return KeyHash;\n}\n", "private static final String ALGO = \"AES\";\nprivate static final byte[] keyValue = new byte[] { 'o', 'n', 'e', 'n','e', 't', 'e','d', 'o', 'c', 'e', 'i', 'r', 's', 'r', 'p' };\n    public static String decrypt(String encryptedData){\n        String decryptedValue = null;\n        try{\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        decryptedValue = new String(decValue);\n    }catch(Exception e){\n        //LOGGER.error(\"In TD:\" + e);\n        //Teneno_StartupService.loadForConnectionFailed();\n    }\n    return decryptedValue;\n}\nprivate static Key generateKey(){\n    Key key = new SecretKeySpec(keyValue, ALGO);\n    return key;\n}\n", "  static {   \n          Security.addProvider(new PACKED-NAME.JSSEProvider());   \n         }  \n", "public class ImageCache {\n    private static final String TAG = \"ImageCache\";\n\n    // Default memory cache size\n    private static final int DEFAULT_MEM_CACHE_SIZE = 1024 * 1024 * 5; // 5MB\n\n    // Default disk cache size\n    private static final int DEFAULT_DISK_CACHE_SIZE = 1024 * 1024 * 10; // 10MB\n\n    // Compression settings when writing images to disk cache\n    private static final CompressFormat DEFAULT_COMPRESS_FORMAT = CompressFormat.JPEG;\n    private static final int DEFAULT_COMPRESS_QUALITY = 70;\n    private static final int DISK_CACHE_INDEX = 0;\n\n    // Constants to easily toggle various caches\n    private static final boolean DEFAULT_MEM_CACHE_ENABLED = true;\n    private static final boolean DEFAULT_DISK_CACHE_ENABLED = true;\n    private static final boolean DEFAULT_CLEAR_DISK_CACHE_ON_START = false;\n    private static final boolean DEFAULT_INIT_DISK_CACHE_ON_CREATE = false;\n\n    private DiskLruCache mDiskLruCache;\n    private LruCache&lt;String, Bitmap&gt; mMemoryCache;\n    private ImageCacheParams mCacheParams;\n    private final Object mDiskCacheLock = new Object();\n    private boolean mDiskCacheStarting = true;\n\n    /**\n     * Creating a new ImageCache object using the specified parameters.\n     *\n     * @param cacheParams The cache parameters to use to initialize the cache\n     */\n    public ImageCache(ImageCacheParams cacheParams) {\n        init(cacheParams);\n    }\n\n    /**\n     * Creating a new ImageCache object using the default parameters.\n     *\n     * @param context The context to use\n     * @param uniqueName A unique name that will be appended to the cache directory\n     */\n    public ImageCache(Context context, String uniqueName) {\n        init(new ImageCacheParams(context, uniqueName));\n    }\n\n    /**\n     * Find and return an existing ImageCache stored in a {@link RetainFragment}, if not found a new\n     * one is created using the supplied params and saved to a {@link RetainFragment}.\n     *\n     * @param fragmentManager The fragment manager to use when dealing with the retained fragment.\n     * @param cacheParams The cache parameters to use if creating the ImageCache\n     * @return An existing retained ImageCache object or a new one if one did not exist\n     */\n    public static ImageCache findOrCreateCache(\n            FragmentManager fragmentManager, ImageCacheParams cacheParams) {\n\n        // Search for, or create an instance of the non-UI RetainFragment\n        final RetainFragment mRetainFragment = findOrCreateRetainFragment(fragmentManager);\n\n        // See if we already have an ImageCache stored in RetainFragment\n        ImageCache imageCache = (ImageCache) mRetainFragment.getObject();\n\n        // No existing ImageCache, create one and store it in RetainFragment\n        if (imageCache == null) {\n            imageCache = new ImageCache(cacheParams);\n            mRetainFragment.setObject(imageCache);\n        }\n\n        return imageCache;\n    }\n\n    /**\n     * Initialize the cache, providing all parameters.\n     *\n     * @param cacheParams The cache parameters to initialize the cache\n     */\n    private void init(ImageCacheParams cacheParams) {\n        mCacheParams = cacheParams;\n\n        // Set up memory cache\n        if (mCacheParams.memoryCacheEnabled) {\n            if (BuildConfig.DEBUG) {\n                Log.d(TAG, \"Memory cache created (size = \" + mCacheParams.memCacheSize + \")\");\n            }\n            mMemoryCache = new LruCache&lt;String, Bitmap&gt;(mCacheParams.memCacheSize) {\n                /**\n                 * Measure item size in bytes rather than units which is more practical\n                 * for a bitmap cache\n                 */\n                @Override\n                protected int sizeOf(String key, Bitmap bitmap) {\n                    return getBitmapSize(bitmap);\n                }\n            };\n        }\n\n        // By default the disk cache is not initialized here as it should be initialized\n        // on a separate thread due to disk access.\n        if (cacheParams.initDiskCacheOnCreate) {\n            // Set up disk cache\n            initDiskCache();\n        }\n    }\n\n    /**\n     * Initializes the disk cache.  Note that this includes disk access so this should not be\n     * executed on the main/UI thread. By default an ImageCache does not initialize the disk\n     * cache when it is created, instead you should call initDiskCache() to initialize it on a\n     * background thread.\n     */\n    public void initDiskCache() {\n        // Set up disk cache\n        synchronized (mDiskCacheLock) {\n            if (mDiskLruCache == null || mDiskLruCache.isClosed()) {\n                File diskCacheDir = mCacheParams.diskCacheDir;\n                if (mCacheParams.diskCacheEnabled &amp;&amp; diskCacheDir != null) {\n                    if (!diskCacheDir.exists()) {\n                        diskCacheDir.mkdirs();\n                    }\n                    if (getUsableSpace(diskCacheDir) &gt; mCacheParams.diskCacheSize) {\n                        try {\n                            mDiskLruCache = DiskLruCache.open(\n                                    diskCacheDir, 1, 1, mCacheParams.diskCacheSize);\n                            if (BuildConfig.DEBUG) {\n                                Log.d(TAG, \"Disk cache initialized\");\n                            }\n                        } catch (final IOException e) {\n                            mCacheParams.diskCacheDir = null;\n                            Log.e(TAG, \"initDiskCache - \" + e);\n                        }\n                    }\n                }\n            }\n            mDiskCacheStarting = false;\n            mDiskCacheLock.notifyAll();\n        }\n    }\n\n    /**\n     * Adds a bitmap to both memory and disk cache.\n     * @param data Unique identifier for the bitmap to store\n     * @param bitmap The bitmap to store\n     */\n    public void addBitmapToCache(String data, Bitmap bitmap) {\n        if (data == null || bitmap == null) {\n            return;\n        }\n\n        // Add to memory cache\n        if (mMemoryCache != null &amp;&amp; mMemoryCache.get(data) == null) {\n            mMemoryCache.put(data, bitmap);\n        }\n\n        synchronized (mDiskCacheLock) {\n            // Add to disk cache\n            if (mDiskLruCache != null) {\n                final String key = hashKeyForDisk(data);\n                OutputStream out = null;\n                try {\n                    DiskLruCache.Snapshot snapshot = mDiskLruCache.get(key);\n                    if (snapshot == null) {\n                        final DiskLruCache.Editor editor = mDiskLruCache.edit(key);\n                        if (editor != null) {\n                            out = editor.newOutputStream(DISK_CACHE_INDEX);\n                            bitmap.compress(\n                                    mCacheParams.compressFormat, mCacheParams.compressQuality, out);\n                            editor.commit();\n                            out.close();\n                        }\n                    } else {\n                        snapshot.getInputStream(DISK_CACHE_INDEX).close();\n                    }\n                } catch (final IOException e) {\n                    Log.e(TAG, \"addBitmapToCache - \" + e);\n                } catch (Exception e) {\n                    Log.e(TAG, \"addBitmapToCache - \" + e);\n                } finally {\n                    try {\n                        if (out != null) {\n                            out.close();\n                        }\n                    } catch (IOException e) {}\n                }\n            }\n        }\n    }\n\n    /**\n     * Get from memory cache.\n     *\n     * @param data Unique identifier for which item to get\n     * @return The bitmap if found in cache, null otherwise\n     */\n    public Bitmap getBitmapFromMemCache(String data) {\n        if (mMemoryCache != null) {\n            final Bitmap memBitmap = mMemoryCache.get(data);\n            if (memBitmap != null) {\n                if (BuildConfig.DEBUG) {\n                    Log.d(TAG, \"Memory cache hit\");\n                }\n                return memBitmap;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get from disk cache.\n     *\n     * @param data Unique identifier for which item to get\n     * @return The bitmap if found in cache, null otherwise\n     */\n    public Bitmap getBitmapFromDiskCache(String data) {\n        final String key = hashKeyForDisk(data);\n        synchronized (mDiskCacheLock) {\n            while (mDiskCacheStarting) {\n                try {\n                    mDiskCacheLock.wait();\n                } catch (InterruptedException e) {}\n            }\n            if (mDiskLruCache != null) {\n                InputStream inputStream = null;\n                try {\n                    final DiskLruCache.Snapshot snapshot = mDiskLruCache.get(key);\n                    if (snapshot != null) {\n                        if (BuildConfig.DEBUG) {\n                            Log.d(TAG, \"Disk cache hit\");\n                        }\n                        inputStream = snapshot.getInputStream(DISK_CACHE_INDEX);\n                        if (inputStream != null) {\n                            final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);\n                            return bitmap;\n                        }\n                    }\n                } catch (final IOException e) {\n                    Log.e(TAG, \"getBitmapFromDiskCache - \" + e);\n                } finally {\n                    try {\n                        if (inputStream != null) {\n                            inputStream.close();\n                        }\n                    } catch (IOException e) {}\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Clears both the memory and disk cache associated with this ImageCache object. Note that\n     * this includes disk access so this should not be executed on the main/UI thread.\n     */\n    public void clearCache() {\n        if (mMemoryCache != null) {\n            mMemoryCache.evictAll();\n            if (BuildConfig.DEBUG) {\n                Log.d(TAG, \"Memory cache cleared\");\n            }\n        }\n\n        synchronized (mDiskCacheLock) {\n            mDiskCacheStarting = true;\n            if (mDiskLruCache != null &amp;&amp; !mDiskLruCache.isClosed()) {\n                try {\n                    mDiskLruCache.delete();\n                    if (BuildConfig.DEBUG) {\n                        Log.d(TAG, \"Disk cache cleared\");\n                    }\n                } catch (IOException e) {\n                    Log.e(TAG, \"clearCache - \" + e);\n                }\n                mDiskLruCache = null;\n                initDiskCache();\n            }\n        }\n    }\n\n    /**\n     * Flushes the disk cache associated with this ImageCache object. Note that this includes\n     * disk access so this should not be executed on the main/UI thread.\n     */\n    public void flush() {\n        synchronized (mDiskCacheLock) {\n            if (mDiskLruCache != null) {\n                try {\n                    mDiskLruCache.flush();\n                    if (BuildConfig.DEBUG) {\n                        Log.d(TAG, \"Disk cache flushed\");\n                    }\n                } catch (IOException e) {\n                    Log.e(TAG, \"flush - \" + e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes the disk cache associated with this ImageCache object. Note that this includes\n     * disk access so this should not be executed on the main/UI thread.\n     */\n    public void close() {\n        synchronized (mDiskCacheLock) {\n            if (mDiskLruCache != null) {\n                try {\n                    if (!mDiskLruCache.isClosed()) {\n                        mDiskLruCache.close();\n                        mDiskLruCache = null;\n                        if (BuildConfig.DEBUG) {\n                            Log.d(TAG, \"Disk cache closed\");\n                        }\n                    }\n                } catch (IOException e) {\n                    Log.e(TAG, \"close - \" + e);\n                }\n            }\n        }\n    }\n\n    /**\n     * A holder class that contains cache parameters.\n     */\n    public static class ImageCacheParams {\n        public int memCacheSize = DEFAULT_MEM_CACHE_SIZE;\n        public int diskCacheSize = DEFAULT_DISK_CACHE_SIZE;\n        public File diskCacheDir;\n        public CompressFormat compressFormat = DEFAULT_COMPRESS_FORMAT;\n        public int compressQuality = DEFAULT_COMPRESS_QUALITY;\n        public boolean memoryCacheEnabled = DEFAULT_MEM_CACHE_ENABLED;\n        public boolean diskCacheEnabled = DEFAULT_DISK_CACHE_ENABLED;\n        public boolean clearDiskCacheOnStart = DEFAULT_CLEAR_DISK_CACHE_ON_START;\n        public boolean initDiskCacheOnCreate = DEFAULT_INIT_DISK_CACHE_ON_CREATE;\n\n        public ImageCacheParams(Context context, String uniqueName) {\n            diskCacheDir = getDiskCacheDir(context, uniqueName);\n        }\n\n        public ImageCacheParams(File diskCacheDir) {\n            this.diskCacheDir = diskCacheDir;\n        }\n\n        /**\n         * Sets the memory cache size based on a percentage of the device memory class.\n         * Eg. setting percent to 0.2 would set the memory cache to one fifth of the device memory\n         * class. Throws {@link IllegalArgumentException} if percent is &lt; 0.05 or &gt; .8.\n         *\n         * This value should be chosen carefully based on a number of factors\n         * Refer to the corresponding Android Training class for more discussion:\n         * http://developer.android.com/training/displaying-bitmaps/\n         *\n         * @param context Context to use to fetch memory class\n         * @param percent Percent of memory class to use to size memory cache\n         */\n        public void setMemCacheSizePercent(Context context, float percent) {\n            if (percent &lt; 0.05f || percent &gt; 0.8f) {\n                throw new IllegalArgumentException(\"setMemCacheSizePercent - percent must be \"\n                        + \"between 0.05 and 0.8 (inclusive)\");\n            }\n            memCacheSize = Math.round(percent * getMemoryClass(context) * 1024 * 1024);\n        }\n\n        private static int getMemoryClass(Context context) {\n            return ((ActivityManager) context.getSystemService(\n                    Context.ACTIVITY_SERVICE)).getMemoryClass();\n        }\n    }\n\n    /**\n     * Get a usable cache directory (external if available, internal otherwise).\n     *\n     * @param context The context to use\n     * @param uniqueName A unique directory name to append to the cache dir\n     * @return The cache dir\n     */\n    public static File getDiskCacheDir(Context context, String uniqueName) {\n        // Check if media is mounted or storage is built-in, if so, try and use external cache dir\n        // otherwise use internal cache dir\n        final String cachePath =\n                Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||\n                        !isExternalStorageRemovable() ? getExternalCacheDir(context).getPath() :\n                                context.getCacheDir().getPath();\n\n        return new File(cachePath + File.separator + uniqueName);\n    }\n\n    /**\n     * A hashing method that changes a string (like a URL) into a hash suitable for using as a\n     * disk filename.\n     */\n    public static String hashKeyForDisk(String key) {\n        String cacheKey;\n        try {\n            final MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n            mDigest.update(key.getBytes());\n            cacheKey = bytesToHexString(mDigest.digest());\n        } catch (NoSuchAlgorithmException e) {\n            cacheKey = String.valueOf(key.hashCode());\n        }\n        return cacheKey;\n    }\n\n    private static String bytesToHexString(byte[] bytes) {\n        // http://stackoverflow.com/questions/332079\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; bytes.length; i++) {\n            String hex = Integer.toHexString(0xFF &amp; bytes[i]);\n            if (hex.length() == 1) {\n                sb.append('0');\n            }\n            sb.append(hex);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Get the size in bytes of a bitmap.\n     * @param bitmap\n     * @return size in bytes\n     */\n    @TargetApi(12)\n    public static int getBitmapSize(Bitmap bitmap) {\n        if (Utils.hasHoneycombMR1()) {\n            return bitmap.getByteCount();\n        }\n        // Pre HC-MR1\n        return bitmap.getRowBytes() * bitmap.getHeight();\n    }\n\n    /**\n     * Check if external storage is built-in or removable.\n     *\n     * @return True if external storage is removable (like an SD card), false\n     *         otherwise.\n     */\n    @TargetApi(9)\n    public static boolean isExternalStorageRemovable() {\n        if (Utils.hasGingerbread()) {\n            return Environment.isExternalStorageRemovable();\n        }\n        return true;\n    }\n\n    /**\n     * Get the external app cache directory.\n     *\n     * @param context The context to use\n     * @return The external cache dir\n     */\n    @TargetApi(8)\n    public static File getExternalCacheDir(Context context) {\n        if (Utils.hasFroyo()) {\n            return context.getExternalCacheDir();\n        }\n\n        // Before Froyo we need to construct the external cache dir ourselves\n        final String cacheDir = \"/Android/data/\" + context.getPackageName() + \"/cache/\";\n        return new File(Environment.getExternalStorageDirectory().getPath() + cacheDir);\n    }\n\n    /**\n     * Check how much usable space is available at a given path.\n     *\n     * @param path The path to check\n     * @return The space available in bytes\n     */\n    @TargetApi(9)\n    public static long getUsableSpace(File path) {\n        if (Utils.hasGingerbread()) {\n            return path.getUsableSpace();\n        }\n        final StatFs stats = new StatFs(path.getPath());\n        return (long) stats.getBlockSize() * (long) stats.getAvailableBlocks();\n    }\n\n    /**\n     * Locate an existing instance of this Fragment or if not found, create and\n     * add it using FragmentManager.\n     *\n     * @param fm The FragmentManager manager to use.\n     * @return The existing instance of the Fragment or the new instance if just\n     *         created.\n     */\n    public static RetainFragment findOrCreateRetainFragment(FragmentManager fm) {\n        // Check to see if we have retained the worker fragment.\n        RetainFragment mRetainFragment = (RetainFragment) fm.findFragmentByTag(TAG);\n\n        // If not retained (or first time running), we need to create and add it.\n        if (mRetainFragment == null) {\n            mRetainFragment = new RetainFragment();\n            fm.beginTransaction().add(mRetainFragment, TAG).commitAllowingStateLoss();\n        }\n\n        return mRetainFragment;\n    }\n\n    /**\n     * A simple non-UI Fragment that stores a single Object and is retained over configuration\n     * changes. It will be used to retain the ImageCache object.\n     */\n    public static class RetainFragment extends Fragment {\n        private Object mObject;\n\n        /**\n         * Empty constructor as per the Fragment documentation\n         */\n        public RetainFragment() {}\n\n        @Override\n        public void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n\n            // Make sure this Fragment is retained over a configuration change\n            setRetainInstance(true);\n        }\n\n        /**\n         * Store a single object in this Fragment.\n         *\n         * @param object The object to store\n         */\n        public void setObject(Object object) {\n            mObject = object;\n        }\n\n        /**\n         * Get the stored object.\n         *\n         * @return The stored object\n         */\n        public Object getObject() {\n            return mObject;\n        }\n    }\n\n}\n", "    String Verify_Mobile_URL =\"https://www.sample.php\";\n                        try \n                        {\n\n                            StringBuilder postDataBuilder = new StringBuilder();\n                            postDataBuilder.append(\"param1\").append(\"=\").append(\"paramvalue\");\n                            postDataBuilder.append(\"&amp;\").append(\"param2\").append(\"=\").append(\"paramvalue\");\n\n\n                            byte[] postData = postDataBuilder.toString().getBytes();\n\n                            // Hit the dm URL.\n\n                            URL url = new URL(Verify_Mobile_URL);\n                            HttpsURLConnection.setDefaultHostnameVerifier(new AllVerifier());\n                            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                            sslContext.init(null, new TrustManager[] { new AllTrustManager() }, null);\n                            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n                            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();        \n                            conn.setReadTimeout(60000);\n                            conn.setConnectTimeout(35000);\n                            conn.setDoOutput(true);\n                            conn.setUseCaches(false);\n                            conn.setRequestMethod(\"POST\");\n                            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                            conn.setRequestProperty(\"Content-Length\",Integer.toString(postData.length));\n\n                            OutputStream out = conn.getOutputStream();\n                            out.write(postData);\n                            out.close();\n\n                            int responseCode = conn.getResponseCode();\n                            if(responseCode==200)\n                            {\n                                InputStream inputstream=conn.getInputStream();  \n                                String result=streamToString(inputstream);   // here you will will get result from\n\n                            }\n                            catch(Exception e)\n                            {\n                            }\n\n\n\n\n\n\n\n/**\n     * This method convert inputstream to string\n     * @param is - inputtream to be converted\n     * @return String - converted string \n     */\n    public static String streamToString(InputStream is)\n    {\n        DataInputStream din = new DataInputStream(is);\n        StringBuffer sb = new StringBuffer();\n        try {\n            String line = null;\n            while ((line = din.readLine()) != null) \n            {\n                sb.append(line + \"\\n\");\n            }\n\n        } \n        catch (Exception ex) \n        {}      \n\n        finally \n        {\n            try \n            {  if(is!=null)\n                {\n                    din.close();\n                    is.close();\n                }\n            } \n            catch (Exception ex) \n            {}\n\n        }\n        return sb.toString();\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class AllTrustManager implements X509TrustManager {\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n        // TODO Auto-generated method stub\n\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        // TODO Auto-generated method stub\n        return new X509Certificate[0];\n    }\n\n}\n\n\n\n\n\npublic class AllVerifier implements HostnameVerifier {\n\n    @Override\n    public boolean verify(String hostname, SSLSession session) {\n        // TODO Auto-generated method stub\n        return true;\n    }\n\n}\n", "public class Cryptos {\n\nprivate static final String ME = Cryptos.class.getSimpleName();\nprivate static String strEncoding = \"UTF-8\";\nprivate static String STATIC_STRING_IV_16 = \"1234567890123456\";\nprivate String iv;\nprivate String key;\nprivate IvParameterSpec mIvParameterSpec;\nprivate SecretKeySpec mSecretKeySpec;\nprivate Cipher mCipher;\n\npublic Cryptos(String key) {\n    this(STATIC_STRING_IV_16,key);\n}\n\npublic Cryptos(String iv, String key) {\n    this.iv = cut(iv, 16);\n    this.key = key;\n\n    mIvParameterSpec = new IvParameterSpec(this.iv.getBytes());\n    mSecretKeySpec = new SecretKeySpec(this.key.getBytes(), \"AES\");\n\n    try {\n        mCipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    } catch (NoSuchAlgorithmException e) {\n        App.log.e(ME, \"Got Exception while initializing mCipher: \" + e.toString(), e);\n    } catch (NoSuchPaddingException e) {\n        App.log.e(ME, \"Got Exception while initializing mCipher: \" + e.toString(), e);\n    }\n}\n\n\npublic byte[] decryptHex(String hexString) throws Exception {\n    if(hexString == null || hexString.length() == 0) {\n        throw new Exception(\"Emtpy string given\");\n    }\n    return byteTrim(decrypt(hexToBytes(hexString)));\n}\n\npublic byte[] decrypt(byte[] input){\n    try {\n        mCipher.init(Cipher.DECRYPT_MODE, mSecretKeySpec, mIvParameterSpec);\n        byte[] decrypted = new byte[mCipher.getOutputSize(input.length)];\n        int dec_len = mCipher.update(input, 0, input.length, decrypted, 0);\n        dec_len += mCipher.doFinal(decrypted, dec_len);\n        return ARRAY.copyOf(decrypted, dec_len);\n    } catch (ShortBufferException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\n\n\npublic byte[] encrypt(String text) throws Exception{\n    if(text == null || text.length() == 0) throw new Exception(\"Empty string\");\n    return encrypt(text.getBytes(strEncoding));\n}\n\npublic byte[] encrypt(byte[] data){\n    if(data==null) return null;\n\n    try {\n        int bts = data.length;\n        byte[] alignData = ARRAY.copyOf(data, bts+(16-bts%16));\n        data = alignData;\n        mCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, mIvParameterSpec);\n        byte[] encrypted = new byte[mCipher.getOutputSize(data.length)];\n        int enc_len = mCipher.update(data, 0, data.length, encrypted, 0);\n        enc_len += mCipher.doFinal(encrypted, enc_len);\n        return ARRAY.copyOf(encrypted, enc_len);\n    } catch (ShortBufferException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\npublic static String bytesToHex(byte[] b){\n    StringBuffer buf = new StringBuffer();\n    int len = b.length;\n    for (int j=0; j&lt;len; j++)\n        buf.append(byteToHex(b[j]));\n    return buf.toString();\n}\n\npublic static String byteToHex(byte b){\n    char hexDigit[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    char[] a = { hexDigit[(b &gt;&gt; 4) &amp; 0x0f], hexDigit[b &amp; 0x0f] };\n    return new String(a);\n}\n\npublic static byte[] hexToBytes(String str) {\n    if (str==null) {\n        return null;\n    } else if (str.length() &lt; 2) {\n        return null;\n    } else {\n        int len = str.length() / 2;\n        byte[] buffer = new byte[len];\n        for (int i=0; i&lt;len; i++) {\n            buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n        }\n        return buffer;\n    }\n}\n\n\nprivate byte[] byteTrim(byte[] bytes){\n    if( bytes.length &gt; 0){\n        int trim = 0;\n        for( int i = bytes.length - 1; i &gt;= 0; i-- ){\n            if( bytes[i] == 0 ){\n                trim++;\n            }else{\n                break;\n            }\n        }\n        if( trim &gt; 0 ){\n            byte[] newArray = new byte[bytes.length - trim];\n            System.arraycopy(bytes, 0, newArray, 0, bytes.length - trim);\n            return newArray;\n        }\n    }\n    return bytes;\n}\n\nprivate String cut(String s, int n) {\n    byte[] sBytes = s.getBytes();\n    if(sBytes.length &lt; n) {\n        n = sBytes.length;\n    }\n    boolean extraLong = false;\n    int i = 0, n16 = 0;\n    while(i &lt; n) {\n        n16 += (extraLong) ? 2 : 1;\n        extraLong = false;\n        if((sBytes[i] &amp; 0x80) == 0) {\n            i += 1;\n        } else if((sBytes[i] &amp; 0xC0) == 0x80) {\n            i += 2;\n        } else if((sBytes[i] &amp; 0xE0) == 0xC0) {\n            i += 3;\n        } else {\n            i += 4;\n            extraLong = true;\n        }\n    }\n    return s.substring(0, n16);\n}\n\npublic static String encBase64(byte[] bytes){\n    return Base64.encodeToString(bytes, Base64.DEFAULT);\n}\n\npublic static byte[] decBase64(String data){\n    return Base64.decode(data, Base64.DEFAULT);\n}   \n}\n", "MessageDigest md5Hash = MessageDigest.getInstance(\"MD5\");\nmDigest = md5Hash.digest(password.getBytes());\nString hashedMessage = new String(Hex.encodeHex(mDigest));\n", "import java.math.*;\nimport java.security.*;\n\npublic class testMain {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n\n        String stringThatNeedsToBeEncrpyted = \"yourURL\"; // Value to encrypt\n        MessageDigest mdEnc = null;\n        try {\n            mdEnc = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } // Encryption algorithm\n        mdEnc.update(stringThatNeedsToBeEncrpyted.getBytes(), 0, stringThatNeedsToBeEncrpyted.length());\n        String md5 = new BigInteger(1, mdEnc.digest()).toString(16); //Make the Encrypted string\n        System.out.println(md5); //print the string in the console\n\n    }   \n}\n", "KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkmf.init(null, null);\nKeyManager km = kmf.getKeyManagers()[0];\n\nftpsClient = new FTPSClient(\"SSL\");\nftpsClient.setKeyManager(km);\n", "/**\n * A strengthener that can be used to generate and re-seed random number\n * generators that do not seed themselves appropriately.\n * \n * @author owlstead\n */\npublic class SecureRandomStrengthener {\n    private static final String DEFAULT_PSEUDO_RANDOM_NUMBER_GENERATOR = \"SHA1PRNG\";\n\n    private static final EntropySource TIME_ENTROPY_SOURCE = new EntropySource() {\n\n        final ByteBuffer timeBuffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE\n                * 2);\n\n        @Override\n        public ByteBuffer provideEntropy() {\n            this.timeBuffer.clear();\n            this.timeBuffer.putLong(System.currentTimeMillis());\n            this.timeBuffer.putLong(System.nanoTime());\n            this.timeBuffer.flip();\n            return this.timeBuffer;\n        }\n    };\n\n    private final String algorithm;\n    private final List&lt;EntropySource&gt; entropySources = new LinkedList&lt;EntropySource&gt;();\n    private final MessageDigest digest;\n    private final ByteBuffer seedBuffer;\n\n    /**\n     * Generates an instance of a {@link SecureRandomStrengthener} that\n     * generates and re-seeds instances of {@code \"SHA1PRNG\"}.\n     * \n     * @return the strengthener, never null\n     */\n    public static SecureRandomStrengthener getInstance() {\n        return new SecureRandomStrengthener(\n                DEFAULT_PSEUDO_RANDOM_NUMBER_GENERATOR);\n    }\n\n    /**\n     * Generates an instance of a {@link SecureRandomStrengthener} that\n     * generates instances of the given argument. Note that the availability of\n     * the given algorithm arguments in not tested until generation.\n     * \n     * @param algorithm\n     *            the algorithm indicating the {@link SecureRandom} instance to\n     *            use\n     * @return the strengthener, never null\n     */\n    public static SecureRandomStrengthener getInstance(final String algorithm) {\n        return new SecureRandomStrengthener(algorithm);\n    }\n\n    private SecureRandomStrengthener(final String algorithm) {\n        if (algorithm == null || algorithm.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Please provide a PRNG algorithm string such as SHA1PRNG\");\n        }\n\n        this.algorithm = algorithm;\n        try {\n            this.digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\n                    \"MessageDigest to create seed not available\", e);\n        }\n        this.seedBuffer = ByteBuffer.allocate(this.digest.getDigestLength());\n    }\n\n    /**\n     * Add an entropy source, which will be called for each generation and\n     * re-seeding of the given random number generator.\n     * \n     * @param source\n     *            the source of entropy\n     */\n    public void addEntropySource(final EntropySource source) {\n        if (source == null) {\n            throw new IllegalArgumentException(\n                    \"EntropySource should not be null\");\n        }\n        this.entropySources.add(source);\n    }\n\n    /**\n     * Generates and seeds a random number generator of the configured\n     * algorithm. Calls the {@link EntropySource#provideEntropy()} method of all\n     * added sources of entropy.\n     * \n     * @return the random number generator\n     */\n    public SecureRandom generateAndSeedRandomNumberGenerator() {\n        final SecureRandom secureRandom;\n        try {\n            secureRandom = SecureRandom.getInstance(this.algorithm);\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"PRNG is not available\", e);\n        }\n\n        reseed(secureRandom);\n        return secureRandom;\n    }\n\n    /**\n     * Re-seeds the random number generator. Calls the\n     * {@link EntropySource#provideEntropy()} method of all added sources of\n     * entropy.\n     * \n     * @param secureRandom\n     *            the random number generator to re-seed\n     */\n    public void reseed(final SecureRandom secureRandom) {\n        this.seedBuffer.clear();\n        secureRandom.nextBytes(this.seedBuffer.array());\n\n        for (final EntropySource source : this.entropySources) {\n            final ByteBuffer entropy = source.provideEntropy();\n            if (entropy == null) {\n                continue;\n            }\n\n            final ByteBuffer wipeBuffer = entropy.duplicate();\n            this.digest.update(entropy);\n            wipe(wipeBuffer);\n        }\n\n        this.digest.update(TIME_ENTROPY_SOURCE.provideEntropy());\n        this.digest.update(this.seedBuffer);\n        this.seedBuffer.clear();\n        // remove data from seedBuffer so it won't be retrievable\n\n        // reuse\n\n        try {\n            this.digest.digest(this.seedBuffer.array(), 0,\n                    this.seedBuffer.capacity());\n        } catch (final DigestException e) {\n            throw new IllegalStateException(\n                    \"DigestException should not be thrown\", e);\n        }\n        secureRandom.setSeed(this.seedBuffer.array());\n\n        wipe(this.seedBuffer);\n    }\n\n    private void wipe(final ByteBuffer buf) {\n        while (buf.hasRemaining()) {\n            buf.put((byte) 0);\n        }\n    }\n}\n", "public static String getMD5Hash(String s) throws NoSuchAlgorithmException {\n\nString result = s;\nif (s != null) {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\"); // or \"SHA-1\"\n    md.update(s.getBytes());\n    BigInteger hash = new BigInteger(1, md.digest());\n    result = hash.toString(16);\n    while (result.length() &lt; 32) { // 40 for SHA-1\n        result = \"0\" + result;\n    }\n}\nreturn result; }\n", "CertificateFactory factory = CertificateFactory.getInstance(\"X.509\");\nX509Certificate x509Server;\nByteArrayInputStream bias = new ByteArrayInputStream(certBytes);\nx509Server= (X509Certificate) factory.generateCertificate(bias);\n", "private static char[] hextable = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\nprivate static String md5(String s)\n{\n    MessageDigest digest;\n    try\n    {\n        digest = MessageDigest.getInstance(\"MD5\");\n        digest.update(s.getBytes(), 0, s.length());\n        byte[] bytes = digest.digest();\n\n        String hash = \"\";\n        for (int i = 0; i &lt; bytes.length; ++i)\n        {\n            int di = (bytes[i] + 256) &amp; 0xFF;\n            hash = hash + hextable[(di &gt;&gt; 4) &amp; 0xF] + hextable[di &amp; 0xF];\n        }\n\n        return hash;\n    }\n    catch (NoSuchAlgorithmException e)\n    {\n    }\n\n    return \"\";\n}\n", "PackageInfo packageInfo = context.getPackageManager().getPackageInfo(\n    context.getPackageName(), PackageManager.GET_SIGNATURES);\n\nfor (Signature signature : packageInfo.signatures) {\n    byte[] signatureBytes = signature.toByteArray();\n    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n    md.update(signature.toByteArray());\n    final String currentSignature = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n    if (SIGNATURE.equals(currentSignature)){\n      return true;\n    }\n}\nreturn fals;\n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    \"com.org.package\", PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String sign = Base64\n                        .encodeToString(md.digest(), Base64.DEFAULT);\n\n                    Log.e(\"MY KEY HASH:\", sign);\n\n            }\n        } catch (NameNotFoundException e) {\n        } catch (NoSuchAlgorithmException e) {\n        }\n", "try {\n    PackageInfo info = getPackageManager().getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);\n    Signature[] sigs = info.signatures;\n    for (Signature sig : sigs) {\n        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n        ByteArrayInputStream in = new ByteArrayInputStream(sig.toByteArray());\n        X509Certificate cert = (X509Certificate) certFactory.generateCertificate(in);\n        // Verify or inspect cert here\n    }\n} catch (...) {\n    //...\n}\n", "public void buttonAppClick() {\n    final PackageManager pm = getActivity().getPackageManager();\n    //get a list of installed apps.\n    List&lt;ApplicationInfo&gt; packages = pm.getInstalledApplications(PackageManager.GET_META_DATA);\n    outputTextView.setText(\"\");\n    for (ApplicationInfo packageInfo : packages) {\n        try {\n            String packageName = packageInfo.packageName;\n            outputTextView.append(\"Apk Path : \" + packageInfo.sourceDir + \"\\n\");\n            PackageInfo pi = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);\n\n            Signature sig = pi.signatures[0];\n            String md5Fingerprint = doFingerprint(sig.toByteArray(), \"MD5\");\n            Log.d(TAG_HOME, \"MD5 : \" + packageInfo.sourceDir + md5Fingerprint);\n            outputTextView.append(\"MD5 : \" + md5Fingerprint + \"\\n\");\n            outputTextView.append(\"\\n\");\n        }\n        catch (Exception e) {\n            Log.e(TAG_HOME, e.getMessage());\n        }\n    }\n}\n\nprotected static String doFingerprint(byte[] certificateBytes, String algorithm)\n        throws Exception {\n    MessageDigest md = MessageDigest.getInstance(algorithm);\n    md.update(certificateBytes);\n    byte[] digest = md.digest();\n\n    String toRet = \"\";\n    for (int i = 0; i &lt; digest.length; i++) {\n        if (i != 0)\n            toRet += \":\";\n        int b = digest[i] &amp; 0xff;\n        String hex = Integer.toHexString(b);\n        if (hex.length() == 1)\n            toRet += \"0\";\n        toRet += hex;\n    }\n    return toRet;\n}\n", "package com.infovale.cripto;\n\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic class RSA {\n\nKeyPairGenerator kpg;\nKeyPair kp;\nPublicKey publicKey;\nPrivateKey privateKey;\nbyte[] encryptedBytes, decryptedBytes;\nCipher cipher, cipher1;\nString encrypted, decrypted;\n\npublic String Encrypt (String plain) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException \n{\n    kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(1024);\n    kp = kpg.genKeyPair();\n    publicKey = kp.getPublic();\n    privateKey = kp.getPrivate();\n\n    cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    encryptedBytes = cipher.doFinal(plain.getBytes());\n\n    encrypted = bytesToString(encryptedBytes);\n    return encrypted;\n\n}\n\npublic String Decrypt (String result) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException \n{           \n\n    cipher1=Cipher.getInstance(\"RSA\");\n    cipher1.init(Cipher.DECRYPT_MODE, privateKey);\n    decryptedBytes = cipher1.doFinal(stringToBytes(result));\n    decrypted = new String(decryptedBytes);\n    return decrypted;\n\n}\n\npublic  String bytesToString(byte[] b) {\n    byte[] b2 = new byte[b.length + 1];\n    b2[0] = 1;\n    System.arraycopy(b, 0, b2, 1, b.length);\n    return new BigInteger(b2).toString(36);\n}\n\npublic  byte[] stringToBytes(String s) {\n    byte[] b2 = new BigInteger(s, 36).toByteArray();\n    return Arrays.copyOfRange(b2, 1, b2.length);\n}\n}\n", "private static final char[] HEX_ARRAY = (\"0123456789ABCDEF\").toCharArray();\n\npublic static String getSHA512HahsOfString(String toHash) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    String hash = null;\n\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n    byte[] bytes = toHash.getBytes(\"UTF-8\");\n\n    digest.update(bytes, 0, bytes.length);\n    bytes = digest.digest();\n    hash = bytesToHex(bytes);\n\n    return hash;\n}\n\npublic static String bytesToHex(byte[] bytes) {\n    char[] hexChars = new char[bytes.length * 2];\n\n    for (int j = 0; j &lt; bytes.length; j++) {\n        int v = bytes[j] &amp; 0xFF;\n        hexChars[j * 2] = HEX_ARRAY[v &gt;&gt;&gt; 4];\n        hexChars[j * 2 + 1] = HEX_ARRAY[v &amp; 0x0F];\n    }\n\n    return new String(hexChars);\n}\n", "public static String printKeyHash(Activity context) {\n    PackageInfo packageInfo;\n    String key = null;\n    try {\n\n        //getting application package name, as defined in manifest\n        String packageName = context.getApplicationContext().getPackageName();\n\n        //Retriving package info\n        packageInfo = context.getPackageManager().getPackageInfo(packageName,\n                PackageManager.GET_SIGNATURES);\n\n        Log.e(\"Package Name=\", context.getApplicationContext().getPackageName());\n\n        for (Signature signature : packageInfo.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            key = new String(Base64.encode(md.digest(), 0));\n\n            // String key = new String(Base64.encodeBytes(md.digest()));\n            //Log.e(\"Key Hash=\", key);\n             Toast.makeText(TAG, \"Keyhash: \" + key, 1).show();\n\n        }\n    } catch (NameNotFoundException e1) {\n        Log.e(\"Name not found\", e1.toString());\n    }\n\n    catch (NoSuchAlgorithmException e) {\n        Log.e(\"No such an algorithm\", e.toString());\n    } catch (Exception e) {\n        Log.e(\"Exception\", e.toString());\n    }\n\n    return key;\n}\n", "byte[] iv = \"87654321\".getBytes(\"US-ASCII\");\nbyte[] key = \"SampleKey\".getBytes(\"US-ASCII\");\nbyte[] data = new byte[30]; // for example\n\nSecretKeySpec skeySpec = new SecretKeySpec(key, \"RC2\");\n\nRC2ParameterSpec ivSpec = new RC2ParameterSpec(key.length * 8, iv);\n\nCipher cipher = Cipher.getInstance(\"RC2/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);\nbyte[] encrypted = cipher.doFinal(data);\n\n// ....\n", "public static byte[] createChecksum(byte[] b){\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance(\"MD5\");\n\n\n    } catch (NoSuchAlgorithmException e) {\n\n        e.printStackTrace();\n    }\n    md.update(b,0,b.length);\n    byte[] checksum = md.digest();\n    return checksum;\n}\n", "public String encryptString(String string, String key)\n{\n    byte[] aesData;\n    String base64=\"\";\n\n    try \n    {\n        aesData = encrypt(key, string.getBytes(\"UTF8\"));\n        base64 = Base64.encodeToString(aesData, Base64.DEFAULT);\n    } \n    catch (Exception e) \n    {\n        e.printStackTrace();\n    }       \n\n    return base64;\n}\n\npublic String decryptString(String string, String key)\n{\n    byte[] debase64 = null;\n    String result=\"\";\n\n    try \n    {\n        debase64=Base64.decode(string, Base64.DEFAULT);\n        byte[] aesDecrypted = decrypt(key, debase64);;\n\n        result = new String(aesDecrypted, \"UTF8\");\n    } \n    catch (Exception e) \n    {\n        e.printStackTrace();\n    }       \n\n    return result;\n}\n\nprivate byte[] decrypt(String k, byte[] plainBytes) throws Exception \n{\n    // convert key to bytes\n    byte[] keyBytes = k.getBytes(\"UTF-8\");\n    // Use the first 16 bytes (or even less if key is shorter)\n    byte[] keyBytes16 = new byte[16];\n    System.arraycopy(keyBytes, 0, keyBytes16, 0, Math.min(keyBytes.length, 16));\n\n    // setup cipher\n    SecretKeySpec skeySpec = new SecretKeySpec(keyBytes16, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] iv = new byte[16]; // initialization vector with all 0\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(iv));\n\n    // encrypt\n    byte[] encrypted = cipher.doFinal(plainBytes);\n\n    return encrypted;\n}\n\nprivate byte[] encrypt(String k, byte[] plainBytes) throws Exception \n{\n    // convert key to bytes\n    byte[] keyBytes = k.getBytes(\"UTF-8\");\n    // Use the first 16 bytes (or even less if key is shorter)\n    byte[] keyBytes16 = new byte[16];\n    System.arraycopy(keyBytes, 0, keyBytes16, 0, Math.min(keyBytes.length, 16));\n\n    // setup cipher\n    SecretKeySpec skeySpec = new SecretKeySpec(keyBytes16, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] iv = new byte[16]; // initialization vector with all 0\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));\n\n    // encrypt\n    byte[] encrypted = cipher.doFinal(plainBytes);\n\n    return encrypted;\n}\n", "byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,\n    0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 }; //Choose a key wisely\n\nSecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n\nCipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n\nfis = new FileInputStream(\"some_img.png\");\ncis = new CipherInputStream(fis, cipher);\nfos = new FileOutputStream(\"encrypted_img.enc\");\nbyte[] b = new byte[8];\nint i = cis.read(b);\nwhile (i != -1) {\n    fos.write(b, 0, i);\n    i = cis.read(b);\n}\nfos.close();\n", "package me.gilo.a55thavenue.data;\n\nimport android.util.Base64;\nimport android.util.Log;\n\nimport com.squareup.okhttp.HttpUrl;\nimport com.squareup.okhttp.Interceptor;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\n\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.utils.URLEncodedUtils;\nimport org.apache.http.message.BasicNameValuePair;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport retrofit.GsonConverterFactory;\nimport retrofit.Retrofit;\nimport retrofit.RxJavaCallAdapterFactory;\n\n/**\n * Created by Aron on 10/31/2015.\n */\npublic class PostRestAdapter {\n\n    static String oauth_nonce = \"\";\n    static String oauth_timestamp = \"\";\n    static String oauth_signature_method = \"HMAC-SHA1\";\n\n    static ArrayList&lt;NameValuePair&gt; params;\n\n    public static API createAPI(final String endpoint) {\n\n        setParams(endpoint);\n\n        // Define the interceptor, add authentication headers\n        Interceptor interceptor = new Interceptor() {\n            @Override\n            public Response intercept(Chain chain) throws IOException {\n\n                HttpUrl.Builder builder = chain.request().httpUrl().newBuilder();\n                for (NameValuePair entry : params) {\n                    builder.addQueryParameter(entry.getName(), entry.getValue());\n                }\n\n                Request newRequest = chain.request()\n                        .newBuilder()\n                        .url(builder.build())\n                        .build();\n\n                return chain.proceed(newRequest);\n            }\n        };\n\n\n        // Add the interceptor to OkHttpClient\n        OkHttpClient client = new OkHttpClient();\n        client.interceptors().add(interceptor);\n\n\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(API.BASE_URL)\n                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                .addConverterFactory(GsonConverterFactory.create())\n                .client(client)\n                .build();\n        return retrofit.create(API.class);\n    }\n\n    public static ArrayList&lt;NameValuePair&gt; setParams(String endpoint) {\n\n        final String uri = API.BASE_URL + endpoint;\n\n        oauth_nonce = getOauth_nonce();\n        oauth_timestamp = getOauth_timestamp();\n\n        params = new ArrayList&lt;&gt;();\n        params.add(new BasicNameValuePair(\"oauth_consumer_key\", API.CONSUMER_KEY));\n        params.add(new BasicNameValuePair(\"oauth_nonce\", oauth_nonce));\n        params.add(new BasicNameValuePair(\"oauth_timestamp\", oauth_timestamp));\n        params.add(new BasicNameValuePair(\"oauth_signature_method\", oauth_signature_method));\n\n        Collections.sort(params, new SortParams());\n\n        String encodedParams = URLEncodedUtils.format(params, \"utf-8\");\n        Log.d(\"encodedParamString\", encodedParams);\n\n        String string_to_sign = \"\";\n        try {\n            string_to_sign = (new StringBuilder(\"POST&amp;\")).append(URLEncoder.encode(uri, \"utf-8\")).append(\"&amp;\").append(URLEncoder.encode(encodedParams, \"utf-8\")).toString();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        Log.d(\"string to sign\", string_to_sign);\n\n        try {\n            Mac mac = Mac.getInstance(\"HMAC-SHA1\");\n            String secret = API.CONSUMER_SECRET;\n            if (API.WP_API_VERSION.equals(\"3\")) {\n                secret = API.CONSUMER_SECRET + \"&amp;\";\n            }\n            mac.init(new SecretKeySpec(secret.getBytes(\"utf-8\"), \"HMAC-SHA1\"));\n            String signature = Base64.encodeToString(mac.doFinal(string_to_sign.getBytes(\"utf-8\")), 0).trim();\n            Log.d(\"signature\", signature);\n            params.add(new BasicNameValuePair(\"oauth_signature\", signature));\n        } catch (NoSuchAlgorithmException | InvalidKeyException | UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n        return params;\n    }\n\n    public static String getOauth_nonce() {\n        return (new StringBuilder(String.valueOf(Math.random() * 100000000D))).toString();\n    }\n\n    public static String getOauth_timestamp() {\n        long stamp = (long) (System.currentTimeMillis() / 1000D);\n        Log.d(\"stamp\", stamp + \"\");\n        return (new StringBuilder(String.valueOf(stamp))).toString();\n    }\n\n    static class SortParams implements Comparator&lt;NameValuePair&gt; {\n\n        @Override\n        public int compare(NameValuePair nameValuePair1, NameValuePair nameValuePair2) {\n            return nameValuePair1.getName().compareTo(nameValuePair2.getName());\n        }\n    }\n}\n", "private final static String AUTH = \"authentication\";\n\n    private static final String UPDATE_CLIENT_AUTH = \"Update-Client-Auth\";\n\n    public static final String PARAM_REGISTRATION_ID = \"registration_id\";\n\n    public static final String PARAM_DELAY_WHILE_IDLE = \"delay_while_idle\";\n\n    public static final String PARAM_COLLAPSE_KEY = \"collapse_key\";\n\n    private static final String UTF8 = \"UTF-8\";\n\n    public static int sendMessage(String auth_token, String registrationId,\n            String message) throws IOException {\n\n        StringBuilder postDataBuilder = new StringBuilder();\n        postDataBuilder.append(PARAM_REGISTRATION_ID).append(\"=\")\n                .append(registrationId);\n        postDataBuilder.append(\"&amp;\").append(PARAM_COLLAPSE_KEY).append(\"=\")\n                .append(\"0\");\n        postDataBuilder.append(\"&amp;\").append(\"data.payload\").append(\"=\")\n                .append(URLEncoder.encode(message, UTF8));\n\n        byte[] postData = postDataBuilder.toString().getBytes(UTF8);\n\n        // Hit the dm URL.\n\n        URL url = new URL(\"https://android.clients.google.com/c2dm/send\");\n        HttpsURLConnection\n                .setDefaultHostnameVerifier(new CustomizedHostnameVerifier());\n        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.setUseCaches(false);\n        conn.setRequestMethod(\"POST\");\n        conn.setRequestProperty(\"Content-Type\",\n                \"application/x-www-form-urlencoded;charset=UTF-8\");\n        conn.setRequestProperty(\"Content-Length\",\n                Integer.toString(postData.length));\n        conn.setRequestProperty(\"Authorization\", \"GoogleLogin auth=\"\n                + auth_token);\n\n        OutputStream out = conn.getOutputStream();\n        out.write(postData);\n        out.close();\n\n        int responseCode = conn.getResponseCode();\n        return responseCode;\n    }\n", "try {   \n                   GmailSender sender = new GmailSender(\"gmailusername\", \"gmailpassword\",\"\");\n                   sender.sendMail(\"Registration to Model Apps:\",\"username=\"+username+\"\\n password=\"+password,\"gmailusername\",\"gmailusername\");   \n                } \n             catch (Exception e) \n               {   \n                   Log.e(\"SendMail\", e.getMessage(), e);   \n               }\n\n\n\nand create class  GmailSender\n\npackage com.example.ur;//write ur pakage\n\nimport javax.activation.DataHandler;   \nimport javax.activation.DataSource;   \nimport javax.activation.FileDataSource;\nimport javax.mail.BodyPart;\nimport javax.mail.Message;   \nimport javax.mail.PasswordAuthentication;   \nimport javax.mail.Session;   \nimport javax.mail.Transport;   \nimport javax.mail.internet.InternetAddress;   \nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;   \nimport javax.mail.internet.MimeMultipart;\n\nimport android.util.Log;\n\nimport java.io.ByteArrayInputStream;   \nimport java.io.IOException;   \nimport java.io.InputStream;   \nimport java.io.OutputStream;   \nimport java.security.Security;   \nimport java.util.Properties;   \n\npublic class GmailSender extends javax.mail.Authenticator {   \n    private String mailhost = \"smtp.gmail.com\",imagePath;   \n    private String user;   \n    private String password;   \n    private Session session;   \n\n    static \n    {   \n        Security.addProvider(new com.example.model.JSSEProvider());   \n    }  \n\n    public GmailSender(String user, String password,String imagePath) {   \n        this.user = user;   \n        this.password = password;   \n        this.imagePath=imagePath;\n        Properties props = new Properties();   \n        props.setProperty(\"mail.transport.protocol\", \"smtp\");   \n        props.setProperty(\"mail.host\", mailhost);   \n        props.put(\"mail.smtp.auth\", \"true\");   \n\n\n        props.put(\"mail.smtp.port\", \"465\");   \n        props.put(\"mail.smtp.socketFactory.port\", \"465\");   \n        props.put(\"mail.smtp.socketFactory.class\",   \n                \"javax.net.ssl.SSLSocketFactory\");   \n        props.put(\"mail.smtp.socketFactory.fallback\", \"false\");   \n        props.setProperty(\"mail.smtp.quitwait\", \"false\");   \n\n        session = Session.getDefaultInstance(props, this);   \n    }   \n\n    protected PasswordAuthentication getPasswordAuthentication() {   \n        return new PasswordAuthentication(user, password);   \n    }   \n\n    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   \n        try{\n\n\n             Transport transport = session.getTransport();  \n\n             MimeMessage message = new MimeMessage(session);  \n             message.setSubject(subject);  \n             message.setFrom(new InternetAddress(sender));  \n             message.addRecipient(Message.RecipientType.TO, new InternetAddress(recipients));  \n\n             //  \n             // This HTML mail have to 2 part, the BODY and the embedded image  \n             //  \n             MimeMultipart multipart = new MimeMultipart(\"related\");  \n\n             // first part  (the html)  \n             BodyPart messageBodyPart = new MimeBodyPart();  \n             String htmlText = \"&lt;H1&gt;\"+body+\"&lt;/H1&gt;\";  \n             messageBodyPart.setContent(htmlText, \"text/html\");  \n\n             // add it  \n             multipart.addBodyPart(messageBodyPart);  \n\n             // second part (the image)  \n          //   messageBodyPart = new MimeBodyPart();  \n         //    DataSource fds = new FileDataSource(imagePath);  \n         //    messageBodyPart.setDataHandler(new DataHandler(fds));  \n         //    messageBodyPart.setHeader(\"Content-ID\",imagePath);  \n\n             // add it  \n           //  multipart.addBodyPart(messageBodyPart);  \n\n             // put everything together  \n             message.setContent(multipart);  \n\n             transport.connect();  \n             transport.sendMessage(message,message.getRecipients(Message.RecipientType.TO));  \n             transport.close();  \n        }catch(Exception e){\n            Log.e(\"\", \"FILE NOT FOUND EXCEPTION \"+e.getMessage());\n        }\n    }   \n\n    public class ByteArrayDataSource implements DataSource {   \n        private byte[] data;   \n        private String type;   \n\n        public ByteArrayDataSource(byte[] data, String type) {   \n            super();   \n            this.data = data;   \n            this.type = type;   \n        }   \n\n        public ByteArrayDataSource(byte[] data) {   \n            super();   \n            this.data = data;   \n        }   \n\n        public void setType(String type) {   \n            this.type = type;   \n        }   \n\n        public String getContentType() {   \n            if (type == null)   \n                return \"application/octet-stream\";   \n            else  \n                return type;   \n        }   \n\n        public InputStream getInputStream() throws IOException {   \n            return new ByteArrayInputStream(data);   \n        }   \n\n        public String getName() {   \n            return \"ByteArrayDataSource\";   \n        }   \n\n        public OutputStream getOutputStream() throws IOException {   \n            throw new IOException(\"Not Supported\");   \n        }   \n    }   \n}  \n", "    package com.example.model;\n\n\n    import java.security.AccessController;\n    import java.security.Provider;\n\n    public final class JSSEProvider extends Provider {\n\n        public JSSEProvider() {\n            super(\"HarmonyJSSE\", 1.0, \"Harmony JSSE Provider\");\n            AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {\n                public Void run() {\n                    put(\"SSLContext.TLS\",\n                            \"org.apache.harmony.xnet.provider.jsse.SSLContextImpl\");\n                    put(\"Alg.Alias.SSLContext.TLSv1\", \"TLS\");\n                    put(\"KeyManagerFactory.X509\",\n                            \"org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl\");\n                    put(\"TrustManagerFactory.X509\",\n                            \"org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl\");\n                    return null;\n                }\n            });\n        }\n\n }\n", "protected static Certificate ca;\n\n/**\n     * set self signed certificate to trust\n     */\n    public static void trustSelfSignedSSL() {\n\n        try {\n            // set hostname verifier to check hostname validity\n            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n                public boolean verify(String hostname, SSLSession session) {\n                    return hostname.equals(Config.HTTPS_CERTIFICATE_URL) || hostname.equals(Config.HTTPS_GOOGLE_URL);\n                }\n            });\n\n            // load certificate\n            hbgCa = getCert();\n\n            // add certificate to key store\n            if (null != hbgCa) {\n                String keyStoreType = KeyStore.getDefaultType();\n                KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n                keyStore.load(null, null);\n                keyStore.setCertificateEntry(\"hbgCa\", hbgCa);\n\n                String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n                TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n                tmf.init(keyStore);\n\n                SSLContext context = SSLContext.getInstance(\"TLS\");\n                context.init(null, tmf.getTrustManagers(), null);\n//          HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n                HttpsURLConnection.setDefaultSSLSocketFactory(createSslSocketFactory());\n            }\n        } catch (Exception e) { // should never happen\n            e.printStackTrace();\n        }\n    }\n\n\n    /**\n     * create a custom sslsocketfactory to trust server connections\n     *\n     * @return\n     * @throws Exception\n     */\n    private static SSLSocketFactory createSslSocketFactory() throws Exception {\n        TrustManager[] byPassTrustManagers = new TrustManager[]{new X509TrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[0];\n            }\n\n            public void checkClientTrusted(X509Certificate[] chain, String authType) {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\n                // Loading the CA cert\n                if (null == ca) {\n                    ca = getCert();\n                }\n\n                for (X509Certificate cert : chain) {\n\n                    // check if the certificate is the selfsigned trusted one\n                    if (verifiyCertificate(ca, cert)) {\n                        return;\n                    }\n                    // check if current certificate belongs to google\n                    if (cert.getIssuerX500Principal().getName().equals(\"CN=Google Internet Authority G2,O=Google Inc,C=US\")) {\n                        return;\n                    }\n                }\n\n        // if none certificate trusted throw certificate exception to tell to not trust connection\n                throw new CertificateException();\n            }\n        }\n        };\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, byPassTrustManagers, new SecureRandom());\n        return sslContext.getSocketFactory();\n    }\n\n\n    /**\n     * verifiy a certificate against the other\n     */\n    private static boolean verifiyCertificate(Certificate cert1, Certificate cert2) {\n        try {\n            cert1.verify(cert2.getPublicKey());\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * load and return selfsigned local cert\n     *\n     * @return\n     */\n    private static Certificate getCert() {\n\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            Context appContext = HBGApplication.getWrapperContext();\n            AssetManager assets = appContext.getAssets();\n            InputStream caInput = assets.open(Config.HTTPS_CERTIFICATE_ASSETS_FILE);\n            Certificate ca;\n\n            try {\n                return cf.generateCertificate(caInput);\n            } catch (CertificateException e) {\n                e.printStackTrace();\n            } finally {\n                caInput.close();\n            }\n\n            return null;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "try\n{\n    //paste Your package name at the first parameter\n    PackageInfo info = getPackageManager().getPackageInfo(\"PUT_YOUR_PACKAGE_NAME_HERE\",\n            PackageManager.GET_SIGNATURES);\n    for (android.content.pm.Signature signature : info.signatures)\n    {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n        Log.e(\"MY KEY HASH:\", sign);\n        Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG).show();\n    }\n}\ncatch (PackageManager.NameNotFoundException e)\n{\n}\ncatch (NoSuchAlgorithmException e)\n{\n}\n", "        package com.yourapp.android.crypto;\n\n        import java.security.InvalidAlgorithmParameterException;\n        import java.security.InvalidKeyException;\n        import java.security.NoSuchAlgorithmException;\n        import javax.crypto.BadPaddingException;\n        import javax.crypto.Cipher;\n        import javax.crypto.IllegalBlockSizeException;\n        import javax.crypto.NoSuchPaddingException;\n        import javax.crypto.spec.IvParameterSpec;\n        import javax.crypto.spec.SecretKeySpec;\n        import android.content.Context;\n        import android.util.Base64;\n\n        public class Crypto {\n\n           private static final String engine = \"AES\";\n           private static final String crypto = \"AES/CBC/PKCS5Padding\";\n           private static Context ctx;\n           public Crypto(Context cntx) {\n             ctx = cntx;\n           }\n\n           public byte[] cipher(byte[] data, int mode) throws NoSuchAlgorithmException,NoSuchPaddingException,InvalidKeyException,IllegalBlockSizeException,BadPaddingException,InvalidAlgorithmParameterException {\n             KeyManager km = new KeyManager(ctx);\n             SecretKeySpec sks = new SecretKeySpec(km.getId(), engine);\n             IvParameterSpec iv = new IvParameterSpec(km.getIv());\n             Cipher c = Cipher.getInstance(crypto);\n             c.init(mode, sks, iv);\n             return c.doFinal(data);\n           }\n\n           public byte[] encrypt(byte[] data) throws InvalidKeyException,\n        NoSuchAlgorithmException, NoSuchPaddingException,\n        IllegalBlockSizeException, BadPaddingException,\n        InvalidAlgorithmParameterException {\n             return cipher(data, Cipher.ENCRYPT_MODE);\n           }\n\n           public byte[] decrypt(byte[] data) throws InvalidKeyException,\n        NoSuchAlgorithmException, NoSuchPaddingException,\n        IllegalBlockSizeException, BadPaddingException,\n        InvalidAlgorithmParameterException {\n             return cipher(data, Cipher.DECRYPT_MODE);\n           }\n\n        public String armorEncrypt(byte[] data) throws InvalidKeyException,NoSuchAlgorithmException,\n    NoSuchPaddingException,IllegalBlockSizeException,\n    BadPaddingException,InvalidAlgorithmParameterException {\n                 return Base64.encodeToString(encrypt(data), Base64.DEFAULT);\n               }\n\n         public String armorDecrypt(String data) throws InvalidKeyException,NoSuchAlgorithmException,\n    NoSuchPaddingException,IllegalBlockSizeException,\n    BadPaddingException,InvalidAlgorithmParameterException {\n                 return new String(decrypt(Base64.decode(data, Base64.DEFAULT)));\n               }\n}\n", "package com.yourapp.android.crypto;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\nimport android.os.Bundle;\nimport android.app.Activity;\nimport android.content.Context;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.TextView;\n\n\npublic class MainActivity extends Activity {\n    TextView encryptedDataView;\n    EditText editInputData;\n    private Context cntx;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        this.cntx = getApplicationContext();\n        Button btnEncrypt = (Button) findViewById(R.id.buttonEncrypt);\n        Button btnDecrypt = (Button) findViewById(R.id.buttonDecrypt);\n        Button btnDelete = (Button) findViewById(R.id.buttonDelete);\n        editInputData = (EditText)findViewById(R.id.editInputData) ;\n        encryptedDataView = (TextView) findViewById(R.id.encryptView);\n\n        /**********************************************/\n            /** INITIALIZE KEY AND INITIALIZATION VECTOR **/\n        String key = \"12345678909876543212345678909876\";\n        String iv = \"1234567890987654\";\n        KeyManager km = new KeyManager(getApplicationContext());\n        km.setIv(iv.getBytes());\n        km.setId(key.getBytes());\n        /**********************************************/\n\n        btnEncrypt.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                String Data = editInputData.getText().toString();\n                String Encrypted_Data = \"data\";\n                try {\n                    Crypto crypto = new Crypto(cntx);\n                    Encrypted_Data = crypto.armorEncrypt(Data.getBytes());\n                }   catch (InvalidKeyException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (NoSuchAlgorithmException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (NoSuchPaddingException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (IllegalBlockSizeException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (BadPaddingException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (InvalidAlgorithmParameterException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    }\n                encryptedDataView.setText(Encrypted_Data);\n            }\n        });\n\n        btnDecrypt.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                String Data = encryptedDataView.getText().toString();\n                String Decrypted_Data = \"data\";\n                try {\n                    Crypto crypto = new Crypto(cntx);\n                    Decrypted_Data = crypto.armorDecrypt(Data);\n                }   catch (InvalidKeyException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (NoSuchAlgorithmException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (NoSuchPaddingException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (IllegalBlockSizeException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (BadPaddingException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    } catch (InvalidAlgorithmParameterException e) {\n                    Log.e(\"SE3\", \"Exception in StoreData: \" + e.getMessage());\n                    }\n                encryptedDataView.setText(Decrypted_Data);\n            }\n        });\n\n        btnDelete.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                encryptedDataView.setText(\" Deleted \");\n            }\n        });\n\n    }\n\n}\n", "Key prvkey = keyStore.getKey(_alias,_keypass.toCharArray());\nPublicKey pubkey = certificate.getPublicKey();\nKeyPair keypair = new KeyPair(pubkey, (PrivateKey)prvkey);\nPrivateKey privKewy = keypair.getPrivate();\n", "final Charset charset = Charset.forName(\"UTF-8\");\nfinal MessageDigest digest = MessageDigest\n        .getInstance(\"SHA-512\");\nfinal byte[] hashData = digest\n        .digest(json.getBytes(charset));\nfinal String hash = new String(hashData, charset);\nnameValuePairs.add(new BasicNameValuePair(\"credit_card\", hash));\n", "private String getShortenedKey(String key) {\n    String shortenedKey=null;\n    MessageDigest md = null;\n    LogUtils.LOGD(HASH_ALGO, \"before key: \"+ System.currentTimeMillis());\n    try {\n        md = MessageDigest.getInstance(\"MD5\");\n\n        md.update(key.getBytes());\n        byte[] shortenedBytes = md.digest();\n        shortenedKey = Base64.encodeToString(shortenedBytes, Base64.NO_WRAP);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n        shortenedKey = key;\n    }\n    LogUtils.LOGD(HASH_ALGO, \"after key: \"+ System.currentTimeMillis());\n\n    return shortenedKey;\n}\n", "public class MainActivity extends AppCompatActivity {\n\nprivate TextView mTextView;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    mTextView = (TextView) findViewById(R.id.textView);\n\n    String url = \"https://192.168.1.100/testvolley\";\n\n    HurlStack hurlStack = new HurlStack() {\n        @Override\n        protected HttpURLConnection createConnection(URL url) throws IOException {\n            HttpsURLConnection httpsURLConnection = (HttpsURLConnection) super.createConnection(url);\n            try {\n                httpsURLConnection.setSSLSocketFactory(getSSLSocketFactory());\n                httpsURLConnection.setHostnameVerifier(getHostnameVerifier());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return httpsURLConnection;\n        }\n    };\n\n    final JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(Request.Method.GET, url, new Response.Listener&lt;JSONObject&gt;() {\n        @Override\n        public void onResponse(JSONObject response) {\n            try {\n                mTextView.setText(response.toString(5));\n            } catch (JSONException e) {\n                mTextView.setText(e.toString());\n            }\n        }\n    }, new Response.ErrorListener() {\n        @Override\n        public void onErrorResponse(VolleyError error) {\n            mTextView.setText(error.toString());\n        }\n    });\n\n    final RequestQueue requestQueue = Volley.newRequestQueue(this, hurlStack);\n\n    requestQueue.add(jsonObjectRequest);\n}\n\n// Let's assume your server app is hosting inside a server machine\n// which has a server certificate in which \"Issued to\" is \"localhost\",for example.\n// Then, inside verify method you can verify \"localhost\". \n// If not, you can temporarily return true\nprivate HostnameVerifier getHostnameVerifier() {\n    return new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            //return true;\n            HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();\n            return hv.verify(\"localhost\", session);\n        }\n    };\n}\n\nprivate TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {\n    final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];\n    return new TrustManager[]{\n            new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() {\n                    return originalTrustManager.getAcceptedIssuers();\n                }\n\n                public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                    try {\n                        originalTrustManager.checkClientTrusted(certs, authType);\n                    } catch (CertificateException ignored) {\n                    }\n                }\n\n                public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                    try {\n                        originalTrustManager.checkServerTrusted(certs, authType);\n                    } catch (CertificateException ignored) {\n                    }\n                }\n            }\n    };\n}\n\nprivate SSLSocketFactory getSSLSocketFactory()\n        throws CertificateException, KeyStoreException, IOException, NoSuchAlgorithmException, KeyManagementException {\n    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n    InputStream caInput = getResources().openRawResource(R.raw.my_cert); // this cert file stored in \\app\\src\\main\\res\\raw folder path\n\n    Certificate ca = cf.generateCertificate(caInput);\n    caInput.close();\n\n    KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n    keyStore.load(null, null);\n    keyStore.setCertificateEntry(\"ca\", ca);\n\n    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n    tmf.init(keyStore);\n\n    TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());\n\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, wrappedTrustManagers, null);\n\n    return sslContext.getSocketFactory();\n}\n}\n", "import javax.activation.DataHandler;\nimport javax.activation.DataSource;\nimport javax.mail.Message;\nimport javax.mail.PasswordAuthentication;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.Security;\nimport java.util.Properties;\n\npublic class GMailSender extends javax.mail.Authenticator {\nprivate String mailhost = \"smtp.gmail.com\";\nprivate String user;\nprivate String password;\nprivate Session session;\n\nstatic {\nSecurity.addProvider(new JSSEProvider());\n}\n\npublic GMailSender(String user, String password) {\nthis.user = user;\nthis.password = password;\n\nProperties props = new Properties();\nprops.setProperty(\"mail.transport.protocol\", \"smtp\");\nprops.setProperty(\"mail.host\", mailhost);\nprops.put(\"mail.smtp.auth\", \"true\");\nprops.put(\"mail.smtp.port\", \"465\");\nprops.put(\"mail.smtp.socketFactory.port\", \"465\");\nprops.put(\"mail.smtp.socketFactory.class\",\n\"javax.net.ssl.SSLSocketFactory\");\nprops.put(\"mail.smtp.socketFactory.fallback\", \"false\");\nprops.setProperty(\"mail.smtp.quitwait\", \"false\");\n\nsession = Session.getDefaultInstance(props, this);\n}\n\nprotected PasswordAuthentication getPasswordAuthentication() {\nreturn new PasswordAuthentication(user, password);\n}\n\npublic synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {\ntry{\nMimeMessage message = new MimeMessage(session);\nDataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));\nmessage.setSender(new InternetAddress(sender));\nmessage.setSubject(subject);\nmessage.setDataHandler(handler);\nif (recipients.indexOf(',') &gt; 0)\nmessage.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));\nelse\nmessage.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));\nTransport.send(message);\n}catch(Exception e){\n\n}\n}\n\npublic class ByteArrayDataSource implements DataSource {\nprivate byte[] data;\nprivate String type;\n\npublic ByteArrayDataSource(byte[] data, String type) {\nsuper();\nthis.data = data;\nthis.type = type;\n}\n\npublic ByteArrayDataSource(byte[] data) {\nsuper();\nthis.data = data;\n}\n\npublic void setType(String type) {\nthis.type = type;\n}\n\npublic String getContentType() {\nif (type == null)\nreturn \"application/octet-stream\";\nelse\nreturn type;\n}\n\npublic InputStream getInputStream() throws IOException {\nreturn new ByteArrayInputStream(data);\n}\n\npublic String getName() {\nreturn \"ByteArrayDataSource\";\n}\n\npublic OutputStream getOutputStream() throws IOException {\nthrow new IOException(\"Not Supported\");\n}\n}\n}\n", " 136         // Clean up the certificates chain and build a new one.\n 137         // Theoretically, we shouldn't have to do this, but various web servers\n 138         // in practice are mis-configured to have out-of-order certificates or\n 139         // expired self-issued root certificate.\n 140         int chainLength = serverCertificates.length;\n 141         if (serverCertificates.length &gt; 1) {\n 142           // 1. we clean the received certificates chain.\n 143           // We start from the end-entity certificate, tracing down by matching\n 144           // the \"issuer\" field and \"subject\" field until we can't continue.\n 145           // This helps when the certificates are out of order or\n 146           // some certificates are not related to the site.\n 147           int currIndex;\n 148           for (currIndex = 0; currIndex &lt; serverCertificates.length; ++currIndex) {\n 149             boolean foundNext = false;\n 150             for (int nextIndex = currIndex + 1;\n 151                  nextIndex &lt; serverCertificates.length;\n 152                  ++nextIndex) {\n 153               if (serverCertificates[currIndex].getIssuerDN().equals(\n 154                   serverCertificates[nextIndex].getSubjectDN())) {\n 155                 foundNext = true;\n 156                 // Exchange certificates so that 0 through currIndex + 1 are in proper order\n 157                 if (nextIndex != currIndex + 1) {\n 158                   X509Certificate tempCertificate = serverCertificates[nextIndex];\n 159                   serverCertificates[nextIndex] = serverCertificates[currIndex + 1];\n 160                   serverCertificates[currIndex + 1] = tempCertificate;\n 161                 }\n 162                 break;\n 163               }\n 164             }\n 165             if (!foundNext) break;\n 166           }\n 167 \n 168           // 2. we exam if the last traced certificate is self issued and it is expired.\n 169           // If so, we drop it and pass the rest to checkServerTrusted(), hoping we might\n 170           // have a similar but unexpired trusted root.\n 171           chainLength = currIndex + 1;\n 172           X509Certificate lastCertificate = serverCertificates[chainLength - 1];\n 173           Date now = new Date();\n 174           if (lastCertificate.getSubjectDN().equals(lastCertificate.getIssuerDN())\n 175               &amp;&amp; now.after(lastCertificate.getNotAfter())) {\n 176             --chainLength;\n 177           }\n 178         }\n", "import java.io.IOException;\nimport java.net.URLEncoder;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.harmony.javax.security.auth.callback.CallbackHandler;\nimport org.apache.harmony.javax.security.sasl.Sasl;\nimport org.jivesoftware.smack.SASLAuthentication;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.sasl.SASLMechanism;\nimport org.jivesoftware.smack.util.Base64;\n\npublic class SASLXFacebookPlatformMecha extends SASLMechanism {\n\nprivate static final String NAME = \"X-FACEBOOK-PLATFORM\";\n\nprivate String apiKey = \"\";\nprivate String access_token = \"\";\n\n/**\n * Constructor.\n */\npublic SASLXFacebookPlatformMecha(SASLAuthentication saslAuthentication) {\n    super(saslAuthentication);\n}\n\n@Override\nprotected void authenticate() throws IOException, XMPPException {\n\n    getSASLAuthentication().send(new AuthMechanism(NAME, \"\"));\n}\n\n@Override\npublic void authenticate(String apiKey, String host, String acces_token)\n        throws IOException, XMPPException {\n    if (apiKey == null || acces_token == null) {\n        throw new IllegalArgumentException(\"Invalid parameters\");\n    }\n\n    this.access_token = acces_token;\n    this.apiKey = apiKey;\n    this.hostname = host;\n\n    String[] mechanisms = { NAME };\n    Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n    this.sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props,\n            this);\n    authenticate();\n}\n\n@Override\npublic void authenticate(String username, String host, CallbackHandler cbh)\n        throws IOException, XMPPException {\n    String[] mechanisms = { NAME };\n    Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();\n    this.sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props,\n            cbh);\n    authenticate();\n}\n\n@Override\nprotected String getName() {\n    return NAME;\n}\n\n@Override\npublic void challengeReceived(String challenge) throws IOException {\n    byte[] response = null;\n\n    if (challenge != null) {\n        String decodedChallenge = new String(Base64.decode(challenge));\n        Map&lt;String, String&gt; parameters = getQueryMap(decodedChallenge);\n\n        String version = \"1.0\";\n        String nonce = parameters.get(\"nonce\");\n        String method = parameters.get(\"method\");\n\n        long callId = new GregorianCalendar().getTimeInMillis();\n\n        String composedResponse = \"api_key=\"\n                + URLEncoder.encode(apiKey, \"utf-8\") + \"&amp;call_id=\" + callId\n                + \"&amp;method=\" + URLEncoder.encode(method, \"utf-8\")\n                + \"&amp;nonce=\" + URLEncoder.encode(nonce, \"utf-8\")\n                + \"&amp;access_token=\"\n                + URLEncoder.encode(access_token, \"utf-8\") + \"&amp;v=\"\n                + URLEncoder.encode(version, \"utf-8\");\n\n        response = composedResponse.getBytes(\"utf-8\");\n    }\n\n    String authenticationText = \"\";\n\n    if (response != null) {\n        authenticationText = Base64.encodeBytes(response,\n                Base64.DONT_BREAK_LINES);\n    }\n\n    // Send the authentication to the server\n    getSASLAuthentication().send(new Response(authenticationText));\n}\n\nprivate Map&lt;String, String&gt; getQueryMap(String query) {\n    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();\n    String[] params = query.split(\"\\\\&amp;\");\n\n    for (String param : params) {\n        String[] fields = param.split(\"=\", 2);\n        map.put(fields[0], (fields.length &gt; 1 ? fields[1] : null));\n    }\n\n    return map;\n}\n}\n", "import java.io.IOException;\nimport java.io.UnsupportedEncodingException; \nimport java.net.URLEncoder; \nimport java.security.MessageDigest; \nimport java.security.NoSuchAlgorithmException; \nimport java.util.GregorianCalendar; \nimport java.util.HashMap; \nimport java.util.Map;  \nimport org.apache.harmony.javax.security.auth.callback.CallbackHandler; \nimport org.apache.harmony.javax.security.sasl.Sasl; \nimport org.jivesoftware.smack.SASLAuthentication; \nimport org.jivesoftware.smack.XMPPException; \nimport org.jivesoftware.smack.sasl.SASLMechanism; \nimport org.jivesoftware.smack.util.Base64;\n\npublic class SASLXFacebookPlatformMechanism extends SASLMechanism \n{      \n    private static final String NAME              = \"X-FACEBOOK-PLATFORM\";      \n    private String              apiKey            = \"\";     \n    private String              applicationSecret = \"\";     \n    private String              sessionKey        = \"\";      \n    /**      * Constructor.      */     \n    public SASLXFacebookPlatformMechanism(SASLAuthentication saslAuthentication)     \n    {         \n        super(saslAuthentication);     \n    }      \n    @Override     \n    protected void authenticate() throws IOException, XMPPException     \n    {          \n        getSASLAuthentication().send(new AuthMechanism(NAME, \"\"));     \n    }      \n    @Override     \n    public void authenticate(String apiKeyAndSessionKey, String host,             String applicationSecret) throws IOException, XMPPException     \n    {         \n        if (apiKeyAndSessionKey == null || applicationSecret == null)         \n        {             \n            throw new IllegalArgumentException(\"Invalid parameters\");         \n        }          \n        String[] keyArray = apiKeyAndSessionKey.split(\"\\\\|\", 2);         \n        if (keyArray.length &lt; 2)         \n        {             \n            throw new IllegalArgumentException(                     \"API key or session key is not present\");         }          \n            this.apiKey = keyArray[0];         \n            this.applicationSecret = applicationSecret;         \n            this.sessionKey = keyArray[1];          \n            this.authenticationId = sessionKey;         \n            this.password = applicationSecret;         \n            this.hostname = host;          \n            String[] mechanisms = { \"DIGEST-MD5\" };         \n\n            Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();         \n            this.sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props,this);        \n            authenticate();\n        }      \n        @Override     \n        public void authenticate(String username, String host, CallbackHandler cbh)throws IOException, XMPPException     \n        {         \n            String[] mechanisms = { \"DIGEST-MD5\" };         \n            Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();         \n            this.sc = Sasl.createSaslClient(mechanisms, null, \"xmpp\", host, props,cbh);         \n            authenticate();\n        }      @Override     protected String getName()\n\n        {        \n            return NAME;     \n        }      \n        @Override     \n        public void challengeReceived(String challenge) throws IOException     \n        {         \n            byte[] response = null;          \n            if (challenge != null)         \n            {             \n                String decodedChallenge = new String(Base64.decode(challenge));             \n                Map&lt;String, String&gt; parameters = getQueryMap(decodedChallenge);              \n                String version = \"1.0\";             \n                String nonce = parameters.get(\"nonce\");             \n                String method = parameters.get(\"method\");              \n                long callId = new GregorianCalendar().getTimeInMillis();              \n                String sig = \"api_key=\" + apiKey + \"call_id=\" + callId + \"method=\" + method + \"nonce=\" + nonce + \"session_key=\" + sessionKey + \"v=\" + version + applicationSecret;\n                try             \n                {                 \n                    sig = md5(sig);             \n                } \n                catch (NoSuchAlgorithmException e)             \n                {                 \n                    throw new IllegalStateException(e);             \n                }              \n                String composedResponse = \"api_key=\" + URLEncoder.encode(apiKey, \"utf-8\") + \"&amp;call_id=\" + callId + \"&amp;method=\"+ URLEncoder.encode(method, \"utf-8\") + \"&amp;nonce=\"+ URLEncoder.encode(nonce, \"utf-8\")+ \"&amp;session_key=\"+ URLEncoder.encode(sessionKey, \"utf-8\") + \"&amp;v=\"+ URLEncoder.encode(version, \"utf-8\") + \"&amp;sig=\"+ URLEncoder.encode(sig, \"utf-8\");response = composedResponse.getBytes(\"utf-8\");\n                }          \n                String authenticationText = \"\";          \n                if (response != null)         \n                {             \n                    authenticationText = Base64.encodeBytes(response, Base64.DONT_BREAK_LINES);         \n                }          \n\n                // Send the authentication to the server         \n                getSASLAuthentication().send(new Response(authenticationText));     \n                }      \n        private Map&lt;String, String&gt; getQueryMap(String query)     \n        {         \n            Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();         \n            String[] params = query.split(\"\\\\&amp;\");          \n            for (String param : params)         \n            {             \n                String[] fields = param.split(\"=\", 2);             \n                map.put(fields[0], (fields.length &gt; 1 ? fields[1] : null));         \n            }          \n            return map;     \n            }      \n        private String md5(String text) throws NoSuchAlgorithmException,UnsupportedEncodingException     \n        {         \n            MessageDigest md = MessageDigest.getInstance(\"MD5\");         \n            md.update(text.getBytes(\"utf-8\"), 0, text.length());         \n            return convertToHex(md.digest());     \n        }      \n        private String convertToHex(byte[] data)     \n        {         \n            StringBuilder buf = new StringBuilder();         \n            int len = data.length;          \n            for (int i = 0; i &lt; len; i++)         \n            {             \n                int halfByte = (data[i] &gt;&gt;&gt; 4) &amp; 0xF;             \n                int twoHalfs = 0;              \n                do             \n                {                 \n                    if (0 &lt;= halfByte &amp;&amp; halfByte &lt;= 9)                 \n                    {                     \n                        buf.append((char) ('0' + halfByte));                 \n                    }                 \n                    else                 \n                    {                     \n                        buf.append((char) ('a' + halfByte - 10));                 \n                    }                 \n                    halfByte = data[i] &amp; 0xF;             \n                } \n                while (twoHalfs++ &lt; 1);         \n            }          \n            return buf.toString();     \n            } \n        }\n", "package com.avilyne.android;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.ArrayList;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpVersion;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.ConnectTimeoutException;\nimport org.apache.http.conn.params.ConnManagerPNames;\nimport org.apache.http.conn.params.ConnPerRouteBean;\nimport org.apache.http.conn.scheme.LayeredSocketFactory;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.SingleClientConnManager;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.apache.http.params.BasicHttpParams;\nimport org.apache.http.params.HttpConnectionParams;\nimport org.apache.http.params.HttpParams;\nimport org.apache.http.params.HttpProtocolParams;\nimport org.json.JSONObject;\n\nimport android.app.Activity;\nimport android.app.ProgressDialog;\nimport android.content.Context;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.View;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\npublic class MainActivity extends Activity {\n\n    private static final String SERVICE_URL =\n    \"https://192.168.2.101:8443/RestWebServiceDemo/rest/person\";\n\n    private static final String TAG = \"AndroidRESTClientActivity\";\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    public void retrieveSampleData(View vw) {\n\n        String sampleURL = SERVICE_URL + \"/sample\";\n\n        WebServiceTask wst = new WebServiceTask(WebServiceTask.GET_TASK, this,\n                \"GETting data...\");\n\n        wst.execute(new String[] { sampleURL });\n\n    }\n\n    public void clearControls(View vw) {\n\n        EditText edFirstName = (EditText) findViewById(R.id.first_name);\n        EditText edLastName = (EditText) findViewById(R.id.last_name);\n        EditText edEmail = (EditText) findViewById(R.id.email);\n\n        edFirstName.setText(\"\");\n        edLastName.setText(\"\");\n        edEmail.setText(\"\");\n\n    }\n\n    public void postData(View vw) {\n\n        EditText edFirstName = (EditText) findViewById(R.id.first_name);\n        EditText edLastName = (EditText) findViewById(R.id.last_name);\n        EditText edEmail = (EditText) findViewById(R.id.email);\n\n        String firstName = edFirstName.getText().toString();\n        String lastName = edLastName.getText().toString();\n        String email = edEmail.getText().toString();\n\n        if (firstName.equals(\"\") || lastName.equals(\"\") || email.equals(\"\")) {\n            Toast.makeText(this, \"Please enter in all required fields.\",\n                    Toast.LENGTH_LONG).show();\n            return;\n        }\n\n        WebServiceTask wst = new WebServiceTask(WebServiceTask.POST_TASK, this,\n                \"Posting data...\");\n\n        wst.addNameValuePair(\"firstName\", firstName);\n        wst.addNameValuePair(\"lastName\", lastName);\n        wst.addNameValuePair(\"email\", email);\n\n        // the passed String is the URL we will POST to\n        wst.execute(new String[] { SERVICE_URL });\n\n    }\n\n    public void handleResponse(String response) {\n\n        EditText edFirstName = (EditText) findViewById(R.id.first_name);\n        EditText edLastName = (EditText) findViewById(R.id.last_name);\n        EditText edEmail = (EditText) findViewById(R.id.email);\n\n        edFirstName.setText(\"\");\n        edLastName.setText(\"\");\n        edEmail.setText(\"\");\n\n        try {\n\n            JSONObject jso = new JSONObject(response);\n\n            String firstName = jso.getString(\"firstName\");\n            String lastName = jso.getString(\"lastName\");\n            String email = jso.getString(\"email\");\n\n            edFirstName.setText(firstName);\n            edLastName.setText(lastName);\n            edEmail.setText(email);\n\n        } catch (Exception e) {\n            Log.e(TAG, e.getLocalizedMessage(), e);\n        }\n\n    }\n\n    private void hideKeyboard() {\n\n        InputMethodManager inputManager = (InputMethodManager) MainActivity.this\n                .getSystemService(Context.INPUT_METHOD_SERVICE);\n\n        inputManager.hideSoftInputFromWindow(MainActivity.this\n                .getCurrentFocus().getWindowToken(),\n                InputMethodManager.HIDE_NOT_ALWAYS);\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.activity_main, menu);\n        return true;\n    }\n\n    private class WebServiceTask extends AsyncTask&lt;String, Integer, String&gt; {\n\n        public static final int POST_TASK = 1;\n        public static final int GET_TASK = 2;\n\n        private static final String TAG = \"WebServiceTask\";\n\n        // connection timeout, in milliseconds (waiting to connect)\n        // private static final int CONN_TIMEOUT = 3000;\n\n        // socket timeout, in milliseconds (waiting for data)\n        // private static final int SOCKET_TIMEOUT = 5000;\n\n        private int taskType = GET_TASK;\n        private Context mContext = null;\n        private String processMessage = \"Processing...\";\n\n        private ArrayList&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();\n\n        private ProgressDialog pDlg = null;\n\n        public WebServiceTask(int taskType, Context mContext,\n                String processMessage) {\n\n            this.taskType = taskType;\n            this.mContext = mContext;\n            this.processMessage = processMessage;\n        }\n\n        public void addNameValuePair(String name, String value) {\n\n            params.add(new BasicNameValuePair(name, value));\n        }\n\n        private void showProgressDialog() {\n\n            pDlg = new ProgressDialog(mContext);\n            pDlg.setMessage(processMessage);\n            pDlg.setProgressDrawable(mContext.getWallpaper());\n            pDlg.setProgressStyle(ProgressDialog.STYLE_SPINNER);\n            pDlg.setCancelable(false);\n            pDlg.show();\n\n        }\n\n        @Override\n        protected void onPreExecute() {\n\n            hideKeyboard();\n            showProgressDialog();\n\n        }\n\n        protected String doInBackground(String... urls) {\n\n            String url = urls[0];\n            String result = \"\";\n\n            HttpResponse response = doResponse(url);\n\n            if (response == null) {\n                return result;\n            } else {\n\n                try {\n\n                    result = inputStreamToString(response.getEntity()\n                            .getContent());\n\n                } catch (IllegalStateException e) {\n                    Log.e(TAG, e.getLocalizedMessage(), e);\n\n                } catch (IOException e) {\n                    Log.e(TAG, e.getLocalizedMessage(), e);\n                }\n\n            }\n\n            return result;\n        }\n\n        @Override\n        protected void onPostExecute(String response) {\n\n            handleResponse(response);\n            pDlg.dismiss();\n\n        }\n\n        // Establish connection and socket (data retrieval) timeouts\n        /*\n         * private HttpParams getHttpParams() {\n         * \n         * HttpParams htpp = new BasicHttpParams();\n         * \n         * HttpConnectionParams.setConnectionTimeout(htpp, CONN_TIMEOUT);\n         * HttpConnectionParams.setSoTimeout(htpp, SOCKET_TIMEOUT);\n         * \n         * return htpp; }\n         */\n\n        private HttpResponse doResponse(String url) {\n\n            // Use our connection and data timeouts as parameters for our\n            // DefaultHttpClient\n            // HttpClient httpclient = new DefaultHttpClient(getHttpParams());\n\n            DefaultHttpClient httpsclient = httpsClient();\n\n            HttpResponse response = null;\n\n            try {\n                switch (taskType) {\n\n                case POST_TASK:\n                    HttpPost httppost = new HttpPost(url);\n                    // Add parameters\n                    httppost.setEntity(new UrlEncodedFormEntity(params));\n\n                    response = httpsclient.execute(httppost); // httpclient.execute(httppost);\n                    break;\n                case GET_TASK:\n                    HttpGet httpget = new HttpGet(url);\n                    response = httpsclient.execute(httpget); // httpclient.execute(httpget);\n                    break;\n                }\n            } catch (Exception e) {\n\n                Log.e(TAG, e.getLocalizedMessage(), e);\n\n            }\n\n            return response;\n        }\n\n        private String inputStreamToString(InputStream is) {\n\n            String line = \"\";\n            StringBuilder total = new StringBuilder();\n\n            // Wrap a BufferedReader around the InputStream\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n\n            try {\n                // Read response until the end\n                while ((line = rd.readLine()) != null) {\n                    total.append(line);\n                }\n            } catch (IOException e) {\n                Log.e(TAG, e.getLocalizedMessage(), e);\n            }\n\n            // Return full string\n            return total.toString();\n        }\n\n    }\n\n    private DefaultHttpClient httpsClient() {\n        SchemeRegistry schemeRegistry = new SchemeRegistry();\n        schemeRegistry.register(new Scheme(\"http\", PlainSocketFactory\n                .getSocketFactory(), 80));\n        schemeRegistry.register(new Scheme(\"https\", new EasySSLSocketFactory(),\n                443));\n\n        HttpParams httpParams = new BasicHttpParams();\n        httpParams.setParameter(ConnManagerPNames.MAX_TOTAL_CONNECTIONS, 30);\n        httpParams.setParameter(ConnManagerPNames.MAX_CONNECTIONS_PER_ROUTE,\n                new ConnPerRouteBean(30));\n        httpParams.setParameter(HttpProtocolParams.USE_EXPECT_CONTINUE, false);\n        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);\n\n        ClientConnectionManager cm = new SingleClientConnManager(httpParams,\n                schemeRegistry);\n        return new DefaultHttpClient(cm, httpParams);\n    }\n\n    private class EasySSLSocketFactory implements LayeredSocketFactory {\n        private SSLContext sslcontext = null;\n\n        private SSLContext createEasySSLContext() throws IOException {\n            try {\n                SSLContext context = SSLContext.getInstance(\"TLS\");\n                context.init(null,\n                        new TrustManager[] { new EasyX509TrustManager(null) },\n                        null);\n                return context;\n            } catch (Exception e) {\n                throw new IOException(e.getMessage());\n            }\n        }\n\n        private SSLContext getSSLContext() throws IOException {\n            if (this.sslcontext == null) {\n                this.sslcontext = createEasySSLContext();\n            }\n            return this.sslcontext;\n        }\n\n        /**\n         * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket,\n         *      java.lang.String, int, java.net.InetAddress, int,\n         *      org.apache.http.params.HttpParams)\n         */\n        public Socket connectSocket(Socket sock, String host, int port,\n                InetAddress localAddress, int localPort, HttpParams params)\n                throws IOException, UnknownHostException,\n                ConnectTimeoutException {\n            int connTimeout = HttpConnectionParams.getConnectionTimeout(params);\n            int soTimeout = HttpConnectionParams.getSoTimeout(params);\n\n            InetSocketAddress remoteAddress = new InetSocketAddress(host, port);\n            SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock\n                    : createSocket());\n\n            if ((localAddress != null) || (localPort &gt; 0)) {\n                // we need to bind explicitly\n                if (localPort &lt; 0) {\n                    localPort = 0; // indicates \"any\"\n                }\n                InetSocketAddress isa = new InetSocketAddress(localAddress,\n                        localPort);\n                sslsock.bind(isa);\n            }\n\n            sslsock.connect(remoteAddress, connTimeout);\n            sslsock.setSoTimeout(soTimeout);\n            return sslsock;\n\n        }\n\n        /**\n         * @see org.apache.http.conn.scheme.SocketFactory#createSocket()\n         */\n        public Socket createSocket() throws IOException {\n            return getSSLContext().getSocketFactory().createSocket();\n        }\n\n        /**\n         * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)\n         */\n        public boolean isSecure(Socket socket) throws IllegalArgumentException {\n            return true;\n        }\n\n        /**\n         * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket,\n         *      java.lang.String, int, boolean)\n         */\n        public Socket createSocket(Socket socket, String host, int port,\n                boolean autoClose) throws IOException, UnknownHostException {\n            // return getSSLContext().getSocketFactory().createSocket(socket,\n            // host, port, autoClose);\n            return getSSLContext().getSocketFactory().createSocket(socket,\n                    host, port, autoClose);\n        }\n\n        // -------------------------------------------------------------------\n        // javadoc in org.apache.http.conn.scheme.SocketFactory says :\n        // Both Object.equals() and Object.hashCode() must be overridden\n        // for the correct operation of some connection managers\n        // -------------------------------------------------------------------\n\n        public boolean equals(Object obj) {\n            return ((obj != null) &amp;&amp; obj.getClass().equals(\n                    EasySSLSocketFactory.class));\n        }\n\n        public int hashCode() {\n            return EasySSLSocketFactory.class.hashCode();\n        }\n\n    }\n\n    private class EasyX509TrustManager implements X509TrustManager {\n        private X509TrustManager standardTrustManager = null;\n\n        /**\n         * Constructor for EasyX509TrustManager.\n         */\n        public EasyX509TrustManager(KeyStore keystore)\n                throws NoSuchAlgorithmException, KeyStoreException {\n            super();\n            TrustManagerFactory factory = TrustManagerFactory\n                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            factory.init(keystore);\n            TrustManager[] trustmanagers = factory.getTrustManagers();\n            if (trustmanagers.length == 0) {\n                throw new NoSuchAlgorithmException(\"no trust manager found\");\n            }\n            this.standardTrustManager = (X509TrustManager) trustmanagers[0];\n        }\n\n        /**\n         * @see \n         *      javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate\n         *      [],String authType)\n         */\n        public void checkClientTrusted(X509Certificate[] certificates,\n                String authType) throws CertificateException {\n            standardTrustManager.checkClientTrusted(certificates, authType);\n        }\n\n        /**\n         * @see \n         *      javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate\n         *      [],String authType)\n         */\n        public void checkServerTrusted(X509Certificate[] certificates,\n                String authType) throws CertificateException {\n            if ((certificates != null) &amp;&amp; (certificates.length == 1)) {\n                certificates[0].checkValidity();\n            } else {\n                standardTrustManager.checkServerTrusted(certificates, authType);\n            }\n        }\n\n        /**\n         * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()\n         */\n        public X509Certificate[] getAcceptedIssuers() {\n            return this.standardTrustManager.getAcceptedIssuers();\n        }\n\n    }\n}\n", "package com.example.android.streaming.streaming.rtsp;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Locale;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport android.util.Base64;\nimport android.util.Log;\n\nimport com.example.android.streaming.StreamingApp;\nimport com.example.android.streaming.streaming.Session;\nimport com.example.android.streaming.BuildConfig;\n\npublic class RtspSocket extends Socket {\n    public static final int RTSP_HEADER_LENGTH = 4;\n    public static final int RTP_HEADER_LENGTH = 12;\n    public static final int MTU = 1400;\n\n    public static final int PAYLOAD_OFFSET = RTSP_HEADER_LENGTH + RTP_HEADER_LENGTH;\n    public static final int RTP_OFFSET = RTSP_HEADER_LENGTH;\n\n    private ConcurrentHashMap&lt;String, String&gt; headerMap = new ConcurrentHashMap&lt;String, String&gt;();\n\n    static private final String kCRLF = \"\\r\\n\";\n\n    // RTSP request format strings\n    static private final String kOptions = \"OPTIONS %s RTSP/1.0\\r\\n\";\n    static private final String kDescribe = \"DESCRIBE %s RTSP/1.0\\r\\n\";\n    static private final String kAnnounce = \"ANNOUNCE %s RTSP/1.0\\r\\n\";\n    static private final String kSetupPublish = \"SETUP %s/trackid=%d RTSP/1.0\\r\\n\";\n    @SuppressWarnings(\"unused\")\n    static private final String kSetupPlay = \"SETUP %s/trackid=%d RTSP/1.0\\r\\n\";\n    static private final String kRecord = \"RECORD %s RTSP/1.0\\r\\n\";\n    static private final String kPlay = \"PLAY %s RTSP/1.0\\r\\n\";\n    static private final String kTeardown = \"TEARDOWN %s RTSP/1.0\\r\\n\";\n\n    // RTSP header format strings\n    static private final String kCseq = \"Cseq: %d\\r\\n\";\n    static private final String kContentLength = \"Content-Length: %d\\r\\n\";\n    static private final String kContentType = \"Content-Type: %s\\r\\n\";\n    static private final String kTransport = \"Transport: RTP/AVP/%s;unicast;mode=%s;%s\\r\\n\";\n    static private final String kSession = \"Session: %s\\r\\n\";\n    static private final String kRange = \"range: %s\\r\\n\";\n    static private final String kAccept = \"Accept: %s\\r\\n\";\n    static private final String kAuthBasic = \"Authorization: Basic %s\\r\\n\";\n    static private final String kAuthDigest = \"Authorization: Digest username=\\\"%s\\\",realm=\\\"%s\\\",nonce=\\\"%s\\\",uri=\\\"%s\\\",response=\\\"%s\\\"\\r\\n\";\n\n    // RTSP header keys\n    static private final String kSessionKey = \"Session\";\n    static private final String kWWWAuthKey = \"WWW-Authenticate\";\n\n    byte header[] = new byte[RTSP_MAX_HEADER + 1];\n    static private final int RTSP_MAX_HEADER = 4095;\n    static private final int RTSP_MAX_BODY = 4095;\n\n    static private final int RTSP_RESP_ERR = -6;\n    // static private final int RTSP_RESP_ERR_SESSION = -7;\n    static public final int RTSP_OK = 200;\n    static private final int RTSP_BAD_USER_PASS = 401;\n\n    static private final int SOCK_ERR_READ = -5;\n\n    /* Number of channels including control ones. */\n    private int channelCount = 0;\n\n    /* RTSP negotiation cmd seq counter */\n    private int seq = 0;\n\n    private String authentication = null;\n    private String session = null;\n\n    private String path = null;\n    private String url = null;\n    private String user = null;\n    private String pass = null;\n    private String sdp = null;\n\n    private byte[] buffer = new byte[MTU];\n\n    public RtspSocket() {\n        super();\n        try {\n            setTcpNoDelay(true);\n            setSoTimeout(60000);\n        } catch (SocketException e) {\n            Log.e(StreamingApp.TAG, \"Failed to set socket params.\");\n        }\n        buffer[RTSP_HEADER_LENGTH] = (byte) Integer.parseInt(\"10000000\", 2);\n    }\n\n    public byte[] getBuffer() {\n        return buffer;\n    }\n\n    public static final void setLong(byte[] buffer, long n, int begin, int end) {\n        for (end--; end &gt;= begin; end--) {\n            buffer[end] = (byte) (n % 256);\n            n &gt;&gt;= 8;\n        }\n    }\n\n    public void setSequence(int seq) {\n        setLong(buffer, seq, RTP_OFFSET + 2, RTP_OFFSET + 4);\n    }\n\n    public void setSSRC(int ssrc) {\n        setLong(buffer, ssrc, RTP_OFFSET + 8, RTP_OFFSET + 12);\n    }\n\n    public void setPayload(int payload) {\n        buffer[RTP_OFFSET + 1] = (byte) (payload &amp; 0x7f);\n    }\n\n    public void setRtpTimestamp(long timestamp) {\n        setLong(buffer, timestamp, RTP_OFFSET + 4, RTP_OFFSET + 8);\n    }\n\n    /** Sends the RTP packet over the network */\n    private void send(int length, int stream) throws IOException {\n        buffer[0] = '$';\n        buffer[1] = (byte) stream;\n        setLong(buffer, length, 2, 4);\n        OutputStream s = getOutputStream();\n        s.write(buffer, 0, length + RTSP_HEADER_LENGTH);\n        s.flush();\n    }\n\n    public void sendReport(int length, int ssrc, int stream) throws IOException {\n        setPayload(200);\n        setLong(buffer, ssrc, RTP_OFFSET + 4, RTP_OFFSET + 8);\n        send(length + RTP_HEADER_LENGTH, stream);\n    }\n\n    public void sendData(int length, int ssrc, int seq, int payload, int stream, boolean last) throws IOException {\n        setSSRC(ssrc);\n        setSequence(seq);\n        setPayload(payload);\n        buffer[RTP_OFFSET + 1] |= (((last ? 1 : 0) &amp; 0x01) &lt;&lt; 7);\n        send(length + RTP_HEADER_LENGTH, stream);\n    }\n\n    public int getChannelCount() {\n        return channelCount;\n    }\n\n    private void write(String request) throws IOException {\n        try {\n            String asci = new String(request.getBytes(), \"US-ASCII\");\n            OutputStream out = getOutputStream();\n            out.write(asci.getBytes());\n        } catch (IOException e) {\n            throw new IOException(\"Error writing to socket.\");\n        }\n    }\n\n    private String read() throws IOException {\n        String response = null;\n        try {\n            InputStream in = getInputStream();\n            int i = 0, len = 0, crlf_count = 0;\n            boolean parsedHeader = false;\n\n            for (; i &lt; RTSP_MAX_BODY &amp;&amp; !parsedHeader &amp;&amp; len &gt; -1; i++) {\n                len = in.read(header, i, 1);\n                if (header[i] == '\\r' || header[i] == '\\n') {\n                    crlf_count++;\n                    if (crlf_count == 4)\n                        parsedHeader = true;\n                } else {\n                    crlf_count = 0;\n                }\n            }\n            if (len != -1) {\n                len = i;\n                header[len] = '\\0';\n                response = new String(header, 0, len, \"US-ASCII\");\n            }\n        } catch (IOException e) {\n            throw new IOException(\"Connection timed out. Check your network settings.\");\n        }\n        return response;\n    }\n\n    private int parseResponse(String response) {\n        String[] lines = response.split(kCRLF);\n        String[] items = response.split(\" \");\n        String tempString, key, value;\n\n        headerMap.clear();\n        if (items.length &lt; 2)\n            return RTSP_RESP_ERR;\n        int responseCode = RTSP_RESP_ERR;\n        try {\n            responseCode = Integer.parseInt(items[1]);\n        } catch (Exception e) {\n            Log.w(StreamingApp.TAG, e.getMessage());\n            Log.w(StreamingApp.TAG, response);\n        }\n        if (responseCode == RTSP_RESP_ERR)\n            return responseCode;\n\n        // Parse response header into key value pairs.\n        for (int i = 1; i &lt; lines.length; i++) {\n            tempString = lines[i];\n\n            if (tempString.length() == 0)\n                break;\n\n            int idx = tempString.indexOf(\":\");\n\n            if (idx == -1)\n                continue;\n\n            key = tempString.substring(0, idx);\n            value = tempString.substring(idx + 1);\n            headerMap.put(key, value);\n        }\n\n        tempString = headerMap.get(kSessionKey);\n        if (tempString != null) {\n            // Parse session\n            items = tempString.split(\";\");\n            tempString = items[0];\n            session = tempString.trim();\n        }\n\n        return responseCode;\n    }\n\n    private void generateBasicAuth() throws UnsupportedEncodingException {\n        String userpass = String.format(\"%s:%s\", user, pass);\n        authentication = String.format(kAuthBasic, Base64.encodeToString(userpass.getBytes(\"US-ASCII\"), Base64.DEFAULT));\n    }\n\n    public static String md5(String s) {\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(s.getBytes(), 0, s.length());\n            String hash = new BigInteger(1, digest.digest()).toString(16);\n            return hash;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n\n    static private final int CC_MD5_DIGEST_LENGTH = 16;\n\n    private String md5HexDigest(String input) {\n        byte digest[] = md5(input).getBytes();\n        String result = new String();\n        for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++)\n            result = result.concat(String.format(\"%02x\", digest[i]));\n        return result;\n    }\n\n    private void generateDigestAuth(String method) {\n        String nonce, realm;\n        String ha1, ha2, response;\n\n        // WWW-Authenticate: Digest realm=\"Streaming Server\",\n        // nonce=\"206351b944cb28fe37a0794848c2e36f\"\n        String wwwauth = headerMap.get(kWWWAuthKey);\n        int idx = wwwauth.indexOf(\"Digest\");\n        String authReq = wwwauth.substring(idx + \"Digest\".length() + 1);\n\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, String.format(\"Auth Req: %s\", authReq));\n\n        String[] split = authReq.split(\",\");\n        realm = split[0];\n        nonce = split[1];\n\n        split = realm.split(\"=\");\n        realm = split[1];\n        realm = realm.substring(1, 1 + realm.length() - 2);\n\n        split = nonce.split(\"=\");\n        nonce = split[1];\n        nonce = nonce.substring(1, 1 + nonce.length() - 2);\n\n        if (BuildConfig.DEBUG) {\n            Log.d(StreamingApp.TAG, String.format(\"realm=%s\", realm));\n            Log.d(StreamingApp.TAG, String.format(\"nonce=%s\", nonce));\n        }\n\n        ha1 = md5HexDigest(String.format(\"%s:%s:%s\", user, realm, pass));\n        ha2 = md5HexDigest(String.format(\"%s:%s\", method, url));\n        response = md5HexDigest(String.format(\"%s:%s:%s\", ha1, nonce, ha2));\n        authentication = md5HexDigest(String.format(kAuthDigest, user, realm, nonce, url, response));\n    }\n\n    private int options() throws IOException {\n        seq++;\n        StringBuilder request = new StringBuilder();\n        request.append(String.format(kOptions, url));\n        request.append(String.format(kCseq, seq));\n        request.append(kCRLF);\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- OPTIONS Request ---\\n\\n\" + request);\n        write(request.toString());\n        String response = read();\n        if (response == null)\n            return SOCK_ERR_READ;\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- OPTIONS Response ---\\n\\n\" + response);\n        return parseResponse(response);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private int describe() throws IOException {\n        seq++;\n        StringBuilder request = new StringBuilder();\n        request.append(String.format(kDescribe, url));\n        request.append(String.format(kAccept, \"application/sdp\"));\n        request.append(String.format(kCseq, seq));\n        request.append(kCRLF);\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- DESCRIBE Request ---\\n\\n\" + request);\n        write(request.toString());\n        String response = read();\n        if (response == null)\n            return SOCK_ERR_READ;\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- DESCRIBE Response ---\\n\\n\" + response);\n        return parseResponse(response);\n    }\n\n    private int recurseDepth = 0;\n\n    private int announce() throws IOException {\n        seq++;\n        recurseDepth = 0;\n        StringBuilder request = new StringBuilder();\n        request.append(String.format(kAnnounce, url));\n        request.append(String.format(kCseq, seq));\n        request.append(String.format(kContentLength, sdp.length()));\n        request.append(String.format(kContentType, \"application/sdp\"));\n        request.append(kCRLF);\n        if (sdp.length() &gt; 0)\n            request.append(sdp);\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- ANNOUNCE Request ---\\n\\n\" + request);\n        write(request.toString());\n        String response = read();\n        if (response == null)\n            return SOCK_ERR_READ;\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- ANNOUNCE Response ---\\n\\n\" + response);\n\n        int ret = parseResponse(response);\n        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {\n            String wwwauth = headerMap.get(kWWWAuthKey);\n            if (wwwauth != null) {\n                if (BuildConfig.DEBUG)\n                    Log.d(StreamingApp.TAG, String.format(\"WWW Auth Value: %s\", wwwauth));\n                int idx = wwwauth.indexOf(\"Basic\");\n                recurseDepth++;\n\n                if (idx != -1) {\n                    generateBasicAuth();\n                } else {\n                    // We are assuming Digest here.\n                    generateDigestAuth(\"ANNOUNCE\");\n                }\n\n                ret = announce();\n                recurseDepth--;\n            }\n        }\n        return ret;\n    }\n\n    private int setup(int trackId) throws IOException {\n        seq++;\n        recurseDepth = 0;\n        StringBuilder request = new StringBuilder();\n        request.append(String.format(kSetupPublish, url, trackId));\n        request.append(String.format(kCseq, seq));\n\n        /* One channel for rtp (data) and one for rtcp (control) */\n        String tempString = String.format(Locale.getDefault(), \"interleaved=%d-%d\", channelCount++, channelCount++);\n\n        request.append(String.format(kTransport, \"TCP\", \"record\", tempString));\n        request.append(kCRLF);\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- SETUP Request ---\\n\\n\" + request);\n        write(request.toString());\n        String response = read();\n        if (response == null)\n            return SOCK_ERR_READ;\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- SETUP Response ---\\n\\n\" + response);\n\n        int ret = parseResponse(response);\n        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {\n            String wwwauth = headerMap.get(kWWWAuthKey);\n            if (wwwauth != null) {\n                if (BuildConfig.DEBUG)\n                    Log.d(StreamingApp.TAG, String.format(\"WWW Auth Value: %s\", wwwauth));\n                int idx = wwwauth.indexOf(\"Basic\");\n                recurseDepth++;\n\n                if (idx != -1) {\n                    generateBasicAuth();\n                } else {\n                    // We are assuming Digest here.\n                    generateDigestAuth(\"SETUP\");\n                }\n\n                ret = setup(trackId);\n                authentication = null;\n                recurseDepth--;\n            }\n        }\n        return ret;\n    }\n\n    private int record() throws IOException {\n        seq++;\n        recurseDepth = 0;\n        StringBuilder request = new StringBuilder();\n        request.append(String.format(kRecord, url));\n        request.append(String.format(kCseq, seq));\n        request.append(String.format(kRange, \"npt=0.000-\"));\n        if (authentication != null)\n            request.append(authentication);\n        if (session != null)\n            request.append(String.format(kSession, session));\n        request.append(kCRLF);\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- RECORD Request ---\\n\\n\" + request);\n        write(request.toString());\n        String response = read();\n        if (response == null)\n            return SOCK_ERR_READ;\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- RECORD Response ---\\n\\n\" + response);\n        int ret = parseResponse(response);\n        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {\n            String wwwauth = headerMap.get(kWWWAuthKey);\n            if (wwwauth != null) {\n                if (BuildConfig.DEBUG)\n                    Log.d(StreamingApp.TAG, String.format(\"WWW Auth Value: %s\", wwwauth));\n                int idx = wwwauth.indexOf(\"Basic\");\n                recurseDepth++;\n\n                if (idx != -1) {\n                    generateBasicAuth();\n                } else {\n                    // We are assuming Digest here.\n                    generateDigestAuth(\"RECORD\");\n                }\n\n                ret = record();\n                authentication = null;\n                recurseDepth--;\n            }\n        }\n        return ret;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private int play() throws IOException {\n        seq++;\n        recurseDepth = 0;\n        StringBuilder request = new StringBuilder();\n        request.append(String.format(kPlay, url));\n        request.append(String.format(kCseq, seq));\n        request.append(String.format(kRange, \"npt=0.000-\"));\n        if (authentication != null)\n            request.append(authentication);\n        if (session != null)\n            request.append(String.format(kSession, session));\n        request.append(kCRLF);\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- PLAY Request ---\\n\\n\" + request);\n        write(request.toString());\n        String response = read();\n        if (response == null)\n            return SOCK_ERR_READ;\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- PLAY Response ---\\n\\n\" + response);\n        int ret = parseResponse(response);\n        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {\n            String wwwauth = headerMap.get(kWWWAuthKey);\n            if (wwwauth != null) {\n                if (BuildConfig.DEBUG)\n                    Log.d(StreamingApp.TAG, String.format(\"WWW Auth Value: %s\", wwwauth));\n                int idx = wwwauth.indexOf(\"Basic\");\n                recurseDepth++;\n\n                if (idx != -1) {\n                    generateBasicAuth();\n                } else {\n                    // We are assuming Digest here.\n                    generateDigestAuth(\"PLAY\");\n                }\n\n                ret = record();\n                authentication = null;\n                recurseDepth--;\n            }\n        }\n        return ret;\n    }\n\n    private int teardown() throws IOException {\n        seq++;\n        recurseDepth = 0;\n        StringBuilder request = new StringBuilder();\n        request.append(String.format(kTeardown, url));\n        request.append(String.format(kCseq, seq));\n        if (authentication != null)\n            request.append(authentication);\n        if (session != null)\n            request.append(String.format(kSession, session));\n        request.append(kCRLF);\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- TEARDOWN Request ---\\n\\n\" + request);\n        write(request.toString());\n        String response = read();\n        if (response == null)\n            return SOCK_ERR_READ;\n        if (BuildConfig.DEBUG)\n            Log.d(StreamingApp.TAG, \"--- TEARDOWN Response ---\\n\\n\" + response);\n        int ret = parseResponse(response);\n        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {\n            String wwwauth = headerMap.get(kWWWAuthKey);\n            if (wwwauth != null) {\n                if (BuildConfig.DEBUG)\n                    Log.d(StreamingApp.TAG, String.format(\"WWW Auth Value: %s\", wwwauth));\n                int idx = wwwauth.indexOf(\"Basic\");\n                recurseDepth++;\n\n                if (idx != -1) {\n                    generateBasicAuth();\n                } else {\n                    // We are assuming Digest here.\n                    generateDigestAuth(\"TEARDOWN\");\n                }\n\n                ret = record();\n                authentication = null;\n                recurseDepth--;\n            }\n        }\n        return ret;\n    }\n\n    public void connect(String dest, int port, Session session) throws IOException {\n        int trackId = 1;\n        int responseCode;\n\n        if (isConnected())\n            return;\n\n        if (!session.hasAudioTrack() &amp;&amp; !session.hasVideoTrack())\n            throw new IOException(\"No tracks found in session.\");\n\n        InetSocketAddress addr = null;\n        try {\n            addr = new InetSocketAddress(dest, port);\n        } catch (Exception e) {\n            throw new IOException(\"Failed to resolve rtsp server address.\");\n        }\n\n        this.sdp = session.getSDP();\n        this.user = session.getUser();\n        this.pass = session.getPass();\n        this.path = session.getPath();\n        this.url = String.format(\"rtsp://%s:%d%s\", dest, addr.getPort(), this.path);\n\n        try {\n            super.connect(addr);\n        } catch (IOException e) {\n            throw new IOException(\"Failed to connect rtsp server.\");\n        }\n\n        responseCode = announce();\n        if (responseCode != RTSP_OK) {\n            close();\n            throw new IOException(\"RTSP announce failed: \" + responseCode);\n        }\n\n        responseCode = options();\n        if (responseCode != RTSP_OK) {\n            close();\n            throw new IOException(\"RTSP options failed: \" + responseCode);\n        }\n\n        /* Setup audio */\n        if (session.hasAudioTrack()) {\n            session.getAudioTrack().setStreamId(channelCount);\n            responseCode = setup(trackId++);\n            if (responseCode != RTSP_OK) {\n                close();\n                throw new IOException(\"RTSP video failed: \" + responseCode);\n            }\n        }\n\n        /* Setup video */\n        if (session.hasVideoTrack()) {\n            session.getVideoTrack().setStreamId(channelCount);\n            responseCode = setup(trackId++);\n            if (responseCode != RTSP_OK) {\n                close();\n                throw new IOException(\"RTSP audio setup failed: \" + responseCode);\n            }\n        }\n\n        responseCode = record();\n        if (responseCode != RTSP_OK) {\n            close();\n            throw new IOException(\"RTSP record failed: \" + responseCode);\n        }\n    }\n\n    public void close() throws IOException {\n        if (!isConnected())\n            return;\n        teardown();\n        super.close();\n    }\n}\n", "public class PayUMoneyActivity extends AppCompatActivity {\n\n    /**\n     * Adding WebView as setContentView\n     */\n    WebView webView;\n\n    /**\n     * Context for Activity\n     */\n    Context activity;\n    /**\n     * Order Id\n     * To Request for Updating Payment Status if Payment Successfully Done\n     */\n    int mId; //Getting from Previous Activity\n    /**\n     * Required Fields\n     */\n    // Test Variables\n    /*\n    private String mMerchantKey = \"FCyqqZ\";\n    private String mSalt = \"sfBpGA8E\";\n    private String mBaseURL = \"https://test.payu.in\";\n    */\n\n    // Final Variables\n    private String mMerchantKey = \"Your Merchant Key\";\n    private String mSalt = \"Salt\";\n    private String mBaseURL = \"https://secure.payu.in\";\n\n\n    private String mAction = \"\"; // For Final URL\n    private String mTXNId; // This will create below randomly\n    private String mHash; // This will create below randomly\n    private String mProductInfo = \"Food Items\"; //Passing String only\n    private String mFirstName; // From Previous Activity\n    private String mEmailId; // From Previous Activity\n    private double mAmount; // From Previous Activity\n    private String mPhone; // From Previous Activity\n    private String mServiceProvider = \"payu_paisa\";\n    private String mSuccessUrl = \"your success URL\";\n    private String mFailedUrl = \"Your Failure URL\";\n\n\n    boolean isFromOrder;\n    /**\n     * Handler\n     */\n    Handler mHandler = new Handler();\n\n    /**\n     * @param savedInstanceState\n     */\n    @SuppressLint({\"AddJavascriptInterface\", \"SetJavaScriptEnabled\"})\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        getWindow().requestFeature(Window.FEATURE_PROGRESS);\n        super.onCreate(savedInstanceState);\n\n        /**\n        * Setting WebView to Screen\n        */\n        setContentView(R.layout.activity_webview_for_payumoney);\n\n        /**\n         * Creating WebView\n         */\n        webView = (WebView) findViewById(R.id.payumoney_webview);\n\n        /**\n         * Context Variable\n         */\n        activity = getApplicationContext();\n\n        /**\n         * Actionbar Settings\n         */\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n\n        ActionBar ab = getSupportActionBar();\n        ab.setDisplayHomeAsUpEnabled(true);\n        // enabling action bar app icon and behaving it as toggle button\n        ab.setHomeButtonEnabled(true);\n        ab.setTitle(getString(R.string.title_activity_online_payment));\n\n        /**\n         * Getting Intent Variables...\n         */\n        Bundle bundle = getIntent().getExtras();\n        if (bundle != null) {\n\n            mFirstName = bundle.getString(\"name\");\n            mEmailId = bundle.getString(\"email\");\n            mAmount = bundle.getDouble(\"amount\");\n            mPhone = bundle.getString(\"phone\");\n            mId = bundle.getInt(\"id\");\n            isFromOrder = bundle.getBoolean(\"isFromOrder\");\n\n            Log.i(TAG, \"\" + mFirstName + \" : \" + mEmailId + \" : \" + mAmount + \" : \" + mPhone);\n\n            /**\n             * Creating Transaction Id\n             */\n            Random rand = new Random();\n            String randomString = Integer.toString(rand.nextInt()) + (System.currentTimeMillis() / 1000L);\n            mTXNId = hashCal(\"SHA-256\", randomString).substring(0, 20);\n\n            mAmount = new BigDecimal(mAmount).setScale(0, RoundingMode.UP).intValue();\n\n            /**\n             * Creating Hash Key\n             */\n            mHash = hashCal(\"SHA-512\", mMerchantKey + \"|\" +\n                    mTXNId + \"|\" +\n                    mAmount + \"|\" +\n                    mProductInfo + \"|\" +\n                    mFirstName + \"|\" +\n                    mEmailId + \"|||||||||||\" +\n                    mSalt);\n\n            /**\n             * Final Action URL...\n             */\n            mAction = mBaseURL.concat(\"/_payment\");\n\n            /**\n             * WebView Client\n             */\n            webView.setWebViewClient(new WebViewClient() {\n\n                @Override\n                public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) {\n                    super.onReceivedError(view, request, error);\n                    Toast.makeText(activity, \"Oh no! \" + error, Toast.LENGTH_SHORT).show();\n                }\n\n                @Override\n                public void onReceivedSslError(WebView view,\n                                               SslErrorHandler handler, SslError error) {\n                    Toast.makeText(activity, \"SSL Error! \" + error, Toast.LENGTH_SHORT).show();\n                    handler.proceed();\n                }\n\n                @Override\n                public boolean shouldOverrideUrlLoading(WebView view, String url) {\n                    return super.shouldOverrideUrlLoading(view, url);\n                }\n\n                @Override\n                public void onPageFinished(WebView view, String url) {\n\n                    if (url.equals(mSuccessUrl)) {\n                        Intent intent = new Intent(PayUMoneyActivity.this, PaymentStatusActivity.class);\n                        intent.putExtra(\"status\", true);\n                        intent.putExtra(\"transaction_id\", mTXNId);\n                        intent.putExtra(\"id\", mId);\n                        intent.putExtra(\"isFromOrder\", isFromOrder);\n                        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                        startActivity(intent);\n                    } else if (url.equals(mFailedUrl)) {\n                        Intent intent = new Intent(PayUMoneyActivity.this, PaymentStatusActivity.class);\n                        intent.putExtra(\"status\", false);\n                        intent.putExtra(\"transaction_id\", mTXNId);\n                        intent.putExtra(\"id\", mId);\n                        intent.putExtra(\"isFromOrder\", isFromOrder);\n                        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                        startActivity(intent);\n                    }\n                    super.onPageFinished(view, url);\n                }\n            });\n\n            webView.setVisibility(View.VISIBLE);\n            webView.getSettings().setBuiltInZoomControls(true);\n            webView.getSettings().setCacheMode(2);\n            webView.getSettings().setDomStorageEnabled(true);\n            webView.clearHistory();\n            webView.clearCache(true);\n            webView.getSettings().setJavaScriptEnabled(true);\n            webView.getSettings().setSupportZoom(true);\n            webView.getSettings().setUseWideViewPort(false);\n            webView.getSettings().setLoadWithOverviewMode(false);\n            webView.addJavascriptInterface(new PayUJavaScriptInterface(PayUMoneyActivity.this), \"PayUMoney\");\n\n            /**\n             * Mapping Compulsory Key Value Pairs\n             */\n            Map&lt;String, String&gt; mapParams = new HashMap&lt;&gt;();\n\n            mapParams.put(\"key\", mMerchantKey);\n            mapParams.put(\"txnid\", mTXNId);\n            mapParams.put(\"amount\", String.valueOf(mAmount));\n            mapParams.put(\"productinfo\", mProductInfo);\n            mapParams.put(\"firstname\", mFirstName);\n            mapParams.put(\"email\", mEmailId);\n            mapParams.put(\"phone\", mPhone);\n            mapParams.put(\"surl\", mSuccessUrl);\n            mapParams.put(\"furl\", mFailedUrl);\n            mapParams.put(\"hash\", mHash);\n            mapParams.put(\"service_provider\", mServiceProvider);\n\n            webViewClientPost(webView, mAction, mapParams.entrySet());\n        } else {\n            Toast.makeText(activity, \"Something went wrong, Try again.\", Toast.LENGTH_LONG).show();\n        }\n    }\n\n    /**\n     * Posting Data on PayUMoney Site with Form\n     *\n     * @param webView\n     * @param url\n     * @param postData\n     */\n    public void webViewClientPost(WebView webView, String url,\n                                  Collection&lt;Map.Entry&lt;String, String&gt;&gt; postData) {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"&lt;html&gt;&lt;head&gt;&lt;/head&gt;\");\n        sb.append(\"&lt;body onload='form1.submit()'&gt;\");\n        sb.append(String.format(\"&lt;form id='form1' action='%s' method='%s'&gt;\", url, \"post\"));\n\n        for (Map.Entry&lt;String, String&gt; item : postData) {\n            sb.append(String.format(\"&lt;input name='%s' type='hidden' value='%s' /&gt;\", item.getKey(), item.getValue()));\n        }\n        sb.append(\"&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\");\n\n        Log.d(\"TAG\", \"webViewClientPost called: \" + sb.toString());\n        webView.loadData(sb.toString(), \"text/html\", \"utf-8\");\n    }\n\n    /**\n     * Hash Key Calculation\n     *\n     * @param type\n     * @param str\n     * @return\n     */\n    public String hashCal(String type, String str) {\n        byte[] hashSequence = str.getBytes();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(type);\n            algorithm.reset();\n            algorithm.update(hashSequence);\n            byte messageDigest[] = algorithm.digest();\n\n            for (int i = 0; i &lt; messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF &amp; messageDigest[i]);\n                if (hex.length() == 1)\n                    hexString.append(\"0\");\n                hexString.append(hex);\n            }\n        } catch (NoSuchAlgorithmException NSAE) {\n        }\n        return hexString.toString();\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if(item.getItemId() == android.R.id.home) {\n            onPressingBack();\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onBackPressed() {\n        onPressingBack();\n    }\n\n    /**\n     * On Pressing Back\n     * Giving Alert...\n     */\n    private void onPressingBack() {\n\n        final Intent intent;\n\n        if(isFromOrder)\n            intent = new Intent(PayUMoneyActivity.this, ProductInCartList.class);\n        else\n            intent = new Intent(PayUMoneyActivity.this, MainActivity.class);\n\n        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\n        AlertDialog.Builder alertDialog = new AlertDialog.Builder(PayUMoneyActivity.this);\n\n        // Setting Dialog Title\n        alertDialog.setTitle(\"Warning\");\n\n        // Setting Dialog Message\n        alertDialog.setMessage(\"Do you cancel this transaction?\");\n\n        // On pressing Settings button\n        alertDialog.setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int which) {\n                finish();\n                startActivity(intent);\n            }\n        });\n\n        // on pressing cancel button\n        alertDialog.setNegativeButton(\"No\", new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int which) {\n                dialog.dismiss();\n            }\n        });\n\n        // Showing Alert Message\n        alertDialog.show();\n    }\n\n    public class PayUJavaScriptInterface {\n        Context mContext;\n\n        /**\n         * Instantiate the interface and set the context\n         */\n        PayUJavaScriptInterface(Context c) {\n            mContext = c;\n        }\n\n        public void success(long id, final String paymentId) {\n            mHandler.post(new Runnable() {\n\n                public void run() {\n                    mHandler = null;\n                    Toast.makeText(PayUMoneyActivity.this, \"Payment Successfully.\", Toast.LENGTH_SHORT).show();\n                }\n            });\n        }\n    }\n}\n", "import android.app.Activity;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.Signature;\nimport android.os.Bundle;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.linkedin.platform.LISessionManager;\nimport com.linkedin.platform.errors.LIAuthError;\nimport com.linkedin.platform.listeners.AuthListener;\nimport com.linkedin.platform.utils.Scope;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class MainActivity extends Activity {\n    private static final String TAG = MainActivity.class.getSimpleName();\n    public static final String PACKAGE = \"com.android.app\";\n                                          // your package name\n\n    Button login_linkedin_btn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        generateHashkey();\n\n        login_linkedin_btn = (Button) findViewById(R.id.login_button);\n        login_linkedin_btn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                login_linkedin();\n            }\n        });\n    }\n\n    // Authenticate with linkedin and intialize Session.\n\n    public void login_linkedin(){\n        LISessionManager.getInstance(getApplicationContext()).init(this, buildScope(), new AuthListener() {\n            @Override\n            public void onAuthSuccess() {\n\n                // Toast.makeText(getApplicationContext(), \"success\" + LISessionManager.getInstance(getApplicationContext()).getSession().getAccessToken().toString(), Toast.LENGTH_LONG).show();\n\n            }\n\n            @Override\n            public void onAuthError(LIAuthError error) {\n\n                Toast.makeText(getApplicationContext(), \"failed \" + error.toString(),\n                                 Toast.LENGTH_LONG).show();\n            }\n        }, true);\n    }\n\n    // After complete authentication start new HomePage Activity\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        LISessionManager.getInstance(getApplicationContext()).onActivityResult(this,\n                                      requestCode, resultCode, data);\n        Intent intent = new Intent(MainActivity.this,UserProfile.class);\n        startActivity(intent);\n    }\n\n     // generate the hash key \n     public void generateHashkey(){\n        try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    PACKAGE,\n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n\n                Log.d(\"Hask key\",Base64.encodeToString(md.digest(), Base64.NO_WRAP));\n\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            Log.d(TAG, e.getMessage(), e);\n        } catch (NoSuchAlgorithmException e) {\n            Log.d(TAG, e.getMessage(), e);\n        }\n    }\n\n    // This method is used to make permissions to retrieve data from linkedin\n\n    private static Scope buildScope() {\n        return Scope.build(Scope.R_BASICPROFILE, Scope.R_EMAILADDRESS);\n    }\n}\n", "    public String computeFingerPrint(final byte[] certRaw) {\n\n    String strResult = \"\";\n\n    MessageDigest md;\n    try {\n        md = MessageDigest.getInstance(\"SHA1\");\n        md.update(certRaw);\n        for (byte b : md.digest()) {\n            strResult += Integer.toString(b &amp; 0xff, 16);\n        }\n        strResult = strResult.toUpperCase(DATA_LOCALE);\n    }\n    catch (NoSuchAlgorithmException ex) {\n        ex.printStackTrace();\n    }\n\n    return strResult;\n}\n", "    package au.gov.dhsJobSeeker.main.readwriteprefssettings.util;\n\n    import java.security.SecureRandom;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.KeyGenerator;\n    import javax.crypto.SecretKey;\n    import javax.crypto.spec.SecretKeySpec;\n\n    import android.util.Base64;\n\n    public class EncodeDecodeAES {\n\nprivate final static String HEX = \"0123456789ABCDEF\";\nprivate final static int JELLY_BEAN_4_2 = 17;\nprivate final static byte[] key = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n\n// static {\n// Security.addProvider(new BouncyCastleProvider());\n// }\n\npublic static String encrypt(String seed, String cleartext) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    String fromHex = toHex(result);\n    String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));\n    return base64;\n}\n\n\npublic static String decrypt(String seed, String encrypted) throws Exception {\n    byte[] seedByte = seed.getBytes();\n    System.arraycopy(seedByte, 0, key, 0, ((seedByte.length &lt; 16) ? seedByte.length : 16));\n    String base64 = new String(Base64.decode(encrypted, 0));\n    byte[] rawKey = getRawKey(seedByte);\n    byte[] enc = toByte(base64);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\n\npublic static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext);\n    return result;\n}\n\n\npublic static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = decrypt(rawKey, encrypted);\n    return result;\n}\n\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\"); // , \"SC\");\n    SecureRandom sr = null;\n    if (android.os.Build.VERSION.SDK_INT &gt;= JELLY_BEAN_4_2) {\n        sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n    } else {\n        sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    }\n    sr.setSeed(seed);\n    try {\n        kgen.init(256, sr);\n        // kgen.init(128, sr);\n    } catch (Exception e) {\n        // Log.w(LOG, \"This device doesn't suppor 256bits, trying 192bits.\");\n        try {\n            kgen.init(192, sr);\n        } catch (Exception e1) {\n            // Log.w(LOG, \"This device doesn't suppor 192bits, trying 128bits.\");\n            kgen.init(128, sr);\n        }\n    }\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\"); // /ECB/PKCS7Padding\", \"SC\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\"); // /ECB/PKCS7Padding\", \"SC\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\n\npublic static String toHex(String txt) {\n    return toHex(txt.getBytes());\n}\n\n\npublic static String fromHex(String hex) {\n    return new String(toByte(hex));\n}\n\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length() / 2;\n    byte[] result = new byte[len];\n    for (int i = 0; i &lt; len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();\n    return result;\n}\n\n\npublic static String toHex(byte[] buf) {\n    if (buf == null) return \"\";\n    StringBuffer result = new StringBuffer(2 * buf.length);\n    for (int i = 0; i &lt; buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\n\n\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));\n}\n\n    }\n", "package com.fsck.k9.mail.store;\n\nimport android.app.Application;\nimport android.content.Context;\nimport android.util.Log;\nimport com.fsck.k9.K9;\nimport com.fsck.k9.helper.DomainNameChecker;\nimport org.apache.commons.io.IOUtils;\n\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic final class TrustManagerFactory {\n    private static final String LOG_TAG = \"TrustManagerFactory\";\n\n    private static X509TrustManager defaultTrustManager;\n    private static X509TrustManager unsecureTrustManager;\n    private static X509TrustManager localTrustManager;\n\n    private static X509Certificate[] lastCertChain = null;\n\n    private static File keyStoreFile;\n    private static KeyStore keyStore;\n\n\n    private static class SimpleX509TrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType)\n        throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType)\n        throws CertificateException {\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n\n    private static class SecureX509TrustManager implements X509TrustManager {\n        private static final Map&lt;String, SecureX509TrustManager&gt; mTrustManager =\n            new HashMap&lt;String, SecureX509TrustManager&gt;();\n\n        private final String mHost;\n\n        private SecureX509TrustManager(String host) {\n            mHost = host;\n        }\n\n        public synchronized static X509TrustManager getInstance(String host) {\n            SecureX509TrustManager trustManager;\n            if (mTrustManager.containsKey(host)) {\n                trustManager = mTrustManager.get(host);\n            } else {\n                trustManager = new SecureX509TrustManager(host);\n                mTrustManager.put(host, trustManager);\n            }\n\n            return trustManager;\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType)\n        throws CertificateException {\n            defaultTrustManager.checkClientTrusted(chain, authType);\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType)\n        throws CertificateException {\n            // FIXME: Using a static field to store the certificate chain is a bad idea. Instead\n            // create a CertificateException subclass and store the chain there.\n            TrustManagerFactory.setLastCertChain(chain);\n            try {\n                defaultTrustManager.checkServerTrusted(chain, authType);\n            } catch (CertificateException e) {\n                localTrustManager.checkServerTrusted(new X509Certificate[] {chain[0]}, authType);\n            }\n            if (!DomainNameChecker.match(chain[0], mHost)) {\n                try {\n                    String dn = chain[0].getSubjectDN().toString();\n                    if ((dn != null) &amp;&amp; (dn.equalsIgnoreCase(keyStore.getCertificateAlias(chain[0])))) {\n                        return;\n                    }\n                } catch (KeyStoreException e) {\n                    throw new CertificateException(\"Certificate cannot be verified; KeyStore Exception: \" + e);\n                }\n                throw new CertificateException(\"Certificate domain name does not match \"\n                                               + mHost);\n            }\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return defaultTrustManager.getAcceptedIssuers();\n        }\n\n    }\n\n    static {\n        java.io.InputStream fis = null;\n        try {\n            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(\"X509\");\n            Application app = K9.app;\n            keyStoreFile = new File(app.getDir(\"KeyStore\", Context.MODE_PRIVATE) + File.separator + \"KeyStore.bks\");\n            keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            try {\n                fis = new java.io.FileInputStream(keyStoreFile);\n            } catch (FileNotFoundException e1) {\n                fis = null;\n            }\n            try {\n                keyStore.load(fis, \"\".toCharArray());\n            } catch (IOException e) {\n                Log.e(LOG_TAG, \"KeyStore IOException while initializing TrustManagerFactory \", e);\n                keyStore = null;\n            } catch (CertificateException e) {\n                Log.e(LOG_TAG, \"KeyStore CertificateException while initializing TrustManagerFactory \", e);\n                keyStore = null;\n            }\n            tmf.init(keyStore);\n            TrustManager[] tms = tmf.getTrustManagers();\n            if (tms != null) {\n                for (TrustManager tm : tms) {\n                    if (tm instanceof X509TrustManager) {\n                        localTrustManager = (X509TrustManager)tm;\n                        break;\n                    }\n                }\n            }\n            tmf = javax.net.ssl.TrustManagerFactory.getInstance(\"X509\");\n            tmf.init((KeyStore)null);\n            tms = tmf.getTrustManagers();\n            if (tms != null) {\n                for (TrustManager tm : tms) {\n                    if (tm instanceof X509TrustManager) {\n                        defaultTrustManager = (X509TrustManager) tm;\n                        break;\n                    }\n                }\n            }\n\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(LOG_TAG, \"Unable to get X509 Trust Manager \", e);\n        } catch (KeyStoreException e) {\n            Log.e(LOG_TAG, \"Key Store exception while initializing TrustManagerFactory \", e);\n        } finally {\n            IOUtils.closeQuietly(fis);\n        }\n        unsecureTrustManager = new SimpleX509TrustManager();\n    }\n\n    private TrustManagerFactory() {\n    }\n\n    public static X509TrustManager get(String host, boolean secure) {\n        return secure ? SecureX509TrustManager.getInstance(host) :\n               unsecureTrustManager;\n    }\n\n    public static KeyStore getKeyStore() {\n        return keyStore;\n    }\n\n    public static void setLastCertChain(X509Certificate[] chain) {\n        lastCertChain = chain;\n    }\n    public static X509Certificate[] getLastCertChain() {\n        return lastCertChain;\n    }\n\n    public static void addCertificateChain(String alias, X509Certificate[] chain) throws CertificateException {\n        try {\n            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(\"X509\");\n            for (X509Certificate element : chain) {\n                keyStore.setCertificateEntry\n                (element.getSubjectDN().toString(), element);\n            }\n\n            tmf.init(keyStore);\n            TrustManager[] tms = tmf.getTrustManagers();\n            if (tms != null) {\n                for (TrustManager tm : tms) {\n                    if (tm instanceof X509TrustManager) {\n                        localTrustManager = (X509TrustManager) tm;\n                        break;\n                    }\n                }\n            }\n            java.io.OutputStream keyStoreStream = null;\n            try {\n                keyStoreStream = new java.io.FileOutputStream(keyStoreFile);\n                keyStore.store(keyStoreStream, \"\".toCharArray());\n            } catch (FileNotFoundException e) {\n                throw new CertificateException(\"Unable to write KeyStore: \" + e.getMessage());\n            } catch (CertificateException e) {\n                throw new CertificateException(\"Unable to write KeyStore: \" + e.getMessage());\n            } catch (IOException e) {\n                throw new CertificateException(\"Unable to write KeyStore: \" + e.getMessage());\n            } finally {\n                IOUtils.closeQuietly(keyStoreStream);\n            }\n\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(LOG_TAG, \"Unable to get X509 Trust Manager \", e);\n        } catch (KeyStoreException e) {\n            Log.e(LOG_TAG, \"Key Store exception while initializing TrustManagerFactory \", e);\n        }\n    }\n}\n", "trustStore = KeyStore.getInstance(\"PKCS12\");\nInputStream in = getResources().openRawResource(R.raw.keystore);\ntrustStore.load(in, \"xxxpasswordxxx\".toCharArray());\n", "public class MyHttpClient extends DefaultHttpClient {\n    private static final String KEYSTORE_PASS = \"XXXXX\";\n    private static final String KEYSTORE_TYPE = \"BKS\";\n\n    final Context context;\n\n    public MyHttpClient(Context context) {\n        this.context = context;\n    }\n\n    @Override\n    protected ClientConnectionManager createClientConnectionManager() {\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n        // Register for port 443 our SSLSocketFactory with our keystore\n        // to the ConnectionManager\n        registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n        return new SingleClientConnManager(getParams(), registry);\n    }\n\n    private SSLSocketFactory newSslSocketFactory() {\n        try {\n            KeyStore trusted = KeyStore.getInstance(KEYSTORE_TYPE);         \n            InputStream in = context.getResources().openRawResource(R.raw.keystore);\n            try {\n                 trusted.load(in, KEYSTORE_PASS.toCharArray());\n            } finally {\n                in.close();\n            }\n            SSLSocketFactory sf = new SSLSocketFactory(trusted);\n            sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n            return sf;\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n    }\n    }\n\n// In the Login class:\nclass RequestTask extends AsyncTask&lt;String, String, String&gt; {\n\n        @Override\n        protected String doInBackground(String... uri) {\n            DefaultHttpClient client = new MyHttpClient(getActivity());\n            HttpGet get = new HttpGet(uri[0]);\n            String responseString = null;\n            try {           \n                HttpResponse getResponse = client.execute(get);\n                HttpEntity responseEntity = getResponse.getEntity();\n                StatusLine statusLine = getResponse.getStatusLine();\n                if (statusLine.getStatusCode() == HttpStatus.SC_OK) {\n                    ByteArrayOutputStream salida = new ByteArrayOutputStream();\n                    getResponse.getEntity().writeTo(salida);\n                    salida.close();\n                    responseString = salida.toString();\n                } else {\n                    getResponse.getEntity().getContent().close();\n                    throw new IOException(statusLine.getReasonPhrase());\n                }           \n\n            } catch (ClientProtocolException cpe) {\n                cpe.printStackTrace();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n            return responseString;\n\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            super.onPostExecute(result);\n            // Whatever I want = nothing, I only want to do the CA validation with it.\n        }\n    }\n", "@Configuration\npublic class GcmXmppConnection {\n\n@Value(\"${gcm.senderID}\")\nprivate String username;\n\n@Value(\"${gcm.apiKey}\")\nprivate String password;\n\n@Value(\"${gcm.host}\")\nprivate String host;\n\n@Value(\"${gcm.port}\")\nprivate int port;\n\n@Bean(name=\"gcmConnection\")\npublic XmppConnectionFactoryBean xmppConnectionFactoryBean(){\n\n    ConnectionConfiguration configuration = new    ConnectionConfiguration(host, port);\n    configuration.setSecurityMode(SecurityMode.enabled);\n    configuration.setReconnectionAllowed(true);\n    configuration.setRosterLoadedAtLogin(false);\n    configuration.setSendPresence(false);\n    configuration.setSocketFactory(SSLSocketFactory.getDefault());\n\n//      configuration.setDebuggerEnabled(true);\n    XmppConnectionFactoryBean connectionFactoryBean = new XmppConnectionFactoryBean(configuration);\n\n    connectionFactoryBean.setUser(username);\n    connectionFactoryBean.setPassword(password);\n\n    return connectionFactoryBean;\n}\n}\n", "package mypackage;\n\nimport java.security.MessageDigest;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n\n        String text = \"neeraj\";\n\n        String codedtext = new Main().encrypt(text);\n\n        String decodedtext = new Main().decrypt(codedtext);\n\n        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array\n        System.out.println(decodedtext); // This correctly shows \"neeraj\"\n    }\n\n    public String encrypt(String message) throws Exception {\n        final MessageDigest md = MessageDigest.getInstance(\"md5\");\n        final byte[] digestOfPassword = md.digest(\"KEY\"\n                .getBytes(\"utf-8\"));\n        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        for (int j = 0, k = 16; j &lt; 8;) {\n            keyBytes[k++] = keyBytes[j++];\n        }\n\n        final SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n        final Cipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n\n        final byte[] plainTextBytes = message.getBytes(\"utf-8\");\n        final byte[] cipherText = cipher.doFinal(plainTextBytes);\n        // final String encodedCipherText = new sun.misc.BASE64Encoder()\n        // .encode(cipherText);\n\n        return Base64.encodeBase64String(cipherText);\n    }\n\n    public String decrypt(String input) throws Exception {\n\n        byte[] message = Base64.decodeBase64(input);\n\n        final MessageDigest md = MessageDigest.getInstance(\"md5\");\n        final byte[] digestOfPassword = md.digest(\"KEY\"\n                .getBytes(\"utf-8\"));\n        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        for (int j = 0, k = 16; j &lt; 8;) {\n            keyBytes[k++] = keyBytes[j++];\n        }\n\n        final SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n        final Cipher decipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n        decipher.init(Cipher.DECRYPT_MODE, key, iv);\n\n        // final byte[] encData = new\n        // sun.misc.BASE64Decoder().decodeBuffer(message);\n        final byte[] plainText = decipher.doFinal(message);\n\n        return new String(plainText, \"UTF-8\");\n    }\n}\n", "   public class AES2 {\n\n    private static final String TRANSFORMATION = \"AES/CFB8/NoPadding\";\n    private static final String ALGO_MD5       = \"MD5\";\n    private static final String ALGO_AES       = \"AES\";\n\n    /**\n     * See http://www.logikdev.com/2012/12/12/md5-generates-31-bytes-instead-of-32/ form more detail.\n     * \n     * @param input\n     * @return\n     * @throws NoSuchAlgorithmException\n     */\n    private static String md5(String input) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(ALGO_MD5);\n        byte[] messageDigest = md.digest(input.getBytes());\n        BigInteger number = new BigInteger(1, messageDigest);\n        return String.format(\"%032x\", number);\n    }\n\n    public static String decrypt(String encryptedData, String initialVectorString, String secretKey) {\n        String decryptedData = null;\n        try {\n            String md5Key = md5(secretKey);\n            SecretKeySpec skeySpec = new SecretKeySpec(md5Key.getBytes(), ALGO_AES);\n            IvParameterSpec initialVector = new IvParameterSpec(initialVectorString.getBytes());\n            Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec, initialVector);\n            byte[] encryptedByteArray = Base64.decode(encryptedData.getBytes(), Base64.DEFAULT);\n            byte[] decryptedByteArray = cipher.doFinal(encryptedByteArray);\n            decryptedData = new String(decryptedByteArray);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n\n        return decryptedData;\n    }\n\n}\n", " SSLContext sslContext = SSLContext.getInstance(\"TLSv1\");\n                sslContext.init(null, null, null);\n                SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n                            httpURLConnection.setSSLSocketFactory(socketFactory);\n", "public class HttpsClient extends DefaultHttpClient {\n\n    final Context context;\n\n    public HttpsClient(Context context) {\n        this.context = context;\n    }\n\n    @Override\n    protected ClientConnectionManager createClientConnectionManager() {\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory\n                .getSocketFactory(), 80));\n        // Register for port 443 our SSLSocketFactory with our keystore\n        // to the ConnectionManager\n        registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n        return new SingleClientConnManager(getParams(), registry);\n    }\n\n    private SSLSocketFactory newSslSocketFactory() {\n        try {\n            // Get an instance of the Bouncy Castle KeyStore format\n            KeyStore trusted = KeyStore.getInstance(\"BKS\");\n            // Get the raw resource, which contains the keystore with\n            // your trusted certificates (root and any intermediate certs)\n            InputStream in = context.getResources().openRawResource(\n                    R.raw.mykeystore);\n            try {\n                // Initialize the keystore with the provided trusted\n                // certificates\n                // Also provide the password of the keystore\n                trusted.load(in, \"mysecret\".toCharArray());\n            } finally {\n                in.close();\n            }\n            // Pass the keystore to the SSLSocketFactory. The factory is\n            // responsible\n            // for the verification of the server certificate.\n            SSLSocketFactory sf = new SSLSocketFactory(trusted);\n            // Hostname verification from certificate\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n            return sf;\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n    }\n}\n", "KeyPairGenerator kpg;\n\nKeyPair kp;\n\nstatic PublicKey publicKey;\n\nstatic PrivateKey privateKey;\n\nbyte [] encryptedBytes,decryptedBytes;\n\nCipher cipher;\n\npublic String GetEncryptValue(String value) \nthrows InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, \n       IllegalBlockSizeException, BadPaddingException \n{\n    InputStream is = null;\n    javax.security.cert.X509Certificate x5092 = null;\n    try {\n        is = getAssets().open(\"publicCer.cer\");\n         x5092 = javax.security.cert.X509Certificate.getInstance(is);\n    } catch (javax.security.cert.CertificateException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n\n    return RSAEncrypt(\"Gergova\", x5092);\n}\n\npublic String RSAEncrypt (\n    final String plain, javax.security.cert.X509Certificate x5092) \n        throws NoSuchAlgorithmException, NoSuchPaddingException, \n           InvalidKeyException, IllegalBlockSizeException, \n           BadPaddingException \n{\n    kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(1024);\n    kp = kpg.genKeyPair();\n    publicKey = x5092.getPublicKey();\n    privateKey = kp.getPrivate();\n\n    cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    encryptedBytes = cipher.doFinal(stringToBytesASCII(plain));\n    String str = null;\n    try {\n        str = new String(encryptedBytes, \"ISO-8859-1\");\n    } catch (UnsupportedEncodingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return str;\n}\n\npublic static byte[] stringToBytesASCII(String str) {\n\n     byte[] b = new byte[str.length()];\n     for (int i = 0; i &lt; b.length; i++) {\n      b[i] = (byte) str.charAt(i);\n     }\n     return b;\n}\n", "PrivateKey myKey = getKey();\nX509Certificate certificate = getCertificate();\nKeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\nkeyStore.load(null);\nkeystore.setKeyEntry(\"anAlias\", myKey, null, new Certificate[] { certificate });\n", "if (\"https\".equals(url.getProtocol()) &amp;&amp; mSslSocketFactory != null) {            \n    ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);\n    ((HttpsURLConnection)connection).setHostnameVerifier(new CustomHostnameVerifier());         \n}\n", "  OkHttpClient okHttpClient = new OkHttpClient();\n  SSLContext sslContext;\n  try {\n    sslContext = SSLContext.getInstance(\"TLS\");\n    sslContext.init(null, null, null);\n  } catch (GeneralSecurityException e) {\n    throw new AssertionError(); // The system has no TLS. Just give up.\n  }\n  okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());\n", "// Create and initialize HTTP parameters\nHttpParams params = new BasicHttpParams();\nHttpClientParams.setRedirecting(params, true );\n\n// Set the timeout in milliseconds until a connection is established.\nHttpConnectionParams.setConnectionTimeout( params, 5000 );\n\n// Set the default socket timeout (SO_TIMEOUT)\n// in milliseconds which is the timeout for waiting for data.\nHttpConnectionParams.setSoTimeout( params, 10000 );\n\n// The params are read in the ctor of the pool constructed by\n// ThreadSafeClientConnManager, and need to be set before constructing it.\nConnManagerParams.setMaxTotalConnections(params, 15);\nConnPerRoute cpr = new ConnPerRoute() {\n   @Override\n   public int getMaxForRoute(HttpRoute httpRoute) { return 5; }\n};\n\nConnManagerParams.setMaxConnectionsPerRoute(params, cpr);\n\nHttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n\n// Create and initialize scheme registry\nSchemeRegistry schemeRegistry = new SchemeRegistry();\nschemeRegistry.register( new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n\n/* Since I'm in a development environment I need to trust self-signed certs */\nSSLSocketFactory sslSocketFactory = null;\ntry {\n   X509TrustManager tm = new X509TrustManager() {\n      public void checkClientTrusted(X509Certificate[] xcs, String string)\n         throws CertificateException { }\n\n      public void checkServerTrusted(X509Certificate[] xcs, String string)\n         throws CertificateException { }\n\n      public X509Certificate[] getAcceptedIssuers() { return null; }\n   };\n\n   SSLContext ctx = SSLContext.getInstance(\"TLS\");\n   ctx.init(null, new TrustManager[]{tm}, null);\n\n   sslSocketFactory = new TrustAllSSLSocketFactory(ctx);\n   if (sslSocketFactory != null)\n      sslSocketFactory.setHostnameVerifier(\n          SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\n} catch (Exception ex) {\n   Log.e(TAG, ex.getMessage(), ex);\n   sslSocketFactory = null;\n}\n\nif (sslSocketFactory == null) {\n   sslSocketFactory = SSLSocketFactory.getSocketFactory();\n   sslSocketFactory.setHostnameVerifier(\n      SSLSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n}\n\nschemeRegistry.register(new Scheme(\"https\", sslSocketFactory, 443));\n\n// Create an HttpClient with the ThreadSafeClientConnManager.\n// This connection manager must be used if more than one thread will\n// be using the HttpClient.\nClientConnectionManager cm = new ThreadSafeClientConnManager(params, schemeRegistry);\n\nDefaultHttpClient client = new DefaultHttpClient(cm, params);\n\nHttpProtocolParams.setUseExpectContinue(client.getParams(), false);\n\nHttpRequestRetryHandler retryHandler = new HttpRequestRetryHandler() {\n   public boolean retryRequest(IOException exception, int executionCount,\n      HttpContext context) {\n      // retry a max of 5 times\n      if(executionCount &gt;= 5) { return false; }\n      if(exception instanceof NoHttpResponseException){\n         return true;\n      } else if (exception instanceof ClientProtocolException){\n         return true;\n      }\n      return false;\n   }\n};\n\nclient.setHttpRequestRetryHandler(retryHandler);\n\n/* Cookie Management */\nCookiesStore cookieStore = new BasicCookieStore();\nclient.setCookieStore(cookieStore);\n", "static final\nprivate class TrustAllSSLSocketFactory extends SSLSocketFactory {\n\n   private SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n   public TrustAllSSLSocketFactory(KeyStore truststore) \n       throws NoSuchAlgorithmException,\n          KeyManagementException,\n              KeyStoreException, UnrecoverableKeyException {\n      super(truststore);\n\n  TrustManager tm = new X509TrustManager() {\n          @Override\n          public X509Certificate[] getAcceptedIssuers() { return null; }\n\n          @Override\n          public void checkServerTrusted(X509Certificate[] chain, String authType)\n             throws CertificateException { }\n\n          @Override\n          public void checkClientTrusted(X509Certificate[] chain, String authType)\n             throws CertificateException { }\n      };\n\n      sslContext.init(null, new TrustManager[] { tm }, null);\n  }\n\n  public TrustAllSSLSocketFactory(SSLContext context)\n      throws KeyManagementException, \n             NoSuchAlgorithmException, KeyStoreException, \n             UnrecoverableKeyException {\n    super(null);\n    sslContext = context;\n  }\n\n  @Override\n  public Socket createSocket(Socket socket, String host, int port, boolean autoClose)\n     throws IOException, UnknownHostException {\n      return sslContext.getSocketFactory()\n         .createSocket(socket, host, port, autoClose);  \n  }\n\n  @Override\n  public Socket createSocket() throws IOException {\n     return sslContext.getSocketFactory().createSocket();\n  }\n};\n", "            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {\n            }\n        }\n        };\n\n        // Install the all-trusting trust manager\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n        // Create all-trusting host name verifier\n        HostnameVerifier allHostsValid = new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        };\n", "public class Login extends Activity {\n\n      //URL to get JSON Array\n      private static String url = \"https://demo.vtiger.com/webservice.php?operation=getchallenge&amp;username=admin\";\n\n      //JSON Node Names\n      private static final String TAG_RESULT = \"result\";\n      private static final String TAG_TOKEN = \"token\";\n\n      // contacts JSONArray\n      JSONArray contacts = null;\n\n      String token = null;\n      String sessionId;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.login);\n\n        if (android.os.Build.VERSION.SDK_INT &gt; 9) {\n            StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();\n            StrictMode.setThreadPolicy(policy);\n        }\n\n\n        new AsyncTask&lt;Void, Void, Void&gt;() {\n\n            private ProgressDialog dialog = new ProgressDialog(Login.this);\n            protected void onPreExecute() {\n                   dialog.setMessage(\"Loging In... Please wait...\");\n                   dialog.show();\n                  }\n\n            @SuppressWarnings(\"unused\")\n            JSONObject result;\n\n            @Override\n            protected Void doInBackground(Void... params) {\n\n                // Creating new JSON Parser\n                JSONParser jParser = new JSONParser();\n\n                // Getting JSON from URL\n                JSONObject json = jParser.getJSONFromUrl(url);\n\n                try {\n                    // Getting JSON Array\n                    result = json.getJSONObject(TAG_RESULT);\n                      JSONObject json_result = json.getJSONObject(TAG_RESULT);\n\n                    // Storing  JSON item in a Variable\n                    token = json_result.getString(TAG_TOKEN);\n\n                    //Importing TextView\n\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n\n                String username=\"admin\";\n                String accesskeyvalue = \"w9OweWKUS4a5sSL\";\n                String accessKey=md5(token + accesskeyvalue);\n\n                //For debugging purpose only\n                //System.out.println(accesskeyvalue);\n                //System.out.println(token);\n                //System.out.println(accessKey);\n\n        String data = null;\n\n            try {\n                data = URLEncoder.encode(\"username\", \"UTF-8\")\n                        + \"=\" + URLEncoder.encode(username, \"UTF-8\");\n                data += \"&amp;\" + URLEncoder.encode(\"accessKey\", \"UTF-8\") + \"=\"\n                        + URLEncoder.encode(accessKey, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } \n        String text = \"\";\n        BufferedReader reader=null;\n        //System.out.println(data);\n\n        // Send data\n        try\n        {\n\n            // Defined URL  where to send data\n            URL url = new URL(\"https://demo.vtiger.com/webservice.php?operation=login\");\n\n         // Send POST data request\n          URLConnection conn = url.openConnection();\n          conn.setDoOutput(true);\n          OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n          wr.write( data );\n          wr.flush();    \n\n        // Get the server response    \n        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n\n        // Read Server Response\n        while((line = reader.readLine()) != null)\n            {\n                   // Append server response in string\n                   sb.append(line + \"\\n\");\n            }\n\n\n            text = sb.toString();\n        }\n        catch(Exception ex)\n        {\n\n        }\n        finally\n        {\n            try\n            {\n\n                reader.close();\n            }\n\n            catch(Exception ex) {}\n        }\n\n        // Show response\n        System.out.println(text);\n        sessionId = text.substring(41, 62);\n        //System.out.println(\"doInBackground()\"+sessionId);\n\n\n\n    return null;    \n    }\n            @Override\n            protected void onPostExecute(Void aVoid) {\n                super.onPostExecute(aVoid);    \n                dialog.dismiss();\n               }\n\n         }.execute();\n\n    } \n\n    public String md5(String s) \n    {\n    MessageDigest digest;\n        try \n            {\n                digest = MessageDigest.getInstance(\"MD5\");\n                digest.update(s.getBytes(),0,s.length());\n                String hash = new BigInteger(1, digest.digest()).toString(16);\n                return hash;\n            } \n        catch (NoSuchAlgorithmException e) \n            {\n                e.printStackTrace();\n            }\n        return \"\";\n    }\n", "    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        PrintHashKeyInLog();\n\n    }\n\n    public void PrintHashKeyInLog() {\n\n        PackageInfo info;\n        try {\n            info = getPackageManager().getPackageInfo(\n                    \"Your package name\",\n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md;\n                md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                String something = new String(Base64.encode(md.digest(), 0)); // String\n                something = new String(Base64.encode(md.digest(), 0));\n                Log.e(\"hash key\", something);\n            }\n        } catch (NameNotFoundException e1) {\n            Log.e(\"name not found\", e1.toString());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(\"no such an algorithm\", e.toString());\n        } catch (Exception e) {\n            Log.e(\"exception\", e.toString());\n        }\n    }\n", "public static String decrypt(String key, String value)throws java.io.UnsupportedEncodingException,\n        NoSuchAlgorithmException,\n        NoSuchPaddingException,\n        InvalidKeyException,\n        InvalidAlgorithmParameterException,\n        IllegalBlockSizeException,\n        BadPaddingException {\n\n    byte[] keyBytes = key.getBytes(\"UTF-8\");\n    AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n    SecretKeySpec newKey = new SecretKeySpec(keyBytes, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);\n    byte[] decodedVal = Base64.decode(value.getBytes(\"UTF-8\"), Base64.DEFAULT);\n    byte[] cipherData = cipher.doFinal(decodedVal);\n    ILog.d(\"cipherData\",\"\"+cipherData);\n    String decryptedData = new String(cipherData, \"UTF-8\");\n    ILog.d(\"Data\",decryptedData);\n    return decryptedData.trim();\n}\n", "Cipher c1 = Cipher.getInstance(\"RSA\");\nc1.init(Cipher.ENCRYPT_MODE, publicKey);\nencodedBytes = c1.doFinal(secretMessage.getBytes());\nencodedMessage = Base64.encodeToString(encodedBytes, Base64.DEFAULT);\n\nCipher c2 = Cipher.getInstance(\"RSA\");    \nc2.init(Cipher.DECRYPT_MODE, privateKey)      \ndecodedBytes = Base64.decode(encodedMessage.toByteArray(), Base64.DEFAULT);\ndecryptedMessage = c2.doFinal(decodedBytes);\n", "SSLContext sc = SSLContext.getInstance(\"TLS\");\nTrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        return;\n}\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        return;\n    }\n} };\nsc.init(null, trustAllCerts, new SecureRandom());\nHttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\nHttpURLConnection = connection = endPoint.openConnection();\n", "package com.duplicate;\n\n\n\n   public class RSAEncryptionDescription {\n\n\n private static final String PUBLIC_KEY_FILE = \"Public.key\";  \n private static final String PRIVATE_KEY_FILE = \"Private.key\";  \n\n public static void main(String[] args) throws IOException {  \n\n  try {  \n   System.out.println(\"-------GENRATE PUBLIC and PRIVATE KEY-------------\");  \n   KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");  \n   keyPairGenerator.initialize(2048); //1024 used for normal securities  \n   KeyPair keyPair = keyPairGenerator.generateKeyPair();  \n   PublicKey publicKey = keyPair.getPublic();  \n   PrivateKey privateKey = keyPair.getPrivate();  \n   System.out.println(\"Public Key - \" + publicKey);  \n   System.out.println(\"Private Key - \" + privateKey);\n\n   //Pullingout parameters which makes up Key  \n   System.out.println(\"\\n------- PULLING OUT PARAMETERS WHICH MAKES KEYPAIR----------\\n\");  \n   KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");  \n   RSAPublicKeySpec rsaPubKeySpec = keyFactory.getKeySpec(publicKey, RSAPublicKeySpec.class);  \n   RSAPrivateKeySpec rsaPrivKeySpec = keyFactory.getKeySpec(privateKey, RSAPrivateKeySpec.class);  \n   System.out.println(\"PubKey Modulus : \" + rsaPubKeySpec.getModulus());  \n   System.out.println(\"PubKey Exponent : \" + rsaPubKeySpec.getPublicExponent());  \n   System.out.println(\"PrivKey Modulus : \" + rsaPrivKeySpec.getModulus());  \n   System.out.println(\"PrivKey Exponent : \" + rsaPrivKeySpec.getPrivateExponent());  \n\n   //Share public key with other so they can encrypt data and decrypt thoses using private key(Don't share with Other)  \n   System.out.println(\"\\n--------SAVING PUBLIC KEY AND PRIVATE KEY TO FILES-------\\n\");  \n   RSAEncryptionDescription rsaObj = new RSAEncryptionDescription();  \n   rsaObj.saveKeys(PUBLIC_KEY_FILE, rsaPubKeySpec.getModulus(), rsaPubKeySpec.getPublicExponent());  \n   rsaObj.saveKeys(PRIVATE_KEY_FILE, rsaPrivKeySpec.getModulus(), rsaPrivKeySpec.getPrivateExponent());  \n\n   //Encrypt Data using Public Key  \n   byte[] encryptedData = rsaObj.encryptData(\"Anuj Patel - Classified Information !\");  \n\n   //Descypt Data using Private Key  \n   rsaObj.decryptData(encryptedData);  \n\n  } catch (NoSuchAlgorithmException e) {  \n   e.printStackTrace();  \n  }catch (InvalidKeySpecException e) {  \n   e.printStackTrace();  \n  }  \n\n }  \n\n /** \n  * Save Files \n  * @param fileName \n  * @param mod \n  * @param exp \n  * @throws IOException \n  */  \n private void saveKeys(String fileName,BigInteger mod,BigInteger exp) throws IOException{  \n  FileOutputStream fos = null;  \n  ObjectOutputStream oos = null;  \n\n  try {  \n   System.out.println(\"Generating \"+fileName + \"...\");  \n   fos = new FileOutputStream(fileName);  \n   oos = new ObjectOutputStream(new BufferedOutputStream(fos));  \n\n   oos.writeObject(mod);  \n   oos.writeObject(exp);     \n\n   System.out.println(fileName + \" generated successfully\");  \n  } catch (Exception e) {  \n   e.printStackTrace();  \n  }  \n  finally{  \n   if(oos != null){  \n    oos.close();  \n\n    if(fos != null){  \n     fos.close();  \n    }  \n   }  \n  }    \n }  \n\n /** \n  * Encrypt Data \n  * @param data \n  * @throws IOException \n  */  \n private byte[] encryptData(String data) throws IOException {  \n  System.out.println(\"\\n----------------ENCRYPTION STARTED------------\");  \n\n  System.out.println(\"Data Before Encryption :\" + data);  \n  byte[] dataToEncrypt = data.getBytes();  \n  byte[] encryptedData = null;  \n  try {  \n   PublicKey pubKey = readPublicKeyFromFile(PUBLIC_KEY_FILE);  \n   Cipher cipher = Cipher.getInstance(\"RSA\");  \n   cipher.init(Cipher.ENCRYPT_MODE, pubKey);  \n   encryptedData = cipher.doFinal(dataToEncrypt);  \n   System.out.println(\"Encryted Data: \" + encryptedData);  \n\n  } catch (Exception e) {  \n   e.printStackTrace();  \n  }   \n\n  System.out.println(\"----------------ENCRYPTION COMPLETED------------\");    \n  return encryptedData;  \n }  \n\n /** \n  * Encrypt Data \n  * @param data \n  * @throws IOException \n  */  \n private void decryptData(byte[] data) throws IOException {  \n  System.out.println(\"\\n----------------DECRYPTION STARTED------------\");  \n  byte[] descryptedData = null;  \n\n  try {  \n   PrivateKey privateKey = readPrivateKeyFromFile(PRIVATE_KEY_FILE);  \n   Cipher cipher = Cipher.getInstance(\"RSA\");  \n   cipher.init(Cipher.DECRYPT_MODE, privateKey);  \n   descryptedData = cipher.doFinal(data);  \n   System.out.println(\"Decrypted Data: \" + new String(descryptedData));  \n\n  } catch (Exception e) {  \n   e.printStackTrace();  \n  }   \n\n  System.out.println(\"----------------DECRYPTION COMPLETED------------\");    \n }  \n\n /** \n  * read Public Key From File \n  * @param fileName \n  * @return PublicKey \n  * @throws IOException \n  */  \n public PublicKey readPublicKeyFromFile(String fileName) throws IOException{  \n  FileInputStream fis = null;  \n  ObjectInputStream ois = null;  \n  try {  \n   fis = new FileInputStream(new File(fileName));  \n   ois = new ObjectInputStream(fis);  \n\n   BigInteger modulus = (BigInteger) ois.readObject();  \n      BigInteger exponent = (BigInteger) ois.readObject();  \n\n      //Get Public Key  \n      RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(modulus, exponent);  \n      KeyFactory fact = KeyFactory.getInstance(\"RSA\");  \n      PublicKey publicKey = fact.generatePublic(rsaPublicKeySpec);  \n\n      return publicKey;  \n\n  } catch (Exception e) {  \n   e.printStackTrace();  \n  }  \n  finally{  \n   if(ois != null){\n    ois.close();  \n    if(fis != null){\n     fis.close();\n    }\n   }  \n  }  \n  return null;  \n }  \n\n /** \n  * read Public Key From File \n  * @param fileName \n  * @return \n  * @throws IOException \n  */  \n public PrivateKey readPrivateKeyFromFile(String fileName) throws IOException{  \n  FileInputStream fis = null;  \n  ObjectInputStream ois = null;  \n  try {  \n   fis = new FileInputStream(new File(fileName));  \n   ois = new ObjectInputStream(fis);  \n\n   BigInteger modulus = (BigInteger) ois.readObject();  \n      BigInteger exponent = (BigInteger) ois.readObject();  \n\n      //Get Private Key  \n      RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(modulus, exponent);  \n      KeyFactory fact = KeyFactory.getInstance(\"RSA\");  \n      PrivateKey privateKey = fact.generatePrivate(rsaPrivateKeySpec);  \n\n      return privateKey;  \n\n  } catch (Exception e) {  \n   e.printStackTrace();  \n  }  \n  finally{  \n   if(ois != null){  \n    ois.close();  \n    if(fis != null){  \n     fis.close();  \n    }  \n   }  \n  }  \n  return null;  \n }  \n}  \n", "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.UnknownHostException;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\nimport org.osmdroid.tileprovider.MapTile;\nimport org.osmdroid.tileprovider.MapTileRequestState;\nimport org.osmdroid.tileprovider.modules.IFilesystemCache;\nimport org.osmdroid.tileprovider.modules.INetworkAvailablityCheck;\nimport org.osmdroid.tileprovider.modules.MapTileDownloader;\nimport org.osmdroid.tileprovider.modules.MapTileModuleProviderBase;\nimport org.osmdroid.tileprovider.tilesource.BitmapTileSourceBase.LowMemoryException;\nimport org.osmdroid.tileprovider.tilesource.ITileSource;\nimport org.osmdroid.tileprovider.tilesource.OnlineTileSourceBase;\nimport org.osmdroid.tileprovider.util.StreamUtils;\n\nimport android.graphics.drawable.Drawable;\nimport android.text.TextUtils;\nimport android.util.Log;\n\n/**\n * A drop-in replacement for {@link MapTileDownloader}. This loads tiles from an\n * HTTP or HTTPS server, making use of a custom {@link SSLSocketFactory} for SSL\n * peer verification.\n */\npublic class MyTileDownloader extends MapTileModuleProviderBase {\n    private static final String TAG = \"MyMapTileDownloader\";\n\n    protected OnlineTileSourceBase mTileSource;\n    protected final IFilesystemCache mFilesystemCache;\n    protected final INetworkAvailablityCheck mNetworkAvailablityCheck;\n    protected final SSLSocketFactory mSSLSocketFactory;\n\n    public MyTileDownloader(ITileSource pTileSource,\n            IFilesystemCache pFilesystemCache,\n            INetworkAvailablityCheck pNetworkAvailablityCheck,\n            SSLSocketFactory pSSLSocketFactory) {\n        super(4, TILE_DOWNLOAD_MAXIMUM_QUEUE_SIZE);\n        setTileSource(pTileSource);\n        mFilesystemCache = pFilesystemCache;\n        mNetworkAvailablityCheck = pNetworkAvailablityCheck;\n        mSSLSocketFactory = pSSLSocketFactory;\n    }\n\n    public ITileSource getTileSource() {\n        return mTileSource;\n    }\n\n    @Override\n    public void setTileSource(final ITileSource tileSource) {\n        // We are only interested in OnlineTileSourceBase tile sources\n        if (tileSource instanceof OnlineTileSourceBase)\n            mTileSource = (OnlineTileSourceBase) tileSource;\n        else\n            mTileSource = null;\n    }\n\n    @Override\n    public boolean getUsesDataConnection() {\n        return true;\n    }\n\n    @Override\n    protected String getName() {\n        return \"Online Tile Download Provider\";\n    }\n\n    @Override\n    protected String getThreadGroupName() {\n        return \"downloader\";\n    }\n\n    @Override\n    public int getMinimumZoomLevel() {\n        return (mTileSource != null ? mTileSource.getMinimumZoomLevel()\n                : MINIMUM_ZOOMLEVEL);\n    }\n\n    @Override\n    public int getMaximumZoomLevel() {\n        return (mTileSource != null ? mTileSource.getMaximumZoomLevel()\n                : MAXIMUM_ZOOMLEVEL);\n    }\n\n    @Override\n    protected Runnable getTileLoader() {\n        return new TileLoader();\n    };\n\n    private class TileLoader extends MapTileModuleProviderBase.TileLoader {\n        @Override\n        public Drawable loadTile(final MapTileRequestState aState)\n                throws CantContinueException {\n            if (mTileSource == null)\n                return null;\n\n            InputStream in = null;\n            OutputStream out = null;\n            final MapTile tile = aState.getMapTile();\n\n            try {\n                if (mNetworkAvailablityCheck != null\n                        &amp;&amp; !mNetworkAvailablityCheck.getNetworkAvailable()) {\n                    if (DEBUGMODE)\n                        Log.d(TAG, \"Skipping \" + getName()\n                                + \" due to NetworkAvailabliltyCheck.\");\n                    return null;\n                }\n\n                final String tileURLString = mTileSource.getTileURLString(tile);\n                if (DEBUGMODE)\n                    Log.d(TAG, \"Downloading Maptile from url: \" + tileURLString);\n\n                if (TextUtils.isEmpty(tileURLString))\n                    return null;\n\n                // Create an HttpURLConnection to download the tile\n                URL url = new URL(tileURLString);\n                HttpURLConnection connection = (HttpURLConnection) url\n                        .openConnection();\n                connection.setConnectTimeout(30000);\n                connection.setReadTimeout(30000);\n\n                // Use our custom SSLSocketFactory for secure connections\n                if (\"https\".equalsIgnoreCase(url.getProtocol()))\n                    ((HttpsURLConnection) connection)\n                            .setSSLSocketFactory(mSSLSocketFactory);\n\n                // Open the input stream\n                in = new BufferedInputStream(connection.getInputStream(),\n                        StreamUtils.IO_BUFFER_SIZE);\n\n                // Check to see if we got success\n                if (connection.getResponseCode() != 200) {\n                    Log.w(TAG, \"Problem downloading MapTile: \" + tile\n                            + \" HTTP response: \" + connection.getHeaderField(0));\n                    return null;\n                }\n\n                // Read the tile into an in-memory byte array\n                final ByteArrayOutputStream dataStream = new ByteArrayOutputStream();\n                out = new BufferedOutputStream(dataStream,\n                        StreamUtils.IO_BUFFER_SIZE);\n                StreamUtils.copy(in, out);\n                out.flush();\n                final byte[] data = dataStream.toByteArray();\n                final ByteArrayInputStream byteStream = new ByteArrayInputStream(\n                        data);\n\n                // Save the data to the filesystem cache\n                if (mFilesystemCache != null) {\n                    mFilesystemCache.saveFile(mTileSource, tile, byteStream);\n                    byteStream.reset();\n                }\n                final Drawable result = mTileSource.getDrawable(byteStream);\n                return result;\n\n            } catch (final UnknownHostException e) {\n                Log.w(TAG, \"UnknownHostException downloading MapTile: \" + tile\n                        + \" : \" + e);\n                throw new CantContinueException(e);\n\n            } catch (final LowMemoryException e) {\n                Log.w(TAG, \"LowMemoryException downloading MapTile: \" + tile\n                        + \" : \" + e);\n                throw new CantContinueException(e);\n\n            } catch (final FileNotFoundException e) {\n                Log.w(TAG, \"Tile not found: \" + tile + \" : \" + e);\n\n            } catch (final IOException e) {\n                Log.w(TAG, \"IOException downloading MapTile: \" + tile + \" : \"\n                        + e);\n\n            } catch (final Throwable e) {\n                Log.e(TAG, \"Error downloading MapTile: \" + tile, e);\n\n            } finally {\n                StreamUtils.closeStream(in);\n                StreamUtils.closeStream(out);\n            }\n            return null;\n        }\n\n        @Override\n        protected void tileLoaded(final MapTileRequestState pState,\n                final Drawable pDrawable) {\n            // Don't return the tile Drawable because we'll wait for the fs\n            // provider to ask for it. This prevent flickering when a load\n            // of delayed downloads complete for tiles that we might not\n            // even be interested in any more.\n            super.tileLoaded(pState, null);\n        }\n    }\n}\n", "    private TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {\n        final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];\n        return new TrustManager[]{\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return originalTrustManager.getAcceptedIssuers();\n                    }\n\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {\n                        try {\n                            originalTrustManager.checkClientTrusted(certs, authType);\n                        } catch (CertificateException ignored) {\n                        }\n                    }\n\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {\n                        try {\n                            originalTrustManager.checkServerTrusted(certs, authType);\n                        } catch (CertificateException ignored) {\n                        }\n                    }\n                }\n        };\n    }\n\n    private SSLSocketFactory getSSLSocketFactory() {\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            InputStream caInput = getResources().openRawResource(R.raw.your_cert);\n            Certificate ca = cf.generateCertificate(caInput);\n            caInput.close();\n\n            KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n            keyStore.load(null, null);\n            keyStore.setCertificateEntry(\"ca\", ca);\n\n            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n            tmf.init(keyStore);\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, getWrappedTrustManagers(tmf.getTrustManagers()), null);                \n\n            return sslContext.getSocketFactory();\n        } catch (Exception e) {\n            return HttpsURLConnection.getDefaultSSLSocketFactory();\n        }\n    }\n\n    private class GETRequest extends AsyncTask&lt;Void, Void, String&gt; {\n        @Override\n        protected String doInBackground(Void... params) {\n            try {\n                URL url = new URL(\"https://your_server_url\");\n                String token = \"rbkY34HnL...\";\n                HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();\n                urlConnection.setSSLSocketFactory(getSSLSocketFactory());\n                urlConnection.setHostnameVerifier(new HostnameVerifier() {\n                    @Override\n                    public boolean verify(String hostname, SSLSession session) {\n//                        return true;\n                        HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();\n                        return hv.verify(\"your_domain.com\", session);\n                    }\n                });    \n                urlConnection.setRequestProperty(\"Authorization\", \"Bearer \" + token);\n                urlConnection.connect();\n                InputStream inputStream;\n                if (urlConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                    inputStream = urlConnection.getErrorStream();\n                } else {\n                    inputStream = urlConnection.getInputStream();\n                }\n                return String.valueOf(urlConnection.getResponseCode()) + \" \" + urlConnection.getResponseMessage() + \"\\r\\n\" + parseStream(inputStream);\n            } catch (Exception e) {\n                return e.toString();\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String response) {\n            super.onPostExecute(response);\n            // do something...\n        }\n    }\n", "public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n    Cipher cipher = null;\n    TextView tv = new TextView(this);\n    setContentView(tv);\n\n    for (String name : SYMMETRIC_CIPHERS) {\n    try {\n        cipher = Cipher.getInstance(name, \"BC\");\n        tv.append(name);\n        tv.append(\"\\n\");\n    } catch (Exception e) {\n    }\n    }\n}\n", "CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n// From https://www.washington.edu/itconnect/security/ca/load-der.crt\n\nInputStream caInput = new BufferedInputStream(new FileInputStream(\"load-   der.crt\"));\nCertificate ca;\ntry {\nca = cf.generateCertificate(caInput);\nSystem.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());\n} finally {\ncaInput.close();\n}\n", "String keyStoreType = KeyStore.getDefaultType();\nKeyStore keyStore = KeyStore.getInstance(keyStoreType);\nkeyStore.load(null, null);\nkeyStore.setCertificateEntry(\"ca\", ca);\n", "String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\ntmf.init(keyStore);\n", "SSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, tmf.getTrustManagers(), null);\n", "    for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    }\n", "public class Cryptooo {\n\nSecretKeySpec key = null;\nbyte[] ciphertext;\n\n public void generateKey()  {\n\n String passphrase = \"3xtr3meDiFficUltp@ss\";\n\n MessageDigest digest = null;\n try {\n     digest = MessageDigest.getInstance(\"SHA\");\n } catch (NoSuchAlgorithmException e) {\n     e.printStackTrace();\n }\n\n digest.update(passphrase.getBytes());\n key = new SecretKeySpec(digest.digest(), 0, 16, \"AES\");\n\n byte[] keyBytes = key.getEncoded();\n\n\n\n }\n\n\npublic byte[] encrypt(String string)    {\n    Cipher aes = null;\n    try {\n        aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n\n    aes.init(Cipher.ENCRYPT_MODE, key);\n    ciphertext = aes.doFinal(string.getBytes());\n\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    }\n\n    return ciphertext;\n}\n\npublic String decrypt(byte[] ciphertext)    {\n\n    Cipher aes = null;\n    String cleartext =null;\n\n\n    try {\n        aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        aes.init(Cipher.DECRYPT_MODE, key);\n        cleartext = new String(aes.doFinal(ciphertext));\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    }\n\n    return cleartext;\n}\n\n}\n", "File cert = new File(\"mnt/sdcard/\" + filename + \".p12\");\nInputStream inputStreamFromDownload = null;\n\nkeyStore = KeyStore.getInstance(\"PKCS12\");\ninputStreamFromDownload = new BufferedInputStream(new FileInputStream(cert));\n\nLog.i(\"Certificate\", inputStreamFromDownload.available() + \"\");\n", "        KeyStore trustStore;\n        try {\n            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            trustStore.load(null, null);\n            SSLSocketFactory sf = new EasySSLSocketFactory(trustStore);\n            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n            BasicHttpParams params = new BasicHttpParams();\n            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n            SchemeRegistry registry = new SchemeRegistry();\n            registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n            registry.register(new Scheme(\"https\", sf, 443));\n            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);\n            DefaultHttpClient httpClient = new DefaultHttpClient(ccm, params);\n            HttpsURLConnection.setDefaultHostnameVerifier(sf.getHostnameVerifier());\n            HttpGet getRequest = new HttpGet(url);\n            BasicHttpParams httpParameters = new BasicHttpParams();\n            int timeoutConnection = 10000;\n            HttpConnectionParams.setConnectionTimeout(httpParameters, timeoutConnection);\n            int timeoutSocket = 15000;\n            HttpConnectionParams.setSoTimeout(httpParameters, timeoutSocket);\n            httpClient.setParams(httpParameters);\n            HttpResponse getResponse = httpClient.execute(getRequest);\n            final int statusCode = getResponse.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) \n            { \n                return null;\n            }\n            HttpEntity getResponseEntity = getResponse.getEntity();\n            String content = EntityUtils.toString(getResponseEntity);\n            InputStream is = new ByteArrayInputStream(content.getBytes(\"UTF-8\"));\n            return is;\n        } catch (KeyStoreException e1) {\n            e1.printStackTrace();\n        } catch (ParseException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (KeyManagementException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        }\n    return null;\n", "cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv)); \nciphertext = cipher.doFinal(imageByte);\n", "   KeyStore ks = KeyStore.getInstance();\n // get the names of all keys created by our app\n String[] keyNames = ks.saw(\"\");\n\n // store a symmetric key in the keystore\n SecretKey key = Crypto.generateKey();\n boolean success = ks.put(\"secretKey1\", key.getEncoded());\n // check if operation succeeded and get error code if not\n if (!success) {\n    int errorCode = ks.getLastError();\n    throw new RuntimeException(\"Keystore error: \" + errorCode); \n }\n\n // get a key from the keystore\n byte[] keyBytes = ks.get(\"secretKey1\");\n SecretKey key = new SecretKeySpec(keyBytes, \"AES\");\n\n // delete a key\n boolean success = ks.delete(\"secretKey1\");\n", "KeyStore keyStore_manager = KeyStore.getInstance(KeyStore.getDefaultType());\nkeyStore_manager.load(_context.getAssets().open(your_keystore),password.toCharArray());\nKeyStore keyStore_trust = KeyStore.getInstance(KeyStore.getDefaultType());\nkeyStore_trust.load(_context.getAssets().open(your_trustore),password.toCharArray());\nKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkeyManagerFactory.init(keyStore_manager, password.toCharArray());\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init(keyStore_trust);\nHttpsURLConnection.setDefaultHostnameVerifier(new NullHostNameVerifier());\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(keyManagerFactory.getKeyManagers(),tmf.getTrustManagers(), null);\nHttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\nURL url = new URL(your_url);\nHttpsURLConnection urlConnection = (HttpsURLConnection) requestedUrl.openConnection();\nif (urlConnection instanceof HttpsURLConnection)\n{\n    ((HttpsURLConnection) urlConnection).setSSLSocketFactory(sslContext\n            .getSocketFactory());\n}\nurlConnection.setRequestMethod(\"GET\");\nurlConnection.setConnectTimeout(1500);\nurlConnection.connect();\nString data = \"\";\nint http_status = urlConnection.getResponseCode();\nif (http_status == 200)\n{\n//read data sent from server\n    InputStream response = new BufferedInputStream(\n\n    urlConnection.getInputStream());\n\n    int bytesRead = -1;\n    byte[] buffer = new byte[30 * 1024];\n    while ((bytesRead = response.read(buffer)) &gt; 0)\n    {\n        data = new String(buffer, 0, bytesRead);\n    }\n\n}\nurlConnection.disconnect();\n", "    try {\n\n        PackageInfo info = getPackageManager().getPackageInfo(\n                    \"Your PAckage here\", \n                        PackageManager.GET_SIGNATURES);\n                for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n    //              //              System.out.println(\"KEY HASH..........\"+Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                }\n            } catch (NameNotFoundException e) {\n                System.out.println(\"name not found....\"+e);\n            } catch (NoSuchAlgorithmException e) {\n                System.out.println(\"NoSuchAlgorithmException....\"+e);\n            }\n", "private final static String algorithm = \"PBKDF2WithHmacSHA1\";\n\nprivate final static String HEX = \"0123456789ABCDEF\";\n\nprivate static final String CP_ALGORITH = \"AES\";\nprivate static final String CP_KEY = \"PUTsomeKEYinHere\";\n\npublic static String cipher(String cipherKey, String data) throws NoSuchAlgorithmException, \n                    InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, \n                    IllegalBlockSizeException, BadPaddingException {\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(algorithm);\n    KeySpec spec = new PBEKeySpec(cipherKey.toCharArray(), cipherKey.getBytes(), 128, 256);\n    SecretKey tmp = skf.generateSecret(spec);\n    SecretKey key = new SecretKeySpec(tmp.getEncoded(), CP_ALGORITH);\n    Cipher cipher = Cipher.getInstance(CP_ALGORITH);\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    return toHex(cipher.doFinal(data.getBytes()));\n}\n\npublic static String decipher(String cipherKey, String data) throws NoSuchAlgorithmException, \n                        InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, \n                        IllegalBlockSizeException, BadPaddingException {\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(algorithm);\n    KeySpec spec = new PBEKeySpec(cipherKey.toCharArray(), cipherKey.getBytes(), 128, 256);\n    SecretKey tmp = skf.generateSecret(spec);\n    SecretKey key = new SecretKeySpec(tmp.getEncoded(), CP_ALGORITH);\n    Cipher cipher = Cipher.getInstance(CP_ALGORITH);\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    return new String(cipher.doFinal(toByte(data)));\n}\n\nprivate static byte[] toByte(String data) throws NullPointerException{\n    int len = data.length()/2;\n    byte[] result = new byte[len];\n    for (int i = 0; i &lt; len; i++)\n        result[i] = Integer.valueOf(data.substring(2*i, 2*i+2), 16).byteValue();\n    return result;\n}\n\nprivate static String toHex(byte[] doFinal) {\n    StringBuffer result = new StringBuffer(2*doFinal.length);\n    for (int i = 0; i &lt; doFinal.length; i++) {\n        result.append(HEX.charAt((doFinal[i]&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(doFinal[i]&amp;0x0f));\n    }\n    return result.toString();\n}\n", "import android.content.pm.Signature;\n\n      try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                **\"do not forgot to your package name\"**, PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.d(\"KeyHash:\",\n                    Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n\n\n\nOR \n\n1. for Android default keystore  : add this to in your terminal \n\u00c2\u00a0\nkeytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64\n\n2. for signed keystore \n\nkeytool -exportcert -alias aliasname -keystore keystorename | openssl sha1 -binary | openssl base64\n", "HttpsURLConnection.setDefaultHostnameVerifier(new NullHostNameVerifier());\nSSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, new X509TrustManager[]{new NullX509TrustManager()}, new SecureRandom());\nHttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n", "public static void main(String[] args) throws Exception\n{\n    // Initialise secret key with predefined byte array [] like below. I\n    // have used simple string to array method to generate 16 byte array.\n    // AES Key must be minimum 16 bytes.\n    // Now you can put this byte array some where is .SO file.\n    // Generate new Key using this byte []\n    // Then you can generate a key using device specific information at\n    // first boot up.\n    // Use second key to encrypt data and first key to encrypt the second\n    // key\n    // I Hope it clears all the doubts\n    SecretKey key = new SecretKeySpec(\"ABCDEFGHIJKLMNOP\".getBytes(), \"AES\");\n    System.out.println(Arrays.toString(key.getEncoded()));\n    // Initialise Cipher with AES Algorithm\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    // Set The Encrypt Mode\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    // Encrypt some bytes\n    byte[] encrypted = cipher.doFinal(\"ABCDEFGH\".getBytes());\n    // Print it to vefiry\n    System.out.println(Arrays.toString(encrypted));\n\n    // Get The IV\n    byte[] iv = cipher.getIV();\n    System.out.println(iv.length);\n    // Now why storing you can create structure like [16 IV][Encrypted Data]\n    // And while decrypting you can read first [16] bytes IV and then\n    // decrypt remaining bytes\n\n    //byte[] iv = new byte[16];\n    // System.arraycopy(encrypted, 0, iv, 0, 16)\n    //Copy remaining bytes to decrypt\n\n\n    // set cipher to decrypt mode\n\n    cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(iv));\n\n    // decrypt it\n    byte[] decrypted = cipher.doFinal(encrypted);\n    System.out.println(new String(decrypted));\n\n}\n", "public byte[] passwordToHash(String password) {\n    if (password == null) {\n        return null;\n    }\n    String algo = null;\n    byte[] hashed = null;\n    try {\n        byte[] saltedPassword = (password + getSalt()).getBytes();\n        byte[] sha1 = MessageDigest.getInstance(algo = \"SHA-1\").digest(saltedPassword);\n        byte[] md5 = MessageDigest.getInstance(algo = \"MD5\").digest(saltedPassword);\n        hashed = (toHex(sha1) + toHex(md5)).getBytes();\n    } catch (NoSuchAlgorithmException e) {\n        Log.w(TAG, \"Failed to encode string because of missing algorithm: \" + algo);\n    }\n    return hashed;\n}\n", "import java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.jivesoftware.smack.SASLAuthentication;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.packet.Packet;\nimport org.jivesoftware.smack.sasl.SASLMechanism;\nimport org.jivesoftware.smack.util.Base64;\n\nimport de.measite.smack.Sasl;\n\npublic class SASLXOAuth2Mechanism extends SASLMechanism\n{\n    static final String AUTHENTICATOR_URL = \"http://www.google.com/talk/protocol/auth\";\n    protected String authenticationText = null;\n    static final String TAG = \"SASLXOAuth2Mechanism\";\n\n    public SASLXOAuth2Mechanism(SASLAuthentication saslAuthentication) {\n        super(saslAuthentication);\n    }\n\n    @Override\n    protected String getName()\n    {\n        return \"X-OAUTH2\";\n    }\n\n    @Override\n    public void authenticate(String username, String host, String password) throws IOException, XMPPException {\n        this.password = password;\n        this.authenticationId = username;\n\n        StringBuilder credentials = new StringBuilder();\n        credentials.append(\"\\0\");\n        credentials.append(username);\n        credentials.append(\"\\0\");\n        credentials.append(password);\n        authenticationText = Base64.encodeBytes(credentials.toString().getBytes(\"UTF-8\"), Base64.DONT_BREAK_LINES);\n\n        String[] mechanisms = { \"PLAIN\" };\n        Map&lt;String,String&gt; props = new HashMap&lt;String,String&gt;();\n        sc = Sasl.createSaslClient(mechanisms, username, \"xmpp\", host, props, this);\n        authenticate();\n    }\n\n    protected void authenticate() throws IOException, XMPPException {\n        // Send the authentication to the server\n        getSASLAuthentication().send(new XOAuth2AuthMechanism(getName(), authenticationText));\n    }\n\n    /**\n     * Initiating SASL authentication by select a mechanism.\n     */\n    public class XOAuth2AuthMechanism extends Packet {\n        final private String name;\n        final private String authenticationText;\n\n        public XOAuth2AuthMechanism(String name, String authenticationText) {\n            super();\n            this.name = name;\n            this.authenticationText = authenticationText;\n        }\n\n        public String toXML() {\n            StringBuilder stanza = new StringBuilder();\n            stanza.append(\"&lt;auth mechanism=\\\"\").append(name);\n            stanza.append(\"\\\" xmlns=\\\"urn:ietf:params:xml:ns:xmpp-sasl\\\" auth:service=\\\"oauth2\\\" xmlns:auth=\\\"\").append(AUTHENTICATOR_URL);\n            stanza.append(\"\\\"&gt;\");\n            if (authenticationText != null) {\n                stanza.append(authenticationText);\n            }\n            stanza.append(\"&lt;/auth&gt;\");\n            return stanza.toString();\n        }\n    }\n}\n", "// This can be any protocol supported by your target devices.\n// For example \"TLSv1.2\" is supported by the latest versions of Android\nfinal String SSL_PROTOCOL = \"TLS\";\n\ntry {               \n   sslContext = SSLContext.getInstance(SSL_PROTOCOL);\n\n   // Initialize the context with your key manager and the default trust manager \n   // and randomness source\n   sslContext.init(keyManagerFactory.getKeyManagers(), null, null);\n} catch (NoSuchAlgorithmException e) {\n   Log.e(TAG, \"Specified SSL protocol not supported! Protocol=\" + SSL_PROTOCOL);\n   e.printStackTrace();\n} catch (KeyManagementException e) {\n   Log.e(TAG, \"Error setting up the SSL context!\");\n   e.printStackTrace();\n}\n\n// Get the socket factory\nsocketFactory = sslContext.getSocketFactory();\n", "    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    keyGen.init(128); // or 256\n\n    // Generate the secret key specs\n    SecretKey secretKey = keyGen.generateKey();\n    byte[] byteArray = secretKey.getEncoded();\n", "PackageInfo packageInfo = null;\n\ntry {\n   packageInfo = getPackageManager().getPackageInfo(getPackageName(), \n                                           PackageManager.GET_SIGNATURES);\n\n   Signature[] signatures = packageInfo.signatures;\n   byte[] cert = signatures[0].toByteArray();\n   InputStream input = new ByteArrayInputStream(cert);\n\n   CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n   X509Certificate c = (X509Certificate)cf.generateCertificate(input);\n\n   PublicKey key = c.getPublicKey();\n\n   ...   \n\n} catch ( Exception e) {\n        e.printStackTrace();\n}\n", "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n// Some of these exist in more than one package, be careful to include these\nimport java.security.GeneralSecurityException;\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateFactory;\n\n// This would reference to your KeyStore to store the certificate\nKeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\nks.load(null);             // This will make a new store\n// In the next line, specify the file path\n// You can also export the destination certificate (in your case, Paypal's)\n// put it as a hardcoded `String` and work with it.\nInputStream is = ...;\nBufferedInputStream bis = new BufferedInputStream(is);\n\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n\nwhile (bis.available() &gt; 0) {\n  Certificate cert = cf.generateCertificate(bis);\n  trustStore.setCertificateEntry(\"myAlias\" + bis.available(), cert);\n}\n", "@SuppressLint(\"NewApi\")\npublic static void getApplicationSignature(Activity activity){\n    try {\n        PackageInfo info = activity.getPackageManager().getPackageInfo(\"your.package.name.here\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.e(\"MY KEY HASH:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n}\n", "byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, }; // use different random value\nAlgorithmParameterSpec algorithmSpec = new IvParameterSpec(iv);\nCipher ecipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\necipher.init(Cipher.ENCRYPT_MODE, skeySpec, algorithmSpec);\n", "import java.security.NoSuchAlgorithmException;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.NoSuchPaddingException;\n    import javax.crypto.spec.IvParameterSpec;\n    import javax.crypto.spec.SecretKeySpec;\n\n    public class MCrypt {\n\n        private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n        private IvParameterSpec ivspec;\n        private SecretKeySpec keyspec;\n        private Cipher cipher;\n\n        private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n        public MCrypt()\n        {\n            ivspec = new IvParameterSpec(iv.getBytes());\n\n            keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n            try {\n                cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (NoSuchPaddingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        public byte[] encrypt(String text) throws Exception\n        {\n            if(text == null || text.length() == 0)\n                throw new Exception(\"Empty string\");\n\n            byte[] encrypted = null;\n\n            try {\n                cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                encrypted = cipher.doFinal(padString(text).getBytes());\n            } catch (Exception e)\n            {           \n                throw new Exception(\"[encrypt] \" + e.getMessage());\n            }\n\n            return encrypted;\n        }\n\n        public byte[] decrypt(String code) throws Exception\n        {\n            if(code == null || code.length() == 0)\n                throw new Exception(\"Empty string\");\n\n            byte[] decrypted = null;\n\n\n            try {\n                cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n                decrypted = cipher.doFinal(hexToBytes(code));\n                if( decrypted.length &gt; 0)\n                {\n                    int trim = 0;\n                    for( int i = decrypted.length - 1; i &gt;= 0; i-- ) if( decrypted[i] == 0 ) trim++;\n\n                    if( trim &gt; 0 )\n                    {\n                        byte[] newArray = new byte[decrypted.length - trim];\n                        System.arraycopy(decrypted, 0, newArray, 0, decrypted.length - trim);\n                        decrypted = newArray;\n                    }\n                }\n            } catch (Exception e)\n            {\n                throw new Exception(\"[decrypt] \" + e.getMessage());\n            }\n            return decrypted;\n        }\n\n\n\n        public static String bytesToHex(byte[] data)\n        {\n            if (data==null)\n            {\n                return null;\n            }\n\n            int len = data.length;\n            String str = \"\";\n            for (int i=0; i&lt;len; i++) {\n                if ((data[i]&amp;0xFF)&lt;16)\n                    str = str + \"0\" + java.lang.Integer.toHexString(data[i]&amp;0xFF);\n                else\n                    str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);\n            }\n            return str;\n        }\n\n\n        public static byte[] hexToBytes(String str) {\n            if (str==null) {\n                return null;\n            } else if (str.length() &lt; 2) {\n                return null;\n            } else {\n                int len = str.length() / 2;\n                byte[] buffer = new byte[len];\n                for (int i=0; i&lt;len; i++) {\n                    buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                }\n                return buffer;\n            }\n        }\n\n\n\n        private static String padString(String source)\n        {\n          char paddingChar = ' ';\n          int size = 16;\n          int x = source.length() % size;\n          int padLength = size - x;\n\n          for (int i = 0; i &lt; padLength; i++)\n          {\n              source += paddingChar;\n          }\n\n          return source;\n        }\n    }\n", "public static void main(String[] args) throws DataLengthException, IllegalStateException, InvalidCipherTextException {\n\n    // just some constants\n    boolean ENCRYPT = true;\n    boolean DECRYPT = false;\n\n    // the key is either in binary in PHP or a string (dynamic isn't it?), lets assume ASCII\n    byte[] givenKey = args[0].getBytes(Charset.forName(\"ASCII\"));\n\n    // determine the key size dynamically, somebody thought this was a good idea...\n    // NOTE: PHP will emit a warning if the key size is larger, but will simply use the\n    // largest key size otherwise\n    final int keysize;\n    if (givenKey.length &lt;= 128 / Byte.SIZE) {\n        keysize = 128;\n    } else if (givenKey.length &lt;= 192 / Byte.SIZE) {\n        keysize = 192;\n    } else {\n        keysize = 256;\n    }\n\n    // create a 256 bit key by adding zero bytes to the decoded key\n    byte[] keyData = new byte[keysize / Byte.SIZE];\n    System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));\n    KeyParameter key = new KeyParameter(keyData);\n\n    // create a Rijndael cipher with 256 bit block size, this is not AES\n    BlockCipher rijndael = new RijndaelEngine(256);\n\n    // use a padding method that only works on data that cannot end with zero valued bytes\n    ZeroBytePadding c = new ZeroBytePadding();\n\n    // use ECB mode encryption, which should never be used\n    PaddedBufferedBlockCipher pbbc = new PaddedBufferedBlockCipher(rijndael, c);\n\n    // initialize the cipher using the key (no need for an IV, this is ECB)\n    pbbc.init(ENCRYPT, key);\n\n    // create a plain text byte array\n    byte[] plaintext = args[1].getBytes(Charset.forName(\"UTF8\"));\n\n    // create a buffer for the ciphertext\n    byte[] ciphertext = new byte[pbbc.getOutputSize(plaintext.length)];\n\n    int offset = 0;\n    offset += pbbc.processBytes(plaintext, 0, plaintext.length, ciphertext, offset);\n    offset += pbbc.doFinal(ciphertext, offset);\n\n    // show the ciphertext\n    System.out.println(new String(Hex.encode(ciphertext), Charset.forName(\"ASCII\")));\n\n    // reverse the encryption\n    pbbc.init(DECRYPT, key);\n    byte[] decrypted = new byte[pbbc.getOutputSize(ciphertext.length)];\n    offset = 0;\n    offset += pbbc.processBytes(ciphertext, 0, ciphertext.length, decrypted, offset);\n    offset += pbbc.doFinal(decrypted, offset);\n\n    // this will probably print out correctly, but it isn't actually correct\n    System.out.println(new String(decrypted, Charset.forName(\"UTF8\")));\n\n    // check out the zero's at the end\n    System.out.println(new String(Hex.encode(decrypted), Charset.forName(\"UTF8\")));\n\n    // so lets make it a bit shorter... the PHP way\n    // note that in PHP, the string may *not* contain a null terminator\n    // add it yourself before printing the string\n    System.out.println(new String(decrypted, Charset.forName(\"UTF8\")).replaceAll(\"\\\\x00+$\", \"\"));\n}\n", "public class DeviceInfo {\n\nprotected static String imeiNumber;\nprotected static String wifiMacAddress;\nprotected static String deviceID;\n\n// This method must be called before other method\npublic static void init(Context context) throws Exception {\n    imeiNumber = getImei(context);\n    wifiMacAddress = getWifiMacAddress(context);\n    deviceID = getDeviceId(context);\n}\n\npublic static String getDeviceInfo() {\n    return deviceID;\n}\n\npublic static String getImei() {\n    return imeiNumber;\n}\n\npublic static String getWifiMacAddress() {\n    return wifiMacAddress;\n}\n\npublic static String getModel() {\n    return Build.MODEL;\n}\n\npublic static String getOsVersion() {\n    return Build.VERSION.RELEASE;\n}\n\nprotected static String getDeviceId(Context context) throws Exception {\n    String imei = getImei(context);\n    if (imei != null) return imei;\n    String tid = getWifiMacAddress(context);\n    return tid;\n}\n\nprotected static String getWifiMacAddress(Context context) throws Exception {\n    WifiManager manager = (WifiManager) context\n            .getSystemService(Context.WIFI_SERVICE);\n    WifiInfo wifiInfo = manager.getConnectionInfo();\n    if (wifiInfo == null || wifiInfo.getMacAddress() == null)\n        return md5(UUID.randomUUID().toString());\n    else return wifiInfo.getMacAddress().replace(\":\", \"\").replace(\".\", \"\");\n}\n\nprotected static String getImei(Context context) {\n    TelephonyManager m = (TelephonyManager) context\n            .getSystemService(Context.TELEPHONY_SERVICE);\n    String imei = m != null ? m.getDeviceId() : null;\n    return imei;\n}\n\nprotected static String md5(String s) throws Exception {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n    md.update(s.getBytes());\n\n    byte digest[] = md.digest();\n    StringBuffer result = new StringBuffer();\n\n    for (int i = 0; i &lt; digest.length; i++) {\n        result.append(Integer.toHexString(0xFF &amp; digest[i]));\n    }\n    return (result.toString());\n}\n}\n", "if(Build.VERSION.SDK_INT&lt;16)\n    sslContext = SSLContext.getInstance(\"TLS\");\nelse\n    sslContext = SSLContext.getInstance(\"TLSv1.2\");\n", "zerorize(SecretKey key)\n{\n    byte[] rawKey = key.getEncoded();\n    Arrays.fill(rawKey, (byte) 0xFF);\n    Arrays.fill(rawKey, (byte) 0xAA);\n    Arrays.fill(rawKey, (byte) 0x55);\n    Arrays.fill(rawKey, (byte) 0x00);\n}\n", "// Trust manager / truststore\nKeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());\n\n// If we're on an OS version prior to Ice Cream Sandwich (4.0) then use the standard way to get the system\n//   trustStore -- System.getProperty() else we need to use the special name to get the trustStore KeyStore\n//   instance as they changed their trustStore implementation.\nif (Build.VERSION.RELEASE.compareTo(\"4.0\") &lt; 0) {\n    TrustManagerFactory trustManagerFactory=TrustManagerFactory\n        .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    FileInputStream trustStoreStream=new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\"));\n    trustStore.load(trustStoreStream, null);\n    trustManagerFactory.init(trustStore);\n    trustStoreStream.close();\n} else {\n    trustStore=KeyStore.getInstance(\"AndroidCAStore\");\n}\n\nInputStream certificateStream=new FileInputStream(userCertFile);\nKeyStore keyStore=KeyStore.getInstance(\"PKCS12\");\ntry {\n    keyStore.load(certificateStream, certPass.toCharArray());\n    Enumeration&lt;String&gt; aliases=keyStore.aliases();\n    while (aliases.hasMoreElements()) {\n        String alias=aliases.nextElement();\n        if (keyStore.getCertificate(alias).getType().equals(\"X.509\")) {\n            X509Certificate cert=(X509Certificate)keyStore.getCertificate(alias);\n            if (new Date().after(cert.getNotAfter())) {\n                // This certificate has expired\n                return;\n            }\n        }\n    }\n} catch (IOException ioe) {\n    // This occurs when there is an incorrect password for the certificate\n    return;\n} finally {\n    certificateStream.close();\n}\n\nKeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\nkeyManagerFactory.init(keyStore, certPass.toCharArray());\n\nsocketFactory=new SSLSocketFactory(keyStore, certPass, trustStore);\n", "    SecretKeyFactory keyFactory = null;\n    try\n    {\n        keyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    } \n    catch (NoSuchAlgorithmException e)\n", "public ClientConnectionManager createClientConnectionManager() {\n    SchemeRegistry registry = new SchemeRegistry();\n    registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n    // Register for port 443 our SSLSocketFactory with our keystore\n    // to the ConnectionManager\n    registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n    return new SingleClientConnManager(getParams(), registry);\n}\n\npublic SSLSocketFactory newSslSocketFactory() {\n    try {\n        // Get an instance of the Bouncy Castle KeyStore format\n        KeyStore trusted = KeyStore.getInstance(\"BKS\");\n        // Get the raw resource, which contains the keystore with\n        // your trusted certificates (root and any intermediate certs)\n        InputStream in = context.getResources().openRawResource(R.raw.mykeystore);\n        try {\n            // Initialize the keystore with the provided trusted certificates\n            // Also provide the password of the keystore\n            trusted.load(in, \"my_password\".toCharArray());\n        } finally {\n            in.close();\n        }\n        // Pass the keystore to the SSLSocketFactory. The factory is responsible\n        // for the verification of the server certificate.\n        SSLSocketFactory sf = new SSLSocketFactory(trusted);\n        // Hostname verification from certificate\n        // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506\n        sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n        return sf;\n    } catch (Exception e) {\n        throw new AssertionError(e);\n    }\n}\n", "package com.emailsender;\n\nimport java.security.AccessController;\n\nimport java.security.Provider;\n\n\n\npublic final class JSSEProvider extends Provider {\n\n\n\npublic JSSEProvider() {\n\nsuper(\"HarmonyJSSE\", 1.0, \"Harmony JSSE Provider\");\n\n       AccessController\n\n               .doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {\n\n                   public Void run() {\n\n                       put(\"SSLContext.TLS\",\n\n                               \"org.apache.harmony.xnet.provider.jsse.SSLContextImpl\");\n\n                       put(\"Alg.Alias.SSLContext.TLSv1\", \"TLS\");\n\n                       put(\"KeyManagerFactory.X509\",\n\n                               \"org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl\");\n\n                       put(\"TrustManagerFactory.X509\",\n\n                               \"org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl\");\n\n                       return null;\n\n                   }\n\n               });\n\n   }\n\n}\n", "package com.emailsender;\n\nimport javax.activation.DataHandler;\n\nimport javax.activation.DataSource;\n\nimport javax.activation.FileDataSource;\n\nimport javax.mail.BodyPart;\n\nimport javax.mail.Message;\n\nimport javax.mail.Multipart;\n\nimport javax.mail.PasswordAuthentication;\n\nimport javax.mail.Session;\n\nimport javax.mail.Transport;\n\nimport javax.mail.internet.InternetAddress;\n\nimport javax.mail.internet.MimeBodyPart;\n\nimport javax.mail.internet.MimeMessage;\n\nimport javax.mail.internet.MimeMultipart;  \n\nimport java.io.ByteArrayInputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.OutputStream;\n\nimport java.security.Security;\n\nimport java.util.Properties;\n\n\npublic class GMailSender extends javax.mail.Authenticator {\n\nprivate String mailhost = \"smtp.gmail.com\";\n\n    private String user;\n\n    private String password;\n\n    private Session session;\n\n\n\n    private Multipart _multipart = new MimeMultipart();\n\n    static {\n\n        Security.addProvider(new  shooreshi.fayyaz.ghariebartar.JSSEProvider());\n\n    }\n\n\n\n    public GMailSender(String user, String password) {\n\n        this.user = user;\n\n        this.password = password;\n\n\n\n        Properties props = new Properties();\n\n        props.setProperty(\"mail.transport.protocol\", \"smtp\");\n\n        props.setProperty(\"mail.host\", mailhost);\n\n        props.put(\"mail.smtp.auth\", \"true\");\n\n        props.put(\"mail.smtp.port\", \"465\");\n\n        props.put(\"mail.smtp.socketFactory.port\", \"465\");\n\n        props.put(\"mail.smtp.socketFactory.class\",\n\n                \"javax.net.ssl.SSLSocketFactory\");\n\n        props.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n\n        props.setProperty(\"mail.smtp.quitwait\", \"false\");\n\n\n\n        session = Session.getDefaultInstance(props, this);\n\n    }\n\n\n\n    protected PasswordAuthentication getPasswordAuthentication() {\n\n        return new PasswordAuthentication(user, password);\n\n    }\n\n\n\n    public synchronized void sendMail(String subject, String body,\n\n            String sender, String recipients) throws Exception {\n\n        try {\n\n            MimeMessage message = new MimeMessage(session);\n\n            DataHandler handler = new DataHandler(new ByteArrayDataSource(\n\n                    body.getBytes(), \"music\"));\n\n            message.setSender(new InternetAddress(sender));\n\n            message.setSubject(subject);\n\n            message.setDataHandler(handler);\n\n            BodyPart messageBodyPart = new MimeBodyPart();\n\n            messageBodyPart.setText(body);\n\n            _multipart.addBodyPart(messageBodyPart);\n\n\n\n            // Put parts in message\n\n            message.setContent(_multipart);\n\n            if (recipients.indexOf(',') &gt; 0)\n\n                message.setRecipients(Message.RecipientType.TO,\n\n                        InternetAddress.parse(recipients));\n\n            else\n\n                message.setRecipient(Message.RecipientType.TO,\n\n                        new InternetAddress(recipients));\n\n            Transport.send(message);\n\n        } catch (Exception e) {\n\n\n\n        }\n\n    }\n\n\n\n    public void addAttachment(String filename) throws Exception {\n\n        BodyPart messageBodyPart = new MimeBodyPart();\n\n        DataSource source = new FileDataSource(filename);\n\n        messageBodyPart.setDataHandler(new DataHandler(source));\n\n        messageBodyPart.setFileName(\"music.mp3\");\n\n\n\n        _multipart.addBodyPart(messageBodyPart);\n\n    }\n\n\n\n    public class ByteArrayDataSource implements DataSource {\n\n        private byte[] data;\n\n        private String type;\n\n\n\n\n\n        public ByteArrayDataSource(byte[] data, String type) {\n\n            super();\n\n            this.data = data;\n\n            this.type = type;\n\n        }\n\n\n\n        public ByteArrayDataSource(byte[] data) {\n\n            super();\n\n            this.data = data;\n\n        }\n\n\n\n\n\n        public void setType(String type) {\n\n            this.type = type;\n\n        }\n\n\n\n        public String getContentType() {\n\n            if (type == null)\n\n                return \"application/octet-stream\";\n\n            else\n\n                return type;\n\n        }\n\n\n\n        public InputStream getInputStream() throws IOException {\n\n            return new ByteArrayInputStream(data);\n\n        }\n\n\n\n        public String getName() {\n\n            return \"ByteArrayDataSource\";\n\n        }\n\n\n\n        public OutputStream getOutputStream() throws IOException {\n\n            throw new IOException(\"Not Supported\");\n\n        }\n\n    }\n\n}\n", "import java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageInfo;\r\nimport android.content.pm.PackageManager;\r\nimport android.content.pm.PackageManager.NameNotFoundException;\r\nimport android.content.pm.Signature;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.os.Bundle;\r\nimport android.support.v7.app.ActionBarActivity;\r\nimport android.util.Base64;\r\nimport android.util.Log;\r\nimport android.view.View;\r\nimport android.view.View.OnClickListener;\r\nimport android.widget.Button;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\n\r\nimport com.facebook.Request;\r\nimport com.facebook.Response;\r\nimport com.facebook.Session;\r\nimport com.facebook.SessionState;\r\nimport com.facebook.UiLifecycleHelper;\r\nimport com.facebook.model.GraphUser;\r\nimport com.facebook.widget.LoginButton;\r\nimport com.facebook.widget.LoginButton.UserInfoChangedCallback;\r\n\r\n\r\npublic class ShareHelper extends ActionBarActivity{\r\n\r\n     private LoginButton loginBtn;\r\n     private Button updateStatusBtn;\r\n  \r\n     private TextView fbquote;\r\n     \r\n     private TextView userName;\r\n  \r\n     private UiLifecycleHelper uiHelper;\r\n  \r\n     private static final List&lt;String&gt; PERMISSIONS = Arrays.asList(\"publish_actions\");\r\n     \r\n     private String message;\r\n     \r\n     public void onCreate(Bundle savedInstanceState) {\r\n         super.onCreate(savedInstanceState);\r\n         \r\n      // Add code to print out the key hash\r\n         try {\r\n             PackageInfo info = getPackageManager().getPackageInfo(\r\n                     \"com.facebook.samples.hellofacebook\", \r\n                     PackageManager.GET_SIGNATURES);\r\n             for (Signature signature : info.signatures) {\r\n                 MessageDigest md = MessageDigest.getInstance(\"SHA\");\r\n                 md.update(signature.toByteArray());\r\n                 Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\r\n                 }\r\n         } catch (NameNotFoundException e) {\r\n\r\n         } catch (NoSuchAlgorithmException e) {\r\n\r\n         }\r\n\r\n         \r\n         Intent intent = getIntent();\r\n      \r\n      message = intent.getStringExtra(\"quote\");     \r\n    \r\n  \r\n         uiHelper = new UiLifecycleHelper(this, statusCallback);\r\n         uiHelper.onCreate(savedInstanceState);\r\n  \r\n         setContentView(R.layout.sharehelper_activity);\r\n     \r\n         fbquote = (TextView)findViewById(R.id.FbTextView);\r\n         fbquote.setText(message);\r\n         \r\n         userName = (TextView) findViewById(R.id.user_name);\r\n         loginBtn = (LoginButton) findViewById(R.id.fb_login_button);\r\n         loginBtn.setUserInfoChangedCallback(new UserInfoChangedCallback() {\r\n             @Override\r\n             public void onUserInfoFetched(GraphUser user) {\r\n                 if (user != null) {\r\n                     userName.setText(\"Hello, \" + user.getName());\r\n                 } else {\r\n                     userName.setText(\"You are not logged\");\r\n                 }\r\n             }\r\n         });\r\n  \r\n         updateStatusBtn = (Button) findViewById(R.id.update_status);\r\n         updateStatusBtn.setOnClickListener(new OnClickListener() {\r\n  \r\n             @Override\r\n             public void onClick(View v) {\r\n              postStatusMessage();\r\n             }\r\n         });\r\n  \r\n         buttonsEnabled(false);\r\n     }\r\n  \r\n     private Session.StatusCallback statusCallback = new Session.StatusCallback() {\r\n         @Override\r\n         public void call(Session session, SessionState state,\r\n                 Exception exception) {\r\n             if (state.isOpened()) {\r\n                 buttonsEnabled(true);\r\n                 Log.d(\"FacebookSampleActivity\", \"Facebook session opened\");\r\n             } else if (state.isClosed()) {\r\n                 buttonsEnabled(false);\r\n                 Log.d(\"FacebookSampleActivity\", \"Facebook session closed\");\r\n             }\r\n         }\r\n     };\r\n  \r\n     public void buttonsEnabled(boolean isEnabled) {\r\n         updateStatusBtn.setEnabled(isEnabled);\r\n     }\r\n  \r\n    \r\n     public void postStatusMessage() {\r\n         if (checkPermissions()) {\r\n             Request request = Request.newStatusUpdateRequest(\r\n                     Session.getActiveSession(), message,\r\n                     new Request.Callback() {\r\n                         @Override\r\n                         public void onCompleted(Response response) {\r\n                             if (response.getError() == null)\r\n                                 Toast.makeText(ShareHelper.this,\r\n                                         \"Quote Shared successfully\",\r\n                                         Toast.LENGTH_LONG).show();\r\n                         }\r\n                     });\r\n             request.executeAsync();\r\n         } else {\r\n             requestPermissions();\r\n         }\r\n     }\r\n  \r\n     public boolean checkPermissions() {\r\n         Session s = Session.getActiveSession();\r\n         if (s != null) {\r\n             return s.getPermissions().contains(\"publish_actions\");\r\n         } else\r\n             return false;\r\n     }\r\n  \r\n     public void requestPermissions() {\r\n         Session s = Session.getActiveSession();\r\n         if (s != null)\r\n             s.requestNewPublishPermissions(new Session.NewPermissionsRequest(\r\n                     this, PERMISSIONS));\r\n     }\r\n  \r\n     @Override\r\n     public void onResume() {\r\n         super.onResume();\r\n         uiHelper.onResume();\r\n         buttonsEnabled(Session.getActiveSession().isOpened());\r\n     }\r\n  \r\n     @Override\r\n     public void onPause() {\r\n         super.onPause();\r\n         uiHelper.onPause();\r\n     }\r\n  \r\n     @Override\r\n     public void onDestroy() {\r\n         super.onDestroy();\r\n         uiHelper.onDestroy();\r\n     }\r\n  \r\n     @Override\r\n     public void onActivityResult(int requestCode, int resultCode, Intent data) {\r\n         super.onActivityResult(requestCode, resultCode, data);\r\n         uiHelper.onActivityResult(requestCode, resultCode, data);\r\n     }\r\n  \r\n     @Override\r\n     public void onSaveInstanceState(Bundle savedState) {\r\n         super.onSaveInstanceState(savedState);\r\n         uiHelper.onSaveInstanceState(savedState);\r\n     }\r\n}", "String encryptKey(String input)\n{\n    byte[] inBytes=input.getBytes();\n    String finalString=null;\n    try {\n        Cipher cipher=Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] keyBytes=md.digest((KeyPart1+KeyPart2).getBytes());\n        keyBytes = Arrays.copyOf(keyBytes, 16);\n        SecretKey key= new SecretKeySpec(keyBytes,\"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(new byte[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0});\n        cipher.init(Cipher.ENCRYPT_MODE,key,ivSpec);\n        byte[] outBytes = new byte[cipher.getOutputSize(inBytes.length)];\n        //cipher.update(encrypted, 0, encrypted.length, decrypted, 0);\n        outBytes=cipher.doFinal(inBytes);\n        finalString=new String(Base64.encode(outBytes,0));\n        Log.v(TAG,\"Encrypted=\"+finalString);\n\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(TAG,\"No Such Algorithm\",e);\n    } catch (NoSuchPaddingException e) {\n        Log.e(TAG,\"No Such Padding\",e);\n    } catch (InvalidKeyException e) {\n        Log.e(TAG,\"Invalid Key\",e);\n    } catch (InvalidAlgorithmParameterException e) {\n        Log.e(TAG,\"Invalid Algorithm Parameter\",e);\n    } catch (IllegalBlockSizeException e) {\n    } catch (BadPaddingException e) {}\n    return finalString;\n}\n\nString decryptKey(String base64Text)\n{\n    byte[] encrypted=Base64.decode(base64Text,0);\n    //encrypted=base64Text.getBytes();\n    String decryptedString=null;\n    try {\n        Cipher cipher=Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] keyBytes=md.digest((KeyPart1+KeyPart2).getBytes());\n        keyBytes = Arrays.copyOf(keyBytes, 16);\n        SecretKey key= new SecretKeySpec(keyBytes,\"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(new byte[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0});\n        cipher.init(Cipher.DECRYPT_MODE,key,ivSpec);\n        byte[] decrypted = new byte[cipher.getOutputSize(encrypted.length)];\n        //cipher.update(encrypted, 0, encrypted.length, decrypted, 0);\n        decrypted=cipher.doFinal(encrypted);\n        decryptedString=new String(decrypted);\n    } catch (NoSuchAlgorithmException e) {\n        logStackTrace(e);\n    } catch (NoSuchPaddingException e) {\n        logStackTrace(e);\n    } catch (InvalidKeyException e) {\n        logStackTrace(e);\n    } catch (InvalidAlgorithmParameterException e) {\n        logStackTrace(e);\n    } catch (IllegalBlockSizeException e) {\n        logStackTrace(e);\n    } catch (BadPaddingException e) {\n        logStackTrace(e);\n    }\n    return decryptedString;\n}\n", "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpCookie;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.net.ssl.HttpsURLConnection;\n\nimport org.apache.commons.codec.binary.Hex;\nimport org.json.simple.JSONObject;\nimport org.json.simple.parser.JSONParser;\nimport org.json.simple.parser.ParseException;\n\npublic class InstagramPostHelper {\n\n    private static InstagramPostHelper instance = null;\n\n    protected InstagramPostHelper() {}\n\n    public static InstagramPostHelper getInstance() {\n        if (instance == null) {\n            instance = new InstagramPostHelper();\n        }\n        return instance;\n    }\n\n    private String GenerateSignature(String value, String key) \n    {\n        String result = null;\n        try {\n            byte[] keyBytes = key.getBytes();\n            SecretKeySpec signingKey = new SecretKeySpec(keyBytes, \"HmacSHA256\");\n            Mac mac = Mac.getInstance(\"HmacSHA256\");\n            mac.init(signingKey);\n            byte[] rawHmac = mac.doFinal(value.getBytes());\n            byte[] hexBytes = new Hex().encode(rawHmac);\n            result = new String(hexBytes, \"UTF-8\");\n    }\n    catch (Exception e) {\n\n    }\n        return result;\n\n    }\n\n    private static final String COOKIES_HEADER = \"Set-Cookie\";\n    public static java.net.CookieManager msCookieManager = new java.net.CookieManager();\n    private HttpsURLConnection conn;\n\n    private static String TextUtilsJoin(CharSequence delimiter, List&lt;HttpCookie&gt; list) {\n            StringBuilder sb = new StringBuilder();\n            boolean firstTime = true;\n            for (Object token: list) {\n\n                if (token.toString().trim().length()&lt;1) continue;\n\n                if (firstTime) {\n                    firstTime = false;\n                } else {\n                    sb.append(delimiter + \" \");\n                }\n\n                sb.append(token);\n\n            }\n            return sb.toString();\n        }\n\n\n    private String GetJSONStringAndPostData(String jsonaddress,String postdata,String agent)\n    {\n        String sonuc = \"\";\n        try {\n\n            byte[] postDataBytes = postdata.toString().getBytes(\"UTF-8\");\n\n\n            URL url = new URL(jsonaddress);\n\n\n            conn = (HttpsURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Length\", String.valueOf(postDataBytes.length));\n            conn.setRequestProperty(\"User-Agent\", agent);\n\n            //Set Cookies\n            if(msCookieManager.getCookieStore().getCookies().size() &gt; 0)\n            {\n              conn.setRequestProperty(\"Cookie\", TextUtilsJoin(\";\",  msCookieManager.getCookieStore().getCookies()));    \n            }\n\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(postDataBytes);\n\n            if (conn.getResponseCode() != 200) {\n                throw new RuntimeException(\"Failed : HTTP error code : \"\n                        + conn.getResponseCode());\n            }\n\n            //Get Cookies\n            Map&lt;String, List&lt;String&gt;&gt; headerFields = conn.getHeaderFields();\n            List&lt;String&gt; cookiesHeader = headerFields.get(COOKIES_HEADER);\n            if(cookiesHeader != null)\n            {\n                for (String cookie : cookiesHeader) \n                {\n                  msCookieManager.getCookieStore().add(null,HttpCookie.parse(cookie).get(0));\n                }               \n            }\n\n\n\n            BufferedReader br = new BufferedReader(new InputStreamReader(\n                (conn.getInputStream())));\n            String output;\n            while ((output = br.readLine()) != null) {\n                sonuc += output;\n            }\n            conn.disconnect();\n          } catch (MalformedURLException e) {\n            return \"\";\n          } catch (IOException e) {\n            return \"\";\n          }\n        return sonuc;\n    }\n\n    public void SendImage(String Caption,byte[] ImageByteArray) throws UnsupportedEncodingException, ParseException\n    {\n        String Agent = \"Instagram 6.21.2 Android (19/4.4.2; 480dpi; 1152x1920; Meizu; MX4; mx4; mt6595; en_US)\";\n        String Guid = java.util.UUID.randomUUID().toString();\n        String DeviceId = \"android-\" + Guid;\n        String Data = \"{\\\"device_id\\\":\\\"\"  +  DeviceId + \"\\\",\\\"guid\\\":\\\"\" + Guid + \"\\\",\\\"username\\\":\\\"MYUSERNAME\\\",\\\"password\\\":\\\"MYPASSWORD\\\",\\\"Content-Type\\\":\\\"application/x-www-form-urlencoded; charset=UTF-8\\\"}\"; \n        String Sig = GenerateSignature(Data, \"25eace5393646842f0d0c3fb2ac7d3cfa15c052436ee86b5406a8433f54d24a5\");\n        Data  = \"signed_body=\" + Sig + \".\" +  URLEncoder.encode(Data, \"UTF-8\") + \"&amp;ig_sig_key_version=4\";\n\n        if (msCookieManager.getCookieStore()!= null)\n        {\n            msCookieManager.getCookieStore().removeAll();\n        }\n        //Login Request\n        String login = GetJSONStringAndPostData(\"https://instagram.com/api/v1/accounts/login/\", Data,Agent);\n\n        JSONParser parser = new JSONParser();\n        Object obj = parser.parse(login);\n        JSONObject jsonObject = (JSONObject) obj;\n        if (((String) jsonObject.get(\"status\")).equals(\"ok\")) //Login SuccessFul\n        {\n            //Login Successful\n            System.out.println(\"Login Successful !\");\n\n           //Post Image\n            String upload = \"\";\n\n            try {\n                final HttpMultipartHelper http = new HttpMultipartHelper(new URL(\"https://instagram.com/api/v1/media/upload/\"));\n                http.addFormField(\"device_timestamp\", Long.toString((new Date()).getTime()));\n                http.addFilePart(\"photo\", ImageByteArray);\n                final byte[] bytes = http.finish();\n                upload = new String(bytes);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n\n            System.out.println(upload);\n            obj = parser.parse(upload);\n            jsonObject = (JSONObject) obj;\n            if (((String) jsonObject.get(\"status\")).equals(\"ok\")) //Login SuccessFul\n            {\n                String mediaID = (String) jsonObject.get(\"media_id\");\n\n                Data = \"{\\\"device_id\\\":\\\"\" + DeviceId + \"\\\",\\\"guid\\\":\\\"\" + Guid + \"\\\",\\\"media_id\\\":\\\"\" + mediaID + \"\\\",\\\"caption\\\":\\\"\" + Caption + \"\\\",\\\"device_timestamp\\\":\\\"\" + Long.toString((new Date()).getTime()).substring(0,10) + \"\\\",\\\"source_type\\\":\\\"5\\\",\\\"filter_type\\\":\\\"0\\\",\\\"extra\\\":\\\"{}\\\",\\\"Content-Type\\\":\\\"application/x-www-form-urlencoded; charset=UTF-8\\\"}\";\n                Sig = GenerateSignature(Data, \"25eace5393646842f0d0c3fb2ac7d3cfa15c052436ee86b5406a8433f54d24a5\");\n\n                Data  = \"signed_body=\" + Sig + \".\" +  URLEncoder.encode(Data, \"UTF-8\") + \"&amp;ig_sig_key_version=6\";\n\n                //Login Request\n                System.out.println(Data);\n                String result = GetJSONStringAndPostData(\"https://instagram.com/api/v1/media/configure/\", Data,Agent);\n\n                System.out.println(result);\n            }\n\n\n        }\n        else //Login UnsuccessFul\n        {\n            System.out.println(\"Login Unsuccessful !\" + login);\n        }\n\n\n    }\n\n}\n", "// derived from https://developer.android.com/google/gcm/ccs.html\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n//import javax.swing.JScrollPane;\n//import javax.swing.SwingUtilities;\n\nimport org.jivesoftware.smack.ConnectionConfiguration;\nimport org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;\nimport org.jivesoftware.smack.ConnectionListener;\nimport org.jivesoftware.smack.PacketInterceptor;\nimport org.jivesoftware.smack.PacketListener;\nimport org.jivesoftware.smack.SmackException;\nimport org.jivesoftware.smack.SmackException.NotConnectedException;\nimport org.jivesoftware.smack.XMPPConnection;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.filter.PacketTypeFilter;\nimport org.jivesoftware.smack.packet.DefaultPacketExtension;\nimport org.jivesoftware.smack.packet.Message;\nimport org.jivesoftware.smack.packet.Packet;\nimport org.jivesoftware.smack.packet.PacketExtension;\nimport org.jivesoftware.smack.provider.PacketExtensionProvider;\nimport org.jivesoftware.smack.provider.ProviderManager;\nimport org.jivesoftware.smack.tcp.XMPPTCPConnection;\nimport org.jivesoftware.smack.util.StringUtils;\nimport org.json.simple.JSONValue;\nimport org.json.simple.JSONObject;\nimport org.json.simple.parser.ParseException;\nimport org.xmlpull.v1.XmlPullParser;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Random;\nimport java.net.*;\nimport java.io.*;\nimport java.util.*;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.HttpsURLConnection;\n\n// list of all users and associated devices\nclass UserList {\n    // (--deleted--)\n\n    // constructor/read existing data from file\n    public UserList() {\n        // (--deleted--)\n    }\n\n    // add a new device to an existing user (called from networking thread)\n    // duplicate IDs are quietly accepted\n    public synchronized void addDevice( String uname, String newRegToken ) {\n        // (--deleted--)\n    }\n\n    // generate a group address/notification key\n    // !!!!!!!!!!!!!!! W A R N I N G !!!!!!!!!!!!!!!\n    //   If the group addr/notification key is lost, it currently CANNOT be recovered/rebuilt\n    public String createNotificationKey( String nKeyName, String addr ) {\n        String[] idset = new String[1];\n        idset[0] = addr;\n\n        String newGroupAddr;\n\n        try {\n            // create a https connection to create the notification_key\n            URL url = new URL( \"https://android.googleapis.com/gcm/notification\" );\n            HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();\n\n            // send as a POST request\n            conn.setRequestMethod(\"POST\");\n\n            // add request parameters\n            conn.addRequestProperty( \"project_id\", \"\"+GcmPushServer.senderId );\n            conn.addRequestProperty( \"Authorization\", \"key=\"+GcmPushServer.password );\n            // use \"set\" since this may already exist\n            conn.setRequestProperty( \"Content-Type\", \"application/json\" );\n\n            // create data to send with request\n            Map&lt;String,Object&gt; sendData = new HashMap&lt;&gt;();\n\n            // create a new notification key\n            sendData.put( \"operation\", \"create\" );\n            sendData.put( \"notification_key_name\", (--deleted--) );\n            sendData.put( \"registration_ids\", (--deleted--) );\n\n            String strData = JSONValue.toJSONString(sendData);\n\n            // Send post request\n            conn.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(conn.getOutputStream());\n            wr.writeBytes( strData );\n            wr.flush();\n            wr.close();\n\n            // successful?\n            int rc = conn.getResponseCode();\n            //System.out.println(\"ResponseCode = \" + rc );\n\n            // read the response\n            Scanner input = new Scanner( conn.getInputStream() );\n            String resp=\"\";\n\n            // read/display lines\n            while( input.hasNextLine() ) {\n                String s = input.nextLine();\n                resp += s;\n            }\n\n            //System.out.println(\"Response content: \" + resp);\n\n            if ( rc == HttpsURLConnection.HTTP_OK ) {\n                JSONObject obj = (JSONObject) JSONValue.parse(resp);\n\n                newGroupAddr = (String) obj.get( \"notification_key\" );\n                //System.out.println(\" new notification_key: \" + newGroupAddr );\n                return newGroupAddr;\n            } else {\n\n            }\n        } catch ( Exception e ) {\n            //System.out.println(\"-- Exception: \" + e.getMessage() );\n        }\n\n        return null;\n    }\n\n    // add/delete a single address to/from a notification key\n    //  (add if doAdd is true, delete otherwise)\n    // removing final address will quietly delete the key\n    public static void modifyNotificationKey( String nKeyName, String nKey,\n                    String addr, boolean doAdd ) {\n        String[] idset = new String[1];\n        idset[0] = addr;\n\n        try {\n            // create a https connection to create the notification_key\n            URL url = new URL( \"https://android.googleapis.com/gcm/notification\" );\n            HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();\n\n            // send as a POST request\n            conn.setRequestMethod(\"POST\");\n\n            // add request parameters\n            conn.addRequestProperty( \"project_id\", \"\"+GcmPushServer.senderId );\n            conn.addRequestProperty( \"Authorization\", \"key=\"+GcmPushServer.password );\n            // use \"set\" since this may already exist\n            conn.setRequestProperty( \"Content-Type\", \"application/json\" );\n\n            // create data to send with request\n            Map&lt;String,Object&gt; sendData = new HashMap&lt;&gt;();\n\n            // create a new notification key\n            sendData.put( \"operation\", doAdd? \"add\" : \"remove\" );       // add or delete key?\n            sendData.put( \"notification_key_name\", (--deleted--) );\n            sendData.put( \"notification_key\", (--deleted--) );\n            sendData.put( \"registration_ids\", (--deleted--) );\n\n            String strData = JSONValue.toJSONString(sendData);\n            //System.out.println(\"genGroupAddress POST data: \" + strData );\n\n            // Send post request\n            conn.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(conn.getOutputStream());\n            wr.writeBytes( strData );\n            wr.flush();\n            wr.close();\n\n            //conn.openConnection();\n\n            // successful?\n            int rc = conn.getResponseCode();\n            //System.out.println(\"ResponseCode = \" + rc );\n\n            Scanner input = new Scanner( conn.getInputStream() );\n\n            // read/display lines\n            while( input.hasNextLine() ) {\n                System.out.println(\"Response content:\");\n                String s = input.nextLine();\n                System.out.println( s );\n            }\n        } catch ( Exception e ) {\n            // do nothing\n        }\n    }\n}\n\n// text area for log messages\nclass LogTextArea extends JTextArea {\n    // update the \"log\" with the specified message\n    public void logMessage( String msg ) {\n        // (--deleted--)\n    }\n}\n\nclass CcsServer {\n    private static final String GCM_SERVER = \"gcm.googleapis.com\";\n    private static final int GCM_PORT = 5235;\n\n    private static final String GCM_ELEMENT_NAME = \"gcm\";\n    private static final String GCM_NAMESPACE = \"google:mobile:data\";\n\n    // display/log area\n    LogTextArea logArea;\n    UserList users;\n\n    CcsServer( LogTextArea lta, UserList u ) {\n        logArea = lta;\n        users = u;\n    }\n\n    static {\n        ProviderManager.addExtensionProvider(GCM_ELEMENT_NAME, GCM_NAMESPACE,\n            new PacketExtensionProvider() {\n                @Override\n                public PacketExtension parseExtension(XmlPullParser parser) throws\n                        Exception {\n                    String json = parser.nextText();\n                    return new GcmPacketExtension(json);\n                }\n            });\n    }\n\n    private XMPPConnection connection;\n\n    /**\n     * Indicates whether the connection is in draining state, which means that it\n     * will not accept any new downstream messages.\n     */\n    protected volatile boolean connectionDraining = false;\n\n    /**\n     * Sends a downstream message to GCM.\n     *\n     * @return true if the message has been successfully sent.\n     */\n    public boolean sendDownstreamMessage(String jsonRequest) throws\n            NotConnectedException {\n        if (!connectionDraining) {\n            send(jsonRequest);\n            return true;\n        }\n        logArea.logMessage(\"Dropping downstream message since the connection is draining\");\n        return false;\n    }\n\n    /**\n     * Returns a random message id to uniquely identify a message.\n     *\n     * &lt;p&gt;Note: This is generated by a pseudo random number generator for\n     * illustration purpose, and is not guaranteed to be unique.\n     */\n    public String nextMessageId() {\n        return \"m-\" + UUID.randomUUID().toString();\n    }\n\n    /**\n     * Sends a packet with contents provided.\n     */\n    protected void send(String jsonRequest) throws NotConnectedException {\n        Packet request = new GcmPacketExtension(jsonRequest).toPacket();\n        connection.sendPacket(request);\n    }\n\n    /**\n     * Handles an upstream data message from a device application.\n     *\n     * &lt;p&gt;This sample echo server sends an echo message back to the device.\n     * Subclasses should override this method to properly process upstream messages.\n     */\n    protected void handleUpstreamMessage(Map&lt;String, Object&gt; jsonObject) {\n        // PackageName of the application that sent this message.\n        String category = (String) jsonObject.get(\"category\");\n        String from = (String) jsonObject.get(\"from\");\n        @SuppressWarnings(\"unchecked\")\n        Map&lt;String, String&gt; payload = (Map&lt;String, String&gt;) jsonObject.get(\"data\");\n\n        // what type of upstream message is this?\n        if ( ! payload.containsKey( \"my_action\" ) )\n        {\n            // Hmmm - this shouldn't happen!\n            logArea.logMessage( \"handleUpstreamMessage - incoming message is missing my_action\" );\n            // just ignore the  message\n            return;\n        }\n\n        // what action do they want?\n        String my_action = (String) payload.get( \"my_action\" );\n        if ( my_action.equals( \"edu.eku.styere.gcmpushclient.REGISTER\" ) ) {\n            // registration request\n            String username = (String) payload.get( \"username\" );\n\n            logArea.logMessage( \"Registration request: user=\" + username + \", ID/Token=\" + from );\n\n            // save the information\n            users.addDevice( username, from );\n\n            return;\n        } else {\n            // take default action of echoing the message       \n            payload.put(\"ECHO\", \"Application: \" + category);\n\n            // Send an ECHO response back\n            String echo = createJsonMessage(from, nextMessageId(), payload,\n                    \"echo:CollapseKey\", null, false);\n\n            try {\n                sendDownstreamMessage(echo);\n            } catch (NotConnectedException e) {\n                logArea.logMessage( \"Not connected anymore, echo message is not sent: \" + e.getMessage() );\n            }\n        }\n    }\n\n    /**\n     * Handles an ACK.\n     *\n     * &lt;p&gt;Logs a INFO message, but subclasses could override it to\n     * properly handle ACKs.\n     */\n    protected void handleAckReceipt(Map&lt;String, Object&gt; jsonObject) {\n        String messageId = (String) jsonObject.get(\"message_id\");\n        String from = (String) jsonObject.get(\"from\");\n        logArea.logMessage( \"handleAckReceipt() from: \" + from + \", messageId: \" + messageId );\n    }\n\n    /**\n     * Handles a NACK.\n     *\n     * &lt;p&gt;Logs a INFO message, but subclasses could override it to\n     * properly handle NACKs.\n     */\n    protected void handleNackReceipt(Map&lt;String, Object&gt; jsonObject) {\n        String messageId = (String) jsonObject.get(\"message_id\");\n        String from = (String) jsonObject.get(\"from\");\n        logArea.logMessage( \"handleNackReceipt() from: \" + from + \", messageId: \" + messageId );\n    }\n\n    protected void handleControlMessage(Map&lt;String, Object&gt; jsonObject) {\n        logArea.logMessage( \"handleControlMessage(): \" + jsonObject );\n        String controlType = (String) jsonObject.get(\"control_type\");\n        if (\"CONNECTION_DRAINING\".equals(controlType)) {\n            connectionDraining = true;\n        } else {\n            logArea.logMessage( \"Unrecognised control type: \" + controlType + \". This could \"+\n                    \"happen if new features are \" + \"added to the CCS protocol.\" );\n        }\n    }\n\n    /**\n     * Creates a JSON encoded GCM message.\n     *\n     * @param to RegistrationId of the target device (Required).\n     * @param messageId Unique messageId for which CCS sends an\n     *         \"ack/nack\" (Required).\n     * @param payload Message content intended for the application. (Optional).\n     * @param collapseKey GCM collapse_key parameter (Optional).\n     * @param timeToLive GCM time_to_live parameter (Optional).\n     * @param delayWhileIdle GCM delay_while_idle parameter (Optional).\n     * @return JSON encoded GCM message.\n     */\n    public static String createJsonMessage(String to, String messageId,\n            Map&lt;String, String&gt; payload, String collapseKey, Long timeToLive,\n            Boolean delayWhileIdle) {\n        Map&lt;String, Object&gt; message = new HashMap&lt;String, Object&gt;();\n        message.put(\"to\", to);\n        if (collapseKey != null) {\n            message.put(\"collapse_key\", collapseKey);\n        }\n        if (timeToLive != null) {\n            message.put(\"time_to_live\", timeToLive);\n        }\n        if (delayWhileIdle != null &amp;&amp; delayWhileIdle) {\n            message.put(\"delay_while_idle\", true);\n        }\n      message.put(\"message_id\", messageId);\n      message.put(\"data\", payload);\n      return JSONValue.toJSONString(message);\n    }\n\n    /**\n     * Creates a JSON encoded ACK message for an upstream message received\n     * from an application.\n     *\n     * @param to RegistrationId of the device who sent the upstream message.\n     * @param messageId messageId of the upstream message to be acknowledged to CCS.\n     * @return JSON encoded ack.\n     */\n        protected static String createJsonAck(String to, String messageId) {\n        Map&lt;String, Object&gt; message = new HashMap&lt;String, Object&gt;();\n        message.put(\"message_type\", \"ack\");\n        message.put(\"to\", to);\n        message.put(\"message_id\", messageId);\n        return JSONValue.toJSONString(message);\n    }\n\n    /**\n     * Connects to GCM Cloud Connection Server using the supplied credentials.\n     *\n     * @param senderId Your GCM project number\n     * @param apiKey API Key of your project\n     */\n    public void connect(long senderId, String apiKey)\n            throws XMPPException, IOException, SmackException {\n        ConnectionConfiguration config =\n                new ConnectionConfiguration(GCM_SERVER, GCM_PORT);\n        config.setSecurityMode(SecurityMode.enabled);\n        config.setReconnectionAllowed(true);\n        config.setRosterLoadedAtLogin(false);\n        config.setSendPresence(false);\n        config.setSocketFactory(SSLSocketFactory.getDefault());\n\n        connection = new XMPPTCPConnection(config);\n        connection.connect();\n\n        connection.addConnectionListener( new LoggingConnectionListener() );\n\n        // Handle incoming packets\n        connection.addPacketListener(new PacketListener() {\n\n            @Override\n            public void processPacket(Packet packet) {\n                logArea.logMessage( \"Received: \" + packet.toXML() );\n                Message incomingMessage = (Message) packet;\n                GcmPacketExtension gcmPacket =\n                        (GcmPacketExtension) incomingMessage.\n                        getExtension(GCM_NAMESPACE);\n                String json = gcmPacket.getJson();\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    Map&lt;String, Object&gt; jsonObject =\n                            (Map&lt;String, Object&gt;) JSONValue.\n                            parseWithException(json);\n\n                    // present for \"ack\"/\"nack\", null otherwise\n                    Object messageType = jsonObject.get(\"message_type\");\n\n                    if (messageType == null) {\n                        // Normal upstream data message\n                        handleUpstreamMessage(jsonObject);\n\n                        // Send ACK to CCS\n                        String messageId = (String) jsonObject.get(\"message_id\");\n                        String from = (String) jsonObject.get(\"from\");\n                        String ack = createJsonAck(from, messageId);\n                        send(ack);\n                    } else if (\"ack\".equals(messageType.toString())) {\n                          // Process Ack\n                          handleAckReceipt(jsonObject);\n                    } else if (\"nack\".equals(messageType.toString())) {\n                          // Process Nack\n                          handleNackReceipt(jsonObject);\n                    } else if (\"control\".equals(messageType.toString())) {\n                          // Process control message\n                          handleControlMessage(jsonObject);\n                    } else {\n                          logArea.logMessage( \"Unrecognised message type: \" + \n                                  messageType.toString() );\n                    }\n                } catch (ParseException e) {\n                    logArea.logMessage( \"Error parsing JSON \" + json );\n                } catch (Exception e) {\n                    logArea.logMessage( \"Failed to process packet\" );\n                }\n            }\n        }, new PacketTypeFilter(Message.class));\n\n        // Log all outgoing packets\n        connection.addPacketInterceptor(new PacketInterceptor() {\n            @Override\n                public void interceptPacket(Packet packet) {\n                    logArea.logMessage( \"Sent: \" + packet.toXML());\n                }\n            }, new PacketTypeFilter(Message.class));\n\n        connection.login(senderId + \"@gcm.googleapis.com\", apiKey);\n    }\n\n    //---------- support classes ----------\n\n    /**\n    * XMPP Packet Extension for GCM Cloud Connection Server.\n    */\n    private static class GcmPacketExtension extends DefaultPacketExtension {\n\n        private final String json;\n\n        public GcmPacketExtension(String json) {\n            super( GCM_ELEMENT_NAME, GCM_NAMESPACE);\n            this.json = json;\n        }\n\n        public String getJson() {\n            return json;\n        }\n\n        @Override\n        public String toXML() {\n            return String.format(\"&lt;%s xmlns=\\\"%s\\\"&gt;%s&lt;/%s&gt;\",\n                    GCM_ELEMENT_NAME, GCM_NAMESPACE,\n                    StringUtils.escapeForXML(json), GCM_ELEMENT_NAME);\n        }\n\n        public Packet toPacket() {\n            Message message = new Message();\n            message.addExtension(this);\n            return message;\n        }\n    }\n\n    class LoggingConnectionListener implements ConnectionListener {\n\n        @Override\n        public void connected(XMPPConnection xmppConnection) {\n            logArea.logMessage( \"Connected.\" );\n        }\n\n        @Override\n        public void authenticated(XMPPConnection xmppConnection) {\n            logArea.logMessage( \"Authenticated.\" );\n        }\n\n        @Override\n        public void reconnectionSuccessful() {\n            logArea.logMessage( \"Reconnecting..\" );\n        }\n\n        @Override\n        public void reconnectionFailed(Exception e) {\n            logArea.logMessage( \"Reconnection failed.. \" + e.getMessage() );\n        }\n\n        @Override\n        public void reconnectingIn(int seconds) {\n            logArea.logMessage( \"Reconnecting in \" + seconds + \" secs\" );\n        }\n\n        @Override\n        public void connectionClosedOnError(Exception e) {\n            logArea.logMessage( \"Connection closed on error.\" );\n        }\n\n        @Override\n        public void connectionClosed() {\n            logArea.logMessage( \"Connection closed.\" );\n        }\n    }\n}\n\n// a non-editable combo (drop-down) box for destination addresses\nclass DestComboBox extends JComboBox&lt;String&gt; {\n    // (deleted to save space)\n}\n\n// screen panel for sending a message\nclass SendMessagePanel extends JPanel implements ActionListener, ItemListener {     \n    // Message Types\n    protected final int MSGTYPE_NOTIFICATION = 1;\n    protected final int MSGTYPE_NOTIFICATION_DATA = 2;\n    protected final int MSGTYPE_DATA_COLLAPSE = 3;\n    protected final int MSGTYPE_DATA_NONCOLLAPSE = 4;\n\n    // log window\n    LogTextArea msgs;\n\n    // server class\n    CcsServer ccsServer;\n\n    // constructor\n    SendMessagePanel( UserList u, LogTextArea m, CcsServer c ) {\n        // (deleted to save space)\n    }\n\n    // respond to the button\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        String toAddr = \"zzzzzz\";   // destination address\n               // may be device, notification_key, or topic address\n        ttl = 2419200;              // time-to-live in seconds\n\n        // what type of message?\n        int msgTypeIndex = (--deleted--);\n\n        // create the message\n        Map&lt;String, Object&gt; message = new HashMap&lt;String, Object&gt;();\n        message.put(\"to\", toAddr);\n\n        if ( msgTypeIndex == MSGTYPE_NOTIFICATION ||\n                    msgTypeIndex == MSGTYPE_NOTIFICATION_DATA ||\n                    msgTypeIndex == MSGTYPE_DATA_COLLAPSE ) {\n            // create a collapse key\n            message.put(\"collapse_key\", \"ck\"+msgTypeIndex );\n        }\n\n        message.put(\"time_to_live\", ttl);   \n        message.put(\"message_id\", ccsServer.nextMessageId());\n\n        // notification included?\n        if ( msgTypeIndex == MSGTYPE_NOTIFICATION ||\n                msgTypeIndex == MSGTYPE_NOTIFICATION_DATA ) {\n\n            // create the notification payload\n            HashMap&lt;String, String&gt; notePayload = new HashMap&lt;&gt;();\n            notePayload.put( \"title\", \"Gcm Push Message Example\" );\n            notePayload.put( \"body\", (--deleted--) );\n            // identify which notifications should replace older versions\n            notePayload.put( \"tag\", \"ntag\" + msgTypeIndex );\n            notePayload.put( \"icon\", \"@drawable/new_picture\" );     // notification icon\n\n            // additional stuff if we also have data\n            if ( msgTypeIndex == MSGTYPE_NOTIFICATION_DATA ) {\n                // what to do when the user opens the notification\n                notePayload.put( \"click_action\", \"OPEN_MAIN_ACTIVITY\" );\n            }\n            message.put( \"notification\", notePayload );\n        }\n\n        // data included?\n        if ( msgTypeIndex == MSGTYPE_NOTIFICATION_DATA ||\n                    msgTypeIndex == MSGTYPE_DATA_COLLAPSE ||\n                    msgTypeIndex == MSGTYPE_DATA_NONCOLLAPSE ) {\n            HashMap&lt;String, String&gt; dataPayload = new HashMap&lt;&gt;();\n\n            dataPayload.put( \"contents\", (--deleted--) );\n\n            message.put(\"data\", dataPayload);\n        }\n\n        // actually send the message\n        try {\n            ccsServer.sendDownstreamMessage( JSONValue.toJSONString(message) );\n        } catch (NotConnectedException enc ) {\n            msgs.logMessage( \"Not connected anymore, echo message is not sent: \" + enc.getMessage() );\n        }\n    }\n}\n\nclass BorderPanel extends JPanel {\n    // (--deleted--)\n}\n\npublic class GcmPushServer\n{\n    // (--deleted--)\n}\n", "/**\n * This utility function will upload the file to the Url\n * * @param filePath - absolute path of the file to be uploaded\n * @param postUrl  - Remote Url where the file need to be posted\n * @param contentType - content-type of the uploaded file\n * @throws Exception\n */\npublic static void postFile(String filePath, String postUrl,\n        String pictureTitleStr, String pseudoTextStr)\n        throws Exception {\n\n    String url = postUrl;\n    HttpURLConnection conn = null;\n    final String CrLf = \"\\r\\n\";\n    JSONObject json = new JSONObject();\n    int bytesRead = 0;\n\n\n    String lineEnd = \"\\r\\n\";\n    String twoHyphens = \"--\";\n    String boundary = \"xxxxxxxx\";\n    String EndBoundary = \"\";\n    int maxBufferSize = 1 * 1024 * 1024;\n\n    HttpResponse response = null;\n\n  // Having HttpClient to respond to both HTTP and HTTPS url connection by accepting the urls along with keystore / trust certificates \n\n    try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore\n                .getDefaultType());\n        trustStore.load(null, null);\n\n        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        HttpParams params = new BasicHttpParams();\n        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);\n        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);\n        HttpProtocolParams.setUserAgent(params, \"YourAppName/1.1\");\n        HttpConnectionParams.setStaleCheckingEnabled(params, false);\n        HttpConnectionParams.setConnectionTimeout(params, 20 * 1000);\n        HttpConnectionParams.setSoTimeout(params, 20 * 1000);\n        HttpConnectionParams.setSocketBufferSize(params, 8192);\n        HttpClientParams.setRedirecting(params, false);\n\n        SchemeRegistry registry = new SchemeRegistry();\n        registry.register(new Scheme(\"http\", PlainSocketFactory\n                .getSocketFactory(), 80));\n        registry.register(new Scheme(\"https\", sf, 443));\n\n        ClientConnectionManager ccm = new ThreadSafeClientConnManager(\n                params, registry);\n\n        mHttpClient = new DefaultHttpClient(ccm, params);\n\n\n\n    } catch (Exception e) {\n\n    }\n\n    String base64EncodedCredentials = Base64.encodeToString((userName + \":\" + password).getBytes(\"US-ASCII\"),\n            Base64.DEFAULT);\n    System.out.println(\"Encoded Credit \" + base64EncodedCredentials);\n\n            json.put(\"pseudo\", pseudoTextStr);\n            json.put(\"title\", pictureTitleStr);\n\n           String jsonStr = json.toString(); \n //   System.out.println(\"JSON VALUE  \" + jsonStr);\n\n    URL url2 = new URL(postUrl);\n\n\n\n    Bitmap bm = BitmapFactory.decodeFile(filePath);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    bm.compress(Bitmap.CompressFormat.JPEG, 25, baos); // bm is the bitmap object\n    byte[] b = baos.toByteArray();\n\n    String encodedImage = Base64.encodeToString(b, Base64.DEFAULT);\n\n\n    String str = twoHyphens + boundary + lineEnd;\n    String str2 = \"Content-Disposition: form-data; name=\\\"jsonFile\\\"\";\n    String str3 = \"Content-Type: application/json\";\n    String str4 = \"Content-Disposition: form-data; name=\\\"imgName\\\"\";\n    String str5 = \"Content-Type: image/jpeg\";\n    String str6 = twoHyphens + boundary + twoHyphens;\n\n\n\n    String StrTotal = str + str2 + \"\\r\\n\" + str3 + \"\\r\\n\" +\"\\r\\n\" + jsonStr + \"\\r\\n\" + str\n            + str4 + \"\\r\\n\" + str5 + \"\\r\\n\"+\"\\r\\n\"+ encodedImage + \"\\r\\n\" + str6;\n\n    //System.out.print(\"Multipart request string is \"+StrTotal);\n\n HttpPost post = new HttpPost(postUrl);\n\n\npost.addHeader(BasicScheme.authenticate(new UsernamePasswordCredentials(\n                userName, password), \"UTF-8\", false));\npost.addHeader(\"Content-Type\",\"multipart/form-data;boundary=\"+boundary);\n// System.out.println(\"Sending Post proxy request: \" + post);\n\n StringEntity se = new StringEntity(StrTotal);\n se.setContentEncoding(\"UTF-8\");\n post.setEntity(se);\n response = mHttpClient.execute(post);\n\n/* Checking response */\n\nstatusCode = response.getStatusLine().getStatusCode();\nSystem.out.println(\"Http Execute finish \" + statusCode);\n\nHttpEntity entity = response.getEntity();\nString getResponseText = entity.toString(); // EntityUtils.toString(entity);\nSystem.out.println(\" Post Response Text from Server : \"\n        + getResponseText);\n\n\n\n}\n", "@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.payment_home);\n\n\n    btnBuy.setOnClickListener(new OnClickListener() {\n\n        @SuppressLint({ \"SetJavaScriptEnabled\", \"ShowToast\" }) @Override\n        public void onClick(View v) {\n            // TODO Auto-generated method stub\n            if(f_nm &amp;&amp; f_pn  &amp;&amp; f_email )\n            {\n                webview.setVisibility(View.VISIBLE);\n                Integer randomNum = randInt(0, 9999999);\n                txnid=randomNum.toString();\n                firstname=etName.getText().toString();\n                email=etEmail.getText().toString();\n                amount=study_material_price;\n                productinfo=study_material_name;\n                phone=etPhone.getText().toString();\n                String hashSequence = merchant_key+\"|\"+txnid+\"|\"+amount+\"|\"+productinfo+\"|\"+firstname+\"|\"+email+\"|||||||||||\"+salt;\n                hash = hashCal(\"SHA-512\", hashSequence);\n                webview.addJavascriptInterface(new PayUJavaScriptInterface(), \"PayUMoney\");\n                String json =\"txnid=\"+txnid+\"&amp;key=\"+merchant_key+\"&amp;amount=\"+amount+\"&amp;hash=\"+hash+\"&amp;productinfo=\"+productinfo+\"&amp;surl=\"+SURL+\"&amp;furl=\"+FURL+\"&amp;firstname=\"+firstname+\"&amp;email=\"+email+\"&amp;phone=\"+phone+\"&amp;service_provider=payu_paisa\";\n                webview.getSettings().setUserAgentString(\"Mozilla/5.0 (Linux; U; Android 2.0; en-us; Droid Build/ESD20) AppleWebKit/530.17 (KHTML, like Gecko) Version/4.0 Mobile Safari/530.17\");\n                webview.getSettings().setDomStorageEnabled(true);\n                webview.getSettings().setJavaScriptEnabled(true);\n                webview.getSettings().setSupportMultipleWindows(true);\n                webview.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);\n                webview.getSettings().setSupportZoom(true);       //Zoom Control on web (You don't need this\n                //if ROM supports Multi-Touch\n                webview.getSettings().setBuiltInZoomControls(true);\n                webview.setWebViewClient(new WebViewClient());\n                webview.setWebViewClient(\n                        new SSLTolerentWebViewClient()\n                        );\n                webview.postUrl(\"https://secure.payu.in/_payment\", EncodingUtils.getBytes(json, \"BASE64\"));\n\n                try {\n\n                    webview.setWebViewClient(new WebViewClient() {\n                        @Override\n                        public void onReceivedError(WebView view, int errorCode,\n                                String description, String failingUrl) {\n                            Log.d(\"WEB_VIEW_TEST\", \"error code:\" + errorCode + \" - \" + description);\n                        }\n\n                        @Override\n                        public boolean shouldOverrideUrlLoading(WebView view, String url) {\n                            // handle different requests for different type of files\n                            // this example handles downloads requests for .apk and .mp3 files\n                            // everything else the webview can handle normally\n                            if (url.endsWith(\".mp3\")||url.endsWith(\".zip\") || url.endsWith(\".pdf\") || url.endsWith(\".jpg\")|| url.endsWith(\".doc\")|| url.endsWith(\".png\")|| url.endsWith(\".docx\")|| url.endsWith(\".xml\")|| url.endsWith(\".gif\")) {\n                                String urlSplit[] = url.split(\"/\");\n                                String fileName = urlSplit[urlSplit.length-1];\n                                Uri source = Uri.parse(url);\n                                // Make a new request pointing to the .apk url\n                                DownloadManager.Request request = new DownloadManager.Request(source);\n                                // appears the same in Notification bar while downloading\n                                request.setDescription(\"Description for the DownloadManager Bar\");\n                                request.setTitle(fileName);\n                                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {\n                                    request.allowScanningByMediaScanner();\n                                    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n                                }\n                                // save the file in the \"Downloads\" folder of SDCARD\n                                request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS,fileName);\n                                // get download service and enqueue file\n                                DownloadManager manager = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);\n                                manager.enqueue(request);\n                            }\n                            // if there is a link to anything else than .apk or .mp3 load the URL in the webview\n                            else view.loadUrl(url);\n                            return true;                \n                        }\n                    });\n\n\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }else{\n                Toast.makeText(getApplicationContext(), \"Please fill all the fields.\", 1000).show();\n            }\n        }\n    });\n}   \n\n@Override\npublic boolean onKeyDown(int keyCode, KeyEvent event) {\n    if(event.getAction() == KeyEvent.ACTION_DOWN){\n        switch(keyCode)\n        {\n        case KeyEvent.KEYCODE_BACK:\n            if(webview.canGoBack()){\n                webview.goBack();\n            }else{\n                finish();\n            }\n            return true;\n        }\n\n    }\n    return super.onKeyDown(keyCode, event);\n}\n\nprivate final class PayUJavaScriptInterface {\n    PayUJavaScriptInterface() {\n    }\n\n    /**\n     * This is not called on the UI thread. Post a runnable to invoke\n     * loadUrl on the UI thread.\n     */\n    @JavascriptInterface\n    public void success(long id, final String pId) {\n        mHandler.post(new Runnable() {\n            public void run() {\n                mHandler = null;\n                Toast.makeText(getApplicationContext(), \"Your Transaction is Successful\", 1000).show();\n                status=\"Success\";\n                paymentId=pId;\n                new StoreTransactionData().execute();\n                Intent intent = new Intent();\n                intent.putExtra(\"status\", \"success\");\n                intent.putExtra(\"transaction_id\", paymentId);\n                setResult(RESULT_OK, intent);\n                studyDownloadPaid();\n                finish();\n            }\n        });\n    }\n\n\n\n    @JavascriptInterface\n    public void failure(final String id, String error) {\n        Log.d(\"transaction data fail id\", id +\"   \" +study_material_name);\n        mHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                paymentId=id;\n                status=\"Faluire\";\n                new StoreTransactionData().execute();\n                cancelPayment();\n            }\n        });\n    }\n\n    @JavascriptInterface\n    public void failure() {\n        failure(\"\");\n    }\n\n    @JavascriptInterface\n    public void failure(final String params) {\n        mHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                paymentId=params;\n                status=\"Faluire\";\n                new StoreTransactionData().execute();\n                Log.d(\"transaction data fail param\", params);\n                Intent intent = new Intent();\n                intent.putExtra(\"status\", params);\n                setResult(RESULT_CANCELED, intent);\n                finish();\n            }\n        });\n    }\n\n}\n\nprivate void cancelPayment() {\n    Intent intent = new Intent();\n    intent.putExtra(\"status\", \"cancel\");\n    //mWebView.destroy();\n    setResult(RESULT_CANCELED, intent);\n    finish();\n}\n\npublic static String hashCal(String type, String str) {\n    byte[] hashseq = str.getBytes();\n    StringBuffer hexString = new StringBuffer();\n    try {\n        MessageDigest algorithm = MessageDigest.getInstance(type);\n        algorithm.reset();\n        algorithm.update(hashseq);\n        byte messageDigest[] = algorithm.digest();\n        for (int i = 0; i &lt; messageDigest.length; i++) {\n            String hex = Integer.toHexString(0xFF &amp; messageDigest[i]);\n            if (hex.length() == 1) {\n                hexString.append(\"0\");\n            }\n            hexString.append(hex);\n        }\n    } catch (NoSuchAlgorithmException nsae) {\n    }\n    return hexString.toString();\n}\n\npublic static int randInt(int min, int max) {\n    // Usually this should be a field rather than a method variable so\n    // that it is not re-seeded every call.\n    Random rand = new Random();\n\n    // nextInt is normally exclusive of the top value,\n    // so add 1 to make it inclusive\n    int randomNum = rand.nextInt((max - min) + 1) + min;\n\n    return randomNum;\n}\n\n\nprivate class SSLTolerentWebViewClient extends WebViewClient {\n\n    @Override\n    public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {\n        handler.proceed(); // Ignore SSL certificate errors\n    }\n\n}\n", "private String generateAuthHeader(String verb, String resourceType, String resourceId, String date, String masterKeyBase64) throws Exception\n{\n    //Decode the master key, and setup the MAC object for signing.\n    byte[] masterKeyBytes = Base64.decode(masterKeyBase64, Base64.NO_WRAP);\n    Mac mac = Mac.getInstance(\"HMACSHA256\");\n    mac.init(new SecretKeySpec(masterKeyBytes, \"HMACSHA256\"));\n\n    //Build the unsigned auth string.\n    String stringToSign = verb + \"\\n\"\n            + resourceType + \"\\n\"\n            + resourceId + \"\\n\"\n            + date + \"\\n\"\n            + \"\\n\";\n\n    //Sign and encode the auth string.\n    String signature = Base64.encodeToString(mac.doFinal(stringToSign.toLowerCase().getBytes(\"UTF8\")), Base64.NO_WRAP);\n\n    //Generate the auth header.\n    String authHeader = URLEncoder.encode(\"type=master&amp;ver=1.0&amp;sig=\" + signature, \"UTF8\");\n\n    return authHeader;\n}\n", " fist you download activation.jar,mail.jar,additionnal.jar and add to built to your project                                                       \n\nAnd code r following\n---------Create GMailSender.class\nimport javax.activation.DataHandler;   \nimport javax.activation.DataSource;   \nimport javax.mail.Message;   \nimport javax.mail.PasswordAuthentication;   \nimport javax.mail.Session;   \nimport javax.mail.Transport;   \nimport javax.mail.internet.InternetAddress;   \nimport javax.mail.internet.MimeMessage;   \nimport java.io.ByteArrayInputStream;   \nimport java.io.IOException;   \nimport java.io.InputStream;   \nimport java.io.OutputStream;   \nimport java.security.Security;   \nimport java.util.Properties;   \n\npublic class GMailSender extends javax.mail.Authenticator {   \n    private String mailhost = \"smtp.gmail.com\";   \n    private String user;   \n    private String password;   \n    private Session session;   \n\n    static {   \n        Security.addProvider(new JSSEProvider());   \n    }  \n\n    public GMailSender(String user, String password) {   \n        this.user = user;   \n        this.password = password;   \n\n        Properties props = new Properties();   \n        props.setProperty(\"mail.transport.protocol\", \"smtp\");   \n        props.setProperty(\"mail.host\", mailhost);   \n        props.put(\"mail.smtp.auth\", \"true\");   \n        props.put(\"mail.smtp.port\", \"465\");   \n        props.put(\"mail.smtp.socketFactory.port\", \"465\");   \n        props.put(\"mail.smtp.socketFactory.class\",   \n                \"javax.net.ssl.SSLSocketFactory\");   \n        props.put(\"mail.smtp.socketFactory.fallback\", \"false\");   \n        props.setProperty(\"mail.smtp.quitwait\", \"false\");   \n\n        session = Session.getDefaultInstance(props, this);   \n    }   \n\n    protected PasswordAuthentication getPasswordAuthentication() {   \n         return new PasswordAuthentication(user, password);   \n    }   \n\n    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   \n        try{\n        MimeMessage message = new MimeMessage(session);   \n        DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), \"text/plain\"));   \n        message.setSender(new InternetAddress(sender));   \n        message.setSubject(subject);   \n        message.setDataHandler(handler);   \n        if (recipients.indexOf(',') &gt; 0)   \n            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   \n        else  \n            message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   \n        Transport.send(message);   \n        }catch(Exception e){\n            e.printStackTrace();\n\n        }\n    }   \n\n    public class ByteArrayDataSource implements DataSource {   \n        private byte[] data;   \n        private String type;   \n\n        public ByteArrayDataSource(byte[] data, String type) {   \n            super();   \n            this.data = data;   \n            this.type = type;   \n        }   \n\n        public ByteArrayDataSource(byte[] data) {   \n            super();   \n            this.data = data;   \n        }   \n\n        public void setType(String type) {   \n            this.type = type;   \n        }   \n\n        public String getContentType() {   \n            if (type == null)   \n                return \"application/octet-stream\";   \n            else  \n                return type;   \n        }   \n\n        public InputStream getInputStream() throws IOException {   \n            return new ByteArrayInputStream(data);   \n        }   \n\n        public String getName() {   \n            return \"ByteArrayDataSource\";   \n        }   \n\n        public OutputStream getOutputStream() throws IOException {   \n            throw new IOException(\"Not Supported\");   \n        }   \n    }   \n}  \n\n2-Create JSSEProvider.class\nimport java.security.AccessController;\nimport java.security.Provider;\n\npublic final class JSSEProvider extends Provider {\n\n    public JSSEProvider() {\n        super(\"HarmonyJSSE\", 1.0, \"Harmony JSSE Provider\");\n        AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {\n            public Void run() {\n                put(\"SSLContext.TLS\",\n                        \"org.apache.harmony.xnet.provider.jsse.SSLContextImpl\");\n                put(\"Alg.Alias.SSLContext.TLSv1\", \"TLS\");\n                put(\"KeyManagerFactory.X509\",\n                        \"org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl\");\n                put(\"TrustManagerFactory.X509\",\n                        \"org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl\");\n                return null;\n            }\n        });\n    }\n}\n\n3-use This code in to your Activity button click etc..\ntry {   \n                    GMailSender sender = new GMailSender(\"sender gmail ID\", \"password\");\n                    sender.sendMail(\"This is Subject\",   \n                            \"This is Body\",   \n                            \"receiverID\",   \n                            \"receiverID\");   \n                } catch (Exception e) {   \n                    Log.e(\"SendMail\", e.getMessage(), e);   \n                } \n", "public String encode(String text)\n            throws NoPassGivenException, NoTextGivenException {\n\n        if (text.length() == 0 || text == null) {\n            throw new NoTextGivenException(\"Please give text\");\n        }\n\n        try {\n            SecretKeySpec skeySpec = getKey(KEY);\n\n            System.out.println(\"-----Encoding Key-----\"+skeySpec);\n            byte[] clearText = text.getBytes(\"UTF8\");\n\n            //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID\n            final byte[] iv = new byte[16];\n            Arrays.fill(iv, (byte) 0x00);\n            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n            // Cipher is not thread safe\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);\n\n//          IvParameterSpec ivspec = new IvParameterSpec(IV.getBytes());\n//          cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);\n\n            String encrypedValue = Base64.encodeToString(\n                    cipher.doFinal(clearText), Base64.DEFAULT);\n            return new String(encrypedValue);\n\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n\n/**\n     * Generates a SecretKeySpec for given password\n     * @param password\n     * @return SecretKeySpec\n     * @throws UnsupportedEncodingException\n     */\n    public SecretKeySpec getKey(String password)\n            throws UnsupportedEncodingException {\n\n\n        int keyLength = 128;\n        byte[] keyBytes = new byte[keyLength / 8];\n        // explicitly fill with zeros\n        Arrays.fill(keyBytes, (byte) 0x0);\n\n        // if password is shorter then key length, it will be zero-padded\n        // to key length\n        byte[] passwordBytes = password.getBytes(\"UTF-8\");\n        int length = passwordBytes.length &lt; keyBytes.length ?          passwordBytes.length\n                : keyBytes.length;\n        System.arraycopy(passwordBytes, 0, keyBytes, 0, length);\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n        return key;\n    }\n .// PHP Code to decrypt\n    public function decrypt($code) { \n\n      $decoded = base64_decode($code);\n      $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB), MCRYPT_RAND);\n      $decrypted = trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this-&gt;key, trim($decoded), MCRYPT_MODE_ECB, $iv));\n      $blocksize = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);\n\n     return  $this-&gt;pkcs7unpad($decrypted,$blocksize);\n    }\n function pkcs7unpad($padded, $blocksize)\n    {\n        $l = strlen($padded);\n\n        if ($l % $blocksize != 0) \n        {\n            throw new Exception(\"Padded plaintext cannot be divided by the block size\");\n        }\n\n        $padsize = ord($padded[$l - 1]);\n\n        if ($padsize === 0)\n        {\n            throw new Exception(\"Zero padding found instead of PKCS#7 padding\");\n        }    \n\n        if ($padsize &gt; $blocksize)\n        {\n            throw new Exception(\"Incorrect amount of PKCS#7 padding for blocksize\");\n        }\n\n        // check the correctness of the padding bytes by counting the occurance\n        $padding = substr($padded, -1 * $padsize);\n        if (substr_count($padding, chr($padsize)) != $padsize)\n        {\n            throw new Exception(\"Invalid PKCS#7 padding encountered\");\n        }\n\n        return substr($padded, 0, $l - $padsize);\n    }\n", "private InputStream getInputStream(String urlStr, String user, String password) throws IOException\n{\n    URL url = new URL(urlStr);\n    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n\n    // Create the SSL connection\n    SSLContext sc;\n    sc = SSLContext.getInstance(\"TLS\");\n    sc.init(null, null, new java.security.SecureRandom());\n    conn.setSSLSocketFactory(sc.getSocketFactory());\n\n    // Use this if you need SSL authentication\n    String userpass = user + \":\" + password;\n    String basicAuth = \"Basic \" + Base64.encodeToString(userpass.getBytes(), Base64.DEFAULT);\n    conn.setRequestProperty(\"Authorization\", basicAuth);\n\n    // set Timeout and method\n    conn.setReadTimeout(7000);\n    conn.setConnectTimeout(7000);\n    conn.setRequestMethod(\"POST\");\n    conn.setDoInput(true);\n\n    // Add any data you wish to post here\n\n    conn.connect();\n    return conn.getInputStream();\n}   \n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md;\n\n                    md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    String something = new String(Base64.encode(md.digest(), 0));\n                    Log.e(\"hash key\", something);\n        } \n        }\n        catch (NameNotFoundException e1) {\n            // TODO Auto-generated catch block\n            Log.e(\"name not found\", e1.toString());\n        }\n\n             catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                 Log.e(\"no such an algorithm\", e.toString());\n            }\n             catch (Exception e){\n                 Log.e(\"exception\", e.toString());\n             }\n", "@Override\npublic void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\n\n// Add code to print out the key hash\ntry {\n    PackageInfo info = getPackageManager().getPackageInfo(\n            \"com.facebook.samples.hellofacebook\", \n            PackageManager.GET_SIGNATURES);\n    for (Signature signature : info.signatures) {\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        md.update(signature.toByteArray());\n        Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n\n...\n", "import java.io.*;\nimport java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport android.util.Base64;\n\npublic class ReadPKCS8Pem {\n\n    private final static String PRIVATE_KEY = \n            \"-----BEGIN PRIVATE KEY-----\\n\"\n            + \"MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAM7t8Ub1DP+B91NJ\\n\"\n            + \"nC45zqIvd1QXkQ5Ac1EJl8mUglWFzUyFbhjSuF4mEjrcecwERfRummASbLoyeMXl\\n\"\n            + \"eiPg7jvSaz2szpuV+afoUo9c1T+ORNUzq31NvM7IW6+4KhtttwbMq4wbbPpBfVXA\\n\"\n            + \"IAhvnLnCp/VyY/npkkjAid4c7RoVAgMBAAECgYBcCuy6kj+g20+G5YQp756g95oN\\n\"\n            + \"dpoYC8T/c9PnXz6GCgkik2tAcWJ+xlJviihG/lObgSL7vtZMEC02YXdtxBxTBNmd\\n\"\n            + \"upkruOkL0ElIu4S8CUwD6It8oNnHFGcIhwXUbdpSCr1cx62A0jDcMVgneQ8vv6vB\\n\"\n            + \"/YKlj2dD2SBq3aaCYQJBAOvc5NDyfrdMYYTY+jJBaj82JLtQ/6K1vFIwdxM0siRF\\n\"\n            + \"UYqSRA7G8A4ga+GobTewgeN6URFwWKvWY8EGb3HTwFkCQQDgmKtjjJlX3BotgnGD\\n\"\n            + \"gdxVgvfYG39BL2GnotSwUbjjce/yZBtrbcClfqrrOWWw7lPcX1d0v8o3hJfLF5dT\\n\"\n            + \"6NAdAkA8qAQYUCSSUwxJM9u0DOqb8vqjSYNUftQ9dsVIpSai+UitEEx8WGDn4SKd\\n\"\n            + \"V8kupy/gJlau22uSVYI148fJSCGRAkBz+GEHFiJX657YwPI8JWHQBcBUJl6fGggi\\n\"\n            + \"t0F7ibceOkbbsjU2U4WV7sHyk8Cei3Fh6RkPf7i60gxPIe9RtHVBAkAnPQD+BmND\\n\"\n            + \"By8q5f0Kwtxgo2+YkxGDP5bxDV6P1vd2C7U5/XxaN53Kc0G8zu9UlcwhZcQ5BljH\\n\"\n            + \"N24cUWZOo+60\\n\"\n            + \"-----END PRIVATE KEY-----\";\n\n    public static void main(String[] args) throws Exception {\n        // Read in the key into a String\n        StringBuilder pkcs8Lines = new StringBuilder();\n        BufferedReader rdr = new BufferedReader(new StringReader(PRIVATE_KEY));\n        String line;\n        while ((line = rdr.readLine()) != null) {\n            pkcs8Lines.append(line);\n        }\n\n        // Remove the \"BEGIN\" and \"END\" lines, as well as any whitespace\n\n        String pkcs8Pem = pkcs8Lines.toString();\n        pkcs8Pem = pkcs8Pem.replace(\"-----BEGIN PRIVATE KEY-----\", \"\");\n        pkcs8Pem = pkcs8Pem.replace(\"-----END PRIVATE KEY-----\", \"\");\n        pkcs8Pem = pkcs8Pem.replaceAll(\"\\\\s+\",\"\");\n\n        // Base64 decode the result\n\n        byte [] pkcs8EncodedBytes = Base64.decode(pkcs8Pem, Base64.DEFAULT);\n\n        // extract the private key\n\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(pkcs8EncodedBytes);\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        PrivateKey privKey = kf.generatePrivate(keySpec);\n        System.out.println(privKey);\n    }\n\n}\n", "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.security.CodeSource;\nimport java.security.ProtectionDomain;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\nimport java.util.zip.ZipFile;\n\npublic class Sandbox\n{\n    public static void main(final String[] args)\n        throws URISyntaxException,\n               ZipException,\n               IOException\n    {\n        final URI uri;\n        final URI exe;\n\n        uri = getJarURI();\n        // Extract the adb application\n        exe = getFile(uri, \"adb.exe\");\n        // Extract the AdbWinApi dll file.\n        getFile(uri, \"AdbWinApi.dll\");\n        System.out.println(exe);\n    }\n\n    private static URI getJarURI()\n        throws URISyntaxException\n    {\n        final ProtectionDomain domain;\n        final CodeSource       source;\n        final URL              url;\n        final URI              uri;\n\n        domain = Sandbox.class.getProtectionDomain();\n        source = domain.getCodeSource();\n        url    = source.getLocation();\n        uri    = url.toURI();\n\n        return (uri);\n    }    \n\n    private static URI getFile(final URI    where,\n                               final String fileName)\n        throws ZipException,\n               IOException\n    {\n        final File location;\n        final URI  fileURI;\n\n        location = new File(where);\n\n        // not in a JAR, just return the path on disk\n        if(location.isDirectory())\n        {\n            fileURI = URI.create(where.toString() + fileName);\n        }\n        else\n        {\n            final ZipFile zipFile;\n\n            zipFile = new ZipFile(location);\n\n            try\n            {\n                fileURI = extract(zipFile, fileName);\n            }\n            finally\n            {\n                zipFile.close();\n            }\n        }\n\n        return (fileURI);\n    }\n\n    private static URI extract(final ZipFile zipFile,\n                           final String  fileName)\n        throws IOException\n    {\n        final File         tempFile;\n        final ZipEntry     entry;\n        final InputStream  zipStream;\n        OutputStream       fileStream;\n\n        //tempFile = File.createTempFile(fileName,     Long.toString(System.currentTimeMillis()));\n        tempFile = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + fileName);\n\n        tempFile.deleteOnExit();\n        entry    = zipFile.getEntry(fileName);\n\n        if(entry == null)\n\n        {\n            throw new FileNotFoundException(\"cannot find file: \" + fileName + \" in archive: \" + zipFile.getName());\n        }\n\n        zipStream  = zipFile.getInputStream(entry);\n        fileStream = null;\n\n        try\n        {\n            final byte[] buf;\n            int          i;\n\n            fileStream = new FileOutputStream(tempFile);\n            buf        = new byte[1024];\n            i          = 0;\n\n            while((i = zipStream.read(buf)) != -1)\n            {\n                fileStream.write(buf, 0, i);\n            }\n        }\n        finally\n        {\n            close(zipStream);\n            close(fileStream);\n        }\n\n        return (tempFile.toURI());\n    }\n\n    private static void close(final Closeable stream)\n    {\n        if(stream != null)\n        {\n            try\n            {\n                stream.close();\n            }\n            catch(final IOException ex)\n            {\n                ex.printStackTrace();\n            }\n        }\n    }\n}\n", "import android.app.Activity;\nimport android.widget.EditText;\nimport android.os.Bundle;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.Header\nimport java.io.InputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport android.util.Log;\nimport android.view.Menu;\npublic class MainActivity extends Activity {\n\n    private EditText text;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        text = (EditText) findViewById(R.id.editText1);\n        connect();\n    }\n\n    private void connect(){\n        try {\n            DataLoader dl = new DataLoader();\n            String url = \"https://IpAddress\";\n            HttpResponse response = dl.secureLoadData(url); \n\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"HEADERS:\\n\\n\");\n\n            Header[] headers = response.getAllHeaders();\n            for (int i = 0; i &lt; headers.length; i++) {\n                Header h = headers[i];\n                sb.append(h.getName()).append(\":\\t\").append(h.getValue()).append(\"\\n\");\n            }\n\n            InputStream is = response.getEntity().getContent();\n            StringBuilder out = new StringBuilder();\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            for (String line = br.readLine(); line != null; line = br.readLine())\n                out.append(line);\n            br.close();\n\n            sb.append(\"\\n\\nCONTENT:\\n\\n\").append(out.toString()); \n\n            Log.i(\"response\", sb.toString());\n            text.setText(sb.toString());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.activity_main, menu);\n        return true;\n    }\n\n}\n\n\nimport android.app.Application;\nimport android.content.Context;\nimport java.io.InputStream;\npublic class MeaApplication extends Application {\n\n    private static Context context;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        MeaApplication.context = getApplicationContext();\n    }\n\n    public static Context getAppContext() {\n        return MeaApplication.context;\n    }\n\n    public static InputStream loadCertAsInputStream() {\n        return MeaApplication.context.getResources().openRawResource(\n                R.raw.meacert);\n    }\n\n}\n\n\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLContext;\nimport java.security.KeyStore;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStoreException;\nimport java.security.UnrecoverableKeyException;\nimport javax.net.ssl.TrustManager;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.net.UnknownHostException;\n/**\n * Taken from: http://janis.peisenieks.lv/en/76/english-making-an-ssl-connection-via-android/\n *\n */\npublic class CustomSSLSocketFactory extends SSLSocketFactory {\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public CustomSSLSocketFactory(KeyStore truststore)\n            throws NoSuchAlgorithmException, KeyManagementException,\n            KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new CustomX509TrustManager();\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    public CustomSSLSocketFactory(SSLContext context)\n            throws KeyManagementException, NoSuchAlgorithmException,\n            KeyStoreException, UnrecoverableKeyException {\n        super(null);\n        sslContext = context;\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port,\n            boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port,\n                autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n}\n\n\nimport javax.net.ssl.X509TrustManager;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.cert.CertificateFactory;\npublic class CustomX509TrustManager implements X509TrustManager {\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n    }\n\n    @Override\n    public void checkServerTrusted(java.security.cert.X509Certificate[] certs,\n            String authType) throws CertificateException {\n\n        // Here you can verify the servers certificate. (e.g. against one which is stored on mobile device)\n\n        // InputStream inStream = null;\n        // try {\n        // inStream = MeaApplication.loadCertAsInputStream();\n        // CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        // X509Certificate ca = (X509Certificate)\n        // cf.generateCertificate(inStream);\n        // inStream.close();\n        //\n        // for (X509Certificate cert : certs) {\n        // // Verifing by public key\n        // cert.verify(ca.getPublicKey());\n        // }\n        // } catch (Exception e) {\n        // throw new IllegalArgumentException(\"Untrusted Certificate!\");\n        // } finally {\n        // try {\n        // inStream.close();\n        // } catch (IOException e) {\n        // e.printStackTrace();\n        // }\n        // }\n    }\n\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n\n}\n\n\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport java.io.IOException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.KeyManagementException;\nimport java.net.URISyntaxException;\nimport java.security.KeyStoreException;\nimport java.security.UnrecoverableKeyException;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport java.security.SecureRandom;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.client.methods.HttpGet;\npublic class DataLoader {\n\n    public HttpResponse secureLoadData(String url)\n            throws ClientProtocolException, IOException,\n            NoSuchAlgorithmException, KeyManagementException,\n            URISyntaxException, KeyStoreException, UnrecoverableKeyException {\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n        ctx.init(null, new TrustManager[] { new CustomX509TrustManager() },\n                new SecureRandom());\n\n        HttpClient client = new DefaultHttpClient();\n\n        SSLSocketFactory ssf = new CustomSSLSocketFactory(ctx);\n        ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        ClientConnectionManager ccm = client.getConnectionManager();\n        SchemeRegistry sr = ccm.getSchemeRegistry();\n        sr.register(new Scheme(\"https\", ssf, 443));\n        DefaultHttpClient sslClient = new DefaultHttpClient(ccm,\n                client.getParams());\n\n        HttpGet get = new HttpGet(new URI(url));\n        HttpResponse response = sslClient.execute(get);\n\n        return response;\n    }\n\n}\n", "private static String convertToHex(byte[] data) { \n    StringBuffer buf = new StringBuffer();\n    for (int i = 0; i &lt; data.length; i++) { \n        int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;\n        int two_halfs = 0;\n        do { \n            if ((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9)) {\n                buf.append((char) ('0' + halfbyte));\n            }\n            else {\n                buf.append((char) ('a' + (halfbyte - 10)));\n            }\n            halfbyte = data[i] &amp; 0x0F;\n        } while(two_halfs++ &lt; 1);\n    } \n    return buf.toString();\n} \n\n\npublic static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException  { \n    MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n    byte[] sha1hash = new byte[40];\n    md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n    sha1hash = md.digest();\n    return convertToHex(sha1hash);\n} \n", "// NOTE could replace Principal w/ Spring Security's Authentication object too\n// Just be careful you don't expose the password over REST!\n@RequestMapping(value=\"/user\",produces = \"application/json\")\npublic Map&lt;String,String&gt; helloUser(Principal principal) {\n    HashMap&lt;String,String&gt; result = new HashMap&lt;String,String&gt;();\n    result.put(\"username\", principal.getName());\n    return result;\n}\n", "public static void calculate(Context context) {\n\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n        ZipInputStream fis = get(context);\n        System.out.println(\"fis: \" + fis);\n\n        byte[] dataBytes = new byte[1024];\n\n        int nread = 0; \n        while ((nread = fis.read(dataBytes)) != -1) {\n          md.update(dataBytes, 0, nread);\n        };\n        byte[] mdbytes = md.digest();\n\n        //convert the byte to hex format method 1\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i &lt; mdbytes.length; i++) {\n          sb.append(Integer.toString((mdbytes[i] &amp; 0xff) + 0x100, 16).substring(1));\n        }\n\n        System.out.println(\"Digest(in hex format):: \" + sb.toString());\n\n        //convert the byte to hex format method 2\n        StringBuffer hexString = new StringBuffer();\n        for (int i=0;i&lt;mdbytes.length;i++) {\n            String hex=Integer.toHexString(0xff &amp; mdbytes[i]);\n            if(hex.length()==1) hexString.append('0');\n            hexString.append(hex);\n        }\n        System.out.println(\"Digest(in hex format):: \" + hexString.toString());\n\n        if(fis!=null){\n            fis.close();\n        }\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\npublic static ZipInputStream get(Context context){\n\n      // Get the path to the apk container.\n    String apkPath = context.getApplicationInfo().sourceDir;\n    JarFile containerJar = null;\n\n    try {\n\n        // Open the apk container as a jar..\n        containerJar = new JarFile(apkPath);\n\n        // Look for the \"classes.dex\" entry inside the container.\n        ZipEntry zzz = containerJar.getEntry(\"classes.dex\");\n\n        // If this entry is present in the jar container \n        if (zzz != null) {\n\n            System.out.println(\"long \" + zzz.getCrc());\n\n             // Get an Input Stream for the \"classes.dex\" entry\n            InputStream in = containerJar.getInputStream(zzz);\n\n             ZipInputStream zin = new ZipInputStream(in);\n\n             return zin;\n        }   \n\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if (containerJar != null)\n            try {\n                containerJar.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n    }\n\n    return null;\n}\n", "public static String getHmac(String entity, String salt) throws Exception{\n    Mac mac = Mac.getInstance(\"HmacSHA256\");\n    mac.init(new SecretKeySpec(salt.getBytes(), \"HmacSHA1\"));\n    byte[] bs = mac.doFinal(entity.getBytes());\n    return new HexDumpEncoder().encode(bs); // use your favorite hex converter\n}\n", "package cc.ndl.testencryption;\n\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\n\npublic class Crypto {\n\n    Cipher ecipher;\n    Cipher dcipher;\n\n    // 8-byte Salt\n    byte[] salt = { 1, 2, 4, 5, 7, 8, 3, 6 };\n\n    // Iteration count\n    int iterationCount = 1979;\n\n    Crypto(String passPhrase) {\n        try {\n            // Create the key\n            KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray(), salt,\n                    iterationCount);\n            SecretKey key = SecretKeyFactory.getInstance(\n                    \"PBEWITHSHA256AND128BITAES-CBC-BC\").generateSecret(keySpec);\n            ecipher = Cipher.getInstance(key.getAlgorithm());\n            dcipher = Cipher.getInstance(key.getAlgorithm());\n\n            // Prepare the parameter to the ciphers\n            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt,\n                    iterationCount);\n\n            // Create the ciphers\n            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n        } catch (Exception e) {\n        }\n    }\n\n    public String encrypt(String str) {\n        String rVal;\n        try {\n            // Encode the string into bytes using utf-8\n            byte[] utf8 = str.getBytes(\"UTF8\");\n\n            // Encrypt\n            byte[] enc = ecipher.doFinal(utf8);\n\n            // Encode bytes to base64 to get a string\n            rVal = toHex(enc);\n        } catch (Exception e) {\n            rVal = \"Error encrypting: \" + e.getMessage();\n        }\n        return rVal;\n    }\n\n    public String decrypt(String str) {\n        String rVal;\n        try {\n            // Decode base64 to get bytes\n            byte[] dec = toByte(str);\n\n            // Decrypt\n            byte[] utf8 = dcipher.doFinal(dec);\n\n            // Decode using utf-8\n            rVal = new String(utf8, \"UTF8\");\n        } catch (Exception e) {\n            rVal = \"Error encrypting: \" + e.getMessage();\n        }\n        return rVal;\n    }\n\n    private static byte[] toByte(String hexString) {\n        int len = hexString.length() / 2;\n        byte[] result = new byte[len];\n        for (int i = 0; i &lt; len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),\n                    16).byteValue();\n        return result;\n    }\n\n    private static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2 * buf.length);\n        for (int i = 0; i &lt; buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n\n    private final static String HEX = \"0123456789ABCDEF\";\n\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));\n    }\n}\n", "try {\nPackageInfo info = getPackageManager().getPackageInfo(\"com.facebook.scrumptious\", PackageManager.GET_SIGNATURES);\nfor (Signature signature : info.signatures) {\n    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n    md.update(signature.toByteArray());\n    Log.e(\"MY KEY HASH:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));\n}\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n\n            //load keystore stream\n            byte[] keystoreData = readInputStream(getAssets().open(\"client.keystore\"));\n\n            //load keystore\n            ByteArrayInputStream bais = new ByteArrayInputStream(keystoreData);\n            keyStore.load(bais, KEYSTORE_PASSWORD.toCharArray());\n            //load truststore\n            bais = new ByteArrayInputStream(keystoreData);\n            trustStore.load(bais, KEYSTORE_PASSWORD.toCharArray());\n            //load trustmanager\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            tmf.init(trustStore);\n            //init keymanager\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            kmf.init(keyStore, KEYSTORE_PASSWORD.toCharArray());\n            //create ssl context\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n\n\nHostnameVerifier HOSTNAME_VERIFIER = new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            List&lt;String&gt; allowedHostnames = new ArrayList&lt;String&gt;();\n            allowedHostnames.add(\"pinterest.com\");\n            allowedHostnames.add(\"192.168.1.43\");\n            allowedHostnames.add(\"10.0.2.2\");\n            return allowedHostnames.indexOf(hostname) != -1;\n        }\n    };\n\n                    //open https connection\n                    URL url = new URL(\"https://\" + SERVER_URL + \":\" + SERVER_PORT + \"/api/v1/publication/getDescriptor/\" + publicationId);\n                    HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();\n                    urlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n                    urlConnection.setHostnameVerifier(HOSTNAME_VERIFIER);\n\n                    //read server response\n                    byte[] serverResult = readInputStream(urlConnection.getInputStream());\n", "import java.io.UnsupportedEncodingException; \nimport java.security.MessageDigest; \nimport java.security.NoSuchAlgorithmException; \n\npublic class AeSimpleSHA1 { \n\n    private static String convertToHex(byte[] data) { \n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i &lt; data.length; i++) { \n            int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;\n            int two_halfs = 0;\n            do { \n                if ((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9)) \n                    buf.append((char) ('0' + halfbyte));\n                else \n                    buf.append((char) ('a' + (halfbyte - 10)));\n                halfbyte = data[i] &amp; 0x0F;\n            } while(two_halfs++ &lt; 1);\n        } \n        return buf.toString();\n    } \n\n    public static String SHA1(String text) \n    throws NoSuchAlgorithmException, UnsupportedEncodingException  { \n    MessageDigest md;\n    md = MessageDigest.getInstance(\"SHA-1\");\n    byte[] sha1hash = new byte[40];\n    md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n    sha1hash = md.digest();\n    return convertToHex(sha1hash);\n    } \n}\n", " HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;\n    DefaultHttpClient defaultclient = new DefaultHttpClient();\n\n    SchemeRegistry registry = new SchemeRegistry();\n    SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();\n    socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);\n    registry.register(new Scheme(\"https\", socketFactory, 443));\n\n    cm = new ThreadSafeClientConnManager(defaultclient.getParams(), registry);\n    client = new DefaultHttpClient(cm, defaultclient.getParams());\n\n    // Set verifier     \n    HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);             \n    post = new HttpPost(\"https://my-app.herokuapp.com/api/player\"); \n", "    /**\n     * Encrypts the data passed to it using Hmac-SHA1.\n     * \n     * @param dataToEncrypt\n     *            data that is to be encrypted.\n     * @return The token that is generated after encrypting data.\n     */\n    public static String convertDataToHmacSHA1(final String dataToEncrypt) {\n        String returnString;\n        try {\n            // Get an hmac_sha1 key from the raw key bytes\n            final byte[] keyBytes = HMAC_SHA1_KEY.getBytes();\n            final SecretKeySpec signingKey = new SecretKeySpec(keyBytes,\n                    \"HmacSHA1\");\n\n            // Get an hmac_sha1 Mac instance and initialize with the signing key\n            final Mac mac = Mac.getInstance(\"HmacSHA1\");\n            mac.init(signingKey);\n\n            // Compute the hmac on input data bytes\n            final byte[] rawHmac = mac.doFinal(dataToEncrypt.getBytes());\n\n            final StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : rawHmac) {\n                stringBuffer.append(String.format(\"%02x\", b));\n            }\n            returnString = stringBuffer.toString();\n            Log.e(\"Token\", returnString);\n            return returnString;\n        } catch (Exception e) {\n            Log.e(TAG, \"\" + e);\n        }\n        return returnString;\n    }\n", "// Add code to print out the key hash\n\n\ntry {\nPackageInfo info = getPackageManager().getPackageInfo(\n        \"com.your.packagename\", \n        PackageManager.GET_SIGNATURES);\nfor (Signature signature : info.signatures) {\n    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n    md.update(signature.toByteArray());\n    Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT));// g\n    }\n} catch (NameNotFoundException e) {\n\n} catch (NoSuchAlgorithmException e) {\n\n}\n", "Signature sig = Signature.getInstance(\"NONEwithECDSA\", \"BC\");\nsig.initVerify(pubKey);\nsig.update(plainBytes);\nif (!sig.verify(signedBytes)) {\n    throw new Exception(\"ECDSA signature verification failed.\");\n}\n", "import android.content.Context;\nimport android.util.Log;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.params.HttpParams;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.*;\n\npublic class MyHttpClient extends DefaultHttpClient {\n\n    private static Context appContext = null;\n    private static HttpParams params = null;\n    private static SchemeRegistry schmReg = null;\n    private static Scheme httpsScheme = null;\n    private static Scheme httpScheme = null;\n    private static String TAG = \"MyHttpClient\";\n\n    public MyHttpClient(Context myContext) {\n\n        appContext = myContext;\n\n        if (httpScheme == null || httpsScheme == null) {\n            httpScheme = new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80);\n            httpsScheme = new Scheme(\"https\", mySSLSocketFactory(), 443);\n        }\n\n        getConnectionManager().getSchemeRegistry().register(httpScheme);\n        getConnectionManager().getSchemeRegistry().register(httpsScheme);\n\n    }\n\n    private SSLSocketFactory mySSLSocketFactory() {\n        SSLSocketFactory ret = null;\n        try {\n            final KeyStore ks = KeyStore.getInstance(\"BKS\");\n\n            final InputStream inputStream = appContext.getResources().openRawResource(R.raw.certs);\n\n            ks.load(inputStream, appContext.getString(R.string.store_pass).toCharArray());\n            inputStream.close();\n\n            ret = new SSLSocketFactory(ks);\n        } catch (UnrecoverableKeyException ex) {\n            Log.d(TAG, ex.getMessage());\n        } catch (KeyStoreException ex) {\n            Log.d(TAG, ex.getMessage());\n        } catch (KeyManagementException ex) {\n            Log.d(TAG, ex.getMessage());\n        } catch (NoSuchAlgorithmException ex) {\n            Log.d(TAG, ex.getMessage());\n        } catch (IOException ex) {\n            Log.d(TAG, ex.getMessage());\n        } catch (Exception ex) {\n            Log.d(TAG, ex.getMessage());\n        } finally {\n            return ret;\n        }\n    }\n\n}\n", "try {\n                  PackageInfo info = getPackageManager().getPackageInfo(\"com.sipl.virtualbinoculars\", PackageManager.GET_SIGNATURES);\n                  for (Signature signature : info.signatures) {\n                        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                        md.update(signature.toByteArray());\n                        Log.d(\"KeyHash:\",Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                        System.out.println(\"KEY HASH: \"+Base64.encodeToString(md.digest(), Base64.DEFAULT));\n                  }\n                } catch (NameNotFoundException e) {\n                    Log.d(\"KeyHash:\",e.getMessage());\n                } catch (NoSuchAlgorithmException e) {\n                    Log.d(\"KeyHash:\",e.getMessage());\n                }\n", "/**\n * Perform SHA-256 hash on the given string.\n * It returns a hashed string as Base64 string.\n * @param str String to be hashed in SHA-256\n * @return Base64 string if hashed successfully, else NULL\n */\npublic static String getHashSHA256(String str){\n    String hash = null;\n\n    try{\n        MessageDigest digest = null;\n\n        try { digest = MessageDigest.getInstance(\"SHA-256\"); }\n        catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return hash;\n        }\n\n        digest.reset();\n        hash = Base64.encodeToString(digest.digest(str.getBytes()),\n                  Base64.DEFAULT).trim();\n        digest = null;\n    }\n    catch (Exception e) {\n        Log.e(\"SHA-256\", \"Error in getHashSHA256() due to -&gt; \" + e.toString());\n    }\n\n    return hash;\n}\n", "/**\n * Perform MD-5 hash on the given string.\n * It returns a hashed string as Base64 string.\n * @param str String to be hashed in MD5\n * @return Base64 string if hashed successfully, else NULL\n */\npublic static String getHashMD5(String str){\n    String hash = null;\n\n    try{\n        MessageDigest digest = null;\n\n        try { digest = MessageDigest.getInstance(\"MD5\"); }\n        catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return hash;\n        }\n\n        digest.reset();\n        hash = Base64.encodeToString(digest.digest(str.getBytes()),\n                  Base64.DEFAULT).trim();\n        digest = null;\n    }\n    catch (Exception e) {\n        Log.e(\"MD5\", \"Error in getHashMD5() due to -&gt; \" + e.toString());\n    }\n\n    return hash;\n}\n", "KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\ntrustStore.load(null, null);\n\nMySSLSocketFactory socketFactory = new MySSLSocketFactory(trustStore);\nsocketFactory.setHostnameVerifier(MySSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n\nhttpClient.setTimeout(30 * 1000);\nhttpClient.setSSLSocketFactory(socketFactory);\n", "    public String hashCal(String type,String str){\n        byte[] hashseq=str.getBytes();\n        StringBuffer hexString = new StringBuffer();\n        try{\n            MessageDigest algorithm = MessageDigest.getInstance(type);\n            algorithm.reset();\n            algorithm.update(hashseq);\n            byte messageDigest[] = algorithm.digest();\n\n\n\n            for (int i=0;i&lt;messageDigest.length;i++) {\n                String hex=Integer.toHexString(0xFF &amp; messageDigest[i]);\n                if(hex.length()==1) hexString.append(\"0\");\n                hexString.append(hex);\n            }\n\n        }catch(NoSuchAlgorithmException nsae){ }\n\n        return hexString.toString();\n\n\n    }\n\n}\n", "try {\n            PackageInfo info = getPackageManager().getPackageInfo(\n                    \"com.example.yourpackagename\",\n                    PackageManager.GET_SIGNATURES);\n            for (Signature signature : info.signatures) {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(signature.toByteArray());\n                Log.d(\"KeyHash:\",\n                        Base64.encodeToString(md.digest(), Base64.DEFAULT));\n            }\n        } catch (NameNotFoundException e) {\n\n        } catch (NoSuchAlgorithmException e) {\n\n        }\n", "Android Code:\npublic static final int SALT_LENGTH = 20;\npublic static final int PBE_ITERATION_COUNT = 1000;\n\nprivate static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\nprivate static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\nprivate static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\nprivate static final String TAG = Act.class.getSimpleName();\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.main);\n\n    try {\n\n        String password = \"password\";\n        String plainText = \"plaintext message to be encrypted\";\n\n        // byte[] salt = generateSalt();\n        byte[] salt = \"dfghjklpoiuytgftgyhj\".getBytes();\n        Log.i(TAG, \"Salt: \" + salt.length + \" \" + HexEncoder.toHex(salt));\n        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n        SecretKey tmp = factory.generateSecret(pbeKeySpec);\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n        byte[] key = secret.getEncoded();\n        Log.i(TAG, \"Key: \" + HexEncoder.toHex(key));\n\n        // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, ITERATION_COUNT);\n\n        Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n        // byte[] encryptionSalt = generateSalt();\n        // Log.i(TAG, \"Encrypted Salt: \" + encryptionSalt.length + \" \" + HexEncoder.toHex(encryptionSalt));\n        // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(encryptionSalt, 1000);\n        // byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n        Log.i(TAG, encryptionCipher.getParameters() + \" \");\n        byte[] iv = generateIv();\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n        encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n        byte[] encryptedText = encryptionCipher.doFinal(plainText.getBytes());\n        Log.i(TAG, \"Encrypted: \" + HexEncoder.toHex(encryptedText));\n\n        Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n        decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n        byte[] decryptedText = decryptionCipher.doFinal(encryptedText);\n        Log.i(TAG, \"Decrypted: \" + new String(decryptedText));\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n\nprivate byte[] generateSalt() throws NoSuchAlgorithmException {\n    SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n    byte[] salt = new byte[SALT_LENGTH];\n    random.nextBytes(salt);\n    return salt;\n}\n\nprivate byte[] generateIv() throws NoSuchAlgorithmException {\n    SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n    byte[] iv = new byte[16];\n    random.nextBytes(iv);\n    return iv;\n}\n", "System.setProperty(\"javax.net.ssl.trustStore\", \"clienttrust\");\n    SSLSocketFactory ssf = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    Socket s = ssf.createSocket(\"127.0.0.1\", 8888);\n\n    OutputStream outs = s.getOutputStream();\n    PrintStream out = new PrintStream(outs);\n    InputStream ins = s.getInputStream();\n    BufferedReader in = new BufferedReader(new InputStreamReader(ins));\n\n    out.println(\"Hi,How are u!\");\n    out.println(\"\");\n    String line = null;\n    while ((line = in.readLine()) != null) {\n      System.out.println(line);\n    }\n\n    in.close();\n    out.close();\n", "package com.example.fakessl;\n\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\n\nimport android.util.Log;\n\npublic class CertificadoAceptar {\n    private static TrustManager[] trustManagers;\n\n    public static class _FakeX509TrustManager implements\n            javax.net.ssl.X509TrustManager {\n        private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};\n\n        public void checkClientTrusted(X509Certificate[] arg0, String arg1)\n                throws CertificateException {\n        }\n\n        public void checkServerTrusted(X509Certificate[] arg0, String arg1)\n                throws CertificateException {\n        }\n\n        public boolean isClientTrusted(X509Certificate[] chain) {\n            return (true);\n        }\n\n        public boolean isServerTrusted(X509Certificate[] chain) {\n            return (true);\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return (_AcceptedIssuers);\n        }\n    }\n\n    public static void allowAllSSL() {\n\n        javax.net.ssl.HttpsURLConnection\n                .setDefaultHostnameVerifier(new HostnameVerifier() {\n                    public boolean verify(String hostname, SSLSession session) {\n                        return true;\n                    }\n                });\n\n        javax.net.ssl.SSLContext context = null;\n\n        if (trustManagers == null) {\n            trustManagers = new javax.net.ssl.TrustManager[] { new _FakeX509TrustManager() };\n        }\n\n        try {\n            context = javax.net.ssl.SSLContext.getInstance(\"TLS\");\n            context.init(null, trustManagers, new SecureRandom());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(\"allowAllSSL\", e.toString());\n        } catch (KeyManagementException e) {\n            Log.e(\"allowAllSSL\", e.toString());\n        }\n        javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(context\n                .getSocketFactory());\n    }\n}\n", "private class DownloadImageTask extends AsyncTask&lt;String, String, Void&gt; {\n    int flag=0;\n    protected Void doInBackground(String... arg0) {\n        try{\n            m = new Mail(emailaddress, password);\n            m.setFrom(emailaddress.trim());\n            toArr =   email.split(\",\");\n            for(int i=0;i&lt;toArr.length;i++)\n            {\n                                    // checking all emails entered are correct or not\n                if (toArr[i].trim().matches(EMAIL_PATTERN))\n                {\n                    emailflag = true;\n                }\n                else\n                {\n                    emailflag = false;\n                    break;\n                }\n            }\n            m.setTo(toArr);\n            if(!Subject.equals(\"\"))\n            {\n                m.setSubject(txtSubject.getText().toString());\n            }\n            else   \n            {\n                m.setSubject(\"No Subject\");\n            }\n            if(!EmailBody.equals(\"\"))\n            {\n                m.setBody(txtEmailBody.getText().toString());\n            }\n            else  \n            {\n                m.setBody(\"No Message\");                    \n            }\n            if(!attachefile.equals(\"\"))\n            {\n                String[] temp;\n                temp = attachefile.split(\"\\\\*\");\n                if(temp.length&gt;0)\n                {\n                    for(int i =0; i &lt; temp.length ; i++)\n                    {   \n                        m.addAttachment(temp[i]);\n                    }\n                }\n            }\n            if(emailflag &amp;&amp; m.send())\n            {\n                flag=1;\n                Intent intent = new Intent(SendEmail.this,SendEmail.class);\n                startActivity(intent);\n            }\n            else\n            {\n                flag = 0;\n            }\n\n        }catch(Exception e){\n\n                e.printStackTrace();\n        }\n        return null;\n    }\n\n    protected void onPostExecute(Void result) \n    {\n        progressDialog.dismiss();\n        if(flag==1)\n        {\n            Toast.makeText(SendEmail.this, \"Sent Successfully\", Toast.LENGTH_SHORT).show();\n        }\n        else\n        {\n            Toast.makeText(SendEmail.this, \"Failed please give correct email address\", Toast.LENGTH_SHORT).show();\n        }\n    }\n}\n", "try { \n                PackageInfo info =     getPackageManager().getPackageInfo(\"PROJECTNAME\",     PackageManager.GET_SIGNATURES);\n                for (Signature signature : info.signatures) {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);\n                    Log.e(\"MY KEY HASH:\", sign);\n                    //textInstructionsOrLink = (TextView)findViewById(R.id.textstring);\n                    //textInstructionsOrLink.setText(sign);\n                    Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();\n                }\n    } catch (NameNotFoundException e) {\n        Log.d(\"nope\",\"nope\");\n    } catch (NoSuchAlgorithmException e) {\n    }", "public void encrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n        // Here you read the cleartext.\n        FileInputStream fis = new FileInputStream(\"data/cleartext\");\n        // This stream write the encrypted text. This stream will be wrapped by\n        // another stream.\n        FileOutputStream fos = new FileOutputStream(\"data/encrypted\");\n\n        // Length is 16 byte\n        SecretKeySpec sks = new SecretKeySpec(\"yourkey\".getBytes(), \"AES\");\n        // Create cipher\n        Cipher cipher = Cipher.getInstance(\"AES/CBC\");\n        cipher.init(Cipher.ENCRYPT_MODE, sks);\n        // Wrap the output stream\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n        // Write bytes\n        int b;\n        byte[] d = new byte[8];\n        while ((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n        }\n        // Flush and close streams.\n        cos.flush();\n        cos.close();\n        fis.close();\n    }\n", "public  void decrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n        FileInputStream fis = new FileInputStream(\"data/encrypted\");\n\n        FileOutputStream fos = new FileOutputStream(\"data/decrypted\");\n        SecretKeySpec sks = new SecretKeySpec(\"yourkey\".getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC\");\n        cipher.init(Cipher.DECRYPT_MODE, sks);\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n        int b;\n        byte[] d = new byte[8];\n        while((b = cis.read(d)) != -1) {\n            fos.write(d, 0, b);\n        }\n        fos.flush();\n        fos.close();\n        cis.close();\n    }\n", "    /* Store these things on disk used to derive key later: */\n    int iterationCount = 1000;\n    int saltLength = 32; // bytes; should be the same size as the output\n                            // (256 / 8 = 32)\n    int keyLength = 256; // 256-bits for AES-256, 128-bits for AES-128, etc\n    byte[] salt = new byte[saltLength]; // Should be of saltLength\n\n    /* When first creating the key, obtain a salt with this: */\n    SecureRandom random = new SecureRandom();\n    random.nextBytes(salt);\n\n    /* Use this to derive the key from the password: */\n    KeySpec keySpec = new PBEKeySpec(new String(key,\n            Constants.CHAR_ENCODING).toCharArray(), key, iterationCount,\n            keyLength);\n    SecretKeyFactory keyFactory = SecretKeyFactory\n            .getInstance(\"PBEWithSHA256And256BitAES-CBC-BC\");\n    byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\n    SecretKey secretKey = new SecretKeySpec(keyBytes, \"AES\");\n\n    return secretKey.getEncoded();\n", "private static byte[] getEncrypt(final String key, final String message) throws GeneralSecurityException {\n  final byte[] rawData = key.getBytes(Charset.forName(\"US-ASCII\"));\n  if (rawData.length != 16) {\n    // If this is not 16 in length, there's a problem with the key size, nothing to do here\n    throw new IllegalArgumentException(\"You've provided an invalid key size\");\n  }\n\n  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, \"AES\");\n  final Cipher ciph = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n  ciph.init(Cipher.ENCRYPT_MODE, seckeySpec, new IvParameterSpec(new byte[16]));\n  return ciph.doFinal(message.getBytes(Charset.forName(\"US-ASCII\")));\n}\n\nprivate static String getDecrypt(String key, byte[] encrypted) throws GeneralSecurityException {\n  final byte[] rawData = key.getBytes(Charset.forName(\"US-ASCII\"));\n  if (rawData.length != 16) {\n    // If this is not 16 in length, there's a problem with the key size, nothing to do here\n    throw new IllegalArgumentException(\"Invalid key size.\");\n  }\n\n  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, \"AES\");\n\n  final Cipher ciph = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n  ciph.init(Cipher.DECRYPT_MODE, seckeySpec, new IvParameterSpec(new byte[16]));\n  final byte[] decryptedmess = ciph.doFinal(encrypted);\n\n  return new String(decryptedmess, Charset.forName(\"US-ASCII\"));\n}\n", "public static void AESObjectEncoder(Serializable object, String password, String path) {\n        try {\n            Cipher cipher = null;\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, fromStringToAESkey(password));\n            SealedObject sealedObject = null;\n            sealedObject = new SealedObject(object, cipher);\n            CipherOutputStream cipherOutputStream = null;\n            cipherOutputStream = new CipherOutputStream(new BufferedOutputStream(new FileOutputStream(path)), cipher);\n            ObjectOutputStream outputStream = null;\n            outputStream = new ObjectOutputStream(cipherOutputStream);\n            outputStream.writeObject(sealedObject);\n            outputStream.close();    \n    }\n", " public static Serializable AESObjectDedcoder(String password, String path) {\n        Cipher cipher = null;\n        Serializable userList = null;\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS7Pdding\");\n\n        //Code to write your object to file\n        cipher.init(Cipher.DECRYPT_MODE, fromStringToAESkey(password));         \n        CipherInputStream cipherInputStream = null;\n        cipherInputStream = new CipherInputStream(new BufferedInputStream(new FileInputStream(path)), cipher);\n\n        ObjectInputStream inputStream = null;\n        inputStream = new ObjectInputStream(cipherInputStream);\n        SealedObject sealedObject = null;\n        sealedObject = (SealedObject) inputStream.readObject();\n        userList = (Serializable) sealedObject.getObject(ciper);  \n        return userList;\n    }\n", "public void generateFbFingerPrint() {\n    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.group3amd.gc.activity\",\n                PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            String sign = Base64\n                    .encodeToString(md.digest(), Base64.DEFAULT);\n            Log.e(\"KEYHASH:\", sign);\n            Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG)\n                    .show();\n        }\n    } catch (NameNotFoundException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n\n\n\n\n}\n", "import java.io.InputStream;\nimport java.security.KeyStore;\nimport org.apache.http.conn.ClientConnectionManager;\nimport org.apache.http.conn.scheme.PlainSocketFactory;\nimport org.apache.http.conn.scheme.Scheme;\nimport org.apache.http.conn.scheme.SchemeRegistry;\nimport org.apache.http.conn.ssl.SSLSocketFactory;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.impl.conn.SingleClientConnManager;\nimport com.arisglobal.aglite.activity.R;\nimport android.content.Context;\n\npublic class MyHttpClient extends DefaultHttpClient{\nfinal Context context;\n\npublic MyHttpClient(Context context) {\n    this.context = context;\n}\n\n@Override\nprotected ClientConnectionManager createClientConnectionManager() {\n    SchemeRegistry registry = new SchemeRegistry();\n\n    registry.register(new Scheme(\"http\", PlainSocketFactory.getSocketFactory(), 80));\n\n    // Register for port 443 our SSLSocketFactory with our keystore to the ConnectionManager\n    registry.register(new Scheme(\"https\", newSslSocketFactory(), 443));\n    return new SingleClientConnManager(getParams(), registry);\n}\n\nprivate SSLSocketFactory newSslSocketFactory() {\n    try {\n        // Get an instance of the Bouncy Castle KeyStore format\n        KeyStore trusted = KeyStore.getInstance(\"BKS\");\n\n        // Get the raw resource, which contains the keystore with your trusted certificates (root and any intermediate certs)\n        InputStream in = context.getResources().openRawResource(R.raw.*nameOfYourKey*);\n        try {\n            // Initialize the keystore with the provided trusted certificates.\n            // Also provide the password of the keystore\n            trusted.load(in, *yourPassword*.toCharArray());\n        } finally {\n            in.close();\n        }\n\n        // Pass the keystore to the SSLSocketFactory. The factory is responsible for the verification of the server certificate.\n        SSLSocketFactory sf = new SSLSocketFactory(trusted);\n\n        // Hostname verification from certificate\n        // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506\n        sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);\n        return sf;\n    } catch (Exception e) {\n        throw new AssertionError(e);\n    }\n}\n}\n", "File bufferFile = new File(path);\nFileInputStream fis   = new FileInputStream(bufferFile);\n\nCipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\nSecretKeySpec keySpec = new SecretKeySpec(\"01234567890abcde\".getBytes(), \"AES\");\nIvParameterSpec ivSpec = new IvParameterSpec(\"fedcba9876543210\".getBytes());\ncipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\nCipherInputStream cis = new CipherInputStream(fis, cipher);\nBitmap ops = BitmapFactory.decodeStream(cis);\nlogo.setImageBitmap(ops);\n", "import org.apache.http.conn.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class MySSLSocketFactory extends SSLSocketFactory {\n         SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n\n    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {\n        super(truststore);\n\n        TrustManager tm = new X509TrustManager() {\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n        };\n\n        sslContext.init(null, new TrustManager[] { tm }, null);\n    }\n\n    @Override\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return sslContext.getSocketFactory().createSocket();\n    }\n}\n", "try {\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(null, null);\n        MySSLSocketFactory sf = new MySSLSocketFactory(trustStore);\n        sf.setHostnameVerifier(MySSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        client.setSSLSocketFactory(sf);\n}\ncatch (Exception e) {}\n", "String Encrypt(String text, String key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] keyBytes = new byte[16];\n    byte[] b = key.getBytes(\"UTF-8\");\n    int len = b.length;\n    if (len &gt; keyBytes.length)\n        len = keyBytes.length;\n    System.arraycopy(b, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n\n    byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));\n    BASE64Decoder encoder = new BASE64Decoder();\n    return encoder.encodeBytes(results);\n}\n", "String Decrypt(String text, String key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] keyBytes = new byte[16];\n    byte[] b = key.getBytes(\"UTF-8\");\n    int len = b.length;\n    if (len &gt; keyBytes.length)\n        len = keyBytes.length;\n    System.arraycopy(b, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    cipher.init(Cipher.DECRYPT_MODE, keySpec,ivSpec);\n\n    BASE64Decoder decoder = new BASE64Decoder();\n    byte[] results = cipher.doFinal(decoder.decode(text));\n    return new String(results, \"UTF-8\");\n}\n", "   public static void main(String[] args) throws SQLException, Exception {\n        Connection con = ConnectionDefinition.getOracleConnection(); //my oracle connection\n        PreparedStatement pr = con.prepareStatement(\"select  utl_raw.cast_to_raw(dbms_obfuscation_toolkit.md5(input_string =&gt;'password')) from dual\");\n        ResultSet rs = pr.executeQuery();\n        rs.next();\n        byte[] raw = rs.getBytes(1);\n        String str = new String(raw);\n        System.err.println(str);        \n\n        //Generate MD5 Java\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"password\".getBytes());        \n        byte byteData[] = md.digest();\n        System.err.println(new String(byteData));        \n        rs.close();\n        pr.close();\n        con.close();        \n    }\n", "  public static String printHashKey(Context context, String packagename)\n        {\n\n            String TAG = packagename;\n            try\n            {\n                Log.d(TAG, \"keyHash: start\");\n                PackageInfo info = context.getPackageManager().getPackageInfo(TAG,PackageManager.GET_SIGNATURES);\n                for (Signature signature: info.signatures)\n                {\n                    MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                    md.update(signature.toByteArray());\n                    String keyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);\n                    Log.d(TAG, \"keyHash: \" + keyHash);\n                    return keyHash;\n                }\n                Log.d(TAG, \"keyHash: end\");\n            }\n            catch (NameNotFoundException e)\n            {\n                Log.d(TAG, \"keyHash: name:\"+e);\n            }\n            catch (NoSuchAlgorithmException e)\n            {\n                Log.d(TAG, \"keyHash: name:\"+e);\n            }\n\n            return \"error\";\n        }\n\n        public static void updateLanguage(Context context, String code)\n        {\n            Locale locale = new Locale(code);\n            Locale.setDefault(locale);\n            Configuration config = new Configuration();\n            config.locale = locale;\n            context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());\n        }\n", "        SchemeRegistry schemeRegistry = new SchemeRegistry ();\n\n        schemeRegistry.register (new Scheme (\"http\",\n        PlainSocketFactory.getSocketFactory (), 80));\n        schemeRegistry.register (new Scheme (\"https\",\n        new CustomSSLSocketFactory (), 443));\n\n        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager (\n           params, schemeRegistry);\n\n\n         return new DefaultHttpClient (cm, params);\n    }\n\n    // CustomSSLSocketFactory:\n\n       public class CustomSSLSocketFactory extends org.apache.http.conn.ssl.SSLSocketFactory\n         {\n           private SSLSocketFactory FACTORY =  HttpsURLConnection.getDefaultSSLSocketFactory ();\n\n        public CustomSSLSocketFactory ()\n          {\n            super(null);  \n        try\n           {\n            SSLContext context = SSLContext.getInstance (\"TLS\");\n            TrustManager[] tm = new TrustManager[] { new FullX509TrustManager () };\n             context.init (null, tm, new SecureRandom ());\n\n             FACTORY = context.getSocketFactory ();\n          }\n         catch (Exception e)\n         {\n              e.printStackTrace();\n         }\n    }\n\n   public Socket createSocket() throws IOException\n     {\n        return FACTORY.createSocket();\n      }\n\n     // TODO: add other methods like createSocket() and getDefaultCipherSuites().\n   // Hint: they all just make a call to member FACTORY \n}\n\n\n   //FullX509TrustManager is a class that implements javax.net.ssl.X509TrustManager,    yet   none of the methods actually perform any work, get a sample here.\n", "    try {\n        PackageInfo info = getPackageManager().getPackageInfo(\n                \"com.google.shoppingvn\", PackageManager.GET_SIGNATURES);\n        for (Signature signature : info.signatures) {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(signature.toByteArray());\n            Log.i(\"KeyHash:\",\n                    Base64.encodeToString(md.digest(), Base64.DEFAULT));\n        }\n    } catch (NameNotFoundException e) {\n\n    } catch (NoSuchAlgorithmException e) {\n\n    }\n", "import java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Base64;\nimport android.util.Log;\n\npublic class Crypto {\n     public static final String TAG = \"smsfwd\";\n\n        private static Cipher aesCipher;\n        private static SecretKey secretKey;\n        private static IvParameterSpec ivParameterSpec;\n\n        private static String CIPHER_TRANSFORMATION = \"AES/CBC/PKCS5Padding\";\n        private static String CIPHER_ALGORITHM = \"AES\";\n        // Replace me with a 16-byte key, share between Java and C#\n        private static byte[] rawSecretKey = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n        private static String MESSAGEDIGEST_ALGORITHM = \"MD5\";\n\n        public Crypto(String passphrase) {\n            byte[] passwordKey = encodeDigest(passphrase);\n\n            try {\n                aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);\n            } catch (NoSuchAlgorithmException e) {\n                Log.e(TAG, \"No such algorithm \" + CIPHER_ALGORITHM, e);\n            } catch (NoSuchPaddingException e) {\n                Log.e(TAG, \"No such padding PKCS5\", e);\n            }\n\n            secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);\n            ivParameterSpec = new IvParameterSpec(rawSecretKey);\n        }\n\n        public String encryptAsBase64(byte[] clearData) {\n            byte[] encryptedData = encrypt(clearData);\n            return  Base64.encodeToString(encryptedData, Base64.DEFAULT);\n        }\n\n        public byte[] encrypt(byte[] clearData) {\n            try {\n                aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);\n            } catch (InvalidKeyException e) {\n                Log.e(TAG, \"Invalid key\", e);\n                return null;\n            } catch (InvalidAlgorithmParameterException e) {\n                Log.e(TAG, \"Invalid algorithm \" + CIPHER_ALGORITHM, e);\n                return null;\n            }\n\n            byte[] encryptedData;\n            try {\n                encryptedData = aesCipher.doFinal(clearData);\n            } catch (IllegalBlockSizeException e) {\n                Log.e(TAG, \"Illegal block size\", e);\n                return null;\n            } catch (BadPaddingException e) {\n                Log.e(TAG, \"Bad padding\", e);\n                return null;\n            }\n            return encryptedData;\n        }\n\n        private byte[] encodeDigest(String text) {\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);\n                return digest.digest(text.getBytes());\n            } catch (NoSuchAlgorithmException e) {\n                Log.e(TAG, \"No such algorithm \" + MESSAGEDIGEST_ALGORITHM, e);\n            }\n\n            return null;\n        }\n}\n", "/*\n * ====================================================================\n * Licensed to the Apache Software Foundation (ASF) [...add this back]\n *\n */\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Principal;\nimport java.security.PrivateKey;\nimport java.security.SecureRandom;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.net.ssl.KeyManager;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.X509ExtendedKeyManager;\nimport javax.net.ssl.X509TrustManager;\n\n/**\n * Builder for {@link javax.net.ssl.SSLContext} instances.\n * &lt;p&gt;\n * Please note: the default Oracle JSSE implementation of {@link SSLContext#init(KeyManager[], TrustManager[], SecureRandom)}\n * accepts multiple key and trust managers, however only only first matching type is ever used.\n * See for example:\n * &lt;a href=\"http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLContext.html#init%28javax.net.ssl.KeyManager[],%20javax.net.ssl.TrustManager[],%20java.security.SecureRandom%29\"&gt;\n * SSLContext.html#init\n * &lt;/a&gt;\n *\n * @since 4.4\n */\npublic class SSLContextBuilder {\n\n    static final String TLS   = \"TLS\";\n\n    private String protocol;\n    private final Set&lt;KeyManager&gt; keymanagers;\n    private final Set&lt;TrustManager&gt; trustmanagers;\n    private SecureRandom secureRandom;\n\n    public static SSLContextBuilder create() {\n        return new SSLContextBuilder();\n    }\n\n    public SSLContextBuilder() {\n        super();\n        this.keymanagers = new LinkedHashSet&lt;KeyManager&gt;();\n        this.trustmanagers = new LinkedHashSet&lt;TrustManager&gt;();\n    }\n\n    public SSLContextBuilder useProtocol(final String protocol) {\n        this.protocol = protocol;\n        return this;\n    }\n\n    public SSLContextBuilder setSecureRandom(final SecureRandom secureRandom) {\n        this.secureRandom = secureRandom;\n        return this;\n    }\n\n    public SSLContextBuilder loadTrustMaterial(\n            final KeyStore truststore,\n            final TrustStrategy trustStrategy) throws NoSuchAlgorithmException, KeyStoreException {\n        final TrustManagerFactory tmfactory = TrustManagerFactory.getInstance(\n                TrustManagerFactory.getDefaultAlgorithm());\n        tmfactory.init(truststore);\n        final TrustManager[] tms = tmfactory.getTrustManagers();\n        if (tms != null) {\n            if (trustStrategy != null) {\n                for (int i = 0; i &lt; tms.length; i++) {\n                    final TrustManager tm = tms[i];\n                    if (tm instanceof X509TrustManager) {\n                        tms[i] = new TrustManagerDelegate(\n                                (X509TrustManager) tm, trustStrategy);\n                    }\n                }\n            }\n            for (final TrustManager tm : tms) {\n                this.trustmanagers.add(tm);\n            }\n        }\n        return this;\n    }\n\n    public SSLContextBuilder loadTrustMaterial(\n            final TrustStrategy trustStrategy) throws NoSuchAlgorithmException, KeyStoreException {\n        return loadTrustMaterial(null, trustStrategy);\n    }\n\n    public SSLContextBuilder loadTrustMaterial(\n            final File file,\n            final char[] storePassword,\n            final TrustStrategy trustStrategy) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {\n        Args.notNull(file, \"Truststore file\");\n        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        final FileInputStream instream = new FileInputStream(file);\n        try {\n            trustStore.load(instream, storePassword);\n        } finally {\n            instream.close();\n        }\n        return loadTrustMaterial(trustStore, trustStrategy);\n    }\n\n    public SSLContextBuilder loadTrustMaterial(\n            final File file,\n            final char[] storePassword) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {\n        return loadTrustMaterial(file, storePassword, null);\n    }\n\n    public SSLContextBuilder loadTrustMaterial(\n            final File file) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {\n        return loadTrustMaterial(file, null);\n    }\n\n    public SSLContextBuilder loadTrustMaterial(\n            final URL url,\n            final char[] storePassword,\n            final TrustStrategy trustStrategy) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {\n        Args.notNull(url, \"Truststore URL\");\n        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        final InputStream instream = url.openStream();\n        try {\n            trustStore.load(instream, storePassword);\n        } finally {\n            instream.close();\n        }\n        return loadTrustMaterial(trustStore, trustStrategy);\n    }\n\n    public SSLContextBuilder loadTrustMaterial(\n            final URL url,\n            final char[] storePassword) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {\n        return loadTrustMaterial(url, storePassword, null);\n    }\n\n    public SSLContextBuilder loadKeyMaterial(\n            final KeyStore keystore,\n            final char[] keyPassword,\n            final PrivateKeyStrategy aliasStrategy)\n            throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {\n        final KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(\n                KeyManagerFactory.getDefaultAlgorithm());\n        kmfactory.init(keystore, keyPassword);\n        final KeyManager[] kms =  kmfactory.getKeyManagers();\n        if (kms != null) {\n            if (aliasStrategy != null) {\n                for (int i = 0; i &lt; kms.length; i++) {\n                    final KeyManager km = kms[i];\n                    if (km instanceof X509ExtendedKeyManager) {\n                        kms[i] = new KeyManagerDelegate((X509ExtendedKeyManager) km, aliasStrategy);\n                    }\n                }\n            }\n            for (final KeyManager km : kms) {\n                keymanagers.add(km);\n            }\n        }\n        return this;\n    }\n\n    public SSLContextBuilder loadKeyMaterial(\n            final KeyStore keystore,\n            final char[] keyPassword) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {\n        return loadKeyMaterial(keystore, keyPassword, null);\n    }\n\n    public SSLContextBuilder loadKeyMaterial(\n            final File file,\n            final char[] storePassword,\n            final char[] keyPassword,\n            final PrivateKeyStrategy aliasStrategy) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException, CertificateException, IOException {\n        Args.notNull(file, \"Keystore file\");\n        final KeyStore identityStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        final FileInputStream instream = new FileInputStream(file);\n        try {\n            identityStore.load(instream, storePassword);\n        } finally {\n            instream.close();\n        }\n        return loadKeyMaterial(identityStore, keyPassword, aliasStrategy);\n    }\n\n    public SSLContextBuilder loadKeyMaterial(\n            final File file,\n            final char[] storePassword,\n            final char[] keyPassword) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException, CertificateException, IOException {\n        return loadKeyMaterial(file, storePassword, keyPassword, null);\n    }\n\n    public SSLContextBuilder loadKeyMaterial(\n            final URL url,\n            final char[] storePassword,\n            final char[] keyPassword,\n            final PrivateKeyStrategy aliasStrategy) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException, CertificateException, IOException {\n        Args.notNull(url, \"Keystore URL\");\n        final KeyStore identityStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        final InputStream instream = url.openStream();\n        try {\n            identityStore.load(instream, storePassword);\n        } finally {\n            instream.close();\n        }\n        return loadKeyMaterial(identityStore, keyPassword, aliasStrategy);\n    }\n\n    public SSLContextBuilder loadKeyMaterial(\n            final URL url,\n            final char[] storePassword,\n            final char[] keyPassword) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException, CertificateException, IOException {\n        return loadKeyMaterial(url, storePassword, keyPassword, null);\n    }\n\n    protected void initSSLContext(\n            final SSLContext sslcontext,\n            final Collection&lt;KeyManager&gt; keyManagers,\n            final Collection&lt;TrustManager&gt; trustManagers,\n            final SecureRandom secureRandom) throws KeyManagementException {\n        sslcontext.init(\n                !keyManagers.isEmpty() ? keyManagers.toArray(new KeyManager[keyManagers.size()]) : null,\n                !trustManagers.isEmpty() ? trustManagers.toArray(new TrustManager[trustManagers.size()]) : null,\n                secureRandom);\n    }\n\n    public SSLContext build() throws NoSuchAlgorithmException, KeyManagementException {\n        final SSLContext sslcontext = SSLContext.getInstance(\n                this.protocol != null ? this.protocol : TLS);\n        initSSLContext(sslcontext, keymanagers, trustmanagers, secureRandom);\n        return sslcontext;\n    }\n\n    static class TrustManagerDelegate implements X509TrustManager {\n\n        private final X509TrustManager trustManager;\n        private final TrustStrategy trustStrategy;\n\n        TrustManagerDelegate(final X509TrustManager trustManager, final TrustStrategy trustStrategy) {\n            super();\n            this.trustManager = trustManager;\n            this.trustStrategy = trustStrategy;\n        }\n\n        @Override\n        public void checkClientTrusted(\n                final X509Certificate[] chain, final String authType) throws CertificateException {\n            this.trustManager.checkClientTrusted(chain, authType);\n        }\n\n        @Override\n        public void checkServerTrusted(\n                final X509Certificate[] chain, final String authType) throws CertificateException {\n            if (!this.trustStrategy.isTrusted(chain, authType)) {\n                this.trustManager.checkServerTrusted(chain, authType);\n            }\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return this.trustManager.getAcceptedIssuers();\n        }\n\n    }\n\n    static class KeyManagerDelegate extends X509ExtendedKeyManager {\n\n        private final X509ExtendedKeyManager keyManager;\n        private final PrivateKeyStrategy aliasStrategy;\n\n        KeyManagerDelegate(final X509ExtendedKeyManager keyManager, final PrivateKeyStrategy aliasStrategy) {\n            super();\n            this.keyManager = keyManager;\n            this.aliasStrategy = aliasStrategy;\n        }\n\n        @Override\n        public String[] getClientAliases(\n                final String keyType, final Principal[] issuers) {\n            return this.keyManager.getClientAliases(keyType, issuers);\n        }\n\n        public Map&lt;String, PrivateKeyDetails&gt; getClientAliasMap(\n                final String[] keyTypes, final Principal[] issuers) {\n            final Map&lt;String, PrivateKeyDetails&gt; validAliases = new HashMap&lt;String, PrivateKeyDetails&gt;();\n            for (final String keyType: keyTypes) {\n                final String[] aliases = this.keyManager.getClientAliases(keyType, issuers);\n                if (aliases != null) {\n                    for (final String alias: aliases) {\n                        validAliases.put(alias,\n                                new PrivateKeyDetails(keyType, this.keyManager.getCertificateChain(alias)));\n                    }\n                }\n            }\n            return validAliases;\n        }\n\n        public Map&lt;String, PrivateKeyDetails&gt; getServerAliasMap(\n                final String keyType, final Principal[] issuers) {\n            final Map&lt;String, PrivateKeyDetails&gt; validAliases = new HashMap&lt;String, PrivateKeyDetails&gt;();\n            final String[] aliases = this.keyManager.getServerAliases(keyType, issuers);\n            if (aliases != null) {\n                for (final String alias: aliases) {\n                    validAliases.put(alias,\n                            new PrivateKeyDetails(keyType, this.keyManager.getCertificateChain(alias)));\n                }\n            }\n            return validAliases;\n        }\n\n        @Override\n        public String chooseClientAlias(\n                final String[] keyTypes, final Principal[] issuers, final Socket socket) {\n            final Map&lt;String, PrivateKeyDetails&gt; validAliases = getClientAliasMap(keyTypes, issuers);\n            return this.aliasStrategy.chooseAlias(validAliases, socket);\n        }\n\n        @Override\n        public String[] getServerAliases(\n                final String keyType, final Principal[] issuers) {\n            return this.keyManager.getServerAliases(keyType, issuers);\n        }\n\n        @Override\n        public String chooseServerAlias(\n                final String keyType, final Principal[] issuers, final Socket socket) {\n            final Map&lt;String, PrivateKeyDetails&gt; validAliases = getServerAliasMap(keyType, issuers);\n            return this.aliasStrategy.chooseAlias(validAliases, socket);\n        }\n\n        @Override\n        public X509Certificate[] getCertificateChain(final String alias) {\n            return this.keyManager.getCertificateChain(alias);\n        }\n\n        @Override\n        public PrivateKey getPrivateKey(final String alias) {\n            return this.keyManager.getPrivateKey(alias);\n        }\n\n        @Override\n        public String chooseEngineClientAlias(\n                final String[] keyTypes, final Principal[] issuers, final SSLEngine sslEngine) {\n            final Map&lt;String, PrivateKeyDetails&gt; validAliases = getClientAliasMap(keyTypes, issuers);\n            return this.aliasStrategy.chooseAlias(validAliases, null);\n        }\n\n        @Override\n        public String chooseEngineServerAlias(\n                final String keyType, final Principal[] issuers, final SSLEngine sslEngine) {\n            final Map&lt;String, PrivateKeyDetails&gt; validAliases = getServerAliasMap(keyType, issuers);\n            return this.aliasStrategy.chooseAlias(validAliases, null);\n        }\n\n    }\n\n}\n", "       SSLContextBuilder sslContextBuilder = SSLContextBuilder.create();\n       KeyStore keyStore = KeyStore.getInstance(\"BKS\", BouncyCastleProvider.PROVIDER_NAME);\n       android.content.res.Resources res = &lt;getter for resources&gt;;\n       InputStream inputStream = res.openRawResources(R.raw.cert);           \n       keyStore.load(inputStream, trustStorePassword);\n       sslContextBuilder.loadTrustMaterial(keyStore, trustStorePassword);\n       SSLContext sslContext = sslContextBuilder.build();\n       //okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());\n", "                keyStore.load(byteArrayInputStream, keyStorePassword);\n                Certificate[] certificates = keyStore.getCertificateChain(\"key-alias\"); //you need to know the alias\n                if(certificates.length &gt; 0) {\n                    Certificate certificate = certificates[0];\n                    X509Certificate x509Certificate = (X509Certificate) certificate;\n                    Log.d(TAG,\n                          \"Certificate found with DN [\" + x509Certificate.getSubjectDN() + \"]\");\n", "/*Copyright 2015 Bhavit Singh Sengar\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.*/\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport javax.net.ssl.HandshakeCompletedListener;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\n\npublic class NoSSLv3SocketFactory extends SSLSocketFactory{\n    private final SSLSocketFactory delegate;\n\npublic NoSSLv3SocketFactory() {\n    this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();\n}\n\npublic NoSSLv3SocketFactory(SSLSocketFactory delegate) {\n    this.delegate = delegate;\n}\n\n@Override\npublic String[] getDefaultCipherSuites() {\n    return delegate.getDefaultCipherSuites();\n}\n\n@Override\npublic String[] getSupportedCipherSuites() {\n    return delegate.getSupportedCipherSuites();\n}\n\nprivate Socket makeSocketSafe(Socket socket) {\n    if (socket instanceof SSLSocket) {\n        socket = new NoSSLv3SSLSocket((SSLSocket) socket);\n    }\n    return socket;\n}\n\n@Override\npublic Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));\n}\n\n@Override\npublic Socket createSocket(String host, int port) throws IOException {\n    return makeSocketSafe(delegate.createSocket(host, port));\n}\n\n@Override\npublic Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));\n}\n\n@Override\npublic Socket createSocket(InetAddress host, int port) throws IOException {\n    return makeSocketSafe(delegate.createSocket(host, port));\n}\n\n@Override\npublic Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));\n}\n\nprivate class NoSSLv3SSLSocket extends DelegateSSLSocket {\n\n    private NoSSLv3SSLSocket(SSLSocket delegate) {\n        super(delegate);\n\n    }\n\n    @Override\n    public void setEnabledProtocols(String[] protocols) {\n        if (protocols != null &amp;&amp; protocols.length == 1 &amp;&amp; \"SSLv3\".equals(protocols[0])) {\n\n            List&lt;String&gt; enabledProtocols = new ArrayList&lt;String&gt;(Arrays.asList(delegate.getEnabledProtocols()));\n            if (enabledProtocols.size() &gt; 1) {\n                enabledProtocols.remove(\"SSLv3\");\n                System.out.println(\"Removed SSLv3 from enabled protocols\");\n            } else {\n                System.out.println(\"SSL stuck with protocol available for \" + String.valueOf(enabledProtocols));\n            }\n            protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);\n        }\n\n        super.setEnabledProtocols(protocols);\n    }\n}\n\npublic class DelegateSSLSocket extends SSLSocket {\n\n    protected final SSLSocket delegate;\n\n    DelegateSSLSocket(SSLSocket delegate) {\n        this.delegate = delegate;\n    }\n\n    @Override\n    public String[] getSupportedCipherSuites() {\n        return delegate.getSupportedCipherSuites();\n    }\n\n    @Override\n    public String[] getEnabledCipherSuites() {\n        return delegate.getEnabledCipherSuites();\n    }\n\n    @Override\n    public void setEnabledCipherSuites(String[] suites) {\n        delegate.setEnabledCipherSuites(suites);\n    }\n\n    @Override\n    public String[] getSupportedProtocols() {\n        return delegate.getSupportedProtocols();\n    }\n\n    @Override\n    public String[] getEnabledProtocols() {\n        return delegate.getEnabledProtocols();\n    }\n\n    @Override\n    public void setEnabledProtocols(String[] protocols) {\n        delegate.setEnabledProtocols(protocols);\n    }\n\n    @Override\n    public SSLSession getSession() {\n        return delegate.getSession();\n    }\n\n    @Override\n    public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {\n        delegate.addHandshakeCompletedListener(listener);\n    }\n\n    @Override\n    public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {\n        delegate.removeHandshakeCompletedListener(listener);\n    }\n\n    @Override\n    public void startHandshake() throws IOException {\n        delegate.startHandshake();\n    }\n\n    @Override\n    public void setUseClientMode(boolean mode) {\n        delegate.setUseClientMode(mode);\n    }\n\n    @Override\n    public boolean getUseClientMode() {\n        return delegate.getUseClientMode();\n    }\n\n    @Override\n    public void setNeedClientAuth(boolean need) {\n        delegate.setNeedClientAuth(need);\n    }\n\n    @Override\n    public void setWantClientAuth(boolean want) {\n        delegate.setWantClientAuth(want);\n    }\n\n    @Override\n    public boolean getNeedClientAuth() {\n        return delegate.getNeedClientAuth();\n    }\n\n    @Override\n    public boolean getWantClientAuth() {\n        return delegate.getWantClientAuth();\n    }\n\n    @Override\n    public void setEnableSessionCreation(boolean flag) {\n        delegate.setEnableSessionCreation(flag);\n    }\n\n    @Override\n    public boolean getEnableSessionCreation() {\n        return delegate.getEnableSessionCreation();\n    }\n\n    @Override\n    public void bind(SocketAddress localAddr) throws IOException {\n        delegate.bind(localAddr);\n    }\n\n    @Override\n    public synchronized void close() throws IOException {\n        delegate.close();\n    }\n\n    @Override\n    public void connect(SocketAddress remoteAddr) throws IOException {\n        delegate.connect(remoteAddr);\n    }\n\n    @Override\n    public void connect(SocketAddress remoteAddr, int timeout) throws IOException {\n        delegate.connect(remoteAddr, timeout);\n    }\n\n    @Override\n    public SocketChannel getChannel() {\n        return delegate.getChannel();\n    }\n\n    @Override\n    public InetAddress getInetAddress() {\n        return delegate.getInetAddress();\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        return delegate.getInputStream();\n    }\n\n    @Override\n    public boolean getKeepAlive() throws SocketException {\n        return delegate.getKeepAlive();\n    }\n\n    @Override\n    public InetAddress getLocalAddress() {\n        return delegate.getLocalAddress();\n    }\n\n    @Override\n    public int getLocalPort() {\n        return delegate.getLocalPort();\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return delegate.getLocalSocketAddress();\n    }\n\n    @Override\n    public boolean getOOBInline() throws SocketException {\n        return delegate.getOOBInline();\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        return delegate.getOutputStream();\n    }\n\n    @Override\n    public int getPort() {\n        return delegate.getPort();\n    }\n\n    @Override\n    public synchronized int getReceiveBufferSize() throws SocketException {\n        return delegate.getReceiveBufferSize();\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return delegate.getRemoteSocketAddress();\n    }\n\n    @Override\n    public boolean getReuseAddress() throws SocketException {\n        return delegate.getReuseAddress();\n    }\n\n    @Override\n    public synchronized int getSendBufferSize() throws SocketException {\n        return delegate.getSendBufferSize();\n    }\n\n    @Override\n    public int getSoLinger() throws SocketException {\n        return delegate.getSoLinger();\n    }\n\n    @Override\n    public synchronized int getSoTimeout() throws SocketException {\n        return delegate.getSoTimeout();\n    }\n\n    @Override\n    public boolean getTcpNoDelay() throws SocketException {\n        return delegate.getTcpNoDelay();\n    }\n\n    @Override\n    public int getTrafficClass() throws SocketException {\n        return delegate.getTrafficClass();\n    }\n\n    @Override\n    public boolean isBound() {\n        return delegate.isBound();\n    }\n\n    @Override\n    public boolean isClosed() {\n        return delegate.isClosed();\n    }\n\n    @Override\n    public boolean isConnected() {\n        return delegate.isConnected();\n    }\n\n    @Override\n    public boolean isInputShutdown() {\n        return delegate.isInputShutdown();\n    }\n\n    @Override\n    public boolean isOutputShutdown() {\n        return delegate.isOutputShutdown();\n    }\n\n    @Override\n    public void sendUrgentData(int value) throws IOException {\n        delegate.sendUrgentData(value);\n    }\n\n    @Override\n    public void setKeepAlive(boolean keepAlive) throws SocketException {\n        delegate.setKeepAlive(keepAlive);\n    }\n\n    @Override\n    public void setOOBInline(boolean oobinline) throws SocketException {\n        delegate.setOOBInline(oobinline);\n    }\n\n    @Override\n    public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {\n        delegate.setPerformancePreferences(connectionTime, latency, bandwidth);\n    }\n\n    @Override\n    public synchronized void setReceiveBufferSize(int size) throws SocketException {\n        delegate.setReceiveBufferSize(size);\n    }\n\n    @Override\n    public void setReuseAddress(boolean reuse) throws SocketException {\n        delegate.setReuseAddress(reuse);\n    }\n\n    @Override\n    public synchronized void setSendBufferSize(int size) throws SocketException {\n        delegate.setSendBufferSize(size);\n    }\n\n    @Override\n    public void setSoLinger(boolean on, int timeout) throws SocketException {\n        delegate.setSoLinger(on, timeout);\n    }\n\n    @Override\n    public synchronized void setSoTimeout(int timeout) throws SocketException {\n        delegate.setSoTimeout(timeout);\n    }\n\n    @Override\n    public void setTcpNoDelay(boolean on) throws SocketException {\n        delegate.setTcpNoDelay(on);\n    }\n\n    @Override\n    public void setTrafficClass(int value) throws SocketException {\n        delegate.setTrafficClass(value);\n    }\n\n    @Override\n    public void shutdownInput() throws IOException {\n        delegate.shutdownInput();\n    }\n\n    @Override\n    public void shutdownOutput() throws IOException {\n        delegate.shutdownOutput();\n    }\n\n    @Override\n    public String toString() {\n        return delegate.toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return delegate.equals(o);\n    }\n}\n}\n", "SSLContext sslcontext = SSLContext.getInstance(\"TLSv1\");\n\n            sslcontext.init(null,\n                    null,\n                    null);\n            SSLSocketFactory NoSSLv3Factory = new NoSSLv3SocketFactory(sslcontext.getSocketFactory());\n\n            HttpsURLConnection.setDefaultSSLSocketFactory(NoSSLv3Factory);\n            l_connection = (HttpsURLConnection) l_url.openConnection();\n            l_connection.connect();\n", "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Enumeration;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport android.annotation.SuppressLint;\nimport android.app.AlertDialog;\nimport android.app.ProgressDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.graphics.Color;\nimport android.os.AsyncTask;\nimport android.util.Log;\nimport android.view.Gravity;\nimport android.widget.TextView;\npublic class Utils\n    {\n            public static void createDir(String path,String dirName)\n            {\n                  String newFolder = \"/\"+dirName;\n                  File myNewFolder = new File(path + newFolder);\n                  myNewFolder.mkdir();\n            }\n\n            public void downloadEventData(Context context,String zipFile,String unzipLocation,String url) throws IOException\n            {\n                try {\n                        new DownloadMapAsync(context,zipFile,unzipLocation).execute(url);\n                } catch (Exception e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n                private class DownloadMapAsync extends AsyncTask&lt;String, String, String&gt; {\n                    String result =\"\";\n                    Context context;\n                    String zipFile;\n                    String unzipLocation;\n                    private ProgressDialog progressDialog;\n                    String string;\n                    public DownloadMapAsync(Context context,String zipFile,String unzipLocation) {\n                        // TODO Auto-generated constructor stub\n                        this.context=context;\n                        this.zipFile=zipFile;\n                        this.unzipLocation=unzipLocation;\n                    }\n                    @Override\n                    protected void onPreExecute() {\n                        super.onPreExecute();\n                        progressDialog = new ProgressDialog(context);\n                        progressDialog.setMessage(\"Downloading Zip File..\");\n                        progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n                        progressDialog.setCancelable(false);\n                        progressDialog.show();\n                    }\n\n                    @Override\n                    protected String doInBackground(String... aurl) {\n                        int count;\n                        HttpURLConnection http = null;\n                    try {\n                        URL url = new URL(aurl[0]);\n                        if (url.getProtocol().toLowerCase().equals(\"https\")) {\n                            trustAllHosts();\n                            HttpsURLConnection https = (HttpsURLConnection) url.openConnection();\n                            https.setHostnameVerifier(DO_NOT_VERIFY);\n                            http = https;\n                        } else {\n                            http = (HttpURLConnection) url.openConnection();\n                        }\n                    http.connect();\n                    if (http.getResponseCode()==200)\n                    {\n                        int lenghtOfFile = http.getContentLength();\n                        InputStream input = new BufferedInputStream(url.openStream());\n\n                        OutputStream output = new FileOutputStream(zipFile);\n\n                        byte data[] = new byte[1024];\n                        long total = 0;\n\n                            while ((count = input.read(data)) != -1) {\n                                total += count;\n                                publishProgress(\"\"+(int)((total*100)/lenghtOfFile));\n                                output.write(data, 0, count);\n                            }\n                            output.close();\n                            input.close();\n                            result = \"true\";\n                    } \n                    else if (http.getResponseCode()==401)\n                    {\n                        result = \"false\";\n                        string= \"Download Limit exceed.\";   \n                    }  \n                    else \n                    {\n                        result = \"false\";\n                        string=http.getResponseMessage();\n                    }\n\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        result = \"false\";\n                        try {\n                            if (http.getResponseCode()==401)\n                            {\n                                string= \"Download Failed\";  \n                            } else {\n                                string=e.toString();\n                            }\n\n                        } catch (IOException e1) {\n                            // TODO Auto-generated catch block\n                            e1.printStackTrace();\n                        }\n                    }\n                    return result;\n\n                    }\n                    protected void onProgressUpdate(String... progress) {\n                         Log.d(\"ANDRO_ASYNC\",progress[0]);\n                         progressDialog.setProgress(Integer.parseInt(progress[0]));\n                    }\n\n                    @Override\n                    protected void onPostExecute(String unused) {\n                        progressDialog.dismiss();\n                        if(result.equalsIgnoreCase(\"true\"))\n                        {\n                        try {\n                            unzip(context,zipFile,unzipLocation);\n                        } catch (IOException e) {\n                            // TODO Auto-generated catch block\n                            e.printStackTrace();\n                        }\n                        }\n                        else\n                        {\n                            customAlert(context, string);\n                        }\n                    }\n                }\n                @SuppressLint(\"NewApi\")\n                public void customAlert(Context context,String msgString)\n                {\n                    AlertDialog.Builder alertDialog2 = new AlertDialog.Builder(context,AlertDialog.THEME_DEVICE_DEFAULT_LIGHT);\n                    TextView title = new TextView(context);\n                    title.setText(\"Message\");\n                    title.setPadding(10, 10, 10, 10);\n                    title.setGravity(Gravity.CENTER);\n                    title.setTextColor(Color.BLACK);\n                    title.setTextSize(20);\n                    alertDialog2.setCustomTitle(title);\n                    TextView msg = new TextView(context);\n                    msg.setText(msgString);\n                    msg.setPadding(10, 10, 10, 10);\n                    msg.setGravity(Gravity.CENTER);\n                    msg.setTextSize(18);\n                    msg.setTextColor(Color.BLACK);\n                    alertDialog2.setView(msg);\n                    alertDialog2.setPositiveButton(\"OK\",\n                        new DialogInterface.OnClickListener() {\n                            public void onClick(DialogInterface dialog, int which) {\n                                dialog.cancel();\n                            }\n                        });\n                    alertDialog2.show();\n                }\n                  public void unzip(Context context,String zipFile,String unzipLocation) throws IOException \n                  {\n                        new UnZipTask(context,zipFile).execute(unzipLocation);\n                  }\n\n                private class UnZipTask extends AsyncTask&lt;String, Void, Boolean&gt; {\n                    Context context;\n                    String zipFile;\n                    ProgressDialog progressDialog;\n\n                 public UnZipTask(Context context,String zipFile) {\n                    // TODO Auto-generated constructor stub\n                     this.context=context;\n                     this.zipFile=zipFile;\n                    }\n                  @Override\n                    protected void onPreExecute() {\n                        super.onPreExecute();\n                        progressDialog = new ProgressDialog(context);\n                        progressDialog.setMessage(\"Please Wait...Extracting zip file ... \");\n                        progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);\n                        progressDialog.setCancelable(false);\n                        progressDialog.show();\n\n                    }\n                  protected Boolean doInBackground(String... params) \n                  {\n                      String filePath = zipFile;\n                      String destinationPath = params[0];\n\n                      File archive = new File(filePath);\n                      try {\n\n\n                         ZipFile zipfile = new ZipFile(archive);\n                          for (@SuppressWarnings(\"rawtypes\")\n                        Enumeration e = zipfile.entries(); e.hasMoreElements();) {\n                              ZipEntry entry = (ZipEntry) e.nextElement();\n                              unzipEntry(zipfile, entry, destinationPath);\n                          }\n\n\n                            UnzipUtil d = new UnzipUtil(zipFile,params[0]); \n                            d.unzip();\n\n                      } catch (Exception e) {\n                          e.printStackTrace();\n                          return false;\n                      }\n\n                      return true;\n                  }\n\n                  @Override\n                  protected void onPostExecute(Boolean result)\n                  {\n                      progressDialog.dismiss();\n                      File file=new File(zipFile);\n                      file.delete();\n                      customAlert(context,\"Unzipping completed\");\n                  }\n\n                  private void unzipEntry(ZipFile zipfile, ZipEntry entry,String outputDir) throws IOException \n                    {\n\n                      if (entry.isDirectory()) {\n                          createDir(new File(outputDir, entry.getName()));\n                          return;\n                      }\n\n                      File outputFile = new File(outputDir, entry.getName());\n                      if (!outputFile.getParentFile().exists()) {\n                          createDir(outputFile.getParentFile());\n                      }\n\n                      BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n                      BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n\n                      try {\n\n                      } finally {\n                        outputStream.flush();\n                        outputStream.close();\n                        inputStream.close();\n\n\n                      }\n                  }\n\n                  public void createDir(File dir)\n                  {\n                      if (dir.exists()) {\n                          return;\n                      }\n                      if (!dir.mkdirs()) {\n                          throw new RuntimeException(\"Can not create dir \" + dir);\n                      }\n                  }\n\n                  }\n\n                 final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier()\n                 {\n                        public boolean verify(String hostname, SSLSession session) {\n                            return true;\n                        }\n                };\n                private static void trustAllHosts() {\n                    // Create a trust manager that does not validate certificate chains\n                    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                            return new java.security.cert.X509Certificate[] {};\n                        }\n\n                        public void checkClientTrusted(X509Certificate[] chain,\n                                String authType) throws CertificateException {\n                        }\n\n                        public void checkServerTrusted(X509Certificate[] chain,\n                                String authType) throws CertificateException {\n                        }\n                    } };\n\n                    // Install the all-trusting trust manager\n                    try {\n                        SSLContext sc = SSLContext.getInstance(\"TLS\");\n                        sc.init(null, trustAllCerts, new java.security.SecureRandom());\n                        HttpsURLConnection\n                                .setDefaultSSLSocketFactory(sc.getSocketFactory());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }   \n}\n"], "features": []}